Bottom: 71f085ab88d8560020ccb030f33c9694963372af
Top:    c134e1ff3a6bd87b215804c5e4b30a1d61376ccc
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-04 18:51:27 +0000

WIP on quad edge play


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 75c9bc6..dcc4913 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -185,7 +185,9 @@ LIBGTK_GL_SRCS= \
 	hid/gtk/edge3d.c \
 	hid/gtk/edge3d.h \
 	hid/gtk/object3d.c \
-	hid/gtk/object3d.h
+	hid/gtk/object3d.h \
+	hid/gtk/appearance.c \
+	hid/gtk/appearance.h
 
 GL_SRCS= \
 	hid/common/hidgl.c \
diff --git a/src/hid/gtk/appearance.c b/src/hid/gtk/appearance.c
new file mode 100644
index 0000000..92790fcc
--- /dev/null
+++ b/src/hid/gtk/appearance.c
@@ -0,0 +1,25 @@
+#include <glib.h>
+
+#include "appearance.h"
+
+appearance
+*make_appearance (void)
+{
+  appearance *appear = g_new0 (appearance, 1);
+
+  return appear;
+}
+
+void
+destroy_appearance (appearance *appear)
+{
+  g_free (appear);
+}
+
+void
+appearance_set_color (appearance *appear, float r, float g, float b)
+{
+  appear->r = r;
+  appear->g = g;
+  appear->b = b;
+}
diff --git a/src/hid/gtk/appearance.h b/src/hid/gtk/appearance.h
new file mode 100644
index 0000000..d4917d7
--- /dev/null
+++ b/src/hid/gtk/appearance.h
@@ -0,0 +1,7 @@
+typedef struct {
+  float r, g, b;
+} appearance;
+
+appearance *make_appearance (void);
+void destroy_appearance (appearance *appearance);
+void appearance_set_color (appearance *appearance, float r, float g, float b);
diff --git a/src/hid/gtk/face3d.c b/src/hid/gtk/face3d.c
index e69de29..1a8c8c3 100644
--- a/src/hid/gtk/face3d.c
+++ b/src/hid/gtk/face3d.c
@@ -0,0 +1,27 @@
+#include <glib.h>
+
+#include "quad.h"
+#include "face3d.h"
+
+face3d *
+make_face3d (void)
+{
+  face3d *face;
+
+  face = g_new0 (face3d, 1);
+
+  return face;
+}
+
+void
+destroy_face3d (face3d *face)
+{
+  g_list_free (face->contours);
+  g_free (face);
+}
+
+void
+face3d_add_contour (face3d *face, edge_ref contour)
+{
+  face->contours = g_list_append (face->contours, (void *)contour);
+}
diff --git a/src/hid/gtk/face3d.h b/src/hid/gtk/face3d.h
index e69de29..6200161 100644
--- a/src/hid/gtk/face3d.h
+++ b/src/hid/gtk/face3d.h
@@ -0,0 +1,8 @@
+typedef struct {
+  float nx, ny, nz; /* Face normal?*/
+  GList *contours;
+} face3d;
+
+face3d *make_face3d (void);
+void destroy_face3d (face3d *face);
+void face3d_add_contour (face3d *face, edge_ref contour);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 6d3799c..ef2e97a 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -16,6 +16,9 @@
 #include "pcb-printf.h"
 
 #include "quad.h"
+#include "vertex3d.h"
+#include "face3d.h"
+#include "appearance.h"
 #include "object3d.h"
 
 #ifndef WIN32
diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index ddcf35e..35f2330 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -3,10 +3,13 @@
 #include <assert.h>
 #include <stdbool.h>
 
+#include <glib.h>
+
 #include "quad.h"
 #include "vertex3d.h"
 #include "face3d.h"
 #include "edge3d.h"
+#include "appearance.h"
 #include "object3d.h"
 #include "polygon.h"
 #include "data.h"
@@ -62,13 +65,14 @@ object3d_test_init (void)
 }
 
 object3d *
-make_object3d ()
+make_object3d (char *name)
 {
   static int object3d_count = 0;
   object3d *object;
 
-  object = malloc (sizeof (object3d));
+  object = g_new (object3d, 1);
   object->id = object3d_count++;
+  name = g_strdup (name);
 
   return object;
 }
@@ -76,8 +80,35 @@ make_object3d ()
 void
 destroy_object3d (object3d *object)
 {
-  /* XXX: LEAK GEOMETERY AND TOPOLOGY */
-  free (object);
+  g_list_free_full (object->vertices, (GDestroyNotify)destroy_vertex3d);
+  g_list_free_full (object->edges, (GDestroyNotify)destroy_edge);
+  g_list_free_full (object->faces, (GDestroyNotify)destroy_face3d);
+  g_free (object->name);
+  g_free (object);
+}
+
+void
+object3d_set_appearance (object3d *object, appearance *appear)
+{
+  object->appear = appear;
+}
+
+void
+object3d_add_edge (object3d *object, edge_ref edge)
+{
+  object->edges = g_list_append (object->edges, (void *)edge);
+}
+
+void
+object3d_add_vertex (object3d *object, vertex3d *vertex)
+{
+  object->vertices = g_list_append (object->vertices, vertex);
+}
+
+void
+object3d_add_face (object3d *object, face3d *face)
+{
+  object->faces = g_list_append (object->faces, face);
 }
 
 #define XOFFSET 50
@@ -90,8 +121,11 @@ object3d_create_test_cube (void)
   object3d *object;
   vertex3d *cube_vertices[8];
   edge_ref cube_edges[12];
+  face3d *faces[6];
   int i;
 
+  object = make_object3d ("TEST CUBE");
+
   cube_vertices[0] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 0., ZOFFSET + SCALE *  0.);
   cube_vertices[1] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 0., ZOFFSET + SCALE *  0.);
   cube_vertices[2] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 0., ZOFFSET + SCALE * -1.);
@@ -101,8 +135,18 @@ object3d_create_test_cube (void)
   cube_vertices[6] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 1., ZOFFSET + SCALE * -1.);
   cube_vertices[7] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 1., ZOFFSET + SCALE * -1.);
 
-  for (i = 0; i < 12; i++)
+  for (i = 0; i < 8; i++)
+    object3d_add_vertex (object, cube_vertices[i]);
+
+  for (i = 0; i < 12; i++) {
     cube_edges[i] = make_edge ();
+    object3d_add_edge (object, cube_edges[i]);
+  }
+
+  for (i = 0; i < 6; i++) {
+    faces[i] = make_face3d ();
+    object3d_add_face (object, faces[i]);
+  }
 
   for (i = 0; i < 4; i++) {
     int next_vertex = (i + 1) % 4;
@@ -132,8 +176,6 @@ object3d_create_test_cube (void)
 
   quad_enum (cube_edges[0], debug_print_edge, NULL);
 
-  object = make_object3d ();
-  object->first_edge = cube_edges[0];
 
   return object;
 }
@@ -195,7 +237,9 @@ draw_quad_edge (edge_ref e, void *data)
 void
 object3d_draw_debug (void)
 {
-  quad_enum (object3d_test_object->first_edge, draw_quad_edge, NULL);
+  g_return_if_fail (object3d_test_object->edges != NULL);
+
+  quad_enum ((edge_ref)object3d_test_object->edges->data, draw_quad_edge, NULL);
 }
 
 /*********************************************************************************************************/
@@ -238,13 +282,26 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
   *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
 }
 
+
+static void
+fprint_idlist (FILE *f, int *ids, int num_ids)
+{
+  int i;
+  fprintf (f, "(");
+  for (i = 0; i < num_ids - 1; i++)
+    fprintf (f, "#%i, ", ids[i]);
+  fprintf (f, "#%i) ) ;\n", ids[i]);
+}
+
 void
 object3d_export_to_step (object3d *object, char *filename)
 {
   FILE *f;
   time_t currenttime;
   struct tm utc;
-  //int next_step_identifier;
+  int next_step_identifier;
+  int brep_identifier;
+  int pcb_shell_identifier;
 
   f = fopen (filename, "w");
   if (f == NULL)
@@ -312,463 +369,146 @@ object3d_export_to_step (object3d *object, char *filename)
               "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
               "test_pcb_absr_name");
 
-  //next_step_identifier = 21;
+  next_step_identifier = 21;
 
   /* TODO.. EXPORT FROM A QUAD DATA-STRUCTURE */
-#if 0
+#if 1
 #define FWD 1
 #define REV 2
-static void
-quad_emit_board_contour_step (FILE *f, PLINE *contour)
-{
-  int ncontours;
-  int npoints;
-
-  int brep_identifier;
-
-  int bottom_plane_identifier;
-  int top_plane_identifier;
-  int *side_plane_identifier;
-
-  int *bottom_infinite_line_identifier;
-  int *top_infinite_line_identifier;
-  int *side_infinite_line_identifier;
-
-  int *bottom_vertex_identifier;
-  int *top_vertex_identifier;
-
-  int *bottom_edge_identifier;
-  int *top_edge_identifier;
-  int *side_edge_identifier;
-
-  int *bottom_face_bound_identifier;
-  int *top_face_bound_identifier;
-
-  int bottom_face_identifier;
-  int top_face_identifier;
-  int *side_face_identifier;
-
-  int pcb_shell_identifier;
-
-  int i;
-
-  PLINE *ct;
-
-  ncontours = 0;
-  npoints = 0;
-  ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
-
-  /* TODO: Avoid needing to store these identifiers by nailing down our usage pattern of identifiers */
-  /* Allocate some storage for identifiers */
-
-            side_plane_identifier = malloc (sizeof (int) * npoints);
-  bottom_infinite_line_identifier = malloc (sizeof (int) * npoints);
-     top_infinite_line_identifier = malloc (sizeof (int) * npoints);
-    side_infinite_line_identifier = malloc (sizeof (int) * npoints);
-         bottom_vertex_identifier = malloc (sizeof (int) * npoints);
-            top_vertex_identifier = malloc (sizeof (int) * npoints);
-           bottom_edge_identifier = malloc (sizeof (int) * npoints);
-              top_edge_identifier = malloc (sizeof (int) * npoints);
-             side_edge_identifier = malloc (sizeof (int) * npoints);
-             side_face_identifier = malloc (sizeof (int) * npoints);
-
-     bottom_face_bound_identifier = malloc (sizeof (int) * ncontours);
-        top_face_bound_identifier = malloc (sizeof (int) * ncontours);
-
-  /* For a n-sided outline, we need: */
-
-  // PLANES:               2 + n
-  // 2 bottom + top planes
-  // n side planes
-
-  // INFINITE LINES:       3n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-  // n for the sides (joining the top + bottom vertex of the extruded shape (n sided outline = n vertices)
-
-  // VERTICES:             2n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-
-  // EDGES:                3n          (6n oriented edges)
-  // n for the bottom
-  // n for the top
-  // n for the sides
-
-  // FACES:                2 + n
-  // 2 bottom + top faces
-  // n side faces
-
-  // A consistent numbering scheme will avoid needing complex data-structures here!
 
   /* Save a place for the brep identifier */
   brep_identifier = next_step_identifier++;
 
-  /* Define the bottom and top planes */
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0,  1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', (  1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           next_step_identifier, 0.0, 0.0, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           next_step_identifier + 1,
-           next_step_identifier + 2,
-           next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-           next_step_identifier + 4, next_step_identifier + 3);
-  bottom_plane_identifier = next_step_identifier + 4;
-  next_step_identifier = next_step_identifier + 5;
-
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0, -1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', ( -1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           next_step_identifier, 0.0, 0.0, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           next_step_identifier + 1,
-           next_step_identifier + 2,
-           next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-           next_step_identifier + 4, next_step_identifier + 3);
-  top_plane_identifier = next_step_identifier + 4;
-  next_step_identifier = next_step_identifier + 5;
-
-  /* Define the side planes */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
+  /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
+  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
+  for (;;)
+    {
+      if (ct->is_round)
+        {
+          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+           * BECAUSE OUR ROUND CONTOURS ARE (CURRENTLY) ALWAYS HOLES IN THE SOLID,
+           * THIS MEANS THE CYLINDER NORMAL POINTS INTO THE OBJECT
+           */
+          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
+                      "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
+                   next_step_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
+                   next_step_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
+                   next_step_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
+                   next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
+
+          plane_identifiers[i] = next_step_identifier + 4;
+          next_step_identifier = next_step_identifier + 5;
+        }
+      else
+        {
+          /* FOR CONSISTENCY WITH ABOVE, DEFINE PLANE NORMAL TO BE POINTING INSIDE THE SHAPE.
+           * THIS ALLOWS TO FLIP THE ORIENTATION OF THE UNDERLYING SURFACE WHEN DEFINING EVERY ADVANCED_FACE
+           */
+          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier, x1, y1, 0.0);    // <-- A locating point on the plane. Forms 0,0 of its parameterised coords.
+          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 1,  -(y2 - y1), (x2 - x1), 0.0);  /* An axis direction pointing into the shape */ // <-- Or is this the z-axis of the coordinate placement -> plane normal?
+          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 2, 0.0, 0.0, 1.0);          // <-- Reference x-axis, should be orthogonal to the z-axis above.
+          fprintf (f, "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
+          fprintf (f, "#%i = PLANE ( 'NONE',  #%i ) ;\n",
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
+                   next_step_identifier + 4, next_step_identifier + 3);
+          plane_identifiers[i] = next_step_identifier + 4;
+          next_step_identifier = next_step_identifier + 5;
+        }
     }
 
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Surface edges bounded by a cylindrical surface, not n-planes) */
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
-                 next_step_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
-                 next_step_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-
-        side_plane_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-    else
-      {
-        get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-        get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-                 next_step_identifier,     /* A point on the plane                      */ x1, y1, 0.0,
-                 next_step_identifier + 1, /* An axis direction pointing into the shape */ -(y2 - y1), (x2 - x1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* A reference direction pointing.. "meh"?   */ 0.0, 0.0, 1.0,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3);
-        side_plane_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-  }
-
-  /* Define the infinite lines */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
+  /* Define the infinite lines corresponding to every edge (either lines or circles)*/
+  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
+  for (;;)
+    {
 
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
+      if (ct->is_round)
+        {
+          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
+                      "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
+                   next_step_identifier,     /* Center of the circle   */ edge_info->cx, edge_info->cy, edge_info->cz, // <--- Center of coordinate placement
+                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
+                   next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
+                   next_step_identifier + 4, next_step_identifier + 3, edge_info->radius;
+          infinite_line_identifiers[i] = next_step_identifier + 4;
+          next_step_identifier = next_step_identifier + 5;
+        }
+      else
+        {
+          float dx, dy, dz;
+
+          dx = end_v->x - start_v->x;
+          dy = end_v->y - start_v->y;
+          dz = end_v->z - start_v->z;
+
+          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
+                      "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
+                   next_step_identifier,     /* A point on the line         */ start_v->x, start_v->y, start_v->z,
+                   next_step_identifier + 1, /* A direction along the line  */ dx, dy, dz,
+                   next_step_identifier + 2, next_step_identifier + 1,
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
+          infinite_line_identifiers[i] = next_step_identifier + 3;
+          next_step_identifier = next_step_identifier + 4;
+        }
     }
 
-    get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-    get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Top and bottom faces bounded a circular contour, not n-lines) */
-
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-        bottom_infinite_line_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-        top_infinite_line_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-    else
-      {
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 next_step_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, next_step_identifier + 1,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-        bottom_infinite_line_identifier[i] = next_step_identifier + 3;
-        next_step_identifier = next_step_identifier + 4;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 next_step_identifier,     /* A point on the line         */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, next_step_identifier + 1,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-        top_infinite_line_identifier[i] = next_step_identifier + 3;
-        next_step_identifier = next_step_identifier + 4;
-      }
-
-    /* Side */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-             next_step_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, /* A direction along the line  */ 0.0, 0.0, 1.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-             next_step_identifier + 2, next_step_identifier + 1,
-             next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-    side_infinite_line_identifier[i] = next_step_identifier + 3;
-    next_step_identifier = next_step_identifier + 4;
-  }
-
   /* Define the vertices */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
+  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
+  for (;;)
+    {
+      fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier,     /* Vertex coordinate  */ x, y, z);
+      fprintf (f, "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",             next_step_identifier + 1, next_step_identifier);
+      vertex_identifiers[i] = next_step_identifier + 1;
+      next_step_identifier = next_step_identifier + 2;
     }
 
-    get_contour_coord_n_in_mm (ct, adjusted_i, &x1, &y1);
-
-    /* Bottom */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             next_step_identifier,     /* Vertex coordinate  */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, next_step_identifier);
-    bottom_vertex_identifier[i] = next_step_identifier + 1;
-    next_step_identifier = next_step_identifier + 2;
-
-    /* Top */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             next_step_identifier,     /* Vertex coordinate  */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, next_step_identifier);
-    top_vertex_identifier[i] = next_step_identifier + 1;
-    next_step_identifier = next_step_identifier + 2;
-  }
-
   /* Define the Edges */
-  for (i = 0; i < npoints; i++) {
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
+  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
+  for (;;)
+    {
+      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; ", next_step_identifier, start_vertex_identifiers[i], end_vertex_identifiers[i], infinite_line_identifier[i],
+      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; ",    next_step_identifier + 1, next_step_identifier,
+      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",   next_step_identifier + 2, next_step_identifier);
+      edge_identifiers[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
+      next_step_identifier = next_step_identifier + 3;
     }
 
-    /* Due to the way the index wrapping works, this works for circular cutouts as well as n-sided */
-
-    /* Bottom */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, bottom_vertex_identifier[i], bottom_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], bottom_infinite_line_identifier[i],      // <-- MIGHT NEED TO REVERSE THIS???
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    bottom_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-
-    /* Top */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, top_vertex_identifier[i], top_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], top_infinite_line_identifier[i],                 // <-- MIGHT NEED TO REVERSE THIS???
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    top_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-
-    /* Side */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, bottom_vertex_identifier[i], top_vertex_identifier[i], side_infinite_line_identifier[i],
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    side_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-  }
-
   /* Define the faces */
+  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE (ESPECIALLY FOR CORRECT ORDERING!)*/
+  for (;;)
+    {
+      start_i = 0;
+      for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
+
+        /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */ 
+        fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_edge_identifiers[i], face_contour_npoints[i]); fprintf (f, " ) ; ");
+        fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n", next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
+        face_bound_identifiers[icont] = next_step_identifier + 1;
+        next_step_identifier = next_step_identifier + 2;
+      }
 
-  /* Bottom */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               next_step_identifier);
-      for (i = start_i + get_contour_npoints (ct) - 1; i > start_i; i--)
-        fprintf (f, "#%i, ", bottom_edge_identifier[i] + FWD);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               bottom_edge_identifier[start_i] + FWD,
-               next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-      bottom_face_bound_identifier[icont] = next_step_identifier + 1;
-      next_step_identifier = next_step_identifier + 2;
-    }
-
-    fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ( ",
-             next_step_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               bottom_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             bottom_face_bound_identifier[ncontours - 1], bottom_plane_identifier);
-    bottom_face_identifier = next_step_identifier;
-    next_step_identifier = next_step_identifier + 1;
-  }
-
-  /* Top */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               next_step_identifier);
-      for (i = start_i; i < start_i + get_contour_npoints (ct) - 1; i++)
-        fprintf (f, "#%i, ", top_edge_identifier[i] + REV);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               top_edge_identifier[start_i + get_contour_npoints (ct) - 1] + REV,
-               next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-      top_face_bound_identifier[icont] = next_step_identifier + 1;
-      next_step_identifier = next_step_identifier + 2;
-    }
-
-    fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ( ",
-             next_step_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               top_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             top_face_bound_identifier[ncontours - 1], top_plane_identifier);
-    top_face_identifier = next_step_identifier;
-    next_step_identifier = next_step_identifier + 1;
-  }
-
-  /* Sides */
-  for (i = 0; i < npoints; i++) {
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
+      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_bound_identifiers, ncontours);  fprintf (f, ", #%i, .F. ) ;\n", plane_identifiers[i]);
+      face_identifiers[i] = next_step_identifier;
+      next_step_identifier = next_step_identifier + 1;
     }
 
-    fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( #%i, #%i, #%i, #%i ) ) ; "
-                "#%i = FACE_OUTER_BOUND ( 'NONE', #%i, .T. ) ; "
-                "#%i = ADVANCED_FACE ( 'NONE', ( #%i ), #%i, .F. ) ;\n",
-             next_step_identifier, side_edge_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)] + REV, top_edge_identifier[i] + FWD, side_edge_identifier[i] + FWD, bottom_edge_identifier[i] + REV,
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier + 1, side_plane_identifier[i]);
-    side_face_identifier[i] = next_step_identifier + 2;
-    next_step_identifier = next_step_identifier + 3;
-  }
-
   /* Closed shell which bounds the brep solid */
   pcb_shell_identifier = next_step_identifier;
   next_step_identifier++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ( #%i, #%i, ", pcb_shell_identifier, bottom_face_identifier, top_face_identifier);
-  for (i = 0; i < npoints - 1; i++) {
-    fprintf (f, "#%i, ", side_face_identifier[i]);
-  }
-  fprintf (f, "#%i) ) ;\n",
-           side_face_identifier[npoints - 1]);
+  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ", pcb_shell_identifier); fprint_idlist (f, face_identifiers, nfaces); fprintf (f, " ) ;\n");
 
   /* Finally emit the brep solid definition */
   fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
 
-  free (side_plane_identifier);
-  free (bottom_infinite_line_identifier);
-  free (top_infinite_line_identifier);
-  free (side_infinite_line_identifier);
-  free (bottom_vertex_identifier);
-  free (top_vertex_identifier);
-  free (bottom_edge_identifier);
-  free (top_edge_identifier);
-  free (side_edge_identifier);
-  free (side_face_identifier);
-  free (bottom_face_bound_identifier);
-  free (top_face_bound_identifier);
-}
 #undef FWD
 #undef REV
 #endif
@@ -782,7 +522,8 @@ quad_emit_board_contour_step (FILE *f, PLINE *contour)
 object3d *
 object3d_from_board_outline (void)
 {
-  object3d *object;
+  object3d *board_object;
+  appearance *board_appearance;
   POLYAREA *outline;
   PLINE *contour;
   PLINE *ct;
@@ -791,6 +532,7 @@ object3d_from_board_outline (void)
   int i;
   vertex3d **vertices;
   edge_ref *edges;
+  face3d **faces;
   int start_of_ct;
   int offset_in_ct;
   int ct_npoints;
@@ -822,8 +564,15 @@ object3d_from_board_outline (void)
    * holes = ncontours - 1  (LATER)
    */
 
+  board_object = make_object3d (PCB->Name);
+  board_appearance = make_appearance ();
+  appearance_set_color (board_appearance, 1., 1., 0.);
+
+  object3d_set_appearance (board_object, board_appearance);
+
   vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
   edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
+  faces    = malloc (sizeof (face3d *) * (2 + npoints));
 
   /* Define the vertices */
   ct = contour;
@@ -844,12 +593,29 @@ object3d_from_board_outline (void)
     get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
     vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
     vertices[npoints + i] = make_vertex3d (x1, y1, 0); /* Top */
+
+    object3d_add_vertex (board_object, vertices[i]);
+    object3d_add_vertex (board_object, vertices[npoints + i]);
   }
 
   /* Define the edges */
-
-  for (i = 0; i < 3 * npoints; i++)
+  for (i = 0; i < 3 * npoints; i++) {
     edges[i] = make_edge ();
+    object3d_add_edge (board_object, edges[i]);
+  }
+
+  /* Define the faces */
+  for (i = 0; i < npoints; i++) {
+    faces[i] = make_face3d ();
+    /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+    face3d_add_contour (faces[i], edges[2 * npoints + i]);
+  }
+  faces[npoints]     = make_face3d (); /* bottom_face */
+  faces[npoints + 1] = make_face3d (); /* top_face */
+
+  /* Pick the first bottom / top edge which within the bottom / top face outer contour loop, and link it to the face */
+  face3d_add_contour (faces[npoints], edges[0]);
+  face3d_add_contour (faces[npoints + 1], edges[npoints]);
 
   ct = contour;
   start_of_ct = 0;
@@ -858,6 +624,7 @@ object3d_from_board_outline (void)
 
   for (i = 0; i < npoints; i++, offset_in_ct++) {
     int next_i_around_ct;
+    int prev_i_around_ct;
 
     /* Update which contour we're looking at */
     if (offset_in_ct == ct_npoints) {
@@ -866,9 +633,14 @@ object3d_from_board_outline (void)
       offset_in_ct = 0;
       ct = ct->next;
       ct_npoints = get_contour_npoints (ct);
+
+      /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+      face3d_add_contour (faces[npoints], edges[i]);
+      face3d_add_contour (faces[npoints + 1], edges[npoints + i]);
     }
 
     next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
     /* Assign the appropriate vertex geometric data to each edge end */
     ODATA (edges[0 * npoints + i]) = vertices[0 * npoints + i];
@@ -877,6 +649,12 @@ object3d_from_board_outline (void)
     DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
     ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
     DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+    LDATA (edges[0 * npoints + i]) = faces[i];
+    RDATA (edges[0 * npoints + i]) = faces[npoints];
+    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+    RDATA (edges[1 * npoints + i]) = faces[i];
+    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+    RDATA (edges[2 * npoints + i]) = faces[i];
 
     /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
     splice (edges[i], edges[npoints + i]);
@@ -898,10 +676,7 @@ object3d_from_board_outline (void)
 
   poly_Free (&outline);
 
-  object = make_object3d ();
-  object->first_edge = edges[0]; /* edges[34] */
-
-  return object;
+  return board_object;
 }
 
 void
diff --git a/src/hid/gtk/object3d.h b/src/hid/gtk/object3d.h
index 4f40a3b..8d081a2 100644
--- a/src/hid/gtk/object3d.h
+++ b/src/hid/gtk/object3d.h
@@ -1,12 +1,20 @@
 typedef struct {
-  edge_ref first_edge;
   int id;
+  char *name;
+  appearance *appear;
+  GList *edges;
+  GList *vertices;
+  GList *faces;
 } object3d;
 
 void object3d_test_init (void);
 void object3d_draw_debug (void);
-object3d *make_object3d (void);
+object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
+void object3d_set_appearance (object3d *object, appearance *appear);
+void object3d_add_edge (object3d *object, edge_ref edge);
+void object3d_add_vertex (object3d *object, vertex3d *vertex);
+void object3d_add_face (object3d *object, face3d *face);
 object3d *object3d_create_test_cube (void);
 object3d *object3d_from_board_outline (void);
 void object3d_export_to_step (object3d *object, char *filename);
