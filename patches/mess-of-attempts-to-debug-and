Bottom: 8cfcf769bdb0d3d859bbb84e0e1b0a7c7d9e26ab
Top:    12c031c0135b919e0737705a2be3f64c83a9a815
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-18 20:36:34 +0000

Mess of attempts to debug and improve arc-support in polygon code


---

diff --git a/src/polygon1.c b/src/polygon1.c
index ae9c69e..d93c817 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -204,6 +204,28 @@ poly_CreateNodeFull (Vector v, bool is_round, double cx, double cy, double radiu
   if (res == NULL)
     return NULL;
 
+#if 0
+  if (is_round)
+    {
+      Angle start_angle;
+//      Angle end_angle;
+      Coord check_x, check_y;
+
+      start_angle = atan2 ((v[1] - cy), -(v[0] - cx)) / M180;
+
+      check_x = cx + radius * -cos (start_angle * M180);
+      check_y = cy + radius *  sin (start_angle * M180);
+
+      if (check_x != v[0] || check_y != v[1])
+        {
+          fprintf (stderr, "poly_CreateNodeFull() Tweaking from vertex location to match angle calculation\n");
+          pcb_fprintf (stderr, "Moving from (%$mn, %$mn) to (%$mn, %$mn)\n", v[0], v[1], check_x, check_y);
+          v[0] = check_x;
+          v[1] = check_y;
+        }
+    }
+#endif
+
   c = res->point;
   *c++ = *v++;
   *c = *v;
@@ -603,6 +625,31 @@ node_add_single_point (VNODE * a, Vector p)
   return new_node;
 }				/* node_add_point */
 
+static void
+cvc_list_dump (CVCList *list)
+{
+  VNODE *node = list->parent;
+  CVCList *iter;
+
+  pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
+
+  iter = list;
+  do {
+    pcb_fprintf (stderr, "angle = %.30e, poly = %c, side = %c, (%mn, %mn)-(%mn, %mn), curvature = %f Vertices: %p-%p Edge: %p\n",
+                 iter->angle,
+                 iter->poly,
+                 iter->side,
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[0],
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[1],
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[0],
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[1],
+                 iter->curvature,
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side)),
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side)),
+                 VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side));
+  } while ((iter = iter->next) != list);
+
+}
 
 /* \brief Compare the curvature / geometries of two edges
  *
@@ -737,9 +784,11 @@ add_descriptors (PLINE * pl, char poly, CVCList * list)
 	  list = node->cvc_prev = insert_descriptor (node, poly, 'P', list);
 	  if (!node->cvc_prev)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	  list = node->cvc_next = insert_descriptor (node, poly, 'N', list);
 	  if (!node->cvc_next)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	}
     }
   while ((node = NEXT_VERTEX(node)) != &pl->head);
@@ -1125,6 +1174,7 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
   printf ("  Intersect count is %i\n", cnt);
 
+#if 0
   if (cnt == 0)
     {
       printf ("Trying with a perturbation\n");
@@ -1139,6 +1189,10 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
       printf ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<<<<\n");
     }
+#endif
+
+  if (cnt == 0)
+    return 0;
 
   if (cnt == 2)
     {
@@ -3619,6 +3673,8 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               Angle end_angle;
               Angle delta_angle;
               BoxType arc_bound;
+              Coord p_check_x, p_check_y;
+              Coord c_check_x, c_check_y;
 
               start_angle = atan2 ((p->point[1] - p->cy), -(p->point[0] - p->cx)) / M180;
               end_angle   = atan2 ((c->point[1] - p->cy), -(c->point[0] - p->cx)) / M180;
@@ -3629,6 +3685,34 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               if (delta_angle > 180.) delta_angle -= 360.;
               if (delta_angle < -180.) delta_angle += 360.;
 
+              p_check_x = p->cx + p->radius * -cos (start_angle * M180);
+              p_check_y = p->cy + p->radius *  sin (start_angle * M180);
+              c_check_x = p->cx + p->radius * -cos (end_angle * M180);
+              c_check_y = p->cy + p->radius *  sin (end_angle * M180);
+
+              if (p_check_x != p->point[0] || p_check_y != p->point[1] ||
+                  c_check_x != c->point[0] || c_check_y != c->point[1])
+                {
+                  fprintf (stderr, "Oh dear, arc start point doesn't land correctly\n");
+                  pcb_fprintf (stderr, "p = (%$mn, %$mn), c = (%$mn, %$mn) (by endpoint)\n",
+                               p->point[0], p->point[1], c->point[0], c->point[1]);
+                  pcb_fprintf (stderr, "! = (%$mn, %$mn), ! = (%$mn, %$mn) (by angles, center and radius)\n",
+                               p_check_x, p_check_y, c_check_x, c_check_y);
+                  fprintf (stderr, "Error distances are %fnm %fnm\n",
+                           hypot (p->point[0] - p_check_x, p->point[1] - p_check_y),
+                           hypot (c->point[0] - c_check_x, c->point[1] - c_check_y));
+                  fprintf (stderr, "\n");
+                  //*(char *)0 = 0;
+                  p->point[0] = p_check_x;
+                  p->point[1] = p_check_y;
+                  c->point[0] = c_check_x;
+                  c->point[1] = c_check_y;
+                }
+              else
+                {
+                  fprintf (stderr, "angles ok\n");
+                }
+
               arc_bound = calc_thin_arc_bounds (p->cx, p->cy, p->radius, p->radius, start_angle, delta_angle);
 
               C->xmin = min (C->xmin, arc_bound.X1);
