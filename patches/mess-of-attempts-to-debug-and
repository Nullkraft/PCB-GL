Bottom: e6f29f3897960285a183b5892c2a28afcfa8db4c
Top:    1568bd156545fc2700815243ec791b18e04bf3c9
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-10 16:56:03 +0000

Mess of attempts to debug and improve arc-support in polygon code


---

diff --git a/src/misc.c b/src/misc.c
index b4babfd..79416c8 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -362,10 +362,12 @@ SetLineBoundingBox (LineType *Line)
  */
 void
 calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle,
-                                         Coord *cx, Coord *cy, Coord *radius,
+                                         double *cx, double *cy, double *radius,
+//                                         Coord *cx, Coord *cy, Coord *radius,
                                          Angle *start_angle, Angle *delta_angle)
 {
-  Coord hx, hy;
+  double hx, hy;
+//  Coord hx, hy;
   double p_to_h_dist;
   double c_to_h_dist;
   double unit_hcx, unit_hcy;
@@ -434,7 +436,8 @@ SetPolygonBoundingBox (PolygonType *Polygon)
     if (point->included_angle != 0)
       {
         BoxType arc_bound;
-        Coord cx, cy, radius;
+        double cx, cy, radius;
+//        Coord cx, cy, radius;
         Angle start_angle, delta_angle;
         PointType *next_point;
 
diff --git a/src/misc.h b/src/misc.h
index 84f62ed..ded72f6 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -53,7 +53,8 @@ void SetArcEndpoints (ArcType *);
 void SetPointBoundingBox (PointType *);
 void SetPinBoundingBox (PinType *);
 void SetPadBoundingBox (PadType *);
-void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, Coord *cx, Coord *cy, Coord *radius, Angle *start_angle, Angle *delta_angle);
+void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, double *cx, double *cy, double *radius, Angle *start_angle, Angle *delta_angle);
+//void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, Coord *cx, Coord *cy, Coord *radius, Angle *start_angle, Angle *delta_angle);
 void SetPolygonBoundingBox (PolygonType *);
 void SetElementBoundingBox (DataType *, ElementType *, FontType *);
 bool IsDataEmpty (DataType *);
diff --git a/src/polyarea.h b/src/polyarea.h
index c892307..199bc59 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -94,8 +94,10 @@ struct VNODE
     double p0; /* Smaller parameter along curve, 0-1 */
     double p1; /* Larger  parameter along curve, 0-1 */
     bool is_round;
-    Coord cx, cy;
-    Coord radius;
+    double cx, cy;
+    double radius;
+//    Coord cx, cy;
+//    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -130,7 +132,8 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
-VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
+VNODE *poly_CreateNodeArcApproximation(Vector v, double cx, double cy, double radius);
+//VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index c04b153..40296ed 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -293,7 +293,8 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
+//degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
+degree_circle (PLINE * c, double X, double Y /* <- Center */, double radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -393,8 +394,10 @@ original_poly (PolygonType * p)
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
-          Coord cx, cy;
-          Coord radius;
+          double cx, cy;
+          double radius;
+//          Coord cx, cy;
+//          Coord radius;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -2460,6 +2463,12 @@ POLYAREA *board_outline_poly (bool include_holes)
   return clipped;
 #endif
 
+  if (clipped == NULL)
+    {
+      fprintf (stderr, "clipped == NULL in board_outline_poly\n");
+      return clipped;
+    }
+
   /* Now we just need to work out which pieces of polygon are inside
      and outside the board! */
 
diff --git a/src/polygon1.c b/src/polygon1.c
index df10837..89233a6 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -159,7 +159,7 @@ pline_dump (VNODE * v)
   do
     {
       n = NEXT_VERTEX(v);
-      pcb_fprintf (stderr, "Line [%#mS %#mS %#mS %#mS 10 10 \"%s\"]\n",
+      pcb_fprintf (stderr, "Line [%#$mn %#$mn %#$mn %#$mn 10 10 \"%s\"]\n",
 	       v->point[0], v->point[1],
 	       n->point[0], n->point[1], theState (v));
     }
@@ -190,7 +190,8 @@ poly_dump (POLYAREA * p)
 }
 
 static VNODE *
-poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+poly_CreateNodeFull (Vector v, bool is_round, double cx, double cy, double radius)
+//poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
 {
   VNODE *res;
   Coord *c;
@@ -200,6 +201,29 @@ poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
   if (res == NULL)
     return NULL;
   // bzero (res, sizeof (VNODE) - sizeof(Vector));
+
+#if 0
+  if (is_round)
+    {
+      Angle start_angle;
+//      Angle end_angle;
+      Coord check_x, check_y;
+
+      start_angle = atan2 ((v[1] - cy), -(v[0] - cx)) / M180;
+
+      check_x = cx + radius * -cos (start_angle * M180);
+      check_y = cy + radius *  sin (start_angle * M180);
+
+      if (check_x != v[0] || check_y != v[1])
+        {
+          fprintf (stderr, "poly_CreateNodeFull() Tweaking from vertex location to match angle calculation\n");
+          pcb_fprintf (stderr, "Moving from (%$mn, %$mn) to (%$mn, %$mn)\n", v[0], v[1], check_x, check_y);
+          v[0] = check_x;
+          v[1] = check_y;
+        }
+    }
+#endif
+
   c = res->point;
   *c++ = *v++;
   *c = *v;
@@ -224,7 +248,8 @@ poly_CreateNode (Vector v)
 }
 
 VNODE *
-poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+//poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+poly_CreateNodeArcApproximation (Vector v, double cx, double cy, double radius)
 {
 //  return poly_CreateNodeFull (v, false /*true*/, cx, cy, radius);
   return poly_CreateNodeFull (v, true, cx, cy, radius);
@@ -643,7 +668,16 @@ edge_label (VNODE * pn)
        */
       if (l->poly == l->next->poly &&
           l->side != l->next->side && /* <-- PCJC: Not sure if this is required, including for sanity */
-          l->angle == l->next->angle)
+          l->angle == l->next->angle &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->is_round ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->is_round &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->radius ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->radius &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->cx ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->cx &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->cy ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->cy)
+
         l = l->next->next;
     }
   assert (l->poly != this_poly);
@@ -719,6 +753,34 @@ edge_label (VNODE * pn)
   return region;
 }				/* edge_label */
 
+static void
+cvc_list_dump (CVCList *list)
+{
+  VNODE *node = list->parent;
+  CVCList *iter;
+
+  /* Only print for the vertex we're interested in at the moment */
+  if (!(
+      (node->point[0] == 69088001 || node->point[0] == 69088000 || node->point[0] == 69087998) &&
+      node->point[1] == 29336999))
+    return;
+
+  pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
+
+  iter = list;
+  do {
+    pcb_fprintf (stderr, "angle = %f, poly = %c, side = %c, (%mm, %mm)-(%mm, %mm)\n",
+                 iter->angle,
+                 iter->poly,
+                 iter->side,
+                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
+                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1],
+                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
+                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1]);
+  } while ((iter = iter->next) != list);
+
+}
+
 /*
  add_descriptors
  (C) 2006 harry eaton
@@ -737,9 +799,11 @@ add_descriptors (PLINE * pl, char poly, CVCList * list)
 	  list = node->cvc_prev = insert_descriptor (node, poly, 'P', list);
 	  if (!node->cvc_prev)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	  list = node->cvc_next = insert_descriptor (node, poly, 'N', list);
 	  if (!node->cvc_next)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	}
     }
   while ((node = NEXT_VERTEX(node)) != &pl->head);
@@ -1115,6 +1179,7 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
   printf ("  Intersect count is %i\n", cnt);
 
+#if 0
   if (cnt == 0)
     {
       printf ("Trying with a perturbation\n");
@@ -1129,6 +1194,10 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
       printf ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<<<<\n");
     }
+#endif
+
+  if (cnt == 0)
+    return 0;
 
   if (cnt == 2)
     {
@@ -2502,8 +2571,8 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
           VERTEX_FORWARD_EDGE (newn)->orig_point0[1] = VERTEX_BACKWARD_EDGE (curv)->orig_point1[1];
           VERTEX_FORWARD_EDGE (newn)->orig_point1[0] = VERTEX_BACKWARD_EDGE (curv)->orig_point0[0];
           VERTEX_FORWARD_EDGE (newn)->orig_point1[1] = VERTEX_BACKWARD_EDGE (curv)->orig_point0[1];
-          VERTEX_FORWARD_EDGE (newn)->p0 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->prev->p1;
-          VERTEX_FORWARD_EDGE (newn)->p1 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->prev->p0;
+          VERTEX_FORWARD_EDGE (newn)->p0 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->/*prev->*/p1;
+          VERTEX_FORWARD_EDGE (newn)->p1 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->/*prev->*/p0;
           if (VERTEX_FORWARD_EDGE (newn)->p1 < VERTEX_FORWARD_EDGE (newn)->p0)
             {
               printf ("!FORW: OH DEAR, p0=%f, p1=%f\n", newn->p0, newn->p1);
@@ -3639,6 +3708,8 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               Angle end_angle;
               Angle delta_angle;
               BoxType arc_bound;
+              Coord p_check_x, p_check_y;
+              Coord c_check_x, c_check_y;
 
               start_angle = atan2 ((p->point[1] - p->cy), -(p->point[0] - p->cx)) / M180;
               end_angle   = atan2 ((c->point[1] - p->cy), -(c->point[0] - p->cx)) / M180;
@@ -3649,6 +3720,34 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               if (delta_angle > 180.) delta_angle -= 360.;
               if (delta_angle < -180.) delta_angle += 360.;
 
+              p_check_x = p->cx + p->radius * -cos (start_angle * M180);
+              p_check_y = p->cy + p->radius *  sin (start_angle * M180);
+              c_check_x = p->cx + p->radius * -cos (end_angle * M180);
+              c_check_y = p->cy + p->radius *  sin (end_angle * M180);
+
+              if (p_check_x != p->point[0] || p_check_y != p->point[1] ||
+                  c_check_x != c->point[0] || c_check_y != c->point[1])
+                {
+                  fprintf (stderr, "Oh dear, arc start point doesn't land correctly\n");
+                  pcb_fprintf (stderr, "p = (%$mn, %$mn), c = (%$mn, %$mn) (by endpoint)\n",
+                               p->point[0], p->point[1], c->point[0], c->point[1]);
+                  pcb_fprintf (stderr, "! = (%$mn, %$mn), ! = (%$mn, %$mn) (by angles, center and radius)\n",
+                               p_check_x, p_check_y, c_check_x, c_check_y);
+                  fprintf (stderr, "Error distances are %fnm %fnm\n",
+                           hypot (p->point[0] - p_check_x, p->point[1] - p_check_y),
+                           hypot (c->point[0] - c_check_x, c->point[1] - c_check_y));
+                  fprintf (stderr, "\n");
+                  //*(char *)0 = 0;
+                  p->point[0] = p_check_x;
+                  p->point[1] = p_check_y;
+                  c->point[0] = c_check_x;
+                  c->point[1] = c_check_y;
+                }
+              else
+                {
+                  fprintf (stderr, "angles ok\n");
+                }
+
               arc_bound = calc_thin_arc_bounds (p->cx, p->cy, p->radius, p->radius, start_angle, delta_angle);
 
               C->xmin = min (C->xmin, arc_bound.X1);
