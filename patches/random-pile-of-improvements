Bottom: 83369e71366369c9ecb257bb01c4ebaacf57ae75
Top:    c146c73b96284422ad79d077444251bea27af7c6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-13 17:05:24 +0000

Random pile of improvements, hacks and awesomeness


---

diff --git a/configure.ac b/configure.ac
index 058fa40..ab8e873 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1143,7 +1143,7 @@ LIBS="$LIBS $XM_LIBS $DBUS_LIBS $X_LIBS $GLIB_LIBS $GTK_LIBS $DMALLOC_LIBS $GD_L
 # if we have gcc then add -Wall
 if test "x$GCC" = "xyes"; then
 	# see about adding some extra checks if the compiler takes them
-	for flag in -Wall ; do
+	for flag in -Wall -fno-omit-frame-pointer; do
 		case " ${CFLAGS} " in
 			*\ ${flag}\ *)
 				# flag is already present
diff --git a/src/hid/common/contour3d.c b/src/hid/common/contour3d.c
index eb2235e..2372ca9 100644
--- a/src/hid/common/contour3d.c
+++ b/src/hid/common/contour3d.c
@@ -10,7 +10,7 @@ make_contour3d (edge_ref first_edge)
 {
   contour3d *contour;
 
-  contour = g_new0 (contour3d, 1);
+  contour = g_slice_new0 (contour3d);
   contour->first_edge = first_edge;
 
   return contour;
@@ -19,5 +19,5 @@ make_contour3d (edge_ref first_edge)
 void
 destroy_contour3d (contour3d *contour)
 {
-  g_free (contour);
+  g_slice_free (contour3d, contour);
 }
diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index 411d59c..ebcdc08 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -9,7 +9,7 @@ make_edge_info (void)
 {
   edge_info *info;
 
-  info = g_new0 (edge_info, 1);
+  info = g_slice_new0 (edge_info);
 
   return info;
 }
@@ -35,5 +35,5 @@ void edge_info_set_stitch (edge_info *info)
 void
 destroy_edge_info (edge_info *info)
 {
-  g_free (info);
+  g_slice_free (edge_info, info);
 }
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index cf59b95..a98cda1 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -12,7 +12,7 @@ make_face3d (char *name)
 {
   face3d *face;
 
-  face = g_new0 (face3d, 1);
+  face = g_slice_new0 (face3d);
   face->name = g_strdup (name);
 
   return face;
@@ -23,7 +23,7 @@ destroy_face3d (face3d *face)
 {
   g_list_free_full (face->contours, (GDestroyNotify)destroy_contour3d);
   g_free (face->name);
-  g_free (face);
+  g_slice_free (face3d, face);
 }
 
 void
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 277d99f..efe337c 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -33,6 +33,8 @@
 #include "hid/hidint.h"
 
 #define PERFECT_ROUND_CONTOURS
+#define SUM_PINS_VIAS_ONCE
+#define HASH_OBJECTS
 
 #define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
 //#undef REVERSED_PCB_CONTOURS
@@ -93,7 +95,7 @@ make_object3d (char *name)
   static int object3d_count = 0;
   object3d *object;
 
-  object = g_new0 (object3d, 1);
+  object = g_slice_new0 (object3d);
   object->id = object3d_count++;
   object->name = g_strdup (name);
 
@@ -107,7 +109,7 @@ destroy_object3d (object3d *object)
   g_list_free_full (object->edges, (GDestroyNotify)destroy_edge);
   g_list_free_full (object->faces, (GDestroyNotify)destroy_face3d);
   g_free (object->name);
-  g_free (object);
+  g_slice_free (object3d, object);
 }
 
 void
@@ -723,12 +725,13 @@ object3d_from_contours (POLYAREA *contours,
 
       objects = g_list_prepend (objects, object);
 
-      link = malloc (sizeof (polygon_3d_link));
+      link = g_slice_new0 (polygon_3d_link);
       pa->user_data = link;
       link->object = object;
       link->bottom_face = faces[npoints];
       link->top_face = faces[npoints + 1];
 
+      object->user_data = g_list_prepend ((GList *)object->user_data, link);
     }
   while (pa = pa->f, pa != contours);
 
@@ -994,6 +997,9 @@ pv_drill_callback (const BoxType * b, void *cl)
   struct mask_info *info = cl;
   POLYAREA *np, *res;
 
+  if (TEST_FLAG (HOLEFLAG, pv))
+    return 0;
+
   if (!(np = CirclePoly (pv->X, pv->Y, (pv->DrillingHole + 1) / 2, NULL)))
     return 0;
 
@@ -1011,6 +1017,9 @@ pv_barrel_callback (const BoxType * b, void *cl)
   struct mask_info *info = cl;
   POLYAREA *np, *res;
 
+  if (TEST_FLAG (HOLEFLAG, pv))
+    return 0;
+
   if (!(np = CirclePoly (pv->X, pv->Y, (pv->DrillingHole + HACK_PLATED_BARREL_THICKNESS + 1) / 2, NULL)))
     return 0;
 
@@ -1354,6 +1363,9 @@ pv_copper_callback (const BoxType * b, void *cl)
   POLYAREA *np, *res;
   char *netname;
 
+  if (TEST_FLAG (HOLEFLAG, pv))
+    return 0;
+
   if (!(np = PinPoly (pv, PIN_SIZE (pv))))
     return 0;
 
@@ -1372,7 +1384,7 @@ pv_copper_callback (const BoxType * b, void *cl)
 
 
 static void
-steal_object_geometry (object3d *dst, object3d *src)
+steal_object_geometry (object3d *src, object3d *dst)
 {
   g_assert (dst != src);
 
@@ -1383,11 +1395,26 @@ steal_object_geometry (object3d *dst, object3d *src)
   src->faces = NULL;
   src->edges = NULL;
   src->vertices = NULL;
+
+  /* Join up their link data */
+  dst->user_data = g_list_concat (dst->user_data, src->user_data);
+  src->user_data = NULL;
 }
 
 static void
-update_object_pointers (POLYAREA **group_m_poly, object3d *old_object, object3d *new_object)
+update_object_pointers (/*POLYAREA **group_m_poly, int touched_group, */object3d *old_object, object3d *new_object)
 {
+  GList *iter;
+
+  for (iter = old_object->user_data; iter != NULL; iter = g_list_next (iter))
+    {
+      polygon_3d_link *link = iter->data;
+
+      g_warn_if_fail (link->object == old_object);
+      link->object = new_object;
+    }
+
+#if 0
   int group;
   int top_group;
   int bottom_group;
@@ -1401,8 +1428,19 @@ update_object_pointers (POLYAREA **group_m_poly, object3d *old_object, object3d
   min_copper_group = MIN (bottom_group, top_group);
   max_copper_group = MAX (bottom_group, top_group);
 
-  for (group = min_copper_group; group <= max_copper_group; group++)
+  for (group = min_copper_group; group <= touched_group + 1 /*max_copper_group*/; group++)
     {
+
+      /* Skip this group if it isn't one we've touched, or will be working on, and isn't
+       * the top / bottom
+       * groups (which will be required to be correct for inserting drill holes
+       */
+      if (group != min_copper_group &&
+          group != max_copper_group &&
+          group != touched_group &&
+          group != touched_group + 1)
+        continue;
+
       pa = group_m_poly[group];
       do
         {
@@ -1414,6 +1452,7 @@ update_object_pointers (POLYAREA **group_m_poly, object3d *old_object, object3d
         }
       while ((pa = pa->f) != group_m_poly[group]);
     }
+#endif
 }
 
 /* Returns a string allocated with g_malloc family of functions */
@@ -1437,6 +1476,16 @@ merge_contour_name (char *old, const char *new)
   return combined;
 }
 
+#ifdef HASH_OBJECTS
+static void
+copy_glist_into_hash (GHashTable *hash, GList *items)
+{
+  GList *iter;
+  for (iter = items; iter != NULL; iter = g_list_next (iter))
+    g_hash_table_insert (hash, iter->data, iter);
+}
+#endif
+
 GList *
 object3d_from_copper_layers_within_area (POLYAREA *area)
 {
@@ -1454,6 +1503,13 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   POLYAREA **group_m_polyarea;
   POLYAREA *barrel_m_polyarea;
   POLYAREA *drill_m_polyarea;
+#ifdef SUM_PINS_VIAS_ONCE
+  POLYAREA *pinvia_m_polyarea;
+  POLYAREA *temp;
+#endif
+#ifdef HASH_OBJECTS
+  GHashTable *object_hash;
+#endif
 
 //  poly_Copy0 (&info.poly, area);
 
@@ -1476,18 +1532,32 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   group_m_polyarea = calloc (max_copper_group + 1, sizeof (POLYAREA *));
 
   group_objects = NULL;
+#ifdef HASH_OBJECTS
+  object_hash = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, NULL);
+#endif
+
+#ifdef SUM_PINS_VIAS_ONCE
+  info.poly = NULL;
+  fprintf (stderr, "Accumulating master pin + via polygon\n");
+  r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
+  r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
+  pinvia_m_polyarea = info.poly;
+#endif
 
   for (group = min_copper_group; group <= max_copper_group; group++)
     {
+      GList *new_objects;
       Coord depth = compute_depth (group);
 
       info.poly = NULL;
 
       fprintf (stderr, "Computing copper geometry for group %i\n", group);
 
+      fprintf (stderr, "Accumulating pin + via pads\n");
+
       GROUP_LOOP (PCB->Data, group);
         {
-          fprintf (stderr, "Accumulating elements from layer %i\n", GetLayerNumber (PCB->Data, layer));
+          fprintf (stderr, "Accumulating copper from layer %i\n", GetLayerNumber (PCB->Data, layer));
 
           r_search (layer->line_tree, &bounds, NULL, line_copper_callback, &info);
           r_search (layer->arc_tree,  &bounds, NULL, arc_copper_callback, &info);
@@ -1496,9 +1566,13 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
         }
       END_LOOP;
 
-      fprintf (stderr, "Accumulating pin + via pads\n");
+#ifdef SUM_PINS_VIAS_ONCE
+      poly_M_Copy0 (&temp, pinvia_m_polyarea);
+      poly_Boolean_free (info.poly, temp, &info.poly, PBO_UNITE);
+#else
       r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
       r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
+#endif
 
       if (group == top_group ||
           group == bottom_group)
@@ -1545,7 +1619,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           continue;
         }
 
-      if (1)
+      if (0)
         {
           POLYAREA *pa = info.poly;
           do
@@ -1559,7 +1633,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
       group_m_polyarea[group] = info.poly;
       poly_Simplify (group_m_polyarea[group]);
 
-      group_objects = g_list_concat (group_objects,
+      new_objects =
         object3d_from_contours (group_m_polyarea[group],
 #ifdef REVERSED_PCB_CONTOURS
                                 depth,                         /* Bottom */
@@ -1571,9 +1645,17 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
                                 copper_appearance,
                                 NULL,  /* top_bot_appearance */
                                 false, /* Don't invert */
-                                "Net")); /* Name */
+                                "Net"); /* Name */
+#ifdef HASH_OBJECTS
+      copy_glist_into_hash (object_hash, new_objects);
+#endif
+      group_objects = g_list_concat (group_objects, new_objects);
     }
 
+#ifdef SUM_PINS_VIAS_ONCE
+  poly_Free (&pinvia_m_polyarea);
+#endif
+
   /* Now need to punch drill-holes through the inter-layers..
    * Ideally, we construct a polygon of drill-holes, so any overlapping are taken into account
    */
@@ -1733,20 +1815,28 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           /* All edges must end up in the top object, so we leave them */
 
           /* Steal the data from the barrel object */
-          steal_object_geometry (top_group_object, barrel_object);
+          update_object_pointers (barrel_object, top_group_object);
+          steal_object_geometry (barrel_object, top_group_object);
           destroy_object3d (barrel_object);
 
           if (top_group_object != bottom_group_object)
             { /* Top object and bottom object were previously distinct */
+              GList *link;
 
               /* Update any remaining link pointers to the previous bottom object we are about to delete */
-              update_object_pointers (group_m_polyarea, bottom_group_object, top_group_object);
+              update_object_pointers (/*group_m_polyarea, group, */bottom_group_object, top_group_object);
 
               /* Remove the old bottom object from the list of output objects */
+#ifdef HASH_OBJECTS
+              link = g_hash_table_lookup (object_hash, bottom_group_object);
+              group_objects = g_list_delete_link (group_objects, link);
+              g_hash_table_remove (object_hash, bottom_group_object);
+#else
               group_objects = g_list_remove (group_objects, bottom_group_object);
+#endif
 
               /* Steal the data from the old bottom object */
-              steal_object_geometry (top_group_object, bottom_group_object);
+              steal_object_geometry (bottom_group_object, top_group_object);
 
 //              printf ("Merging object with name %s and %s\n", top_group_object->name, bottom_group_object->name);
               top_group_object->name = merge_contour_name (top_group_object->name, bottom_group_object->name);
@@ -1755,7 +1845,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
               destroy_object3d (bottom_group_object);
             }
 
-          free (pa->user_data);
+//          g_slice_free (polygon_3d_link, pa->user_data);
         }
       while (pa = pa->f, pa != barrel_m_polyarea);
 
@@ -1816,7 +1906,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           edge_ref drill_bottom_face_first_edge = ((contour3d *)drill_bottom_face->contours->data)->first_edge;
           edge_ref e;
 
-          g_warn_if_fail (top_group_object == bottom_group_object);
+          g_assert (top_group_object == bottom_group_object);
 
           /* Do some magic to join the objects */
 
@@ -1856,10 +1946,10 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           /* All edges must end up in the top object, so we leave them */
 
           /* Steal the data from the drill object */
-          steal_object_geometry (top_group_object, drill_object);
+          steal_object_geometry (drill_object, top_group_object);
           destroy_object3d (drill_object);
 
-          free (pa->user_data);
+          g_slice_free (polygon_3d_link, pa->user_data);
         }
       while (pa = pa->f, pa != drill_m_polyarea);
 
@@ -1890,10 +1980,13 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
     {
       if (group_m_polyarea[group] != NULL)
         {
-          free (group_m_polyarea[group]->user_data);
+          g_slice_free (polygon_3d_link, group_m_polyarea[group]->user_data);
           poly_Free (&group_m_polyarea[group]);
         }
     }
 
+#ifdef HASH_OBJECTS
+  g_hash_table_destroy (object_hash);
+#endif
   return group_objects;
 }
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index edf4d4c..094d307 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -5,6 +5,7 @@ typedef struct {
   GList *edges;
   GList *vertices;
   GList *faces;
+  void *user_data
 } object3d;
 
 void object3d_test_init (void);
diff --git a/src/hid/common/vertex3d.c b/src/hid/common/vertex3d.c
index e92dcb0..6f8f4e0 100644
--- a/src/hid/common/vertex3d.c
+++ b/src/hid/common/vertex3d.c
@@ -11,7 +11,7 @@ make_vertex3d (double x, double y, double z)
 {
   vertex3d *v;
 
-  v = g_new0 (vertex3d, 1);
+  v = g_slice_new0 (vertex3d);
   v->x = x;
   v->y = y;
   v->z = z;
@@ -23,5 +23,5 @@ make_vertex3d (double x, double y, double z)
 void
 destroy_vertex3d (vertex3d *v)
 {
-  g_free (v);
+  g_slice_free (vertex3d, v);
 }
diff --git a/src/polygon1.c b/src/polygon1.c
index e3c7227..81d8574 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -76,6 +76,9 @@ double vect_len2 (Vector v1);
 
 int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 		  Vector S2);
+int vect_inters2_fp (double p1[2], double p2[2],
+                     double q1[2], double q2[2],
+                     double S1[2], double S2[2]);
 
 /* note that a vertex v's Flags.status represents the edge defined by
  * v to v->next (i.e. the edge is forward of v)
@@ -118,6 +121,7 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 #undef DEBUG_GATHER
 #undef DEBUG_ANGLE
 #undef DEBUG
+#define DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -621,7 +625,7 @@ edge_label (VNODE * pn, int existing_label)
        */
       region = (l->side == 'P') ? SHARED2 : SHARED;
       pn->shared = VERTEX_SIDE_DIR_EDGE (l->parent, l->side);
-      cvc_list_dump (l);
+//      cvc_list_dump (l);
     }
   else
     {
@@ -697,18 +701,21 @@ struct _insert_node_task
   insert_node_task *next;
   seg * node_seg;
   VNODE *new_node;
+  POLYAREA *poly;
 };
 
 typedef struct info
 {
   double m, b;
-  rtree_t *tree;
+//  rtree_t *tree;
   VNODE *v;
   struct seg *s;
   jmp_buf *env, sego, *touch;
   int need_restart;
   insert_node_task *node_insert_list;
   bool debug;
+  POLYAREA *looping_over_poly;
+  POLYAREA *rtree_over_poly;
 } info;
 
 typedef struct contour_info
@@ -718,6 +725,8 @@ typedef struct contour_info
   jmp_buf *getout;
   int need_restart;
   insert_node_task *node_insert_list;
+  POLYAREA *looping_over_poly;
+  POLYAREA *rtree_over_poly;
 } contour_info;
 
 
@@ -782,12 +791,13 @@ seg_in_region (const BoxType * b, void *cl)
 
 /* Prepend a deferred node-insersion task to a list */
 static insert_node_task *
-prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
+prepend_insert_node_task (insert_node_task *list, POLYAREA *poly, seg *seg, VNODE *new_node)
 {
   insert_node_task *task = (insert_node_task *)malloc (sizeof (*task));
   task->node_seg = seg;
   task->new_node = new_node;
   task->next = list;
+  task->poly = poly;
   return task;
 }
 
@@ -837,7 +847,7 @@ seg_in_seg (const BoxType * b, void *cl)
 	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
 #endif
 	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, i->s, new_node);
+	    prepend_insert_node_task (i->node_insert_list, i->looping_over_poly, i->s, new_node);
 	  i->s->intersected = 1;
 	  done_insert_on_i = true;
 	}
@@ -849,7 +859,7 @@ seg_in_seg (const BoxType * b, void *cl)
 	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
 #endif
 	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, s, new_node);
+	    prepend_insert_node_task (i->node_insert_list, i->rtree_over_poly, s, new_node);
 	  s->intersected = 1;
 	  return 0; /* Keep looking for intersections with segment "i" */
 	}
@@ -917,6 +927,309 @@ get_seg (const BoxType * b, void *cl)
 }
 
 /*
+ * intersect_rounded() (and helpers)
+ * (C) 2006, harry eaton
+ * (C) 2016, Peter Clifton
+ *
+ * Handling of snap-rounding edges against other vertex end-points
+ *
+ * This uses an rtree to find A-B intersections. Whenever a new vertex is
+ * added, the search for intersections is re-started because the rounding
+ * could alter the topology otherwise. 
+ * This should use a faster algorithm for snap rounding intersection finding.
+ * The best algorthim is probably found in:
+ *
+ * "Improved output-sensitive snap rounding," John Hershberger, Proceedings
+ * of the 22nd annual symposium on Computational geomerty, 2006, pp 357-366.
+ * http://doi.acm.org/10.1145/1137856.1137909
+ *
+ * Algorithms described by de Berg, or Goodrich or Halperin, or Hobby would
+ * probably work as well.
+ *
+ */
+
+static bool
+process_deferred_intersections (/*POLYAREA *b, */insert_node_task *task)
+{
+  bool any_inserted = false;
+
+  while (task != NULL)
+    {
+      insert_node_task *next = task->next;
+
+      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
+      task->node_seg->v->is_round = false;
+
+      /* Do insersion */
+      PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
+      NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
+      PREV_VERTEX (EDGE_FORWARD_VERTEX (task->node_seg->v)) = task->new_node;
+      EDGE_FORWARD_VERTEX (task->node_seg->v) = task->new_node;
+      task->node_seg->p->Count++;
+
+      if (cntrbox_check (task->node_seg->p, task->new_node->point))
+        {
+          /* First delete the contour from the contour r-tree, as its bounds
+           * may be adjusted whilst inserting nodes
+           */
+          r_delete_entry (task->poly->contour_tree, (const BoxType *) task->node_seg->p);
+          cntrbox_adjust (task->node_seg->p, task->new_node->point);
+          r_insert_entry (task->poly->contour_tree, (const BoxType *) task->node_seg->p, 0);
+        }
+
+      if (adjust_tree (task->node_seg->p->tree, task->node_seg))
+        assert (0); /* XXX: Memory allocation failure */
+
+      any_inserted = true; /* Any new nodes could intersect */
+
+      free (task);
+      task = next;
+    }
+
+  return any_inserted;
+}
+
+/*
+ Based upon vect_inters2
+ (C) 1993 Klamer Schutte
+ (C) 1997 Michael Leonov, Alexey Nikitin
+*/
+static bool
+line_point_inters (Vector p1, Vector p2, Vector point)
+{
+  double p1_fp[2] = {p1[0], p1[1]};
+  double p2_fp[2] = {p2[0], p2[1]};
+  double q1_fp[2];
+  double q2_fp[2];
+  double s1_fp[2];
+  double s2_fp[2];
+
+  q1_fp[0] = point[0] - 0.5;
+  q2_fp[0] = point[0] + 0.5;
+  q1_fp[1] = point[1] - 0.5;
+  q2_fp[1] = point[1] - 0.5;
+
+  if (vect_inters2_fp (p1_fp, p2_fp, q1_fp, q2_fp, /* out */s1_fp, s2_fp) > 0)
+    return true;
+
+  q1_fp[0] = point[0] + 0.5;
+  q2_fp[0] = point[0] + 0.5;
+  q1_fp[1] = point[1] - 0.5;
+  q2_fp[1] = point[1] + 0.5;
+
+  if (vect_inters2_fp (p1_fp, p2_fp, q1_fp, q2_fp, /* out */s1_fp, s2_fp) > 0)
+    return true;
+
+  q1_fp[0] = point[0] - 0.5;
+  q2_fp[0] = point[0] + 0.5;
+  q1_fp[1] = point[1] + 0.5;
+  q2_fp[1] = point[1] + 0.5;
+
+  if (vect_inters2_fp (p1_fp, p2_fp, q1_fp, q2_fp, /* out */s1_fp, s2_fp) > 0)
+    return true;
+
+  q1_fp[0] = point[0] - 0.5;
+  q2_fp[0] = point[0] - 0.5;
+  q1_fp[1] = point[1] - 0.5;
+  q2_fp[1] = point[1] + 0.5;
+
+  if (vect_inters2_fp (p1_fp, p2_fp, q1_fp, q2_fp, /* out */s1_fp, s2_fp) > 0)
+    return true;
+
+  return false;
+}
+
+/*
+ * vertex_in_seg_rounded()
+ * (C) 2006 harry eaton
+ * (C) 2016 Peter Clifton
+ * This routine checks if the segment in the tree intersect the search segment.
+ * If it does, the plines are marked as intersected and the point is marked for
+ * the cvclist. If the point is not already a vertex, a new vertex is inserted
+ * and the search for intersections starts over at the beginning.
+ * That is potentially a significant time penalty, but it does solve the snap rounding
+ * problem. There are efficient algorithms for finding intersections with snap
+ * rounding, but I don't have time to implement them right now.
+ */
+static int
+vertex_in_seg_rounded (const BoxType * b, void *cl)
+{
+  struct info *i = (struct info *) cl;
+  struct seg *s = (struct seg *) b;
+  VNODE *new_node;
+
+  if (!line_point_inters (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point, i->v->point))
+    return 0;
+
+  /* When new nodes are added at the end of a pass due to an intersection
+   * the segments may be altered. If either segment we're looking at has
+   * already been intersected this pass, skip it until the next pass.
+   */
+  if (s->intersected)
+    return 0;
+
+  if (i->touch)			/* if checking touches one find and we're done */
+    longjmp (*i->touch, TOUCHES);
+
+//  i->s->p->Flags.status = ISECTED; /* XXX */
+  s->p->Flags.status = ISECTED;
+
+  new_node = node_add_single_point (s->v, i->v->point);
+  if (new_node != NULL)
+    {
+//#ifdef DEBUG_INTERSECT
+      DEBUGP ("found new rounded intersection on segment \"s\" at (%$mn, %$mn)\n",
+              i->v->point[0], i->v->point[1]);
+//#endif
+      i->node_insert_list =
+        prepend_insert_node_task (i->node_insert_list, i->rtree_over_poly, s, new_node);
+      s->intersected = 1;
+      return 0; /* Keep looking for intersections with the test vertex */
+    }
+  return 0;
+}
+
+
+static int
+rounded_contour_bounds_touch (const BoxType * b, void *cl)
+{
+  contour_info *c_info = (contour_info *) cl;
+  PLINE *pa = c_info->pa;
+  PLINE *pb = (PLINE *) b;
+  PLINE *rtree_over;
+  PLINE *looping_over;
+  VNODE *av; /* node iterators */ /* av is considered an edge */
+  struct info info;
+  BoxType box;
+  jmp_buf restart;
+
+  /* Have vertex_in_seg_rounded return to our desired location if it touches */
+  info.env = &restart;
+  info.touch = c_info->getout;
+  info.need_restart = 0;
+  info.node_insert_list = c_info->node_insert_list;
+  info.looping_over_poly = c_info->looping_over_poly;
+  info.rtree_over_poly = c_info->rtree_over_poly;
+
+  looping_over = pa;
+  rtree_over = pb;
+
+  av = &looping_over->head;
+  do				/* Loop over the edges in the smaller contour */
+    {
+      /* check this vertex for any insertions */
+      info.v = av;
+#if 0
+      /* check this edge for any insertions */
+      double dx;
+      /* compute the slant for region trimming */
+      dx = EDGE_FORWARD_VERTEX (av)->point[0] - EDGE_BACKWARD_VERTEX (av)->point[0];
+      if (dx == 0)
+	info.m = 0;
+      else
+	{
+	  info.m = (EDGE_FORWARD_VERTEX (av)->point[1] - EDGE_BACKWARD_VERTEX (av)->point[1]) / dx;
+	  info.b = EDGE_BACKWARD_VERTEX (av)->point[1] - info.m * EDGE_BACKWARD_VERTEX (av)->point[0];
+	}
+      box.X2 = (box.X1 = EDGE_BACKWARD_VERTEX (av)->point[0]) + 1;
+      box.Y2 = (box.Y1 = EDGE_BACKWARD_VERTEX (av)->point[1]) + 1;
+#endif
+
+      box.X2 = (box.X1 = av->point[0] - 1) + 3; /* NB: We expand the search box to ensure we catch edges which may round to this coordinate */
+      box.Y2 = (box.Y1 = av->point[1] - 1) + 3;
+
+#if 0
+      /* fill in the segment in info corresponding to this node */
+      if (setjmp (info.sego) == 0)
+	{
+	  info.debug = false;
+	  r_search (looping_over->tree, &box, NULL, get_seg, &info);
+	  g_error ("Did not find segment in contour tree!");
+	}
+
+      /* If we're going to have another pass anyway, skip this */
+      if (info.s->intersected && info.node_insert_list != NULL)
+	continue;
+#endif
+
+      if (setjmp (restart))
+	continue;
+
+      /* NB: If this actually hits anything, we are teleported back to the beginning */
+//      info.tree = rtree_over->tree;
+//      if (info.tree)
+//	if (UNLIKELY (r_search (info.tree, &box /*&info.s->box*/,
+      if (rtree_over->tree)
+	if (UNLIKELY (r_search (rtree_over->tree, &box /*&info.s->box*/,
+				NULL/*seg_in_region*/, vertex_in_seg_rounded, &info)))
+	  assert (0); /* XXX: Memory allocation failure */
+    }
+  while ((av = NEXT_VERTEX (av)) != &looping_over->head);
+
+  c_info->node_insert_list = info.node_insert_list;
+  if (info.need_restart)
+    c_info->need_restart = 1;
+  return 0;
+}
+
+static int
+intersect_rounded_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+{
+  PLINE *pa;
+  contour_info c_info;
+  int need_restart = 0;
+  c_info.need_restart = 0;
+  c_info.node_insert_list = NULL;
+  c_info.looping_over_poly = a;
+  c_info.rtree_over_poly = b;
+
+  for (pa = a->contours; pa; pa = pa->next)     /* Loop over the contours of POLYAREA "a" */
+    {
+      BoxType sb;
+      jmp_buf out;
+      int retval;
+
+      c_info.getout = NULL;
+      c_info.pa = pa;
+
+      if (!add)
+        {
+          retval = setjmp (out);
+          if (retval)
+            {
+              /* The intersection test short-circuited back here,
+               * we need to clean up, then longjmp to jb */
+              longjmp (*jb, retval);
+            }
+          c_info.getout = &out;
+        }
+
+      sb.X1 = pa->xmin;
+      sb.Y1 = pa->ymin;
+      sb.X2 = pa->xmax + 1;
+      sb.Y2 = pa->ymax + 1;
+
+      r_search (b->contour_tree, &sb, NULL, rounded_contour_bounds_touch, &c_info);
+      if (c_info.need_restart)
+        need_restart = 1;
+    }
+
+  /* Process any deferred node insersions */
+  need_restart |= process_deferred_intersections (c_info.node_insert_list);
+
+  return need_restart;
+}
+
+static int
+intersect_rounded (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+{
+  int call_count = 1;
+  while (intersect_rounded_impl (jb, b, a, add))
+    call_count++;
+  return 0;
+}
+
+/*
  * intersect() (and helpers)
  * (C) 2006, harry eaton
  * This uses an rtree to find A-B intersections. Whenever a new vertex is
@@ -961,11 +1274,15 @@ contour_bounds_touch (const BoxType * b, void *cl)
     {
       rtree_over = pb;
       looping_over = pa;
+      info.rtree_over_poly = c_info->rtree_over_poly;
+      info.looping_over_poly = c_info->looping_over_poly;
     }
   else
     {
       rtree_over = pa;
       looping_over = pb;
+      info.rtree_over_poly = c_info->looping_over_poly;
+      info.looping_over_poly = c_info->rtree_over_poly;
     }
 
   av = &looping_over->head;
@@ -1002,9 +1319,11 @@ contour_bounds_touch (const BoxType * b, void *cl)
 	continue;
 
       /* NB: If this actually hits anything, we are teleported back to the beginning */
-      info.tree = rtree_over->tree;
-      if (info.tree)
-	if (UNLIKELY (r_search (info.tree, &info.s->box,
+//      info.tree = rtree_over->tree;
+//      if (info.tree)
+//	if (UNLIKELY (r_search (info.tree, &info.s->box,
+      if (rtree_over->tree)
+	if (UNLIKELY (r_search (rtree_over->tree, &info.s->box,
 				seg_in_region, seg_in_seg, &info)))
 	  assert (0); /* XXX: Memory allocation failure */
     }
@@ -1016,6 +1335,7 @@ contour_bounds_touch (const BoxType * b, void *cl)
   return 0;
 }
 
+
 static int
 intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
@@ -1023,7 +1343,6 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
   PLINE *pa;
   contour_info c_info;
   int need_restart = 0;
-  insert_node_task *task;
   c_info.need_restart = 0;
   c_info.node_insert_list = NULL;
 
@@ -1035,6 +1354,13 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       t = b;
       b = a;
       a = t;
+      c_info.looping_over_poly = b;
+      c_info.rtree_over_poly = a;
+    }
+  else
+    {
+      c_info.looping_over_poly = a;
+      c_info.rtree_over_poly = b;
     }
 
   for (pa = a->contours; pa; pa = pa->next)	/* Loop over the contours of POLYAREA "a" */
@@ -1069,39 +1395,7 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     }
 
   /* Process any deferred node insersions */
-  task = c_info.node_insert_list;
-  while (task != NULL)
-    {
-      insert_node_task *next = task->next;
-
-      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-      task->node_seg->v->is_round = false;
-
-      /* Do insersion */
-      PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
-      NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
-      PREV_VERTEX (EDGE_FORWARD_VERTEX (task->node_seg->v)) = task->new_node;
-      EDGE_FORWARD_VERTEX (task->node_seg->v) = task->new_node;
-      task->node_seg->p->Count++;
-
-      if (cntrbox_check (task->node_seg->p, task->new_node->point))
-        {
-          /* First delete the contour from the contour r-tree, as its bounds
-           * may be adjusted whilst inserting nodes
-           */
-          r_delete_entry (b->contour_tree, (const BoxType *) task->node_seg->p);
-          cntrbox_adjust (task->node_seg->p, task->new_node->point);
-          r_insert_entry (b->contour_tree, (const BoxType *) task->node_seg->p, 0);
-        }
-
-      if (adjust_tree (task->node_seg->p->tree, task->node_seg))
-	assert (0); /* XXX: Memory allocation failure */
-
-      need_restart = 1; /* Any new nodes could intersect */
-
-      free (task);
-      task = next;
-    }
+  need_restart |= process_deferred_intersections (c_info.node_insert_list);
 
   return need_restart;
 }
@@ -1124,6 +1418,26 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CV
 
   if (a == NULL || b == NULL)
     error (err_bad_parm);
+
+#if 1
+  do
+    {
+      do
+        {
+          if (a->contours->xmax >= b->contours->xmin &&
+              a->contours->ymax >= b->contours->ymin &&
+              a->contours->xmin <= b->contours->xmax &&
+              a->contours->ymin <= b->contours->ymax)
+            {
+              intersect_rounded (e, a, b, add);
+              intersect_rounded (e, b, a, add);
+            }
+        }
+      while (add && (a = a->f) != afst);
+    }
+  while (add && (b = b->f) != bfst);
+#endif
+
   do
     {
       do
@@ -2647,7 +2961,7 @@ next_cvc_from_same_poly (CVCList *start)
   return n;
 }
 
-
+#if 0
 static seg *
 find_edge_seg (VNODE *edge, PLINE *contour)
 {
@@ -2703,6 +3017,7 @@ find_cvc_at_point (CVCList *start, Vector point)
     }
   while (1);
 }
+#endif
 
 /* NOTE: If any contour is split into multiple pieces due to hairline edge pairs
  * will not necessarily be inserted into the correct location. Hole contours
@@ -4197,7 +4512,7 @@ vect_det2 (Vector v1, Vector v2)
 }
 
 static double
-vect_m_dist (Vector v1, Vector v2)
+vect_m_dist_fp (double v1[2], double v2[2])
 {
   double dx = v1[0] - v2[0];
   double dy = v1[1] - v2[1];
@@ -4210,17 +4525,20 @@ vect_m_dist (Vector v1, Vector v2)
   if (dy > 0)
     return +dd;
   return -dd;
-}				/* vect_m_dist */
+}				/* vect_m_dist_fp */
 
 /*
-vect_inters2
+vect_inters2_fp
  (C) 1993 Klamer Schutte
  (C) 1997 Michael Leonov, Alexey Nikitin
+ (C) 2016 Peter Clifton
 */
 
+
 int
-vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
-	      Vector S1, Vector S2)
+vect_inters2_fp (double p1[2], double p2[2],
+                 double q1[2], double q2[2],
+                 double S1[2], double S2[2])
 {
   double s, t, deel;
   double rpx, rpy, rqx, rqy;
@@ -4238,10 +4556,13 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
 
   deel = rpy * rqx - rpx * rqy;	/* -vect_det(rp,rq); */
 
+  /* XXX: THIS IS NOT NECESSARILY TRUE ANY MORE...
+   *      deel MAY NEED TO BE COMPARED USING
+   *      SOME EPSILON VALUE
+   */
   /* coordinates are 30-bit integers so deel will be exactly zero
    * if the lines are parallel
    */
-
   if (deel == 0)		/* parallel */
     {
       double dc1, dc2, d1, d2, h;	/* Check to see whether p1-p2 and q1-q2 are on the same line */
@@ -4256,9 +4577,9 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
 	return 0;
       dc1 = 0;			/* m_len(p1 - p1) */
 
-      dc2 = vect_m_dist (p1, p2);
-      d1 = vect_m_dist (p1, q1);
-      d2 = vect_m_dist (p1, q2);
+      dc2 = vect_m_dist_fp (p1, p2);
+      d1 = vect_m_dist_fp (p1, q1);
+      d2 = vect_m_dist_fp (p1, q2);
 
 /* Sorting the independent points from small to large */
       Vcpy2 (hp1, p1);
@@ -4359,6 +4680,32 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
     }
 }				/* vect_inters2 */
 
+int
+vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
+              Vector S1, Vector S2)
+{
+  double p1_fp[2] = {p1[0], p1[1]};
+  double p2_fp[2] = {p2[0], p2[1]};
+  double q1_fp[2] = {q1[0], q1[1]};
+  double q2_fp[2] = {q2[0], q2[1]};
+  double s1_fp[2];
+  double s2_fp[2];
+  int cnt;
+
+  cnt = vect_inters2_fp (p1_fp, p2_fp,
+                         q1_fp, q2_fp,
+                         /* out */
+                         s1_fp,
+                         s2_fp);
+
+  S1[0] = s1_fp[0];
+  S1[1] = s1_fp[1];
+  S2[0] = s2_fp[0];
+  S2[1] = s2_fp[1];
+
+  return cnt;
+}
+
 /* how about expanding polygons so that edges can be arcs rather than
  * lines. Consider using the third coordinate to store the radius of the
  * arc. The arc would pass through the vertex points. Positive radius
@@ -4426,8 +4773,8 @@ simplify_contour (PLINE *contour)
       if (!VERTEX_FORWARD_EDGE (p)->is_round && !VERTEX_FORWARD_EDGE (c)->is_round)
         {
           delete_vertex_c = line_segments_can_merge (VERTEX_FORWARD_EDGE (p), VERTEX_FORWARD_EDGE (c));
-          if (delete_vertex_c)
-            fprintf (stderr, "Merging adjacent line segments\n");
+//          if (delete_vertex_c)
+//            fprintf (stderr, "Merging adjacent line segments\n");
         }
       else if (VERTEX_FORWARD_EDGE (p)->is_round && VERTEX_FORWARD_EDGE (c)->is_round)
         {
@@ -4440,7 +4787,7 @@ simplify_contour (PLINE *contour)
             }
           if (delete_vertex_c)
             {
-              fprintf (stderr, "Merging adjacent arc segments\n");
+//              fprintf (stderr, "Merging adjacent arc segments\n");
               count++;
             }
         }
