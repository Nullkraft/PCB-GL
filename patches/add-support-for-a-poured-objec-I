Bottom: bc6c87fd8de2eb77ab8e4b66e5f8c7a50bfb6508
Top:    78e5b643ff8012c7b5e1df225f5f4439e57bbfe1
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-20 14:03:01 +0000

Add support for a "poured" object.

This takes half of the existing polygon functionality, and splits it
such that the user defines a poured region (similar to drawing a polygon
previously), and after clipping, this produces zero or more polygon
objects which are drawn and connectivity checked with the existing
polygon code.

Selecting a "polygon" will cause the parent "pour" to be looked up, and
all child polygons selected. Manipulations will always occur on the
"pour", with "polygons" being updated after clipping.

It remains to be seen whether "pour" will have its own file-format entry,
or if it will take over the meaning of the existing "polygon" entry.


---

diff --git a/globalconst.h b/globalconst.h
index cd6f4f9..4ab3813 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -118,6 +118,8 @@
 						/* line points */
 #define	MAX_POLYGON_POINT_DISTANCE	0	/* maximum distance when searching */
 						/* polygon points */
+#define	MAX_POUR_POINT_DISTANCE	0	/* maximum distance when searching */
+						/* pour points */
 #define	MAX_ELEMENTNAMES		3	/* number of supported names of */
 						/* an element */
 #define	MAX_LIBRARY_LINE_LENGTH		255	/* maximum line length in the */
diff --git a/po/POTFILES.in b/po/POTFILES.in
index f83167f..55f3f34 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -41,6 +41,7 @@ src/netlist.c
 src/parse_y.c
 src/pcb-menu.res
 src/polygon.c
+src/pour.c
 src/rats.c
 src/report.c
 src/res_parse.c
diff --git a/src/Makefile.am b/src/Makefile.am
index b7857bd..18f2a19 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -121,6 +121,8 @@ PCB_SRCS = \
 	polygon.h \
 	polygon1.c \
 	polyarea.h \
+	pour.c \
+	pour.h \
 	puller.c \
 	print.c \
 	print.h \
diff --git a/src/action.c b/src/action.c
index 657b337..635ee27 100644
--- a/src/action.c
+++ b/src/action.c
@@ -57,6 +57,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 /*#include "print.h"*/
 #include "rats.h"
 #include "remove.h"
@@ -144,8 +145,8 @@ typedef enum
   F_PinByName,
   F_PinOrPadName,
   F_Pinout,
-  F_Polygon,
-  F_PolygonHole,
+  F_Pour,
+  F_PourHole,
   F_PreviousPoint,
   F_RatsNest,
   F_Rectangle,
@@ -297,7 +298,7 @@ static PointType InsertedPoint;
 static LayerTypePtr lastLayer;
 static struct
 {
-  PolygonTypePtr poly;
+  PourTypePtr pour;
   LineType line;
 }
 fake;
@@ -380,8 +381,8 @@ static FunctionType Functions[] = {
   {"PinByName", F_PinByName},
   {"PinOrPadName", F_PinOrPadName},
   {"Pinout", F_Pinout},
-  {"Polygon", F_Polygon},
-  {"PolygonHole", F_PolygonHole},
+  {"Pour", F_Pour},
+  {"PourHole", F_PourHole},
   {"PreviousPoint", F_PreviousPoint},
   {"RatsNest", F_RatsNest},
   {"Rectangle", F_Rectangle},
@@ -843,9 +844,9 @@ AdjustAttachedObjects (void)
       AdjustAttachedBox ();
       break;
 
-      /* polygon creation mode */
-    case POLYGON_MODE:
-    case POLYGONHOLE_MODE:
+      /* pour creation mode */
+    case POUR_MODE:
+    case POURHOLE_MODE:
       AdjustAttachedLine ();
       break;
       /* line creation mode */
@@ -1354,12 +1355,12 @@ NotifyMode (void)
 	  Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X &&
 	  Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y)
 	{
-	  PolygonTypePtr polygon;
+	  PourTypePtr pour;
 
 	  int flags = CLEARPOLYFLAG;
 	  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
 	    flags |= FULLPOLYFLAG;
-	  if ((polygon = CreateNewPolygonFromRectangle (CURRENT,
+	  if ((pour = CreateNewPourFromRectangle (CURRENT,
 							Crosshair.
 							AttachedBox.Point1.X,
 							Crosshair.
@@ -1372,10 +1373,10 @@ NotifyMode (void)
 							(flags))) !=
 	      NULL)
 	    {
-	      AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT,
-					 polygon, polygon);
+	      AddObjectToCreateUndoList (POUR_TYPE, CURRENT,
+					 pour, pour);
 	      IncrementUndoSerialNumber ();
-	      DrawPolygon (CURRENT, polygon, 0);
+	      DrawPour (CURRENT, pour, 0);
 	      Draw ();
 	    }
 
@@ -1413,10 +1414,10 @@ NotifyMode (void)
 	break;
       }
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       {
-	PointTypePtr points = Crosshair.AttachedPolygon.Points;
-	Cardinal n = Crosshair.AttachedPolygon.PointN;
+	PointTypePtr points = Crosshair.AttachedPour.Points;
+	Cardinal n = Crosshair.AttachedPour.PointN;
 
 	/* do update of position; use the 'LINE_MODE' mechanism */
 	NotifyLine ();
@@ -1426,7 +1427,7 @@ NotifyMode (void)
 	    points->X == Crosshair.AttachedLine.Point2.X &&
 	    points->Y == Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CopyAttachedPolygonToLayer ();
+	    CopyAttachedPourToLayer ();
 	    Draw ();
 	    break;
 	  }
@@ -1438,9 +1439,9 @@ NotifyMode (void)
 	    points[n - 1].X != Crosshair.AttachedLine.Point2.X ||
 	    points[n - 1].Y != Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
-				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+	    CreateNewPointInPour (&Crosshair.AttachedPour,
+				  Crosshair.AttachedLine.Point2.X,
+				  Crosshair.AttachedLine.Point2.Y);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1449,14 +1450,14 @@ NotifyMode (void)
 	break;
       }
 
-    case POLYGONHOLE_MODE:
+    case POURHOLE_MODE:
       {
 	switch (Crosshair.AttachedObject.State)
 	  {
 	    /* first notify, lookup object */
 	  case STATE_FIRST:
 	    Crosshair.AttachedObject.Type =
-	      SearchScreen (Note.X, Note.Y, POLYGON_TYPE,
+	      SearchScreen (Note.X, Note.Y, POUR_TYPE,
 			    &Crosshair.AttachedObject.Ptr1,
 			    &Crosshair.AttachedObject.Ptr2,
 			    &Crosshair.AttachedObject.Ptr3);
@@ -1478,8 +1479,8 @@ NotifyMode (void)
             /* second notify, insert new point into object */
           case STATE_SECOND:
             {
-	      PointTypePtr points = Crosshair.AttachedPolygon.Points;
-	      Cardinal n = Crosshair.AttachedPolygon.PointN;
+	      PointTypePtr points = Crosshair.AttachedPour.Points;
+	      Cardinal n = Crosshair.AttachedPour.PointN;
 	      POLYAREA *original, *new_hole, *result;
 	      FlagType Flags;
 
@@ -1493,8 +1494,8 @@ NotifyMode (void)
 		{
 		  /* Create POLYAREAs from the original polygon
 		   * and the new hole polygon */
-		  original = PolygonToPoly (Crosshair.AttachedObject.Ptr2);
-		  new_hole = PolygonToPoly (&Crosshair.AttachedPolygon);
+		  original = PourToPoly (Crosshair.AttachedObject.Ptr2);
+		  new_hole = PourToPoly (&Crosshair.AttachedPour);
 
 		  /* Subtract the hole from the original polygon shape */
 		  poly_Boolean_free (original, new_hole, &result, PBO_SUB);
@@ -1504,9 +1505,9 @@ NotifyMode (void)
 		   */
 		  SaveUndoSerialNumber ();
 		  Flags = ((PolygonType *)Crosshair.AttachedObject.Ptr2)->Flags;
-		  PolyToPolygonsOnLayer (PCB->Data, Crosshair.AttachedObject.Ptr1,
-					 result, Flags);
-		  RemoveObject (POLYGON_TYPE,
+		  PolyToPoursOnLayer (PCB->Data, Crosshair.AttachedObject.Ptr1,
+				      result, Flags);
+		  RemoveObject (POUR_TYPE,
 				Crosshair.AttachedObject.Ptr1,
 				Crosshair.AttachedObject.Ptr2,
 				Crosshair.AttachedObject.Ptr3);
@@ -1515,7 +1516,7 @@ NotifyMode (void)
 		  Draw ();
 
 		/* reset state of attached line */
-		memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
+		memset (&Crosshair.AttachedPour, 0, sizeof (PourType));
 		Crosshair.AttachedLine.State = STATE_FIRST;
 		addedLines = 0;
 
@@ -1529,9 +1530,9 @@ NotifyMode (void)
 		  points[n - 1].X != Crosshair.AttachedLine.Point2.X ||
 		  points[n - 1].Y != Crosshair.AttachedLine.Point2.Y)
 		{
-		  CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
-					   Crosshair.AttachedLine.Point2.X,
-					   Crosshair.AttachedLine.Point2.Y);
+		  CreateNewPointInPour (&Crosshair.AttachedPour,
+					Crosshair.AttachedLine.Point2.X,
+					Crosshair.AttachedLine.Point2.Y);
 
 		  /* copy the coordinates */
 		  Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1729,16 +1730,15 @@ NotifyMode (void)
 	      else
 		{
 		  /* get starting point of nearest segment */
-		  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
+		  if (Crosshair.AttachedObject.Type == POUR_TYPE)
 		    {
-		      fake.poly =
-			(PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+		      fake.pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 		      polyIndex =
-			GetLowestDistancePolygonPoint (fake.poly, Note.X,
+			GetLowestDistancePourPoint (fake.pour, Note.X,
 						       Note.Y);
-		      fake.line.Point1 = fake.poly->Points[polyIndex];
-		      fake.line.Point2 = fake.poly->Points[
-			  prev_contour_point (fake.poly, polyIndex)];
+		      fake.line.Point1 = fake.pour->Points[polyIndex];
+		      fake.line.Point2 = fake.pour->Points[
+			  prev_contour_point (fake.pour, polyIndex)];
 		      Crosshair.AttachedObject.Ptr2 = &fake.line;
 
 		    }
@@ -1750,9 +1750,9 @@ NotifyMode (void)
 
 	  /* second notify, insert new point into object */
 	case STATE_SECOND:
-	  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
-	    InsertPointIntoObject (POLYGON_TYPE,
-				   Crosshair.AttachedObject.Ptr1, fake.poly,
+	  if (Crosshair.AttachedObject.Type == POUR_TYPE)
+	    InsertPointIntoObject (POUR_TYPE,
+				   Crosshair.AttachedObject.Ptr1, fake.pour,
 				   &polyIndex,
 				   InsertedPoint.X, InsertedPoint.Y, false, false);
 	  else
@@ -3109,23 +3109,23 @@ ActionMode (int argc, char **argv, int x, int y)
 		  }
 		break;
 	  
-	      case POLYGON_MODE:
+	      case POUR_MODE:
 		if (Crosshair.AttachedLine.State == STATE_FIRST)
 		  SetMode (ARROW_MODE);
 		else
 		  {
 		    SetMode (NO_MODE);
-		    SetMode (POLYGON_MODE);
+		    SetMode (POUR_MODE);
 		  }
 		break;
 
-	      case POLYGONHOLE_MODE:
+	      case POURHOLE_MODE:
 		if (Crosshair.AttachedLine.State == STATE_FIRST)
 		  SetMode (ARROW_MODE);
 		else
 		  {
 		    SetMode (NO_MODE);
-		    SetMode (POLYGONHOLE_MODE);
+		    SetMode (POURHOLE_MODE);
 		  }
 		break;
 
@@ -3154,11 +3154,11 @@ ActionMode (int argc, char **argv, int x, int y)
 	case F_PasteBuffer:
 	  SetMode (PASTEBUFFER_MODE);
 	  break;
-	case F_Polygon:
-	  SetMode (POLYGON_MODE);
+	case F_Pour:
+	  SetMode (POUR_MODE);
 	  break;
-	case F_PolygonHole:
-	  SetMode (POLYGONHOLE_MODE);
+	case F_PourHole:
+	  SetMode (POURHOLE_MODE);
 	  break;
 #ifndef HAVE_LIBSTROKE
 	case F_Release:
@@ -3202,9 +3202,9 @@ ActionMode (int argc, char **argv, int x, int y)
 	  else if (Settings.Mode == RECTANGLE_MODE
 		   && Crosshair.AttachedBox.State != STATE_FIRST)
 	    SetMode (RECTANGLE_MODE);
-	  else if (Settings.Mode == POLYGON_MODE
+	  else if (Settings.Mode == POUR_MODE
 		   && Crosshair.AttachedLine.State != STATE_FIRST)
-	    SetMode (POLYGON_MODE);
+	    SetMode (POUR_MODE);
 	  else
 	    {
 	      SaveMode ();
@@ -4689,6 +4689,9 @@ off are automatically deleted.
 static int
 ActionMorphPolygon (int argc, char **argv, int x, int y)
 {
+#warning FIXME Later
+  Message ("Morph polygon not implemented. Pours are nice though!\n");
+#if 0
   char *function = ARG (0);
   if (function)
     {
@@ -4723,6 +4726,7 @@ ActionMorphPolygon (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
+#endif
   return 0;
 }
 
@@ -6211,7 +6215,7 @@ ActionUndo (int argc, char **argv, int x, int y)
   if (!function || !*function)
     {
       /* don't allow undo in the middle of an operation */
-      if (Settings.Mode != POLYGONHOLE_MODE &&
+      if (Settings.Mode != POURHOLE_MODE &&
 	  Crosshair.AttachedObject.State != STATE_FIRST)
 	return 1;
       if (Crosshair.AttachedBox.State != STATE_FIRST
@@ -6220,11 +6224,11 @@ ActionUndo (int argc, char **argv, int x, int y)
       /* undo the last operation */
 
       HideCrosshair (true);
-      if ((Settings.Mode == POLYGON_MODE ||
-           Settings.Mode == POLYGONHOLE_MODE) &&
-          Crosshair.AttachedPolygon.PointN)
+      if ((Settings.Mode == POUR_MODE ||
+           Settings.Mode == POURHOLE_MODE) &&
+          Crosshair.AttachedPour.PointN)
 	{
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  RestoreCrosshair (true);
 	  return 0;
 	}
@@ -6384,9 +6388,9 @@ three "undone" lines.
 static int
 ActionRedo (int argc, char **argv, int x, int y)
 {
-  if (((Settings.Mode == POLYGON_MODE ||
-        Settings.Mode == POLYGONHOLE_MODE) &&
-       Crosshair.AttachedPolygon.PointN) ||
+  if (((Settings.Mode == POUR_MODE ||
+        Settings.Mode == POURHOLE_MODE) &&
+       Crosshair.AttachedPour.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
   HideCrosshair (true);
@@ -6436,19 +6440,19 @@ static int
 ActionPolygon (int argc, char **argv, int x, int y)
 {
   char *function = ARG (0);
-  if (function && Settings.Mode == POLYGON_MODE)
+  if (function && Settings.Mode == POUR_MODE)
     {
       HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
-	  /* close open polygon if possible */
+	  /* close open pour if possible */
 	case F_Close:
-	  ClosePolygon ();
+	  ClosePour ();
 	  break;
 
 	  /* go back to the previous point */
 	case F_PreviousPoint:
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  break;
 	}
       RestoreCrosshair (true);
diff --git a/src/action.h b/src/action.h
index ee116e8..7529e8a 100644
--- a/src/action.h
+++ b/src/action.h
@@ -33,7 +33,7 @@
 
 #include "global.h"
 
-#define CLONE_TYPES LINE_TYPE | ARC_TYPE | VIA_TYPE | POLYGON_TYPE
+#define CLONE_TYPES LINE_TYPE | ARC_TYPE | VIA_TYPE | POUR_TYPE
 
 void ActionMovePointer (char *, char *);
 void ActionAdjustStyle (char *);
diff --git a/src/autoroute.c b/src/autoroute.c
index e53587c..285ab38 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -74,6 +74,7 @@
 #include "misc.h"
 #include "mtspace.h"
 #include "mymem.h"
+#include "pour.h"
 #include "polygon.h"
 #include "rats.h"
 #include "remove.h"
@@ -767,6 +768,8 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
 			     polygon->BoundingBox.X2,
 			     polygon->BoundingBox.Y2,
 			     layergroup, polygon, style);
+#warning FIXME LATER
+#if 0
   if (polygon->PointN == 4 &&
       polygon->HoleIndexN == 0 &&
       (polygon->Points[0].X == polygon->Points[1].X ||
@@ -778,6 +781,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
       (polygon->Points[3].X == polygon->Points[0].X ||
        polygon->Points[3].Y == polygon->Points[0].Y))
     is_not_rectangle = 0;
+#endif
   rb->flags.nonstraight = is_not_rectangle;
   rb->layer = layer;
   rb->came_from = ALL;
@@ -1183,12 +1187,16 @@ CreateRouteData ()
       }
       END_LOOP;
       /* add all polygons */
-      POLYGON_LOOP (LAYER_PTR (i));
+      POUR_LOOP (LAYER_PTR (i));
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  CLEAR_FLAG (DRCFLAG, polygon);
-	else
-	  AddPolygon (layergroupboxes, i, polygon, rd->styles[NUM_STYLES]);
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            CLEAR_FLAG (DRCFLAG, polygon);
+          else
+            AddPolygon (layergroupboxes, i, polygon, rd->styles[NUM_STYLES]);
+        }
+        END_LOOP;
       }
       END_LOOP;
       /* add all copper text */
@@ -5071,20 +5079,18 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 	  int type = FindPin (&p->box, &pin);
 	  if (pin)
 	    {
-	      AddObjectToClearPolyUndoList (type,
+	      AddObjectToClearPourUndoList (type,
 					    pin->Element ? pin->Element : pin,
 					    pin, pin, false);
-	      RestoreToPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
-				pin);
+	      RestoreToPours (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer), pin);
 	      AddObjectToFlagUndoList (type,
 				       pin->Element ? pin->Element : pin, pin,
 				       pin);
 	      ASSIGN_THERM (p->layer, PCB->ThermStyle, pin);
-	      AddObjectToClearPolyUndoList (type,
+	      AddObjectToClearPourUndoList (type,
 					    pin->Element ? pin->Element : pin,
 					    pin, pin, true);
-	      ClearFromPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
-				pin);
+	      ClearFromPours (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer), pin);
 	      changed = true;
 	    }
 	}
diff --git a/src/buffer.c b/src/buffer.c
index 4447c30..a5a6420 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rotate.h"
 #include "remove.h"
@@ -72,14 +73,14 @@ static void *AddLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *AddArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *AddRatToBuffer (RatTypePtr);
 static void *AddTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *AddPourToBuffer (LayerTypePtr, PourTypePtr);
 static void *AddElementToBuffer (ElementTypePtr);
 static void *MoveViaToBuffer (PinTypePtr);
 static void *MoveLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToBuffer (RatTypePtr);
 static void *MoveTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToBuffer (LayerTypePtr, PourTypePtr);
 static void *MoveElementToBuffer (ElementTypePtr);
 static void SwapBuffer (BufferTypePtr);
 
@@ -93,7 +94,8 @@ static DataTypePtr Dest, Source;
 static ObjectFunctionType AddBufferFunctions = {
   AddLineToBuffer,
   AddTextToBuffer,
-  AddPolygonToBuffer,
+  NULL,
+  AddPourToBuffer,
   AddViaToBuffer,
   AddElementToBuffer,
   NULL,
@@ -108,10 +110,17 @@ static ObjectFunctionType AddBufferFunctions = {
 {
 MoveLineToBuffer,
     MoveTextToBuffer,
-    MovePolygonToBuffer,
+    NULL,
+    MovePourToBuffer,
     MoveViaToBuffer,
     MoveElementToBuffer,
-    NULL, NULL, NULL, NULL, NULL, MoveArcToBuffer, MoveRatToBuffer};
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToBuffer,
+    MoveRatToBuffer};
 
 static int ExtraFlag = 0;
 
@@ -186,18 +195,18 @@ AddTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * copies a polygon to buffer
+ * copies a pour to buffer
  */
 static void *
-AddPolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+AddPourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr layer = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
 
-  polygon = CreateNewPolygon (layer, Polygon->Flags);
-  CopyPolygonLowLevel (polygon, Polygon);
-  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, polygon);
-  return (polygon);
+  pour = CreateNewPour (layer, Pour->Flags);
+  CopyPourLowLevel (pour, Pour);
+  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, pour);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -240,7 +249,7 @@ MoveViaToBuffer (PinTypePtr Via)
 {
   PinTypePtr via;
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
+  RestoreToPours (Source, VIA_TYPE, Via, Via);
   r_delete_entry (Source->via_tree, (BoxType *) Via);
   via = GetViaMemory (Dest);
   *via = *Via;
@@ -255,7 +264,7 @@ MoveViaToBuffer (PinTypePtr Via)
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
-  ClearFromPolygon (Dest, VIA_TYPE, via, via);
+  ClearFromPours (Dest, VIA_TYPE, via, via);
   return (via);
 }
 
@@ -293,7 +302,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   LayerTypePtr lay;
   LineTypePtr line;
 
-  RestoreToPolygon (Source, LINE_TYPE, Layer, Line);
+  RestoreToPours (Source, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   line = GetLineMemory (lay);
@@ -310,7 +319,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
-  ClearFromPolygon (Dest, LINE_TYPE, lay, line);
+  ClearFromPours (Dest, LINE_TYPE, lay, line);
   return (line);
 }
 
@@ -323,7 +332,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   LayerTypePtr lay;
   ArcTypePtr arc;
 
-  RestoreToPolygon (Source, ARC_TYPE, Layer, Arc);
+  RestoreToPours (Source, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   arc = GetArcMemory (lay);
@@ -340,7 +349,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
-  ClearFromPolygon (Dest, ARC_TYPE, lay, arc);
+  ClearFromPours (Dest, ARC_TYPE, lay, arc);
   return (arc);
 }
 
@@ -354,7 +363,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   LayerTypePtr lay;
 
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPolygon (Source, TEXT_TYPE, Layer, Text);
+  RestoreToPours (Source, TEXT_TYPE, Layer, Text);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   text = GetTextMemory (lay);
   *text = *Text;
@@ -368,36 +377,39 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
-  ClearFromPolygon (Dest, TEXT_TYPE, lay, text);
+  ClearFromPours (Dest, TEXT_TYPE, lay, text);
   return (text);
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon to buffer. Doesn't allocate memory for the points
+ * moves a pour to buffer. Doesn't allocate memory for the points
  */
 static void *
-MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr lay;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
+  Cardinal i;
 
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  polygon = GetPolygonMemory (lay);
-  *polygon = *Polygon;
-  CLEAR_FLAG (FOUNDFLAG, polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
-  {
-  *Polygon = Layer->Polygon[Layer->PolygonN];
-  r_substitute (Layer->polygon_tree,
-		(BoxTypePtr) & Layer->Polygon[Layer->PolygonN],
-		(BoxTypePtr) Polygon);
-  }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
-  if (!lay->polygon_tree)
-    lay->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  pour = GetPourMemory (lay);
+  *pour = *Pour;
+  CLEAR_FLAG (FOUNDFLAG, pour);
+  if (Pour != &Layer->Pour[--Layer->PourN])
+    {
+      *Pour = Layer->Pour[Layer->PourN];
+      r_substitute (Layer->pour_tree,
+                    (BoxTypePtr) & Layer->Pour[Layer->PourN],
+                    (BoxTypePtr) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
+    }
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
+  if (!lay->pour_tree)
+    lay->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -419,14 +431,14 @@ MoveElementToBuffer (ElementTypePtr Element)
   *element = *Element;
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPours(Source, PIN_TYPE, Element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
     pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPours(Source, PAD_TYPE, Element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
     pad->Element = element;
   }
@@ -442,12 +454,12 @@ MoveElementToBuffer (ElementTypePtr Element)
    */
   PIN_LOOP (element);
   {
-    ClearFromPolygon (Dest, PIN_TYPE, element, pin);
+    ClearFromPours (Dest, PIN_TYPE, element, pin);
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    ClearFromPolygon (Dest, PAD_TYPE, element, pad);
+    ClearFromPours (Dest, PAD_TYPE, element, pad);
   }
   END_LOOP;
 
@@ -999,6 +1011,8 @@ SmashBufferElement (BufferTypePtr Buffer)
   return (true);
 }
 
+#warning FIXME Later
+#if 0
 /*---------------------------------------------------------------------------
  *
  * see if a polygon is a rectangle.  If so, canonicalize it.
@@ -1035,6 +1049,7 @@ polygon_is_rectangle (PolygonTypePtr poly)
     return 1;
   return 0;
 }
+#endif
 
 /*---------------------------------------------------------------------------
  *
@@ -1100,34 +1115,40 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       hasParts = true;
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+#warning FIXME Later
+#if 0
+    POUR_LOOP (layer);
     {
-      int x1, y1, x2, y2, w, h, t;
-
-      if (! polygon_is_rectangle (polygon))
-        {
-          crooked = true;
-	  continue;
-        }
-
-      w = polygon->Points[2].X - polygon->Points[0].X;
-      h = polygon->Points[1].Y - polygon->Points[0].Y;
-      t = (w < h) ? w : h;
-      x1 = polygon->Points[0].X + t/2;
-      y1 = polygon->Points[0].Y + t/2;
-      x2 = x1 + (w-t);
-      y2 = y1 + (h-t);
-
-      sprintf (num, "%d", pin_n++);
-      CreateNewPad (Element,
-		    x1, y1, x2, y2, t,
-		    2 * Settings.Keepaway,
-		    t + Settings.Keepaway,
-		    NULL, num,
-		    MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
-      hasParts = true;
+      POURPOLYGON_LOOP (pour);
+      {
+        int x1, y1, x2, y2, w, h, t;
+
+        if (! polygon_is_rectangle (polygon))
+          {
+            crooked = true;
+            continue;
+          }
+
+        w = polygon->Points[2].X - polygon->Points[0].X;
+        h = polygon->Points[1].Y - polygon->Points[0].Y;
+        t = (w < h) ? w : h;
+        x1 = polygon->Points[0].X + t/2;
+        y1 = polygon->Points[0].Y + t/2;
+        x2 = x1 + (w-t);
+        y2 = y1 + (h-t);
+
+        sprintf (num, "%d", pin_n++);
+        CreateNewPad (Element, x1, y1, x2, y2, t,
+                      2 * Settings.Keepaway,
+                      t + Settings.Keepaway,
+                      NULL, num,
+                      MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
+        hasParts = true;
+      }
+      END_LOOP;
     }
     END_LOOP;
+#endif
   }
   END_LOOP;
   /* now get the opposite side pads */
@@ -1278,6 +1299,8 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->text_tree, (BoxTypePtr) text, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1285,6 +1308,14 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    RotatePourLowLevel (pour, Buffer->X, Buffer->Y, Number);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   /* finally the origin and the bounding box */
   ROTATE (Buffer->X, Buffer->Y, Buffer->X, Buffer->Y, Number);
@@ -1336,7 +1367,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     free_rotate (&pin->X, &pin->Y, X, Y, cosa, sina);
     SetPinBoundingBox (pin);
   }
@@ -1346,7 +1377,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     free_rotate (&pad->Point1.X, &pad->Point1.Y, X, Y, cosa, sina);
     free_rotate (&pad->Point2.X, &pad->Point2.Y, X, Y, cosa, sina);
     SetLineBoundingBox ((LineType *) pad);
@@ -1362,7 +1393,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
 
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 void
@@ -1411,6 +1442,8 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
   }
   ENDALL_LOOP;
   /* FIXME: rotate text */
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1423,6 +1456,19 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    POURPOINT_LOOP (pour);
+    {
+      free_rotate (&point->X, &point->Y, Buffer->X, Buffer->Y, cosa, sina);
+    }
+    END_LOOP;
+    SetPourBoundingBox (pour);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   SetBufferBoundingBox (Buffer);
 }
@@ -1529,6 +1575,8 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetArcBoundingBox (arc);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     POLYGONPOINT_LOOP (polygon);
@@ -1540,6 +1588,7 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetPolygonBoundingBox (polygon);
   }
   ENDALL_LOOP;
+#endif
   SetBufferBoundingBox (Buffer);
 }
 
@@ -1594,6 +1643,8 @@ SwapBuffer (BufferTypePtr Buffer)
     r_insert_entry (layer->arc_tree, (BoxTypePtr) arc, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1608,6 +1659,7 @@ SwapBuffer (BufferTypePtr Buffer)
     /* hmmm, how to handle clip */
   }
   ENDALL_LOOP;
+#endif
   ALLTEXT_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->text_tree, (BoxTypePtr) text);
diff --git a/src/change.c b/src/change.c
index 9a2e80b..62dd821 100644
--- a/src/change.c
+++ b/src/change.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "mirror.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -83,6 +84,7 @@ static void *ChangeViaMaskSize (PinTypePtr);
 static void *ChangeLineSize (LayerTypePtr, LineTypePtr);
 static void *ChangeLineClearSize (LayerTypePtr, LineTypePtr);
 static void *ChangePolygonClearSize (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClearSize (LayerTypePtr, PourTypePtr);
 static void *ChangeArcSize (LayerTypePtr, ArcTypePtr);
 static void *ChangeArcClearSize (LayerTypePtr, ArcTypePtr);
 static void *ChangeTextSize (LayerTypePtr, TextTypePtr);
@@ -123,7 +125,7 @@ static void *ClrArcJoin (LayerTypePtr, ArcTypePtr);
 static void *ChangeTextJoin (LayerTypePtr, TextTypePtr);
 static void *SetTextJoin (LayerTypePtr, TextTypePtr);
 static void *ClrTextJoin (LayerTypePtr, TextTypePtr);
-static void *ChangePolyClear (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClear (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -134,7 +136,8 @@ static char *NewName;		/* new name */
 static ObjectFunctionType ChangeSizeFunctions = {
   ChangeLineSize,
   ChangeTextSize,
-  ChangePolyClear,
+  NULL,
+  ChangePourClear,
   ChangeViaSize,
   ChangeElementSize,		/* changes silk screen line width */
   ChangeElementNameSize,
@@ -149,6 +152,7 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeVia2ndSize,
   ChangeElement2ndSize,
   NULL,
@@ -163,6 +167,7 @@ static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaThermal,
   NULL,
   NULL,
@@ -177,6 +182,7 @@ static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangeLineClearSize,
   NULL,
   ChangePolygonClearSize, /* just to tell the user not to :-) */
+  ChangePourClearSize, /* just to tell the user not to :-) */
   ChangeViaClearSize,
   NULL,
   NULL,
@@ -191,6 +197,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   ChangeLineName,
   ChangeTextName,
   NULL,
+  NULL,
   ChangeViaName,
   ChangeElementName,
   NULL,
@@ -206,6 +213,7 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeElementSquare,
   NULL,
   ChangePinSquare,
@@ -226,6 +234,7 @@ static ObjectFunctionType ChangeJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeArcJoin,
   NULL
 };
@@ -233,6 +242,7 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaOctagon,
   ChangeElementOctagon,
   NULL,
@@ -247,6 +257,7 @@ static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaMaskSize,
 #if 0
   ChangeElementMaskSize,
@@ -266,6 +277,7 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetElementSquare,
   NULL,
   SetPinSquare,
@@ -286,6 +298,7 @@ static ObjectFunctionType SetJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetArcJoin,
   NULL
 };
@@ -293,6 +306,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetViaOctagon,
   SetElementOctagon,
   NULL,
@@ -308,6 +322,7 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrElementSquare,
   NULL,
   ClrPinSquare,
@@ -328,6 +343,7 @@ static ObjectFunctionType ClrJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrArcJoin,
   NULL
 };
@@ -335,6 +351,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrViaOctagon,
   ClrElementOctagon,
   NULL,
@@ -353,15 +370,15 @@ static ObjectFunctionType ClrOctagonFunctions = {
 static void *
 ChangeViaThermal (PinTypePtr Via)
 {
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, false);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, false);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, true);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, true);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
 }
@@ -373,15 +390,15 @@ ChangeViaThermal (PinTypePtr Via)
 static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, false);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, element, Pin, Pin, false);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, true);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, element, Pin, Pin, true);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
 }
@@ -405,7 +422,7 @@ ChangeViaSize (PinTypePtr Via)
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       EraseVia (Via);
       r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, PIN_TYPE, Via, Via);
       if (Via->Mask)
 	{
 	  AddObjectToMaskSizeUndoList (VIA_TYPE, Via, Via, Via);
@@ -414,7 +431,7 @@ ChangeViaSize (PinTypePtr Via)
       Via->Thickness = value;
       SetPinBoundingBox (Via);
       r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
       DrawVia (Via, 0);
       return (Via);
     }
@@ -443,10 +460,10 @@ ChangeVia2ndSize (PinTypePtr Via)
       Via->DrillingHole = value;
       if (TEST_FLAG (HOLEFLAG, Via))
 	{
-	  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
 	  AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
 	  Via->Thickness = value;
-	  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
 	}
       DrawVia (Via, 0);
       return (Via);
@@ -475,14 +492,14 @@ ChangeViaClearSize (PinTypePtr Via)
     value = PCB->Bloat * 2 + 2;
   if (Via->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToClearSizeUndoList (VIA_TYPE, Via, Via, Via);
   EraseVia (Via);
   r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
   Via->Clearance = value;
   SetPinBoundingBox (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   Via->Element = NULL;
   return (Via);
@@ -509,12 +526,12 @@ ChangePinSize (ElementTypePtr Element, PinTypePtr Pin)
       AddObjectToMaskSizeUndoList (PIN_TYPE, Element, Pin, Pin);
       ErasePin (Pin);
       r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
       Pin->Mask += value - Pin->Thickness;
       Pin->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
       DrawPin (Pin, 0);
       return (Pin);
     }
@@ -541,14 +558,14 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
     value = PCB->Bloat * 2 + 2;
   if (Pin->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToClearSizeUndoList (PIN_TYPE, Element, Pin, Pin);
   ErasePin (Pin);
   r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
   Pin->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -568,14 +585,14 @@ ChangePadSize (ElementTypePtr Element, PadTypePtr Pad)
     {
       AddObjectToSizeUndoList (PAD_TYPE, Element, Pad, Pad);
       AddObjectToMaskSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Mask += value - Pad->Thickness;
       Pad->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -603,13 +620,13 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
   if (value == Pad->Clearance)
     return NULL;
   AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   ErasePad (Pad);
   r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
   Pad->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return Pad;
 }
@@ -643,10 +660,10 @@ ChangeElement2ndSize (ElementTypePtr Element)
 	DrawPin (pin, 0);
 	if (TEST_FLAG (HOLEFLAG, pin))
 	  {
-	    RestoreToPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    RestoreToPours (PCB->Data, PIN_TYPE, Element, pin);
 	    AddObjectToSizeUndoList (PIN_TYPE, Element, pin, pin);
 	    pin->Thickness = value;
-	    ClearFromPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    ClearFromPours (PCB->Data, PIN_TYPE, Element, pin);
 	  }
       }
   }
@@ -680,10 +697,10 @@ ChangePin2ndSize (ElementTypePtr Element, PinTypePtr Pin)
       DrawPin (Pin, 0);
       if (TEST_FLAG (HOLEFLAG, Pin))
 	{
-	  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
 	  AddObjectToSizeUndoList (PIN_TYPE, Element, Pin, Pin);
 	  Pin->Thickness = value;
-	  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
 	}
       return (Pin);
     }
@@ -707,11 +724,11 @@ ChangeLineSize (LayerTypePtr Layer, LineTypePtr Line)
       AddObjectToSizeUndoList (LINE_TYPE, Layer, Line, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       Line->Thickness = value;
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -733,7 +750,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
   if (value != Line->Clearance)
     {
       AddObjectToClearSizeUndoList (LINE_TYPE, Layer, Line, Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
       Line->Clearance = value;
@@ -744,7 +761,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -772,6 +789,26 @@ ChangePolygonClearSize (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * Handle attepts to change the clearance of a polygon.
+ */
+static void *
+ChangePourClearSize (LayerTypePtr Layer, PourTypePtr pour)
+{
+  static int shown_this_message = 0;
+  if (!shown_this_message)
+    {
+      gui->confirm_dialog ("To change the clearance of objects in a pour, "
+			   "change the objects, not the pour.\n"
+			   "Hint: To set a minimum clearance for a group of objects, "
+			   "select them all then :MinClearGap(Selected,=10,mil)",
+			   "Ok", NULL);
+      shown_this_message = 1;
+    }
+
+  return (NULL);
+}
+
+/* ---------------------------------------------------------------------------
  * changes the size of an arc
  * returns TRUE if changed
  */
@@ -788,11 +825,11 @@ ChangeArcSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Thickness = value;
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -816,7 +853,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToClearSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Clearance = value;
       if (Arc->Clearance == 0)
 	{
@@ -825,7 +862,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -849,11 +886,11 @@ ChangeTextSize (LayerTypePtr Layer, TextTypePtr Text)
       AddObjectToSizeUndoList (TEXT_TYPE, Layer, Text, Text);
       EraseText (Layer, Text);
       r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-      RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
       Text->Scale = value;
       SetTextBoundingBox (&PCB->Font, Text);
       r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-      ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
       DrawText (Layer, Text, 0);
       return (Text);
     }
@@ -1073,12 +1110,12 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG (LOCKFLAG, Text))
     return (NULL);
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   Text->TextString = NewName;
 
   /* calculate size of the bounding box */
   SetTextBoundingBox (&PCB->Font, Text);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (old);
 }
@@ -1134,15 +1171,15 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   EraseLine (Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, false);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, false);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, true);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, true);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
   return (Line);
@@ -1180,17 +1217,17 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
     return (NULL);
   EraseArc (Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
-  {
-    RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-    AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, false);
+    {
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
+      AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, false);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
-  {
-    ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-  AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, true);
-  }
+    {
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
+      AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, true);
+    }
   DrawArc (Layer, Arc, 0);
   return (Arc);
 }
@@ -1228,15 +1265,15 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   EraseText (Layer, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, false);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, false);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, true);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, true);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
   return (Text);
@@ -1399,12 +1436,12 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
   if (TEST_FLAG (LOCKFLAG, Pad))
     return (NULL);
   ErasePad (Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, false);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  AddObjectToClearPourUndoList (PAD_TYPE, Element, Pad, Pad, false);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, true);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  AddObjectToClearPourUndoList (PAD_TYPE, Element, Pad, Pad, true);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
 }
@@ -1446,12 +1483,12 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, false);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, false);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, true);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, true);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1489,12 +1526,12 @@ ChangeViaOctagon (PinTypePtr Via)
   if (TEST_FLAG (LOCKFLAG, Via))
     return (NULL);
   EraseVia (Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, false);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, false);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, true);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, true);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
 }
@@ -1532,12 +1569,12 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, false);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, false);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, true);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, true);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1579,10 +1616,10 @@ ChangeHole (PinTypePtr Via)
   TOGGLE_FLAG (HOLEFLAG, Via);
   if (TEST_FLAG (HOLEFLAG, Via))
     {
-      RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->Thickness = Via->Mask = Via->DrillingHole;
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
     }
   else
     {
@@ -1611,19 +1648,19 @@ ChangePaste (PadTypePtr Pad)
 }
 
 /* ---------------------------------------------------------------------------
- * changes the CLEARPOLY flag of a polygon
+ * changes the CLEARPOLY flag of a pour
  */
 static void *
-ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
+ChangePourClear (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  if (TEST_FLAG (LOCKFLAG, Polygon))
+  if (TEST_FLAG (LOCKFLAG, Pour))
     return (NULL);
-  AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, Polygon, Polygon, true);
-  AddObjectToFlagUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
-  TOGGLE_FLAG (CLEARPOLYFLAG, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  DrawPolygon (Layer, Polygon, 0);
-  return (Polygon);
+  AddObjectToClearPourUndoList (POUR_TYPE, Layer, Pour, Pour, true);
+  AddObjectToFlagUndoList (POUR_TYPE, Layer, Pour, Pour);
+  TOGGLE_FLAG (CLEARPOLYFLAG, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  DrawPour (Layer, Pour, 0);
+  return (Pour);
 }
 
 /* ----------------------------------------------------------------------
diff --git a/src/change.h b/src/change.h
index 7bae706..f0547b8 100644
--- a/src/change.h
+++ b/src/change.h
@@ -40,7 +40,7 @@
 	(VIA_TYPE | PIN_TYPE | PAD_TYPE | TEXT_TYPE | ELEMENT_TYPE | ELEMENTNAME_TYPE | LINE_TYPE)
 
 #define	CHANGESIZE_TYPES        \
-	(POLYGON_TYPE | VIA_TYPE | PIN_TYPE | PAD_TYPE | LINE_TYPE | \
+	(POUR_TYPE | VIA_TYPE | PIN_TYPE | PAD_TYPE | LINE_TYPE | \
 	 ARC_TYPE | TEXT_TYPE | ELEMENTNAME_TYPE | ELEMENT_TYPE)
 
 #define	CHANGE2NDSIZE_TYPES     \
diff --git a/src/const.h b/src/const.h
index 676a6f0..6d34ce8 100644
--- a/src/const.h
+++ b/src/const.h
@@ -78,7 +78,8 @@
 #define	VIA_MODE		1	/* draw vias */
 #define	LINE_MODE		2	/* draw lines */
 #define	RECTANGLE_MODE		3	/* create rectangles */
-#define	POLYGON_MODE		4	/* draw filled polygons */
+//#define	POLYGON_MODE		4	/* draw filled polygons */
+#define	POUR_MODE		4	/* draw poured areas */
 #define	PASTEBUFFER_MODE	5	/* paste objects from buffer */
 #define	TEXT_MODE		6	/* create text objects */
 #define	ROTATE_MODE		102	/* rotate objects */
@@ -92,7 +93,7 @@
 #define ARROW_MODE		110	/* selection with arrow mode */
 #define PAN_MODE                0	/* same as no mode */
 #define LOCK_MODE               111	/* lock/unlock objects */
-#define	POLYGONHOLE_MODE	112	/* cut holes in filled polygons */
+#define	POURHOLE_MODE		112	/* cut holes in poured areas */
 
 /* ---------------------------------------------------------------------------
  * object flags
@@ -303,17 +304,20 @@ When set, element names are not drawn.
 #define	PIN_TYPE		0x00100	/* objects that are part */
 #define	PAD_TYPE		0x00200	/* 'pin' of SMD element */
 #define	ELEMENTNAME_TYPE	0x00400	/* of others */
-#define	POLYGONPOINT_TYPE	0x00800
+//#define	POLYGONPOINT_TYPE	0x00800
+#define POURPOINT_TYPE 		0x00800
 #define	LINEPOINT_TYPE		0x01000
 #define ELEMENTLINE_TYPE        0x02000
 #define ARC_TYPE                0x04000
 #define ELEMENTARC_TYPE		0x08000
 
 #define LOCKED_TYPE 		0x10000	/* used to tell search to include locked items. */
+#define POUR_TYPE 		0x20000
 
 #define PIN_TYPES     (VIA_TYPE | PIN_TYPE)
-#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | ELEMENT_TYPE \
-                      | TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
+#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POUR_TYPE | \
+                       ELEMENT_TYPE | TEXT_TYPE | ELEMENTNAME_TYPE | \
+                       LOCKED_TYPE)
 
 #define	ALL_TYPES		(~0)	/* all bits set */
 
diff --git a/src/copy.c b/src/copy.c
index ee831b9..18729d5 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -47,7 +47,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "move.h"
-#include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rtree.h"
 #include "select.h"
@@ -66,7 +66,7 @@ static void *CopyVia (PinTypePtr);
 static void *CopyLine (LayerTypePtr, LineTypePtr);
 static void *CopyArc (LayerTypePtr, ArcTypePtr);
 static void *CopyText (LayerTypePtr, TextTypePtr);
-static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *CopyPour (LayerTypePtr, PourTypePtr);
 static void *CopyElement (ElementTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -76,7 +76,8 @@ static LocationType DeltaX, DeltaY;	/* movement vector */
 static ObjectFunctionType CopyFunctions = {
   CopyLine,
   CopyText,
-  CopyPolygon,
+  NULL,
+  CopyPour,
   CopyVia,
   CopyElement,
   NULL,
@@ -89,11 +90,11 @@ static ObjectFunctionType CopyFunctions = {
 };
 
 /* ---------------------------------------------------------------------------
- * copies data from one polygon to another
+ * copies data from one pour to another
  * 'Dest' has to exist
  */
-PolygonTypePtr
-CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
+PourTypePtr
+CopyPourLowLevel (PourTypePtr Dest, PourTypePtr Src)
 {
   Cardinal hole = 0;
   Cardinal n;
@@ -102,12 +103,12 @@ CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
     {
       if (hole < Src->HoleIndexN && n == Src->HoleIndex[hole])
         {
-          CreateNewHoleInPolygon (Dest);
+          CreateNewHoleInPour (Dest);
           hole++;
         }
-      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y);
+      CreateNewPointInPour (Dest, Src->Points[n].X, Src->Points[n].Y);
     }
-  SetPolygonBoundingBox (Dest);
+  SetPourBoundingBox (Dest);
   Dest->Flags = Src->Flags;
   CLEAR_FLAG (FOUNDFLAG, Dest);
   return (Dest);
@@ -263,23 +264,23 @@ CopyText (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * copies a polygon 
+ * copies a pour
  */
 static void *
-CopyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+CopyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  PolygonTypePtr polygon;
-
-  polygon = CreateNewPolygon (Layer, NoFlags ());
-  CopyPolygonLowLevel (polygon, Polygon);
-  MovePolygonLowLevel (polygon, DeltaX, DeltaY);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  InitClip (PCB->Data, Layer, polygon);
-  DrawPolygon (Layer, polygon, 0);
-  AddObjectToCreateUndoList (POLYGON_TYPE, Layer, polygon, polygon);
-  return (polygon);
+  PourTypePtr pour;
+
+  pour = CreateNewPour (Layer, NoFlags ());
+  CopyPourLowLevel (pour, Pour);
+  MovePourLowLevel (pour, DeltaX, DeltaY);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  InitPourClip (PCB->Data, Layer, pour);
+  DrawPour (Layer, pour, 0);
+  AddObjectToCreateUndoList (POUR_TYPE, Layer, pour, pour);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -348,7 +349,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	  changed = changed ||
 	    (sourcelayer->LineN != 0) ||
 	    (sourcelayer->ArcN != 0) ||
-	    (sourcelayer->PolygonN != 0) || (sourcelayer->TextN != 0);
+	    (sourcelayer->PourN != 0) || (sourcelayer->TextN != 0);
 	  LINE_LOOP (sourcelayer);
 	  {
 	    CopyLine (destlayer, line);
@@ -364,9 +365,9 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	    CopyText (destlayer, text);
 	  }
 	  END_LOOP;
-	  POLYGON_LOOP (sourcelayer);
+	  POUR_LOOP (sourcelayer);
 	  {
-	    CopyPolygon (destlayer, polygon);
+	    CopyPour (destlayer, pour);
 	  }
 	  END_LOOP;
 	}
diff --git a/src/copy.h b/src/copy.h
index ac50e2c..6a59832 100644
--- a/src/copy.h
+++ b/src/copy.h
@@ -38,10 +38,10 @@
  */
 #define	COPY_TYPES              \
 	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | \
-	ELEMENT_TYPE | ELEMENTNAME_TYPE | POLYGON_TYPE | ARC_TYPE)
+	ELEMENT_TYPE | ELEMENTNAME_TYPE | POUR_TYPE | ARC_TYPE)
 
 
-PolygonTypePtr CopyPolygonLowLevel (PolygonTypePtr, PolygonTypePtr);
+PourTypePtr CopyPourLowLevel (PourTypePtr, PourTypePtr);
 ElementTypePtr CopyElementLowLevel (DataTypePtr, ElementTypePtr,
 				    ElementTypePtr, bool, LocationType, LocationType);
 bool CopyPastebufferToLayout (LocationType, LocationType);
diff --git a/src/create.c b/src/create.c
index 07de918..0aea078 100644
--- a/src/create.c
+++ b/src/create.c
@@ -557,29 +557,28 @@ CreateNewArcOnLayer (LayerTypePtr Layer,
   return (Arc);
 }
 
-
 /* ---------------------------------------------------------------------------
- * creates a new polygon from the old formats rectangle data
+ * creates a new pour from the old formats rectangle data
  */
-PolygonTypePtr
-CreateNewPolygonFromRectangle (LayerTypePtr Layer,
+PourTypePtr
+CreateNewPourFromRectangle (LayerTypePtr Layer,
 			       LocationType X1, LocationType Y1,
 			       LocationType X2, LocationType Y2,
 			       FlagType Flags)
 {
-  PolygonTypePtr polygon = CreateNewPolygon (Layer, Flags);
-  if (!polygon)
-    return (polygon);
-
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
-  SetPolygonBoundingBox (polygon);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  PourTypePtr pour = CreateNewPour (Layer, Flags);
+  if (!pour)
+    return (pour);
+
+  CreateNewPointInPour (pour, X1, Y1);
+  CreateNewPointInPour (pour, X2, Y1);
+  CreateNewPointInPour (pour, X2, Y2);
+  CreateNewPointInPour (pour, X1, Y2);
+  SetPourBoundingBox (pour);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -622,9 +621,9 @@ CreateNewText (LayerTypePtr Layer, FontTypePtr PCBFont,
  * creates a new polygon on a layer
  */
 PolygonTypePtr
-CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
+CreateNewPolygonInPour (PourType *pour, FlagType Flags)
 {
-  PolygonTypePtr polygon = GetPolygonMemory (Layer);
+  PolygonTypePtr polygon = GetPolygonMemoryInPour (pour);
 
   /* copy values */
   polygon->Flags = Flags;
@@ -632,17 +631,40 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->ParentPour = pour;
   return (polygon);
 }
 
 /* ---------------------------------------------------------------------------
- * creates a new point in a polygon
+ * creates a new pour on a layer
+ */
+PourTypePtr
+CreateNewPour (LayerTypePtr Layer, FlagType Flags)
+{
+  PourTypePtr pour = GetPourMemory (Layer);
+
+  /* copy values */
+  pour->Flags = Flags;
+  pour->ID = ID++;
+
+  pour->PointN = 0;
+  pour->PointMax = 0;
+  pour->Points = NULL;
+  pour->PolygonN = 0;
+  pour->PolygonMax = 0;
+  pour->Polygons = NULL;
+
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a new point in a pour
  */
 PointTypePtr
-CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
+CreateNewPointInPour (PourTypePtr Pour, LocationType X,
 			 LocationType Y)
 {
-  PointTypePtr point = GetPointMemoryInPolygon (Polygon);
+  PointTypePtr point = GetPointMemoryInPour (Pour);
 
   /* copy values */
   point->X = X;
@@ -654,12 +676,12 @@ CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
 /* ---------------------------------------------------------------------------
  * creates a new hole in a polygon
  */
-PolygonType *
-CreateNewHoleInPolygon (PolygonType *Polygon)
+PourType *
+CreateNewHoleInPour (PourType *Pour)
 {
-  Cardinal *holeindex = GetHoleIndexMemoryInPolygon (Polygon);
-  *holeindex = Polygon->PointN;
-  return Polygon;
+  Cardinal *holeindex = GetHoleIndexMemoryInPour (Pour);
+  *holeindex = Pour->PointN;
+  return Pour;
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/create.h b/src/create.h
index 521f60e..308698c 100644
--- a/src/create.h
+++ b/src/create.h
@@ -59,15 +59,16 @@ RatTypePtr CreateNewRat (DataTypePtr, LocationType, LocationType,
 ArcTypePtr CreateNewArcOnLayer (LayerTypePtr, LocationType, LocationType,
 				BDimension, BDimension, int, int, BDimension, BDimension,
 				FlagType);
-PolygonTypePtr CreateNewPolygonFromRectangle (LayerTypePtr, LocationType,
+PourTypePtr CreateNewPourFromRectangle (LayerTypePtr, LocationType,
 					      LocationType, LocationType,
 					      LocationType, FlagType);
 TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 			   LocationType, BYTE, int, char *, FlagType);
-PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
-PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
+PolygonTypePtr CreateNewPolygonInPour (PourType *pour, FlagType);
+PourTypePtr CreateNewPour (LayerTypePtr, FlagType);
+PointTypePtr CreateNewPointInPour (PourTypePtr,
 				      LocationType, LocationType);
-PolygonType *CreateNewHoleInPolygon (PolygonType *polygon);
+PourType *CreateNewHoleInPour (PourType *);
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
 				 FontTypePtr, FlagType, char *, char *,
 				 char *, LocationType, LocationType, BYTE,
diff --git a/src/crosshair.c b/src/crosshair.c
index 1e94c8b..90bc19d 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -48,7 +48,7 @@
 #include "misc.h"
 #include "mymem.h"
 #include "search.h"
-#include "polygon.h"
+#include "pour.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -78,6 +78,7 @@ static int CrosshairStackLocation = 0;
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
+static void XORPour (PourTypePtr, LocationType, LocationType);
 static void XORDrawElement (ElementTypePtr, LocationType, LocationType);
 static void XORDrawBuffer (BufferTypePtr);
 static void XORDrawInsertPointObject (void);
@@ -92,6 +93,8 @@ static void XORDrawAttachedArc (BDimension);
 static void
 XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
 {
+#warning FIXME Later
+#if 0
   Cardinal i;
   for (i = 0; i < polygon->PointN; i++)
     {
@@ -102,6 +105,25 @@ XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
                       polygon->Points[next].X + dx,
                       polygon->Points[next].Y + dy);
     }
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a tmp pour with coordinates converted to screen system
+ */
+static void
+XORPour (PourTypePtr pour, LocationType dx, LocationType dy)
+{
+  Cardinal i;
+  for (i = 0; i < pour->PointN; i++)
+    {
+      Cardinal next = next_contour_point (pour, i);
+      gui->draw_line (Crosshair.GC,
+                      pour->Points[i].X + dx,
+                      pour->Points[i].Y + dy,
+                      pour->Points[next].X + dx,
+                      pour->Points[next].Y + dy);
+    }
 }
 
 /*-----------------------------------------------------------
@@ -350,9 +372,11 @@ XORDrawBuffer (BufferTypePtr Buffer)
 	/* the tmp polygon has n+1 points because the first
 	 * and the last one are set to the same coordinates
 	 */
-	POLYGON_LOOP (layer);
+	POUR_LOOP (layer);
 	{
-	  XORPolygon (polygon, x, y);
+	  XORPour (pour, x, y);
+#warning FIXME Later
+//	  XORPolygon (polygon, x, y);
 	}
 	END_LOOP;
       }
@@ -452,6 +476,18 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+    case POUR_TYPE:
+      {
+	PourTypePtr pour =
+	  (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+
+	/* the tmp pour has n+1 points because the first
+	 * and the last one are set to the same coordinates
+	 */
+	XORPour (pour, dx, dy);
+	break;
+      }
+
     case LINEPOINT_TYPE:
       {
 	LineTypePtr line;
@@ -470,27 +506,27 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       {
-	PolygonTypePtr polygon;
+	PourTypePtr pour;
 	PointTypePtr point;
 	Cardinal point_idx, prev, next;
 
-	polygon = (PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+	pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 	point = (PointTypePtr) Crosshair.AttachedObject.Ptr3;
-	point_idx = polygon_point_idx (polygon, point);
+	point_idx = pour_point_idx (pour, point);
 
 	/* get previous and following point */
-	prev = prev_contour_point (polygon, point_idx);
-	next = next_contour_point (polygon, point_idx);
+	prev = prev_contour_point (pour, point_idx);
+	next = next_contour_point (pour, point_idx);
 
 	/* draw the two segments */
 	gui->draw_line (Crosshair.GC,
-			polygon->Points[prev].X, polygon->Points[prev].Y,
+			pour->Points[prev].X, pour->Points[prev].Y,
 			point->X + dx, point->Y + dy);
 	gui->draw_line (Crosshair.GC,
 			point->X + dx, point->Y + dy,
-			polygon->Points[next].X, polygon->Points[next].Y);
+			pour->Points[next].X, pour->Points[next].Y);
 	break;
       }
 
@@ -587,9 +623,9 @@ DrawAttached (bool BlockToo)
 	}
       break;
 
-      /* the attached line is used by both LINEMODE, POLYGON_MODE and POLYGONHOLE_MODE*/
-    case POLYGON_MODE:
-    case POLYGONHOLE_MODE:
+      /* the attached line is used by both LINEMODE, POUR_MODE and POURHOLE_MODE */
+    case POUR_MODE:
+    case POURHOLE_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	gui->draw_line (Crosshair.GC,
@@ -598,10 +634,10 @@ DrawAttached (bool BlockToo)
 			Crosshair.AttachedLine.Point2.X,
 			Crosshair.AttachedLine.Point2.Y);
 
-      /* draw attached polygon only if in POLYGON_MODE or POLYGONHOLE_MODE */
-      if (Crosshair.AttachedPolygon.PointN > 1)
+      /* draw attached polygon only if in POUR_MODE or POURHOLE_MODE */
+      if (Crosshair.AttachedPour.PointN > 1)
 	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
+	  XORPour (&Crosshair.AttachedPour, 0, 0);
 	}
       break;
 
@@ -982,7 +1018,7 @@ FitCrosshairIntoGrid (LocationType X, LocationType Y)
 
   if (TEST_FLAG (SNAPPINFLAG, PCB))
     ans = SearchScreenGridSlop (Crosshair.X, Crosshair.Y,
-                                POLYGONPOINT_TYPE, &ptr1, &ptr2, &ptr3);
+                                POURPOINT_TYPE, &ptr1, &ptr2, &ptr3);
   else
     ans = NO_TYPE;
 
@@ -1156,6 +1192,6 @@ void
 DestroyCrosshair (void)
 {
   CrosshairOff (true);
-  FreePolygonMemory (&Crosshair.AttachedPolygon);
+  FreePourMemory (&Crosshair.AttachedPour);
   gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/draw.c b/src/draw.c
index 56054e2..a1914d1 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -49,6 +49,7 @@
 #include "search.h"
 #include "select.h"
 #include "print.h"
+#include "pour.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -99,6 +100,7 @@ static void DrawPadNameLowLevel (PadTypePtr);
 static void DrawLineLowLevel (LineTypePtr);
 /* static */ void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr);
+static void DrawPourLowLevel (PourTypePtr);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
@@ -671,6 +673,7 @@ struct pin_info
 {
   bool arg;
   LayerTypePtr Layer;
+  const BoxType * clip;
 };
 
 /* static */ int
@@ -682,12 +685,32 @@ clearPin_callback (const BoxType * b, void *cl)
     ClearOnlyPin (pin, true);
   return 1;
 }
+
 static int
 poly_callback (const BoxType * b, void *cl)
 {
   struct pin_info *i = (struct pin_info *) cl;
 
+//  printf ("Got one poly callback, %p\n", b);
   DrawPlainPolygon (i->Layer, (PolygonTypePtr) b);
+
+  return 1;
+}
+
+static int
+pour_callback (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+  PourType *pour = (PourType *)b;
+
+  if (gui->gui)
+    DrawPour (i->Layer, pour, 0);
+
+  if (pour->PolygonN)
+    {
+      r_search (pour->polygon_tree, i->clip, NULL, poly_callback, i);
+    }
+
   return 1;
 }
 
@@ -763,6 +786,7 @@ DrawMask (BoxType * screen)
   OutputType *out = &Output;
 
   info.arg = true;
+  info.clip = screen;
 
   if (thin)
     gui->set_color (Output.pmGC, PCB->MaskColor);
@@ -861,8 +885,9 @@ DrawLayer (LayerTypePtr Layer, const BoxType * screen)
   /* print the non-clearing polys */
   info.Layer = Layer;
   info.arg = false;
+  info.clip = screen;
   clip_box = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+  r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
 
   /* draw all visible lines this layer */
   r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
@@ -900,13 +925,13 @@ DrawLayerGroup (int group, const BoxType * screen)
 	rv = 0;
       if (layernum < max_copper_layer && Layer->On)
 	{
-	  /* draw all polygons on this layer */
-	  if (Layer->PolygonN)
+	  /* draw all pours on this layer */
+	  if (Layer->PourN)
 	    {
 	      info.Layer = Layer;
 	      info.arg = true;
-	      r_search (Layer->polygon_tree, screen, NULL, poly_callback,
-			&info);
+	      info.clip = screen;
+	      r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
 	      info.arg = false;
 
 	      /* HACK: Subcomposite polygons separately from other layer primitives */
@@ -1651,6 +1676,48 @@ DrawPolygonLowLevel (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for pours
+ */
+static void
+DrawPourLowLevel (PourTypePtr Pour)
+{
+  int *x, *y, n, i;
+
+  if (Gathering)
+    {
+      AddPart (Pour);
+      return;
+    }
+
+  n = Pour->PointN;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (i = 0; i < n; i++)
+    {
+      x[i] = Pour->Points[i].X;
+      y[i] = Pour->Points[i].Y;
+    }
+
+//  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+//      TEST_FLAG (THINDRAWPOLYFLAG, PCB) ||
+//      TEST_FLAG (CLEARLINEFLAG, Pour))
+  if (1)
+    {
+      gui->set_line_width (Output.fgGC, 2);
+//      gui->set_line_width (Output.fgGC, 1);
+      for (i = 0; i < n; i++)
+        {
+          Cardinal next = next_contour_point (Pour, i);
+          gui->draw_line (Output.fgGC, x[i], y[i], x[next], y[next]);
+        }
+    }
+  else
+    gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+
+/* ---------------------------------------------------------------------------
  * lowlevel routine to element arcs
  */
 static void
@@ -1969,6 +2036,37 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
   DrawPolygonLowLevel (Polygon);
 }
 
+/* ---------------------------------------------------------------------------
+ * draws a pour on a layer
+ */
+void
+DrawPour (LayerTypePtr Layer, PourTypePtr Pour, int unused)
+{
+  int layernum;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Pour))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, Pour))
+	gui->set_color (Output.fgGC, Layer->SelectedColor);
+      else
+	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, Layer->Color);
+  layernum = GetLayerNumber (PCB->Data, Layer);
+  DrawPourLowLevel (Pour);
+#warning FIXME Later
+#if 0
+  if (TEST_FLAG (CLEARPOLYFLAG, Pour))
+    {
+      r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) PIN_TYPE);
+      r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) VIA_TYPE);
+    }
+#endif
+}
+
 int
 thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 {
@@ -2240,6 +2338,16 @@ ErasePolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * erases a pour on a layer
+ */
+void
+ErasePour (PourTypePtr Pour)
+{
+  gui->set_color (Output.fgGC, Settings.BackgroundColor);
+  DrawPourLowLevel (Pour);
+}
+
+/* ---------------------------------------------------------------------------
  * erases an element
  */
 void
@@ -2310,6 +2418,9 @@ EraseObject (int type, void *lptr, void *ptr)
     case POLYGON_TYPE:
       ErasePolygon ((PolygonTypePtr) ptr);
       break;
+    case POUR_TYPE:
+      ErasePour ((PourTypePtr) ptr);
+      break;
     case ELEMENT_TYPE:
       EraseElement ((ElementTypePtr) ptr);
       break;
@@ -2357,6 +2468,10 @@ DrawObject (int type, void *ptr1, void *ptr2, int unused)
       if (((LayerTypePtr) ptr1)->On)
 	DrawPolygon ((LayerTypePtr) ptr1, (PolygonTypePtr) ptr2, 0);
       break;
+    case POUR_TYPE:
+      if (((LayerTypePtr) ptr1)->On)
+	DrawPour ((LayerTypePtr) ptr1, (PourTypePtr) ptr2, 0);
+      break;
     case ELEMENT_TYPE:
       if (PCB->ElementOn &&
 	  (FRONT ((ElementTypePtr) ptr2) || PCB->InvisibleObjectsOn))
diff --git a/src/draw.h b/src/draw.h
index 077c575..5b4d73a 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -50,6 +50,7 @@ void DrawArc (LayerTypePtr, ArcTypePtr, int);
 void DrawText (LayerTypePtr, TextTypePtr, int);
 void DrawTextLowLevel (TextTypePtr, int);
 void DrawPolygon (LayerTypePtr, PolygonTypePtr, int);
+void DrawPour (LayerTypePtr, PourTypePtr, int);
 void DrawElement (ElementTypePtr, int);
 void DrawElementName (ElementTypePtr, int);
 void DrawElementPackage (ElementTypePtr, int);
@@ -67,6 +68,7 @@ void EraseLine (LineTypePtr);
 void EraseArc (ArcTypePtr);
 void EraseText (LayerTypePtr, TextTypePtr);
 void ErasePolygon (PolygonTypePtr);
+void ErasePour (PourTypePtr);
 void EraseElement (ElementTypePtr);
 void EraseElementPinsAndPads (ElementTypePtr);
 void EraseElementName (ElementTypePtr);
diff --git a/src/file.c b/src/file.c
index 4e4d55d..a7a3489 100644
--- a/src/file.c
+++ b/src/file.c
@@ -89,7 +89,6 @@
 #include "move.h"
 #include "mymem.h"
 #include "parse_l.h"
-#include "polygon.h"
 #include "rats.h"
 #include "remove.h"
 #include "set.h"
@@ -790,7 +789,7 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 {
   int n;
   /* write information about non empty layers */
-  if (layer->LineN || layer->ArcN || layer->TextN || layer->PolygonN ||
+  if (layer->LineN || layer->ArcN || layer->TextN || layer->PourN ||
       (layer->Name && *layer->Name))
     {
       fprintf (FP, "Layer(%i ", (int) Number + 1);
@@ -825,18 +824,18 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	  PrintQuotedString (FP, EMPTY (text->TextString));
 	  fprintf (FP, " %s]\n", F2S (text, TEXT_TYPE));
 	}
-      for (n = 0; n < layer->PolygonN; n++)
+      for (n = 0; n < layer->PourN; n++)
 	{
-	  PolygonTypePtr polygon = &layer->Polygon[n];
+	  PourTypePtr pour = &layer->Pour[n];
 	  int p, i = 0;
 	  Cardinal hole = 0;
-	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (polygon, POLYGON_TYPE));
-	  for (p = 0; p < polygon->PointN; p++)
+	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (pour, POUR_TYPE));
+	  for (p = 0; p < pour->PointN; p++)
 	    {
-	      PointTypePtr point = &polygon->Points[p];
+	      PointTypePtr point = &pour->Points[p];
 
-	      if (hole < polygon->HoleIndexN &&
-		  p == polygon->HoleIndex[hole])
+	      if (hole < pour->HoleIndexN &&
+		  p == pour->HoleIndex[hole])
 		{
 		  if (hole > 0)
 		    fputs ("\n\t\t)", FP);
diff --git a/src/find.c b/src/find.c
index 1cb15dd..fb381e6 100644
--- a/src/find.c
+++ b/src/find.c
@@ -633,6 +633,7 @@ void
 InitLayoutLookup (void)
 {
   Cardinal i;
+  int polycount;
 
   /* initialize line arc and polygon data */
   for (i = 0; i < max_copper_layer; i++)
@@ -653,10 +654,16 @@ InitLayoutLookup (void)
 
 
       /* allocate memory for polygon list */
-      if (layer->PolygonN)
+      polycount = 0;
+      POUR_LOOP (layer);
+      {
+        polycount += pour->PolygonN;
+      }
+      END_LOOP;
+      if (polycount)
         {
-          PolygonList[i].Data = calloc (layer->PolygonN, sizeof (PolygonTypePtr));
-          PolygonList[i].Size = layer->PolygonN;
+          PolygonList[i].Data = calloc (polycount, sizeof (PolygonTypePtr));
+          PolygonList[i].Size = polycount;
         }
 
       /* clear some struct members */
@@ -796,6 +803,16 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
   return 0;
 }
 
+static int
+LOCtoPVpourPoly_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct pv_info *i = (struct pv_info *) cl;
+
+  return r_search (pour->polygon_tree, (BoxType *) &i->pv,
+                   NULL, LOCtoPVpoly_callback, i);
+}
+
 /* ---------------------------------------------------------------------------
  * checks if a PV is connected to LOs, if it is, the LO is added to
  * the appropriate list and the 'used' flag is set
@@ -838,8 +855,8 @@ LookupLOConnectionsToPVList (bool AndRats)
             return true;
           /* check all polygons */
           if (setjmp (info.env) == 0)
-            r_search (LAYER_PTR (layer)->polygon_tree, (BoxType *) & info.pv,
-                      NULL, LOCtoPVpoly_callback, &info);
+            r_search (LAYER_PTR (layer)->pour_tree, (BoxType *) & info.pv,
+                      NULL, LOCtoPVpourPoly_callback, &info);
           else
             return true;
         }
@@ -1936,15 +1953,13 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1960,12 +1975,18 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return true;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsArcInPolygon (Arc, polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2081,8 +2102,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -2099,13 +2118,18 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return true;
+              POUR_LOOP (LAYER_PTR (layer));
+              {
+                POURPOLYGON_LOOP (pour);
+                {
+                  if (!TEST_FLAG (TheFlag, polygon) &&
+                      IsLineInPolygon (Line, polygon) &&
+                      ADD_POLYGON_TO_LIST (layer, polygon))
+                    return true;
+                }
+                END_LOOP;
+              }
+              END_LOOP;
             }
         }
       else
@@ -2163,7 +2187,6 @@ static bool
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2180,8 +2203,6 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           /* find the first line that touches coordinates */
 
           if (setjmp (info.env) == 0)
@@ -2196,12 +2217,17 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (true);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (true);
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsLineInPolygon (Line, polygon))
+                return (true);
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2257,6 +2283,16 @@ PolygonToRat_callback (const BoxType * b, void *cl)
 }
 
 static int
+PourPolygonToRat_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct rat_info *i = (struct rat_info *) cl;
+
+  return r_search_pt (pour->polygon_tree, i->Point, 1,
+                      NULL, PolygonToRat_callback, i);
+}
+
+static int
 LOCtoPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
@@ -2307,8 +2343,8 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
           else
             return true;
           if (setjmp (info.env) == 0)
-            r_search_pt (LAYER_PTR (layer)->polygon_tree, Point, 1,
-                      NULL, PolygonToRat_callback, &info);
+            r_search_pt (LAYER_PTR (layer)->pour_tree, Point, 1,
+                      NULL, PourPolygonToRat_callback, &info);
         }
       else
         {
@@ -2372,6 +2408,16 @@ LOCtoPadPoly_callback (const BoxType * b, void *cl)
 }
 
 static int
+LOCtoPadPourPoly_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct lo_info *i = (struct lo_info *) cl;
+
+  return r_search (pour->polygon_tree, &i->pad.BoundingBox,
+                   NULL, LOCtoPadPoly_callback, i);
+}
+
+static int
 LOCtoPadRat_callback (const BoxType * b, void *cl)
 {
   RatTypePtr rat = (RatTypePtr) b;
@@ -2461,8 +2507,8 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
             return true;
           /* add polygons */
           if (setjmp (info.env) == 0)
-            r_search (LAYER_PTR (layer)->polygon_tree, &info.pad.BoundingBox,
-                      NULL, LOCtoPadPoly_callback, &info);
+            r_search (LAYER_PTR (layer)->pour_tree, &info.pad.BoundingBox,
+                      NULL, LOCtoPadPourPoly_callback, &info);
           else
             return true;
         }
@@ -2572,25 +2618,30 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
+          info.layer = layer;
 
           /* check all polygons */
 
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsPolygonInPolygon (polygon, Polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
 
-          info.layer = layer;
           /* check all lines */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->line_tree,
@@ -3552,17 +3603,21 @@ ResetFoundLinesAndPolygons (bool AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (TheFlag, polygon))
-      {
-        if (AndDraw)
-          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-        CLEAR_FLAG (TheFlag, polygon);
-        if (AndDraw)
-          DrawPolygon (layer, polygon, 0);
-        change = true;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (TheFlag, polygon))
+        {
+          if (AndDraw)
+            AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (TheFlag, polygon);
+          if (AndDraw)
+            DrawPolygon (layer, polygon, 0);
+          change = true;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/find.h b/src/find.h
index 5b04980..f93fca1 100644
--- a/src/find.h
+++ b/src/find.h
@@ -42,7 +42,7 @@
 #define LOOKUP_MORE	\
 	(VIA_TYPE | LINE_TYPE | RATLINE_TYPE | POLYGON_TYPE | ARC_TYPE)
 #define SILK_TYPE	\
-	(LINE_TYPE | ARC_TYPE | POLYGON_TYPE)
+	(LINE_TYPE | ARC_TYPE | POUR_TYPE)
 
 bool LineLineIntersect (LineTypePtr, LineTypePtr);
 bool LineArcIntersect (LineTypePtr, ArcTypePtr);
diff --git a/src/flags.c b/src/flags.c
index 499e59e..ef6b466 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -196,8 +196,9 @@ HID_Flag flags_flag_list[] = {
   {"lockmode", FlagMode, LOCK_MODE},
   {"movemode", FlagMode, MOVE_MODE},
   {"pastebuffermode", FlagMode, PASTEBUFFER_MODE},
-  {"polygonmode", FlagMode, POLYGON_MODE},
-  {"polygonholemode", FlagMode, POLYGONHOLE_MODE},
+//  {"polygonmode", FlagMode, POLYGON_MODE},
+  {"pourmode", FlagMode, POUR_MODE},
+  {"pourholemode", FlagMode, POURHOLE_MODE},
   {"rectanglemode", FlagMode, RECTANGLE_MODE},
   {"removemode", FlagMode, REMOVE_MODE},
   {"rotatemode", FlagMode, ROTATE_MODE},
diff --git a/src/global.h b/src/global.h
index bb78abc..3d5f28f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -251,19 +251,49 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
-struct polygon_st			/* holds information about a polygon */
+struct rtree
+{
+  struct rtree_node *root;
+  int size;			/* number of entries in tree */
+};
+
+typedef struct			/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in polygon */
-    PointMax;			/* max number from malloc() */
-  POLYAREA *Clipped;		/* the clipped region of this polygon */
-  PLINE *NoHoles;		/* the polygon broken into hole-less regions */
-  int NoHolesValid;		/* Is the NoHoles polygon up to date? */
-  PointTypePtr Points;		/* data */
-  Cardinal *HoleIndex;		/* Index of hole data within the Points array */
+
+  Cardinal PointN;		/* number of points in pour outline */
+  Cardinal PointMax;		/* max number from malloc() */
+  PointTypePtr Points;		/* pour outline data */
+
   Cardinal HoleIndexN;		/* number of holes in polygon */
   Cardinal HoleIndexMax;	/* max number from malloc() */
+  Cardinal *HoleIndex;		/* Index of hole data within the Points array */
+
+  Cardinal PolygonN;		/* number of polygons this pour has */
+  Cardinal PolygonMax;		/* max number from malloc() */
+  PolygonTypePtr Polygons;	/* pour polygons */
+
+  rtree_t *polygon_tree;	/* r-tree of child polygons */
+
+} PourType, *PourTypePtr;
 
+struct polygon_st		/* holds information about a polygon */
+{
+  ANYOBJECTFIELDS;
+
+//  Cardinal PointN,		/* number of points in polygon */
+//  Cardinal PointMax;		/* max number from malloc() */
+//  PointTypePtr Points;		/* data */
+
+//  Cardinal HoleIndexN;		/* number of holes in polygon */
+//  Cardinal HoleIndexMax;	/* max number from malloc() */
+//  Cardinal *HoleIndex;		/* Index of hole data within the Points array */
+
+  POLYAREA *Clipped;		/* the clipped region of this polygon */
+  PLINE *NoHoles;		/* the clipped polygon broken into hole-less regions */
+  int NoHolesValid;		/* Is the NoHoles polygon up to date? */
+
+  PourTypePtr ParentPour;	/* The pour which resulted in this polygon */
 };
 
 typedef struct			/* holds information about arcs */
@@ -277,26 +307,25 @@ typedef struct			/* holds information about arcs */
     Delta;
 } ArcType, *ArcTypePtr;
 
-struct rtree
-{
-  struct rtree_node *root;
-  int size;			/* number of entries in tree */
-};
-
 typedef struct			/* holds information about one layer */
 {
   char *Name;			/* layer name */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
-    PolygonN,			/* polygons */
+//    PolygonN,			/* polygons */
+    PourN,			/* poured areas */
     ArcN,			/* and arcs */
     LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
+    TextMax,
+//    PolygonMax,
+    PourMax,
+    ArcMax;
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
-  PolygonTypePtr Polygon;
+//  PolygonTypePtr Polygon;
+  PourTypePtr Pour;
   ArcTypePtr Arc;
-  rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
+  rtree_t *line_tree, *text_tree, *pour_tree, *arc_tree;
   bool On;			/* visible flag */
   char *Color,			/* color */
    *SelectedColor;
@@ -581,7 +610,8 @@ typedef struct			/* holds cursor information */
   bool On;			/* flag for 'is visible' */
   AttachedLineType AttachedLine;	/* data of new lines... */
   AttachedBoxType AttachedBox;
-  PolygonType AttachedPolygon;
+//  PolygonType AttachedPolygon;
+  PourType AttachedPour;
   AttachedObjectType AttachedObject;	/* data of attached objects */
   enum crosshair_shape shape; /* shape of crosshair */
 } CrosshairType, *CrosshairTypePtr;
@@ -696,13 +726,15 @@ typedef struct
   void *(*Line) (LayerTypePtr, LineTypePtr);
   void *(*Text) (LayerTypePtr, TextTypePtr);
   void *(*Polygon) (LayerTypePtr, PolygonTypePtr);
+  void *(*Pour) (LayerTypePtr, PourTypePtr);
   void *(*Via) (PinTypePtr);
   void *(*Element) (ElementTypePtr);
   void *(*ElementName) (ElementTypePtr);
   void *(*Pin) (ElementTypePtr, PinTypePtr);
   void *(*Pad) (ElementTypePtr, PadTypePtr);
   void *(*LinePoint) (LayerTypePtr, LineTypePtr, PointTypePtr);
-  void *(*Point) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+//  void *(*PolygonPoint) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PourPoint) (LayerTypePtr, PourTypePtr, PointTypePtr);
   void *(*Arc) (LayerTypePtr, ArcTypePtr);
   void *(*Rat) (RatTypePtr);
 } ObjectFunctionType, *ObjectFunctionTypePtr;
diff --git a/src/gpcb-menu.res b/src/gpcb-menu.res
index bd9acac..0dc18a1 100644
--- a/src/gpcb-menu.res
+++ b/src/gpcb-menu.res
@@ -516,8 +516,8 @@ PopupMenus =
        {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
        {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
        {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-       {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
-       {"Polygon Hole" checked=polygonholemode,1 Mode(PolygonHole)}
+       {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
+       {"Polygon Hole" checked=pourholemode,1 Mode(PourHole)}
        {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
        {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
        {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index f1bdcea..f3b4c1d 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -281,7 +281,7 @@ gcode_choose_groups ()
     {
       layer = &PCB->Data->Layer[n];
 
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	{
 	  /* layer isn't empty */
 
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index b9caf18..7d94db5 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -382,7 +382,7 @@ gerber_do_export (HID_Attr_Val * options)
   for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index e2fa201..2726c07 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -166,15 +166,19 @@ unset_found_flags (int AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (flag, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	CLEAR_FLAG (flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	change = true;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (flag, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          change = true;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/hid/gtk/gui-icons-mode-buttons.data b/src/hid/gtk/gui-icons-mode-buttons.data
index be040f1..432d47f 100644
--- a/src/hid/gtk/gui-icons-mode-buttons.data
+++ b/src/hid/gtk/gui-icons-mode-buttons.data
@@ -252,7 +252,7 @@ static char *pan[] = {
 
 #endif
 /* XPM */
-static char *poly[] = {
+static char *pour[] = {
 /* columns rows colors chars-per-pixel */
 "21 21 4 1",
 "  c black",
@@ -284,7 +284,7 @@ static char *poly[] = {
 };
 
 /* XPM */
-static char * polyhole[] = {
+static char * pourhole[] = {
 "21 21 3 1",
 " 	c None",
 ".	c #6EA5D7",
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index a607a69..f36c400 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -219,8 +219,8 @@ ghid_mode_cursor (int Mode)
       gport_set_cursor (GDK_LEFT_PTR);
       break;
 
-    case POLYGON_MODE:
-    case POLYGONHOLE_MODE:
+    case POUR_MODE:
+    case POURHOLE_MODE:
       gport_set_cursor (GDK_SB_UP_ARROW);
       break;
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 476b196..63178a1 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -290,8 +290,8 @@ have_crosshair_attachments (void)
     case VIA_MODE:
       result = TRUE;
       break;
-    case POLYGON_MODE:
-    case POLYGONHOLE_MODE:
+    case POUR_MODE:
+    case POURHOLE_MODE:
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	result = TRUE;
       break;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 9daecc6..02d617e 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1980,8 +1980,9 @@ static ModeButton mode_buttons[] = {
   {NULL, NULL, NULL, "arc", ARC_MODE, arc},
   {NULL, NULL, NULL, "text", TEXT_MODE, text},
   {NULL, NULL, NULL, "rectangle", RECTANGLE_MODE, rect},
-  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
-  {NULL, NULL, NULL, "polygonhole", POLYGONHOLE_MODE, polyhole},
+//  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
+  {NULL, NULL, NULL, "pour", POUR_MODE, pour},
+  {NULL, NULL, NULL, "pourhole", POURHOLE_MODE, pourhole},
   {NULL, NULL, NULL, "buffer", PASTEBUFFER_MODE, buf},
   {NULL, NULL, NULL, "remove", REMOVE_MODE, del},
   {NULL, NULL, NULL, "rotate", ROTATE_MODE, rot},
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 5ce698a..bb5615b 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -526,7 +526,7 @@ nelma_choose_groups()
 		layer = &PCB->Data->Layer[n];
 
 		if (layer->LineN || layer->TextN || layer->ArcN ||
-		    layer->PolygonN) {
+		    layer->PourN) {
 			/* layer isn't empty */
 
 			/*
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index ae824cc..a9f27b6 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -342,7 +342,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index a931bcf..4c46feb 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -151,7 +151,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->On)
-	if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+	if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	  print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 4a149db..2bf04b3 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -482,7 +482,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
 
       if (strcmp (layer->Name, "outline") == 0 ||
diff --git a/src/insert.c b/src/insert.c
index 5e62463..19e61f2 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -46,6 +46,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -65,7 +66,7 @@ RCSID ("$Id$");
  * some local prototypes
  */
 static void *InsertPointIntoLine (LayerTypePtr, LineTypePtr);
-static void *InsertPointIntoPolygon (LayerTypePtr, PolygonTypePtr);
+static void *InsertPointIntoPour (LayerTypePtr, PourTypePtr);
 static void *InsertPointIntoRat (RatTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -79,7 +80,8 @@ static bool Forcible;
 static ObjectFunctionType InsertFunctions = {
   InsertPointIntoLine,
   NULL,
-  InsertPointIntoPolygon,
+  NULL,
+  InsertPointIntoPour,
   NULL,
   NULL,
   NULL,
@@ -160,10 +162,10 @@ InsertPointIntoLine (LayerTypePtr Layer, LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * inserts a point into a polygon
+ * inserts a point into a pour
  */
 static void *
-InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+InsertPointIntoPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   PointType save;
   Cardinal n;
@@ -175,40 +177,40 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
        * first make sure adding the point is sensible
        */
       line.Thickness = 0;
-      line.Point1 = Polygon->Points[prev_contour_point (Polygon, InsertAt)];
-      line.Point2 = Polygon->Points[InsertAt];
+      line.Point1 = Pour->Points[prev_contour_point (Pour, InsertAt)];
+      line.Point2 = Pour->Points[InsertAt];
       if (IsPointOnLine ((float) InsertX, (float) InsertY, 0.0, &line))
 	return (NULL);
     }
   /*
    * second, shift the points up to make room for the new point
    */
-  ErasePolygon (Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
-  for (n = Polygon->PointN - 1; n > InsertAt; n--)
-    Polygon->Points[n] = Polygon->Points[n - 1];
+  ErasePour (Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  save = *CreateNewPointInPour (Pour, InsertX, InsertY);
+  for (n = Pour->PointN - 1; n > InsertAt; n--)
+    Pour->Points[n] = Pour->Points[n - 1];
 
   /* Shift up indices of any holes */
-  for (n = 0; n < Polygon->HoleIndexN; n++)
-    if (Polygon->HoleIndex[n] > InsertAt ||
-	(InsertLast && Polygon->HoleIndex[n] == InsertAt))
-      Polygon->HoleIndex[n]++;
+  for (n = 0; n < Pour->HoleIndexN; n++)
+    if (Pour->HoleIndex[n] > InsertAt ||
+	(InsertLast && Pour->HoleIndex[n] == InsertAt))
+      Pour->HoleIndex[n]++;
 
-  Polygon->Points[InsertAt] = save;
+  Pour->Points[InsertAt] = save;
   SetChangedFlag (true);
-  AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
-				  &Polygon->Points[InsertAt]);
+  AddObjectToInsertPointUndoList (POURPOINT_TYPE, Layer, Pour,
+				  &Pour->Points[InsertAt]);
 
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  if (Forcible || !RemoveExcessPolygonPoints (Layer, Polygon))
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  if (Forcible || !RemoveExcessPourPoints (Layer, Pour))
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (&Polygon->Points[InsertAt]);
+  return (&Pour->Points[InsertAt]);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/insert.h b/src/insert.h
index 350a0de..67d1b78 100644
--- a/src/insert.h
+++ b/src/insert.h
@@ -33,7 +33,7 @@
 
 #include "global.h"
 
-#define	INSERT_TYPES	(POLYGON_TYPE | LINE_TYPE | RATLINE_TYPE)
+#define	INSERT_TYPES	(POUR_TYPE | LINE_TYPE | RATLINE_TYPE)
 
 /* ---------------------------------------------------------------------------
  * prototypes
diff --git a/src/macro.h b/src/macro.h
index ddb1fb3..89330ba 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,19 +391,26 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
-#define	POLYGON_LOOP(layer) do {			\
+#define	POUR_LOOP(layer) do {			\
 	Cardinal		n;			\
-	PolygonTypePtr	polygon;			\
-	for (n = (layer)->PolygonN-1; n != -1; n--)	\
+	PourTypePtr	pour;			\
+	for (n = (layer)->PourN-1; n != -1; n--)	\
 	{						\
-		polygon = &(layer)->Polygon[n]
+		pour = &(layer)->Pour[n]
 
-#define	POLYGONPOINT_LOOP(polygon) do	{	\
+#define	POURPOINT_LOOP(pour) do	{	\
 	Cardinal			n;		\
 	PointTypePtr	point;				\
-	for (n = (polygon)->PointN-1; n != -1; n--)	\
+	for (n = (pour)->PointN-1; n != -1; n--)	\
 	{						\
-		point = &(polygon)->Points[n]
+		point = &(pour)->Points[n]
+
+#define	POURPOLYGON_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PolygonTypePtr	polygon;				\
+	for (n = (pour)->PolygonN-1; n != -1; n--)	\
+	{						\
+		polygon = &(pour)->Polygons[n]
 
 #define ENDALL_LOOP }} while (0);  }} while (0)
 
@@ -429,12 +436,12 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	ALLPOLYGON_LOOP(top)	do {		\
+#define	ALLPOUR_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	COPPERLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -450,12 +457,12 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	COPPERPOLYGON_LOOP(top) do	{		\
+#define	COPPERPOUR_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_copper_layer; l++, layer++)	\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	SILKLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -473,13 +480,13 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	SILKPOLYGON_LOOP(top) do	{		\
+#define	SILKPOUR_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	layer += max_copper_layer;			\
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
@@ -512,13 +519,13 @@ extern int mem_any_set (unsigned char *, int);
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
 
-#define	VISIBLEPOLYGON_LOOP(top) do	{	\
+#define	VISIBLEPOUR_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		if (layer->On)				\
-			POLYGON_LOOP(layer)
+			POUR_LOOP(layer)
 
 #define POINTER_LOOP(top) do	{	\
 	Cardinal	n;			\
diff --git a/src/mirror.c b/src/mirror.c
index 7ef7d41..1b76e88 100644
--- a/src/mirror.c
+++ b/src/mirror.c
@@ -46,6 +46,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "search.h"
 #include "select.h"
 #include "set.h"
@@ -78,14 +79,14 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   END_LOOP;
   PIN_LOOP (Element);
   {
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     pin->X = SWAP_X (pin->X);
     pin->Y = SWAP_Y (pin->Y) + yoff;
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     pad->Point1.X = SWAP_X (pad->Point1.X);
     pad->Point1.Y = SWAP_Y (pad->Point1.Y) + yoff;
     pad->Point2.X = SWAP_X (pad->Point2.X);
@@ -115,5 +116,5 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   TOGGLE_FLAG (ONSOLDERFLAG, Element);
   /* this inserts all of the rtree data too */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
diff --git a/src/misc.c b/src/misc.c
index 2e471d0..be6e2ea 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -66,6 +66,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "rotate.h"
@@ -251,22 +252,35 @@ SetLineBoundingBox (LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * sets the bounding box of a polygons
+ * sets the bounding box of a polygon
  */
 void
 SetPolygonBoundingBox (PolygonTypePtr Polygon)
 {
-  Polygon->BoundingBox.X1 = Polygon->BoundingBox.Y1 = MAX_COORD;
-  Polygon->BoundingBox.X2 = Polygon->BoundingBox.Y2 = 0;
-  POLYGONPOINT_LOOP (Polygon);
+  PLINE *outer = Polygon->Clipped->contours;
+  Polygon->BoundingBox.X1 = outer->xmin;
+  Polygon->BoundingBox.Y1 = outer->ymin;
+  Polygon->BoundingBox.X2 = outer->xmax;
+  Polygon->BoundingBox.Y2 = outer->ymax;
+}
+
+/* ---------------------------------------------------------------------------
+ * sets the bounding box of a pour
+ */
+void
+SetPourBoundingBox (PourTypePtr Pour)
+{
+  Pour->BoundingBox.X1 = Pour->BoundingBox.Y1 = MAX_COORD;
+  Pour->BoundingBox.X2 = Pour->BoundingBox.Y2 = 0;
+  POURPOINT_LOOP (Pour);
   {
-    MAKEMIN (Polygon->BoundingBox.X1, point->X);
-    MAKEMIN (Polygon->BoundingBox.Y1, point->Y);
-    MAKEMAX (Polygon->BoundingBox.X2, point->X);
-    MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
+    MAKEMIN (Pour->BoundingBox.X1, point->X);
+    MAKEMIN (Pour->BoundingBox.Y1, point->Y);
+    MAKEMAX (Pour->BoundingBox.X2, point->X);
+    MAKEMAX (Pour->BoundingBox.Y2, point->Y);
   }
   /* boxes don't include the lower right corner */
-  close_box(&Polygon->BoundingBox);
+  close_box(&Pour->BoundingBox);
   END_LOOP;
 }
 
@@ -508,7 +522,9 @@ IsDataEmpty (DataTypePtr Data)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
-      Data->Layer[i].TextN == 0 && Data->Layer[i].PolygonN == 0;
+      Data->Layer[i].TextN == 0 &&
+      Data->Layer[i].PourN == 0;
+
   return (hasNoObjects);
 }
 
@@ -588,13 +604,17 @@ GetDataBoundingBox (DataTypePtr Data)
     box.Y2 = MAX (box.Y2, text->BoundingBox.Y2);
   }
   ENDALL_LOOP;
-  ALLPOLYGON_LOOP (Data);
-  {
-    box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
-    box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
-    box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
-    box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
-  }
+  ALLPOUR_LOOP (Data);
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
+        box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
+        box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
+        box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
+      }
+      END_LOOP;
+    }
   ENDALL_LOOP;
   return (IsDataEmpty (Data) ? NULL : &box);
 }
@@ -1239,6 +1259,7 @@ GetObjectBoundingBox (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     case ARC_TYPE:
     case TEXT_TYPE:
     case POLYGON_TYPE:
+    case POUR_TYPE:
     case PAD_TYPE:
     case PIN_TYPE:
     case ELEMENTNAME_TYPE:
@@ -1246,7 +1267,7 @@ GetObjectBoundingBox (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     case VIA_TYPE:
     case ELEMENT_TYPE:
       return (BoxType *)Ptr1;
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
     case LINEPOINT_TYPE:
       return (BoxType *)Ptr3;
     default:
@@ -1507,14 +1528,14 @@ ChangeArcAngles (LayerTypePtr Layer, ArcTypePtr a,
       new_da = 360;
       new_sa = 0;
     }
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, a);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
   AddObjectToChangeAnglesUndoList (ARC_TYPE, a, a, a);
   a->StartAngle = new_sa;
   a->Delta = new_da;
   SetArcBoundingBox (a);
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) a, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, a);
 }
 
 static char *
@@ -1599,13 +1620,8 @@ GetGridLockCoordinates (int type, void *ptr1,
       *x = ((ElementTypePtr) ptr2)->MarkX;
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
-    case POLYGON_TYPE:
-      *x = ((PolygonTypePtr) ptr2)->Points[0].X;
-      *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
-      break;
-
     case LINEPOINT_TYPE:
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       *x = ((PointTypePtr) ptr3)->X;
       *y = ((PointTypePtr) ptr3)->Y;
       break;
diff --git a/src/misc.h b/src/misc.h
index 776e309..977e2b2 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -42,6 +42,7 @@ void SetPointBoundingBox (PointTypePtr);
 void SetPinBoundingBox (PinTypePtr);
 void SetPadBoundingBox (PadTypePtr);
 void SetPolygonBoundingBox (PolygonTypePtr);
+void SetPourBoundingBox (PourTypePtr);
 void SetElementBoundingBox (DataTypePtr, ElementTypePtr, FontTypePtr);
 bool IsDataEmpty (DataTypePtr);
 BoxTypePtr GetDataBoundingBox (DataTypePtr);
diff --git a/src/move.c b/src/move.c
index cbb2e3d..665d441 100644
--- a/src/move.c
+++ b/src/move.c
@@ -48,6 +48,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -72,14 +73,14 @@ static void *MoveVia (PinTypePtr);
 static void *MoveLine (LayerTypePtr, LineTypePtr);
 static void *MoveArc (LayerTypePtr, ArcTypePtr);
 static void *MoveText (LayerTypePtr, TextTypePtr);
-static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+static void *MovePour (LayerTypePtr, PourTypePtr);
 static void *MoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
-static void *MovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *MovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *MoveLineToLayer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToLayer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToLayer (RatTypePtr);
 static void *MoveTextToLayer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToLayer (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -91,14 +92,15 @@ static bool MoreToCome;
 static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
-  MovePolygon,
+  NULL,
+  MovePour,
   MoveVia,
   MoveElement,
   MoveElementName,
   NULL,
   NULL,
   MoveLinePoint,
-  MovePolygonPoint,
+  MovePourPoint,
   MoveArc,
   NULL
 }, MoveToLayerFunctions =
@@ -106,8 +108,17 @@ static ObjectFunctionType MoveFunctions = {
 {
 MoveLineToLayer,
     MoveTextToLayer,
-    MovePolygonToLayer,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, MoveArcToLayer, MoveRatToLayer};
+    NULL,
+    MovePourToLayer,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToLayer,
+    MoveRatToLayer};
 
 /* ---------------------------------------------------------------------------
  * moves a element by +-X and +-Y
@@ -128,13 +139,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pin_tree, (BoxType *) pin);
-	RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+	RestoreToPours (Data, PIN_TYPE, Element, pin);
       }
     MOVE_PIN_LOWLEVEL (pin, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pin_tree, (BoxType *) pin, 0);
-	ClearFromPolygon (Data, PIN_TYPE, Element, pin);
+	ClearFromPours (Data, PIN_TYPE, Element, pin);
       }
   }
   END_LOOP;
@@ -143,13 +154,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pad_tree, (BoxType *) pad);
-	RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+	RestoreToPours (Data, PAD_TYPE, Element, pad);
       }
     MOVE_PAD_LOWLEVEL (pad, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pad_tree, (BoxType *) pad, 0);
-	ClearFromPolygon (Data, PAD_TYPE, Element, pad);
+	ClearFromPours (Data, PAD_TYPE, Element, pad);
       }
   }
   END_LOOP;
@@ -249,12 +260,12 @@ static void *
 MoveVia (PinTypePtr Via)
 {
   r_delete_entry (PCB->Data->via_tree, (BoxTypePtr) Via);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   MOVE_VIA_LOWLEVEL (Via, DeltaX, DeltaY);
   if (PCB->ViaOn)
     EraseVia (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxTypePtr) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   if (PCB->ViaOn)
     {
       DrawVia (Via, 0);
@@ -271,11 +282,11 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
   r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
     {
       DrawLine (Layer, Line, 0);
@@ -290,7 +301,7 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 static void *
 MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   if (Layer->On)
     {
@@ -304,7 +315,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
       MOVE_ARC_LOWLEVEL (Arc, DeltaX, DeltaY);
     }
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   return (Arc);
 }
 
@@ -314,7 +325,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 MoveText (LayerTypePtr Layer, TextTypePtr Text)
 {
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   if (Layer->On)
     {
@@ -326,45 +337,45 @@ MoveText (LayerTypePtr Layer, TextTypePtr Text)
   else
     MOVE_TEXT_LOWLEVEL (Text, DeltaX, DeltaY);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   return (Text);
 }
 
 /* ---------------------------------------------------------------------------
- * low level routine to move a polygon
+ * low level routine to move a pour
  */
 void
-MovePolygonLowLevel (PolygonTypePtr Polygon, LocationType DeltaX,
+MovePourLowLevel (PourTypePtr Pour, LocationType DeltaX,
 		     LocationType DeltaY)
 {
-  POLYGONPOINT_LOOP (Polygon);
+  POURPOINT_LOOP (Pour);
   {
     MOVE (point->X, point->Y, DeltaX, DeltaY);
   }
   END_LOOP;
-  MOVE_BOX_LOWLEVEL (&Polygon->BoundingBox, DeltaX, DeltaY);
+  MOVE_BOX_LOWLEVEL (&Pour->BoundingBox, DeltaX, DeltaY);
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon
+ * moves a pour
  */
 static void *
-MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  MovePolygonLowLevel (Polygon, DeltaX, DeltaY);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  MovePourLowLevel (Pour, DeltaX, DeltaY);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (Polygon);
+  return (Pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -377,12 +388,12 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
     {
       if (Layer->On)
 	EraseLine (Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, &Line->BoundingBox);
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -408,25 +419,24 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon-point
+ * moves a pour-point
  */
 static void *
-MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
-		  PointTypePtr Point)
+MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
   return (Point);
@@ -498,11 +508,11 @@ MoveArcToLayer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (((long int) Dest == -1) || Dest == Layer)
     return (Arc);
   AddObjectToMoveToLayerUndoList (ARC_TYPE, Layer, Arc, Arc);
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   if (Layer->On)
     EraseArc (Arc);
   new = MoveArcToLayerLowLevel (Layer, Arc, Dest);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Dest, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Dest, Arc);
   if (Dest->On)
     DrawArc (Dest, new, 0);
   Draw ();
@@ -592,10 +602,10 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToMoveToLayerUndoList (LINE_TYPE, Layer, Line, Line);
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   new = MoveLineToLayerLowLevel (Layer, Line, Dest);
   Line = NULL;
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Dest, new);
+  ClearFromPours (PCB->Data, LINE_TYPE, Dest, new);
   if (Dest->On)
     DrawLine (Dest, new, 0);
   Draw ();
@@ -646,7 +656,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
 {
   TextTypePtr new = GetTextMemory (Destination);
 
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Source, Text);
   r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
   /* copy the data and remove it from the former layer */
   *new = *Text;
@@ -664,7 +674,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Destination->text_tree, (BoxTypePtr) new, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, new);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Destination, new);
   return (new);
 }
 
@@ -697,25 +707,28 @@ MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon between layers; lowlevel routines
+ * moves a pour between layers; lowlevel routines
  */
 void *
-MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
+MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
 			    LayerTypePtr Destination)
 {
-  PolygonTypePtr new = GetPolygonMemory (Destination);
+  PourTypePtr new = GetPourMemory (Destination);
+  Cardinal i;
 
-  r_delete_entry (Source->polygon_tree, (BoxType *) Polygon);
+  r_delete_entry (Source->pour_tree, (BoxType *) Pour);
   /* copy the data and remove it from the former layer */
-  *new = *Polygon;
-  *Polygon = Source->Polygon[--Source->PolygonN];
-  r_substitute (Source->polygon_tree,
-		(BoxType *) & Source->Polygon[Source->PolygonN],
-		(BoxType *) Polygon);
-  memset (&Source->Polygon[Source->PolygonN], 0, sizeof (PolygonType));
-  if (!Destination->polygon_tree)
-    Destination->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->polygon_tree, (BoxType *) new, 0);
+  *new = *Pour;
+  *Pour = Source->Pour[--Source->PourN];
+  r_substitute (Source->pour_tree,
+		(BoxType *) & Source->Pour[Source->PourN],
+		(BoxType *) Pour);
+  for (i = 0; i < Pour->PolygonN; i++)
+    Pour->Polygons[i].ParentPour = Pour;
+  memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
+  if (!Destination->pour_tree)
+    Destination->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Destination->pour_tree, (BoxType *) new, 0);
   return (new);
 }
 
@@ -745,37 +758,40 @@ mptl_pin_callback (const BoxType *b, void *cl)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon between layers
+ * moves a pour between layers
  */
 static void *
-MovePolygonToLayer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePourToLayer (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  PolygonTypePtr new;
-  struct mptlc d;
+  PourTypePtr new;
+//  struct mptlc d;
 
-  if (TEST_FLAG (LOCKFLAG, Polygon))
+  if (TEST_FLAG (LOCKFLAG, Pour))
     {
       Message (_("Sorry, the object is locked\n"));
       return NULL;
     }
   if (((long int) Dest == -1) || (Layer == Dest))
-    return (Polygon);
-  AddObjectToMoveToLayerUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
+    return (Pour);
+  AddObjectToMoveToLayerUndoList (POUR_TYPE, Layer, Pour, Pour);
   if (Layer->On)
-    ErasePolygon (Polygon);
-  /* Move all of the thermals with the polygon */
+    ErasePour (Pour);
+#define FIXME Later
+#if 0
+  /* Move all of the thermals with the pour */
   d.snum = GetLayerNumber (PCB->Data, Layer);
   d.dnum = GetLayerNumber (PCB->Data, Dest);
-  d.polygon = Polygon;
+  d.pour = Pour;
   d.type = PIN_TYPE;
-  r_search (PCB->Data->pin_tree, &Polygon->BoundingBox, NULL, mptl_pin_callback, &d);
+  r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
   d.type = VIA_TYPE;
-  r_search (PCB->Data->via_tree, &Polygon->BoundingBox, NULL, mptl_pin_callback, &d);
-  new = MovePolygonToLayerLowLevel (Layer, Polygon, Dest);
-  InitClip (PCB->Data, Dest, new);
+  r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+#endif
+  new = MovePourToLayerLowLevel (Layer, Pour, Dest);
+  InitPourClip (PCB->Data, Dest, new);
   if (Dest->On)
     {
-      DrawPolygon (Dest, new, 0);
+      DrawPour (Dest, new, 0);
       Draw ();
     }
   return (new);
diff --git a/src/move.h b/src/move.h
index c4a844b..9a65143 100644
--- a/src/move.h
+++ b/src/move.h
@@ -85,15 +85,15 @@
 
 #define	MOVE_TYPES	\
 	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | ELEMENT_TYPE | ELEMENTNAME_TYPE |	\
-	POLYGON_TYPE | POLYGONPOINT_TYPE | LINEPOINT_TYPE | ARC_TYPE)
+	POUR_TYPE | POURPOINT_TYPE | LINEPOINT_TYPE | ARC_TYPE)
 #define	MOVETOLAYER_TYPES	\
-	(LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | RATLINE_TYPE | ARC_TYPE)
+	(LINE_TYPE | TEXT_TYPE | POUR_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 
 /* ---------------------------------------------------------------------------
  * prototypes
  */
-void MovePolygonLowLevel (PolygonTypePtr, LocationType, LocationType);
+void MovePourLowLevel (PourTypePtr, LocationType, LocationType);
 void MoveElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			  LocationType);
 void *MoveObject (int, void *, void *, void *, LocationType, LocationType);
@@ -102,7 +102,6 @@ void *MoveObjectAndRubberband (int, void *, void *, void *,
 			       LocationType, LocationType);
 void *MoveLineToLayerLowLevel (LayerTypePtr, LineTypePtr, LayerTypePtr);
 void *MoveTextToLayerLowLevel (LayerTypePtr, TextTypePtr, LayerTypePtr);
-void *MovePolygonToLayerLowLevel (LayerTypePtr, PolygonTypePtr, LayerTypePtr);
 bool MoveSelectedObjectsToLayer (LayerTypePtr);
 
 /* index is 0..MAX_LAYER-1.  If old_index is -1, a new layer is
diff --git a/src/mymem.c b/src/mymem.c
index 09cb6ab..a3a6161 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -395,31 +395,59 @@ GetTextMemory (LayerTypePtr Layer)
 }
 
 /* ---------------------------------------------------------------------------
+ * get next slot for a pour polygon object, allocates memory if necessary
+ */
+PourTypePtr
+GetPourMemory (LayerTypePtr Layer)
+{
+  PourTypePtr pour = Layer->Pour;
+
+  /* realloc new memory if necessary and clear it */
+  if (Layer->PourN >= Layer->PourMax)
+    {
+      Layer->PourMax += STEP_POUR;
+      if (Layer->pour_tree)
+	r_destroy_tree (&Layer->pour_tree);
+      pour = realloc (pour, Layer->PourMax * sizeof (PourType));
+      Layer->Pour = pour;
+      memset (pour + Layer->PourN, 0,
+	      STEP_POUR * sizeof (PourType));
+      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+      POUR_LOOP (Layer);
+      {
+	r_insert_entry (Layer->pour_tree, (BoxType *) pour, 0);
+      }
+      END_LOOP;
+    }
+  return (pour + Layer->PourN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
 PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+GetPolygonMemoryInPour (PourTypePtr Pour)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonTypePtr polygon = Pour->Polygons;
 
   /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
-    {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = realloc (polygon, Layer->PolygonMax * sizeof (PolygonType));
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
-	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
+  if (Pour->PolygonN >= Pour->PolygonMax)
+    {
+      Pour->PolygonMax += STEP_POLYGON;
+      if (Pour->polygon_tree)
+        r_destroy_tree (&Pour->polygon_tree);
+      polygon = realloc (polygon, Pour->PolygonMax * sizeof (PolygonType));
+      Pour->Polygons = polygon;
+      memset (polygon + Pour->PolygonN, 0,
+              STEP_POLYGON * sizeof (PolygonType));
+      Pour->polygon_tree = r_create_tree (NULL, 0, 0);
+      POURPOLYGON_LOOP (Pour);
       {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
+        r_insert_entry (Pour->polygon_tree, (BoxType *) polygon, 0);
       }
       END_LOOP;
     }
-  return (polygon + Layer->PolygonN++);
+  return (polygon + Pour->PolygonN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -429,6 +457,9 @@ GetPolygonMemory (LayerTypePtr Layer)
 PointTypePtr
 GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 {
+  return NULL;
+#warning FIXME Later
+#if 0
   PointTypePtr points = Polygon->Points;
 
   /* realloc new memory if necessary and clear it */
@@ -441,6 +472,28 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 	      STEP_POLYGONPOINT * sizeof (PointType));
     }
   return (points + Polygon->PointN++);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * gets the next slot for a point in a pour struct, allocates memory
+ * if necessary
+ */
+PointTypePtr
+GetPointMemoryInPour (PourTypePtr Pour)
+{
+  PointTypePtr points = Pour->Points;
+
+  /* realloc new memory if necessary and clear it */
+  if (Pour->PointN >= Pour->PointMax)
+    {
+      Pour->PointMax += STEP_POLYGONPOINT;
+      points = realloc (points, Pour->PointMax * sizeof (PointType));
+      Pour->Points = points;
+      memset (points + Pour->PointN, 0,
+	      STEP_POLYGONPOINT * sizeof (PointType));
+    }
+  return (points + Pour->PointN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -448,20 +501,20 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
  * if necessary
  */
 Cardinal *
-GetHoleIndexMemoryInPolygon (PolygonTypePtr Polygon)
+GetHoleIndexMemoryInPour (PourTypePtr Pour)
 {
-  Cardinal *holeindex = Polygon->HoleIndex;
+  Cardinal *holeindex = Pour->HoleIndex;
 
   /* realloc new memory if necessary and clear it */
-  if (Polygon->HoleIndexN >= Polygon->HoleIndexMax)
+  if (Pour->HoleIndexN >= Pour->HoleIndexMax)
     {
-      Polygon->HoleIndexMax += STEP_POLYGONHOLEINDEX;
-      holeindex = realloc (holeindex, Polygon->HoleIndexMax * sizeof (int));
-      Polygon->HoleIndex = holeindex;
-      memset (holeindex + Polygon->HoleIndexN, 0,
+      Pour->HoleIndexMax += STEP_POLYGONHOLEINDEX;
+      holeindex = realloc (holeindex, Pour->HoleIndexMax * sizeof (int));
+      Pour->HoleIndex = holeindex;
+      memset (holeindex + Pour->HoleIndexN, 0,
 	      STEP_POLYGONHOLEINDEX * sizeof (int));
     }
-  return (holeindex + Polygon->HoleIndexN++);
+  return (holeindex + Pour->HoleIndexN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -627,8 +680,8 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
-      free (Polygon->Points);
-      free (Polygon->HoleIndex);
+//      free (Polygon->Points);
+//      free (Polygon->HoleIndex);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
       poly_FreeContours (&Polygon->NoHoles);
@@ -637,6 +690,27 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * frees memory used by a pour
+ */
+void
+FreePourMemory (PourTypePtr Pour)
+{
+  if (Pour)
+    {
+      free (Pour->Points);
+      free (Pour->HoleIndex);
+#define FIXME Later
+#if 0
+      if (Pour->Clipped)
+	poly_Free (&Pour->Clipped);
+      if (Pour->NoHoles)
+	poly_Free (&Pour->NoHoles);
+#endif
+      memset (Pour, 0, sizeof (PourType));
+    }
+}
+
+/* ---------------------------------------------------------------------------
  * frees memory used by a box list
  */
 void
@@ -823,20 +897,31 @@ FreeDataMemory (DataTypePtr Data)
 	  free (layer->Line);
 	  free (layer->Arc);
 	  free (layer->Text);
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (layer);
 	  {
 	    FreePolygonMemory (polygon);
 	  }
 	  END_LOOP;
-	  free (layer->Polygon);
+#endif
+//	  free (layer->Polygon);
+	  POUR_LOOP (layer);
+	  {
+	    FreePourMemory (pour);
+	  }
+	  END_LOOP;
+	  free (layer->Pour);
 	  if (layer->line_tree)
 	    r_destroy_tree (&layer->line_tree);
 	  if (layer->arc_tree)
 	    r_destroy_tree (&layer->arc_tree);
 	  if (layer->text_tree)
 	    r_destroy_tree (&layer->text_tree);
-	  if (layer->polygon_tree)
-	    r_destroy_tree (&layer->polygon_tree);
+//	  if (layer->polygon_tree)
+//	    r_destroy_tree (&layer->polygon_tree);
+	  if (layer->pour_tree)
+	    r_destroy_tree (&layer->pour_tree);
 	}
 
       if (Data->element_tree)
diff --git a/src/mymem.h b/src/mymem.h
index 4e36640..bebff7c 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -56,7 +56,8 @@
 #define	STEP_SELECTORENTRY	128
 #define	STEP_REMOVELIST		500
 #define	STEP_UNDOLIST		500
-#define	STEP_POLYGON		10
+#define	STEP_POUR		10
+#define	STEP_POLYGON		100
 #define	STEP_POLYGONPOINT	10
 #define	STEP_POLYGONHOLEINDEX	10
 #define	STEP_LIBRARYMENU	10
@@ -83,9 +84,11 @@ LineTypePtr GetLineMemory (LayerTypePtr);
 ArcTypePtr GetArcMemory (LayerTypePtr);
 RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
-PolygonTypePtr GetPolygonMemory (LayerTypePtr);
+PolygonTypePtr GetPolygonMemoryInPour (PourTypePtr);
+PourTypePtr GetPourMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
-Cardinal *GetHoleIndexMemoryInPolygon (PolygonTypePtr);
+PointTypePtr GetPointMemoryInPour (PourTypePtr);
+Cardinal *GetHoleIndexMemoryInPour (PourTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
@@ -98,6 +101,7 @@ PinTypeHandle GetDrillPinMemory (DrillTypePtr);
 DrillTypePtr GetDrillInfoDrillMemory (DrillInfoTypePtr);
 void **GetPointerMemory (PointerListTypePtr);
 void FreePolygonMemory (PolygonTypePtr);
+void FreePourMemory (PourTypePtr);
 void FreeElementMemory (ElementTypePtr);
 void FreePCBMemory (PCBTypePtr);
 void FreeBoxListMemory (BoxListTypePtr);
diff --git a/src/parse_y.y b/src/parse_y.y
index 7aa7b80..a80998b 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -52,6 +52,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "strflags.h"
@@ -64,7 +65,7 @@
 RCSID("$Id$");
 
 static	LayerTypePtr	Layer;
-static	PolygonTypePtr	Polygon;
+static	PourTypePtr	Pour;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
@@ -187,8 +188,8 @@ parsepcb
 			 */
 			PCB = yyPCB;
 			for (i = 0; i < yyData->LayerN+2; i++)
-			  for (j = 0; j < yyData->Layer[i].PolygonN; j++)
-			      InitClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Polygon[j]);
+			  for (j = 0; j < yyData->Layer[i].PourN; j++)
+			      InitPourClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Pour[j]);
 			PCB = pcb_save;
 			}
 			   
@@ -885,7 +886,7 @@ layerdefinition
 			/* x1, y1, x2, y2, flags */
 		| T_RECTANGLE '(' NUMBER NUMBER NUMBER NUMBER NUMBER ')'
 			{
-				CreateNewPolygonFromRectangle(Layer,
+				CreateNewPourFromRectangle(Layer,
 					$3*100, $4*100, ($3+$5)*100, ($4+$6)*100, OldFlags($7));
 			}
 		| text_hi_format
@@ -1120,7 +1121,7 @@ polygon_format
 		: /* flags are passed in */
 		T_POLYGON '(' flags ')' '('
 			{
-				Polygon = CreateNewPolygon(Layer, $3);
+				Pour = CreateNewPour(Layer, $3);
 			}
 		  polygonpoints
 		  polygonholes ')'
@@ -1128,13 +1129,13 @@ polygon_format
 				Cardinal contour, contour_start, contour_end;
 				bool bad_contour_found = false;
 				/* ignore junk */
-				for (contour = 0; contour <= Polygon->HoleIndexN; contour++)
+				for (contour = 0; contour <= Pour->HoleIndexN; contour++)
 				  {
 				    contour_start = (contour == 0) ?
-						      0 : Polygon->HoleIndex[contour - 1];
-				    contour_end = (contour == Polygon->HoleIndexN) ?
-						 Polygon->PointN :
-						 Polygon->HoleIndex[contour];
+						      0 : Pour->HoleIndex[contour - 1];
+				    contour_end = (contour == Pour->HoleIndexN) ?
+						 Pour->PointN :
+						 Pour->HoleIndex[contour];
 				    if (contour_end - contour_start < 3)
 				      bad_contour_found = true;
 				  }
@@ -1143,16 +1144,16 @@ polygon_format
 				  {
 				    Message("WARNING parsing file '%s'\n"
 					    "    line:        %i\n"
-					    "    description: 'ignored polygon (< 3 points in a contour)'\n",
+					    "    description: 'ignored pour (< 3 points in a contour)'\n",
 					    yyfilename, yylineno);
-				    DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
+				    DestroyObject(yyData, POLYGON_TYPE, Layer, Pour, Pour);
 				  }
 				else
 				  {
-				    SetPolygonBoundingBox (Polygon);
-				    if (!Layer->polygon_tree)
-				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
+				    SetPourBoundingBox (Pour);
+				    if (!Layer->pour_tree)
+				      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+				    r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 				  }
 			}
 		;
@@ -1166,7 +1167,7 @@ polygonholes
 polygonhole
 		: T_POLYGON_HOLE '('
 			{
-				CreateNewHoleInPolygon (Polygon);
+				CreateNewHoleInPour (Pour);
 			}
 		  polygonpoints ')'
 		;
@@ -1180,11 +1181,11 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' NUMBER NUMBER ')'
 			{
-				CreateNewPointInPolygon(Polygon, $2*100, $3*100);
+				CreateNewPointInPour(Pour, $2*100, $3*100);
 			}
 		| '[' NUMBER NUMBER ']'
 			{
-				CreateNewPointInPolygon(Polygon, $2, $3);
+				CreateNewPointInPour(Pour, $2, $3);
 			}
 		|
 		;
diff --git a/src/pcb-menu.res b/src/pcb-menu.res
index dcba346..3c09378 100644
--- a/src/pcb-menu.res
+++ b/src/pcb-menu.res
@@ -173,8 +173,8 @@ MainMenu =
    {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
    {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
    {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-   {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
-   {"Polygon Hole" checked=polygonholemode,1 Mode(PolygonHole)}
+   {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
+   {"Polygon Hole" checked=pourholemode,1 Mode(PourHole)}
    {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
    {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
    {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/polygon.c b/src/polygon.c
index e427f1a..e07ca16 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -30,6 +30,8 @@
 Here's a brief tour of the data and life of a polygon, courtesy of Ben
 Jackson:
 
+*** FIXME: SOME OF THIS WILL BE OUT DATED BY THE ADDITION OF POURS ****
+
 A PCB PolygonType contains an array of points outlining the polygon.
 This is what is manipulated by the UI and stored in the saved PCB.
 
@@ -105,10 +107,6 @@ dicer output is used for HIDs which cannot render things with holes
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 10
-#define SUBTRACT_PIN_VIA_BATCH_SIZE 100
-#define SUBTRACT_LINE_BATCH_SIZE 20
-
 /* ---------------------------------------------------------------------------
  * local prototypes
  */
@@ -124,73 +122,6 @@ static double circleVerticies[] = {
  * 1 - cos(\alpha/2) < (\alpha/2)^2/2 */
 static double radius_adjustment = (M_PI/CIRC_SEGS)*(M_PI/CIRC_SEGS)/2;
 
-Cardinal
-polygon_point_idx (PolygonTypePtr polygon, PointTypePtr point)
-{
-  assert (point >= polygon->Points);
-  assert (point <= polygon->Points + polygon->PointN);
-  return ((char *)point - (char *)polygon->Points) / sizeof (PointType);
-}
-
-/* Find contour number: 0 for outer, 1 for first hole etc.. */
-Cardinal
-polygon_point_contour (PolygonTypePtr polygon, Cardinal point)
-{
-  Cardinal i;
-  Cardinal contour = 0;
-
-  for (i = 0; i < polygon->HoleIndexN; i++)
-    if (point >= polygon->HoleIndex[i])
-      contour = i + 1;
-  return contour;
-}
-
-Cardinal
-next_contour_point (PolygonTypePtr polygon, Cardinal point)
-{
-  Cardinal contour;
-  Cardinal this_contour_start;
-  Cardinal next_contour_start;
-
-  contour = polygon_point_contour (polygon, point);
-
-  this_contour_start = (contour == 0) ? 0 :
-                                        polygon->HoleIndex[contour - 1];
-  next_contour_start =
-    (contour == polygon->HoleIndexN) ? polygon->PointN :
-                                       polygon->HoleIndex[contour];
-
-  /* Wrap back to the start of the contour we're in if we pass the end */
-  if (++point == next_contour_start)
-    point = this_contour_start;
-
-  return point;
-}
-
-Cardinal
-prev_contour_point (PolygonTypePtr polygon, Cardinal point)
-{
-  Cardinal contour;
-  Cardinal prev_contour_end;
-  Cardinal this_contour_end;
-
-  contour = polygon_point_contour (polygon, point);
-
-  prev_contour_end = (contour == 0) ? 0 :
-                                      polygon->HoleIndex[contour - 1];
-  this_contour_end =
-    (contour == polygon->HoleIndexN) ? polygon->PointN - 1:
-                                       polygon->HoleIndex[contour] - 1;
-
-  /* Wrap back to the start of the contour we're in if we pass the end */
-  if (point == prev_contour_end)
-    point = this_contour_end;
-  else
-    point--;
-
-  return point;
-}
-
 static void
 add_noholes_polyarea (PLINE *pline, void *user_data)
 {
@@ -212,6 +143,7 @@ ComputeNoHoles (PolygonType *poly)
   poly->NoHolesValid = 1;
 }
 
+#if 0
 static POLYAREA *
 biggest (POLYAREA * p)
 {
@@ -261,12 +193,14 @@ biggest (POLYAREA * p)
   assert (p->b);
   return p;
 }
+#endif
 
 POLYAREA *
 ContourToPoly (PLINE * contour)
 {
   POLYAREA *p;
   poly_PreContour (contour, TRUE);
+  poly_ChkContour (contour);
   assert (contour->Flags.orient == PLF_DIR);
   if (!(p = poly_Create ()))
     return NULL;
@@ -275,9 +209,12 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+#warning FIXME Later
+#if 0
 static POLYAREA *
-original_poly (PolygonType * p)
+original_poly (PourType * p)
 {
+  return NULL;
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Cardinal n;
@@ -287,7 +224,7 @@ original_poly (PolygonType * p)
   if ((np = poly_Create ()) == NULL)
     return NULL;
 
-  /* first make initial polygon contour */
+  /* first make initial pour contour */
   for (n = 0; n < p->PointN; n++)
     {
       /* No current contour? Make a new one starting at point */
@@ -335,12 +272,7 @@ original_poly (PolygonType * p)
   }
   return biggest (np);
 }
-
-POLYAREA *
-PolygonToPoly (PolygonType *p)
-{
-  return original_poly (p);
-}
+#endif
 
 POLYAREA *
 RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2)
@@ -723,6 +655,8 @@ SquarePadPoly (PadType * pad, BDimension clear)
   return np;
 }
 
+#warning FIXME Later
+#if 0
 /* clear np1 from the polygon */
 static int
 Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
@@ -756,7 +690,9 @@ Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
       p->NoHoles = NULL;
       return -1;
     }
-  p->Clipped = biggest (merged);
+#warning FIXME Later
+//  p->Clipped = biggest (merged);
+  p->Clipped = merged;
   assert (!p->Clipped || poly_Valid (p->Clipped));
   if (!p->Clipped)
     Message ("Polygon cleared out of existence near (%d, %d)\n",
@@ -764,6 +700,7 @@ Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
              (p->BoundingBox.Y1 + p->BoundingBox.Y2) / 2);
   return 1;
 }
+#endif
 
 /* create a polygon of the pin clearance */
 POLYAREA *
@@ -795,435 +732,14 @@ BoxPolyBloated (BoxType *box, BDimension bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
-/* remove the pin clearance from the polygon */
-static int
-SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-  Cardinal i;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (d, l);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
-      if (!np)
-        return 0;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        return -1;
-    }
-  return Subtract (np, p, TRUE);
-}
-
-static int
-SubtractLine (LineType * line, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    return -1;
-  return Subtract (np, p, true);
-}
-
-static int
-SubtractArc (ArcType * arc, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  if (!(np = ArcPoly (arc, arc->Thickness + arc->Clearance)))
-    return -1;
-  return Subtract (np, p, true);
-}
-
-static int
-SubtractText (TextType * text, PolygonType * p)
-{
-  POLYAREA *np;
-  const BoxType *b = &text->BoundingBox;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  if (!(np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
-                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat)))
-    return -1;
-  return Subtract (np, p, true);
-}
-
-static int
-SubtractPad (PadType * pad, PolygonType * p)
-{
-  POLYAREA *np = NULL;
-
-  if (pad->Clearance == 0)
-    return 0;
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  return Subtract (np, p, true);
-}
-
-struct cpInfo
-{
-  const BoxType *other;
-  DataType *data;
-  LayerType *layer;
-  PolygonType *polygon;
-  bool solder;
-  POLYAREA *accumulate;
-  int batch_size;
-  jmp_buf env;
-};
-
-static void
-subtract_accumulated (struct cpInfo *info, PolygonTypePtr polygon)
-{
-  if (info->accumulate == NULL)
-    return;
-  Subtract (info->accumulate, polygon, true);
-  info->accumulate = NULL;
-  info->batch_size = 0;
-}
-
-static int
-pin_sub_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr pin = (PinTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-  POLYAREA *np;
-  POLYAREA *merged;
-  Cardinal i;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (info->data, info->layer);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (info->data->pcb), pin, i);
-      if (!np)
-        return 1;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        longjmp (info->env, 1);
-    }
-
-  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
-  info->accumulate = merged;
-
-  info->batch_size ++;
-
-  if (info->batch_size == SUBTRACT_PIN_VIA_BATCH_SIZE)
-    subtract_accumulated (info, polygon);
-
-  return 1;
-}
-
-static int
-arc_sub_callback (const BoxType * b, void *cl)
-{
-  ArcTypePtr arc = (ArcTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractArc (arc, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-pad_sub_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (pad->Clearance == 0)
-    return 0;
-  polygon = info->polygon;
-  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), !info->solder))
-    {
-      if (SubtractPad (pad, polygon) < 0)
-        longjmp (info->env, 1);
-      return 1;
-    }
-  return 0;
-}
-
-static int
-line_sub_callback (const BoxType * b, void *cl)
-{
-  LineTypePtr line = (LineTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-  POLYAREA *np;
-  POLYAREA *merged;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  polygon = info->polygon;
-
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    longjmp (info->env, 1);
-
-  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
-  info->accumulate = merged;
-  info->batch_size ++;
-
-  if (info->batch_size == SUBTRACT_LINE_BATCH_SIZE)
-    subtract_accumulated (info, polygon);
-
-  return 1;
-}
-
-static int
-text_sub_callback (const BoxType * b, void *cl)
-{
-  TextTypePtr text = (TextTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractText (text, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-Group (DataTypePtr Data, Cardinal layer)
-{
-  Cardinal i, j;
-  for (i = 0; i < max_group; i++)
-    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
-      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
-        return i;
-  return i;
-}
-
-static int
-clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
-           const BoxType * here, BDimension expand)
-{
-  int r = 0;
-  BoxType region;
-  struct cpInfo info;
-  Cardinal group;
-
-  if (!TEST_FLAG (CLEARPOLYFLAG, polygon)
-      || GetLayerNumber (Data, Layer) >= max_copper_layer)
-    return 0;
-  group = Group (Data, GetLayerNumber (Data, Layer));
-  info.solder = (group == Group (Data, solder_silk_layer));
-  info.data = Data;
-  info.other = here;
-  info.layer = Layer;
-  info.polygon = polygon;
-  if (here)
-    region = clip_box (here, &polygon->BoundingBox);
-  else
-    region = polygon->BoundingBox;
-  region = bloat_box (&region, expand);
-
-  if (setjmp (info.env) == 0)
-    {
-      r = 0;
-      info.accumulate = NULL;
-      info.batch_size = 0;
-      if (info.solder || group == Group (Data, component_silk_layer))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
-      GROUP_LOOP (Data, group);
-      {
-        r +=
-          r_search (layer->line_tree, &region, NULL, line_sub_callback,
-                    &info);
-        subtract_accumulated (&info, polygon);
-        r +=
-          r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
-	r +=
-          r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
-      }
-      END_LOOP;
-      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
-      subtract_accumulated (&info, polygon);
-    }
-  polygon->NoHolesValid = 0;
-  return r;
-}
-
-static int
-Unsubtract (POLYAREA * np1, PolygonType * p)
-{
-  POLYAREA *merged = NULL, *np = np1;
-  POLYAREA *orig_poly, *clipped_np;
-  int x;
-  assert (np);
-  assert (p && p->Clipped);
-
-  orig_poly = original_poly (p);
-
-  x = poly_Boolean_free (np, orig_poly, &clipped_np, PBO_ISECT);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
-      poly_Free (&clipped_np);
-      goto fail;
-    }
-
-  x = poly_Boolean_free (p->Clipped, clipped_np, &merged, PBO_UNITE);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
-      poly_Free (&merged);
-      goto fail;
-    }
-  p->Clipped = biggest (merged);
-  assert (!p->Clipped || poly_Valid (p->Clipped));
-  return 1;
-
-fail:
-  p->Clipped = NULL;
-  if (p->NoHoles) printf ("Just leaked in Unsubtract\n");
-  p->NoHoles = NULL;
-  return 0;
-}
-
-static int
-UnsubtractPin (PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pin, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractArc (ArcType * arc, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) arc, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractLine (LineType * line, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) line, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractText (TextType * text, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return -1;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) text, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPad (PadType * pad, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pad, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static bool inhibit = false;
-
 int
 InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
 {
+  /* NOP */
+  printf ("Someone called InitClip, bad someone.\n");
+  return 0;
+#warning FIXME Later
+#if 0
   if (inhibit)
     return 0;
   if (p->Clipped)
@@ -1238,201 +754,7 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   else
     p->NoHolesValid = 0;
   return 1;
-}
-
-/* --------------------------------------------------------------------------
- * remove redundant polygon points. Any point that lies on the straight
- * line between the points on either side of it is redundant.
- * returns true if any points are removed
- */
-bool
-RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
-{
-  PointTypePtr p;
-  Cardinal n, prev, next;
-  LineType line;
-  bool changed = false;
-
-  if (Undoing ())
-    return (false);
-
-  for (n = 0; n < Polygon->PointN; n++)
-    {
-      prev = prev_contour_point (Polygon, n);
-      next = next_contour_point (Polygon, n);
-      p = &Polygon->Points[n];
-
-      line.Point1 = Polygon->Points[prev];
-      line.Point2 = Polygon->Points[next];
-      line.Thickness = 0;
-      if (IsPointOnLine ((float) p->X, (float) p->Y, 0.0, &line))
-        {
-          RemoveObject (POLYGONPOINT_TYPE, Layer, Polygon, p);
-          changed = true;
-        }
-    }
-  return (changed);
-}
-
-/* ---------------------------------------------------------------------------
- * returns the index of the polygon point which is the end
- * point of the segment with the lowest distance to the passed
- * coordinates
- */
-Cardinal
-GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
-                               LocationType Y)
-{
-  double mindistance = (double) MAX_COORD * MAX_COORD;
-  PointTypePtr ptr1, ptr2;
-  Cardinal n, result = 0;
-
-  /* we calculate the distance to each segment and choose the
-   * shortest distance. If the closest approach between the
-   * given point and the projected line (i.e. the segment extended)
-   * is not on the segment, then the distance is the distance
-   * to the segment end point.
-   */
-
-  for (n = 0; n < Polygon->PointN; n++)
-    {
-      register double u, dx, dy;
-      ptr1 = &Polygon->Points[prev_contour_point (Polygon, n)];
-      ptr2 = &Polygon->Points[n];
-
-      dx = ptr2->X - ptr1->X;
-      dy = ptr2->Y - ptr1->Y;
-      if (dx != 0.0 || dy != 0.0)
-        {
-          /* projected intersection is at P1 + u(P2 - P1) */
-          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
-
-          if (u < 0.0)
-            {                   /* ptr1 is closest point */
-              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
-            }
-          else if (u > 1.0)
-            {                   /* ptr2 is closest point */
-              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
-            }
-          else
-            {                   /* projected intersection is closest point */
-              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
-                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
-            }
-          if (u < mindistance)
-            {
-              mindistance = u;
-              result = n;
-            }
-        }
-    }
-  return (result);
-}
-
-/* ---------------------------------------------------------------------------
- * go back to the  previous point of the polygon
- */
-void
-GoToPreviousPoint (void)
-{
-  switch (Crosshair.AttachedPolygon.PointN)
-    {
-      /* do nothing if mode has just been entered */
-    case 0:
-      break;
-
-      /* reset number of points and 'LINE_MODE' state */
-    case 1:
-      Crosshair.AttachedPolygon.PointN = 0;
-      Crosshair.AttachedLine.State = STATE_FIRST;
-      addedLines = 0;
-      break;
-
-      /* back-up one point */
-    default:
-      {
-        PointTypePtr points = Crosshair.AttachedPolygon.Points;
-        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
-
-        Crosshair.AttachedPolygon.PointN--;
-        Crosshair.AttachedLine.Point1.X = points[n].X;
-        Crosshair.AttachedLine.Point1.Y = points[n].Y;
-        break;
-      }
-    }
-}
-
-/* ---------------------------------------------------------------------------
- * close polygon if possible
- */
-void
-ClosePolygon (void)
-{
-  Cardinal n = Crosshair.AttachedPolygon.PointN;
-
-  /* check number of points */
-  if (n >= 3)
-    {
-      /* if 45 degree lines are what we want do a quick check
-       * if closing the polygon makes sense
-       */
-      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
-        {
-          BDimension dx, dy;
-
-          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
-                    Crosshair.AttachedPolygon.Points[0].X);
-          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
-                    Crosshair.AttachedPolygon.Points[0].Y);
-          if (!(dx == 0 || dy == 0 || dx == dy))
-            {
-              Message
-                (_
-                 ("Cannot close polygon because 45 degree lines are requested.\n"));
-              return;
-            }
-        }
-      CopyAttachedPolygonToLayer ();
-      Draw ();
-    }
-  else
-    Message (_("A polygon has to have at least 3 points\n"));
-}
-
-/* ---------------------------------------------------------------------------
- * moves the data of the attached (new) polygon to the current layer
- */
-void
-CopyAttachedPolygonToLayer (void)
-{
-  PolygonTypePtr polygon;
-  int saveID;
-
-  /* move data to layer and clear attached struct */
-  polygon = CreateNewPolygon (CURRENT, NoFlags ());
-  saveID = polygon->ID;
-  *polygon = Crosshair.AttachedPolygon;
-  polygon->ID = saveID;
-  SET_FLAG (CLEARPOLYFLAG, polygon);
-  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
-    SET_FLAG (FULLPOLYFLAG, polygon);
-  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
-  SetPolygonBoundingBox (polygon);
-  if (!CURRENT->polygon_tree)
-    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
-  InitClip (PCB->Data, CURRENT, polygon);
-  DrawPolygon (CURRENT, polygon, 0);
-  SetChangedFlag (true);
-
-  /* reset state of attached line */
-  Crosshair.AttachedLine.State = STATE_FIRST;
-  addedLines = 0;
-
-  /* add to undo list */
-  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
-  IncrementUndoSerialNumber ();
+#endif
 }
 
 /* find polygon holes in range, then call the callback function for
@@ -1476,61 +798,14 @@ struct plow_info
 };
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-               int type, void *ptr1, void *ptr2)
+plow_callback_2 (const BoxType * b, void *cl)
 {
-  if (!Polygon->Clipped)
-    return 0;
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case LINE_TYPE:
-      SubtractLine ((LineTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case ARC_TYPE:
-      SubtractArc ((ArcTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case PAD_TYPE:
-      SubtractPad ((PadTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case TEXT_TYPE:
-      SubtractText ((TextTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    }
-  return 0;
-}
+  struct plow_info *plow = (struct plow_info *) cl;
+  PolygonTypePtr polygon = (PolygonTypePtr) b;
 
-static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-          int type, void *ptr1, void *ptr2)
-{
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      UnsubtractPin ((PinTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case LINE_TYPE:
-      UnsubtractLine ((LineTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case ARC_TYPE:
-      UnsubtractArc ((ArcTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case PAD_TYPE:
-      UnsubtractPad ((PadTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case TEXT_TYPE:
-      UnsubtractText ((TextTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    }
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return plow->callback (plow->data, plow->layer, polygon, plow->type,
+                           plow->ptr1, plow->ptr2);
   return 0;
 }
 
@@ -1538,12 +813,10 @@ static int
 plow_callback (const BoxType * b, void *cl)
 {
   struct plow_info *plow = (struct plow_info *) cl;
-  PolygonTypePtr polygon = (PolygonTypePtr) b;
+  PourTypePtr pour = (PourTypePtr) b;
+  BoxType *sb = &((PinTypePtr) plow->ptr2)->BoundingBox;
 
-  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
-    return plow->callback (plow->data, plow->layer, polygon, plow->type,
-                           plow->ptr1, plow->ptr2);
-  return 0;
+  return r_search (pour->polygon_tree, sb, NULL, plow_callback_2, plow);
 }
 
 int
@@ -1570,8 +843,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
           LAYER_LOOP (Data, max_copper_layer);
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1581,8 +853,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                          ((LayerTypePtr) ptr1))));
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1600,7 +871,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                      ((LayerTypePtr) ptr1))));
       {
         info.layer = layer;
-        r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
       }
       END_LOOP;
       break;
@@ -1613,7 +884,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
         {
           info.layer = layer;
           r +=
-            r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
         }
         END_LOOP;
       }
@@ -1637,23 +908,6 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
   return r;
 }
 
-void
-RestoreToPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
-{
-  if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  else
-    PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
-}
-
-void
-ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
-{
-  if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  else
-    PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
-}
 
 bool
 isects (POLYAREA * a, PolygonTypePtr p, bool fr)
@@ -1803,6 +1057,9 @@ NoHolesPolygonDicer (PolygonTypePtr p, const BoxType * clip,
 bool
 MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
 {
+  return 0;
+#warning FIXME Later
+#if 0
   POLYAREA *p, *start;
   bool many = false;
   FlagType flags;
@@ -1866,6 +1123,7 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
   inhibit = false;
   IncrementUndoSerialNumber ();
   return many;
+#endif
 }
 
 void debug_pline (PLINE *pl)
@@ -1896,19 +1154,19 @@ debug_polyarea (POLYAREA *p)
 void
 debug_polygon (PolygonType *p)
 {
-  Cardinal i;
+//  Cardinal i;
   POLYAREA *pa;
-  fprintf (stderr, "POLYGON %p  %d pts\n", p, p->PointN);
-  for (i=0; i<p->PointN; i++)
-    fprintf(stderr, "\t%d: %d, %d\n", i, p->Points[i].X, p->Points[i].Y);
-  if (p->HoleIndexN)
-    {
-      fprintf (stderr, "%d holes, starting at indices\n", p->HoleIndexN);
-      for (i=0; i<p->HoleIndexN; i++)
-        fprintf(stderr, "\t%d: %d\n", i, p->HoleIndex[i]);
-    }
-  else
-    fprintf (stderr, "it has no holes\n");
+//  fprintf (stderr, "POLYGON %p  %d pts\n", p, p->PointN);
+//  for (i=0; i<p->PointN; i++)
+//    fprintf(stderr, "\t%d: %d, %d\n", i, p->Points[i].X, p->Points[i].Y);
+//  if (p->HoleIndexN)
+//    {
+//      fprintf (stderr, "%d holes, starting at indices\n", p->HoleIndexN);
+//      for (i=0; i<p->HoleIndexN; i++)
+//        fprintf(stderr, "\t%d: %d\n", i, p->HoleIndex[i]);
+//    }
+//  else
+//    fprintf (stderr, "it has no holes\n");
   pa = p->Clipped;
   while (pa)
     {
@@ -1919,62 +1177,6 @@ debug_polygon (PolygonType *p)
     }
 }
 
-/* Convert a POLYAREA (and all linked POLYAREA) to
- * raw PCB polygons on the given layer.
- */
-void
-PolyToPolygonsOnLayer (DataType *Destination, LayerType *Layer,
-                       POLYAREA *Input, FlagType Flags)
-{
-  PolygonType *Polygon;
-  POLYAREA *pa;
-  PLINE *pline;
-  VNODE *node;
-  bool outer;
-
-  if (Input == NULL)
-    return;
-
-  pa = Input;
-  do
-    {
-      Polygon = CreateNewPolygon (Layer, Flags);
-
-      pline = pa->contours;
-      outer = true;
-
-      do
-        {
-          if (!outer)
-            CreateNewHoleInPolygon (Polygon);
-          outer = false;
-
-          node = &pline->head;
-          do
-            {
-              CreateNewPointInPolygon (Polygon, node->point[0],
-                                                node->point[1]);
-            }
-          while ((node = node->next) != &pline->head);
-
-        }
-      while ((pline = pline->next) != NULL);
-
-      InitClip (Destination, Layer, Polygon);
-      SetPolygonBoundingBox (Polygon);
-      if (!Layer->polygon_tree)
-        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-
-      DrawPolygon (Layer, Polygon, 0);
-      /* add to undo list */
-      AddObjectToCreateUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
-    }
-  while ((pa = pa->f) != Input);
-
-  SetChangedFlag (true);
-}
-
 
 struct clip_outline_info {
   POLYAREA *poly;
diff --git a/src/polygon.h b/src/polygon.h
index 5b3baf6..b8a3202 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -33,32 +33,27 @@
 
 #include "global.h"
 
-Cardinal polygon_point_idx (PolygonTypePtr polygon, PointTypePtr point);
-Cardinal polygon_point_contour (PolygonTypePtr polygon, Cardinal point);
-Cardinal prev_contour_point (PolygonTypePtr polygon, Cardinal point);
-Cardinal next_contour_point (PolygonTypePtr polygon, Cardinal point);
-Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
-					LocationType, LocationType);
-bool RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
-void GoToPreviousPoint (void);
-void ClosePolygon (void);
-void CopyAttachedPolygonToLayer (void);
 int PolygonHoles (PolygonType *ptr, const BoxType *range,
 		  int (*callback) (PLINE *, void *user_data),
                   void *user_data);
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
 void ComputeNoHoles (PolygonType *poly);
+
 POLYAREA * ContourToPoly (PLINE *);
 POLYAREA * PolygonToPoly (PolygonType *);
 POLYAREA * RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2);
-POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
 POLYAREA * OctagonPoly(LocationType x, LocationType y, BDimension radius);
-POLYAREA * LinePoly(LineType *l, BDimension thick);
+void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
+POLYAREA * RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2, BDimension t);
 POLYAREA * ArcPoly(ArcType *l, BDimension thick);
+POLYAREA * LinePoly(LineType *l, BDimension thick);
+POLYAREA * SquarePadPoly (PadType * pad, BDimension clear);
+
 POLYAREA * PinPoly(PinType *l, BDimension thick, BDimension clear);
 POLYAREA * BoxPolyBloated (BoxType *box, BDimension radius);
-void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
@@ -71,6 +66,5 @@ bool isects (POLYAREA *, PolygonTypePtr, bool);
 bool MorphPolygon (LayerTypePtr, PolygonTypePtr);
 void NoHolesPolygonDicer (PolygonType *p, const BoxType *clip,
                           void (*emit) (PLINE *, void *), void *user_data);
-void PolyToPolygonsOnLayer (DataType *, LayerType *, POLYAREA *, FlagType);
 POLYAREA *board_outline_poly ();
 #endif
diff --git a/src/polygon1.c b/src/polygon1.c
index 468c139..c80e761 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -908,6 +908,45 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 }
 
 static void
+M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
+{
+  POLYAREA *a = afst, *b = bfst;
+  PLINE *curcA, *curcB;
+  CVCList *the_list = NULL;
+
+  if (a == NULL || b == NULL)
+    error (err_bad_parm);
+  do
+    {
+      do
+	{
+	  if (a->contours->xmax >= b->contours->xmin &&
+	      a->contours->ymax >= b->contours->ymin &&
+	      a->contours->xmin <= b->contours->xmax &&
+	      a->contours->ymin <= b->contours->ymax)
+	    {
+	      if (intersect (e, a, b, add))
+		error (err_no_memory);
+	    }
+	}
+      while ((a = a->f) != afst);
+      for (curcB = b->contours; curcB != NULL; curcB = curcB->next)
+	if (curcB->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcB, 'B', the_list)))
+	    error (err_no_memory);
+    }
+  while ((b = b->f) != bfst);
+  do
+    {
+      for (curcA = a->contours; curcA != NULL; curcA = curcA->next)
+	if (curcA->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcA, 'A', the_list)))
+	    error (err_no_memory);
+    }
+  while ((a = a->f) != afst);
+}				/* M_POLYAREA_intersect */
+
+static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
 {
   POLYAREA *a = afst, *b = bfst;
@@ -1158,7 +1197,7 @@ M_POLYAREA_label (POLYAREA * afst, POLYAREA * b, BOOLp touch)
 	      return TRUE;
 	  }
     }
-  while (!touch && (a = a->f) != afst);
+  while ((a = a->f) != afst);
   return FALSE;
 }
 
@@ -2272,7 +2311,8 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-      M_POLYAREA_intersect (&e, a, b, false);
+//      M_POLYAREA_intersect (&e, a, b, false);
+      M_POLYAREA_intersect2 (&e, a, b, false);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
@@ -3168,15 +3208,19 @@ inside_sector (VNODE * pn, Vector p2)
 BOOLp
 poly_ChkContour (PLINE * a)
 {
-  VNODE *a1, *a2, *hit1, *hit2;
+  VNODE *a1, *a2, *a2_start, *hit1, *hit2;
   Vector i1, i2;
   int icnt;
+  double d1, d2;
+
+#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
+  return FALSE;
 
   assert (a != NULL);
   a1 = &a->head;
   do
     {
-      a2 = a1;
+      a2_start = a2 = a1;
       do
 	{
 	  if (!node_neighbours (a1, a2) &&
@@ -3186,9 +3230,11 @@ poly_ChkContour (PLINE * a)
 	      if (icnt > 1)
 		return TRUE;
 
-	      if (vect_dist2 (i1, a1->point) < EPSILON)
+	      d1 = -1;
+	      d2 = -1;
+	      if ((d1 = vect_dist2 (i1, a1->point)) < EPSILON)
 		hit1 = a1;
-	      else if (vect_dist2 (i1, a1->next->point) < EPSILON)
+	      else if ((d2 = vect_dist2 (i1, a1->next->point)) < EPSILON)
 		hit1 = a1->next;
 	      else
 		hit1 = NULL;
@@ -3232,7 +3278,7 @@ poly_ChkContour (PLINE * a)
 		}
 	    }
 	}
-      while ((a2 = a2->next) != &a->head);
+      while ((a2 = a2->next) != a2_start);
     }
   while ((a1 = a1->next) != &a->head);
   return FALSE;
diff --git a/src/pour.c b/src/pour.c
new file mode 100644
index 0000000..51df8ac
--- /dev/null
+++ b/src/pour.c
@@ -0,0 +1,1437 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+
+/* special pour editing routines
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <memory.h>
+#include <setjmp.h>
+
+#include "global.h"
+#include "box.h"
+#include "create.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "find.h"
+#include "misc.h"
+#include "move.h"
+#include "polygon.h"
+#include "pour.h"
+#include "remove.h"
+#include "rtree.h"
+#include "search.h"
+#include "set.h"
+#include "thermal.h"
+#include "undo.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+#define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
+
+#define UNSUBTRACT_BLOAT 100
+
+/* ---------------------------------------------------------------------------
+ * local prototypes
+ */
+
+
+Cardinal
+pour_point_idx (PourTypePtr pour, PointTypePtr point)
+{
+  assert (point >= pour->Points);
+  assert (point <= pour->Points + pour->PointN);
+  return ((char *)point - (char *)pour->Points) / sizeof (PointType);
+}
+
+/* Find contour number: 0 for outer, 1 for first hole etc.. */
+Cardinal
+pour_point_contour (PourTypePtr pour, Cardinal point)
+{
+  Cardinal i;
+  Cardinal contour = 0;
+
+  for (i = 0; i < pour->HoleIndexN; i++)
+    if (point >= pour->HoleIndex[i])
+      contour = i + 1;
+  return contour;
+}
+
+Cardinal
+next_contour_point (PourTypePtr pour, Cardinal point)
+{
+  Cardinal contour;
+  Cardinal this_contour_start;
+  Cardinal next_contour_start;
+
+  contour = pour_point_contour (pour, point);
+
+  this_contour_start = (contour == 0) ? 0 :
+                                        pour->HoleIndex[contour - 1];
+  next_contour_start =
+    (contour == pour->HoleIndexN) ? pour->PointN :
+                                       pour->HoleIndex[contour];
+
+  /* Wrap back to the start of the contour we're in if we pass the end */
+  if (++point == next_contour_start)
+    point = this_contour_start;
+
+  return point;
+}
+
+Cardinal
+prev_contour_point (PourTypePtr pour, Cardinal point)
+{
+  Cardinal contour;
+  Cardinal prev_contour_end;
+  Cardinal this_contour_end;
+
+  contour = pour_point_contour (pour, point);
+
+  prev_contour_end = (contour == 0) ? 0 :
+                                      pour->HoleIndex[contour - 1];
+  this_contour_end =
+    (contour == pour->HoleIndexN) ? pour->PointN - 1:
+                                       pour->HoleIndex[contour] - 1;
+
+  /* Wrap back to the start of the contour we're in if we pass the end */
+  if (point == prev_contour_end)
+    point = this_contour_end;
+  else
+    point--;
+
+  return point;
+}
+
+
+/* --------------------------------------------------------------------------
+ * remove redundant polygon points. Any point that lies on the straight
+ * line between the points on either side of it is redundant.
+ * returns true if any points are removed
+ */
+bool
+RemoveExcessPourPoints (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PointTypePtr pt1, pt2, pt3;
+  Cardinal n;
+  LineType line;
+  bool changed = false;
+
+  if (Undoing ())
+    return (false);
+  /* there are always at least three points in a pour */
+  pt1 = &Pour->Points[Pour->PointN - 1];
+  pt2 = &Pour->Points[0];
+  pt3 = &Pour->Points[1];
+  for (n = 0; n < Pour->PointN; n++, pt1++, pt2++, pt3++)
+    {
+      /* wrap around pour */
+      if (n == 1)
+        pt1 = &Pour->Points[0];
+      if (n == Pour->PointN - 1)
+        pt3 = &Pour->Points[0];
+      line.Point1 = *pt1;
+      line.Point2 = *pt3;
+      line.Thickness = 0;
+      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
+        {
+          RemoveObject (POURPOINT_TYPE, (void *) Layer, (void *) Pour,
+                        (void *) pt2);
+          changed = true;
+        }
+    }
+  return (changed);
+}
+
+/* ---------------------------------------------------------------------------
+ * returns the index of the polygon point which is the end
+ * point of the segment with the lowest distance to the passed
+ * coordinates
+ */
+Cardinal
+GetLowestDistancePourPoint (PourTypePtr Pour, LocationType X,
+                            LocationType Y)
+{
+  double mindistance = (double) MAX_COORD * MAX_COORD;
+  PointTypePtr ptr1 = &Pour->Points[Pour->PointN - 1],
+               ptr2 = &Pour->Points[0];
+  Cardinal n, result = 0;
+
+  /* we calculate the distance to each segment and choose the
+   * shortest distance. If the closest approach between the
+   * given point and the projected line (i.e. the segment extended)
+   * is not on the segment, then the distance is the distance
+   * to the segment end point.
+   */
+
+  for (n = 0; n < Pour->PointN; n++, ptr2++)
+    {
+      register double u, dx, dy;
+      dx = ptr2->X - ptr1->X;
+      dy = ptr2->Y - ptr1->Y;
+      if (dx != 0.0 || dy != 0.0)
+        {
+          /* projected intersection is at P1 + u(P2 - P1) */
+          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
+
+          if (u < 0.0)
+            {                   /* ptr1 is closest point */
+              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
+            }
+          else if (u > 1.0)
+            {                   /* ptr2 is closest point */
+              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
+            }
+          else
+            {                   /* projected intersection is closest point */
+              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
+                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
+            }
+          if (u < mindistance)
+            {
+              mindistance = u;
+              result = n;
+            }
+        }
+      ptr1 = ptr2;
+    }
+  return (result);
+}
+
+/* ---------------------------------------------------------------------------
+ * go back to the  previous point of the polygon
+ */
+void
+GoToPreviousPourPoint (void)
+{
+  switch (Crosshair.AttachedPour.PointN)
+    {
+      /* do nothing if mode has just been entered */
+    case 0:
+      break;
+
+      /* reset number of points and 'LINE_MODE' state */
+    case 1:
+      Crosshair.AttachedPour.PointN = 0;
+      Crosshair.AttachedLine.State = STATE_FIRST;
+      addedLines = 0;
+      break;
+
+      /* back-up one point */
+    default:
+      {
+        PointTypePtr points = Crosshair.AttachedPour.Points;
+        Cardinal n = Crosshair.AttachedPour.PointN - 2;
+
+        Crosshair.AttachedPour.PointN--;
+        Crosshair.AttachedLine.Point1.X = points[n].X;
+        Crosshair.AttachedLine.Point1.Y = points[n].Y;
+        break;
+      }
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * close pour if possible
+ */
+void
+ClosePour (void)
+{
+  Cardinal n = Crosshair.AttachedPour.PointN;
+
+  /* check number of points */
+  if (n >= 3)
+    {
+      /* if 45 degree lines are what we want do a quick check
+       * if closing the polygon makes sense
+       */
+      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
+        {
+          BDimension dx, dy;
+
+          dx = abs (Crosshair.AttachedPour.Points[n - 1].X -
+                    Crosshair.AttachedPour.Points[0].X);
+          dy = abs (Crosshair.AttachedPour.Points[n - 1].Y -
+                    Crosshair.AttachedPour.Points[0].Y);
+          if (!(dx == 0 || dy == 0 || dx == dy))
+            {
+              Message
+                (_
+                 ("Cannot close polygon because 45 degree lines are requested.\n"));
+              return;
+            }
+        }
+      CopyAttachedPourToLayer ();
+      Draw ();
+    }
+  else
+    Message (_("A polygon has to have at least 3 points\n"));
+}
+
+/* ---------------------------------------------------------------------------
+ * moves the data of the attached (new) polygon to the current layer
+ */
+void
+CopyAttachedPourToLayer (void)
+{
+  PourTypePtr pour;
+  int saveID;
+
+  /* move data to layer and clear attached struct */
+  pour = CreateNewPour (CURRENT, NoFlags ());
+  saveID = pour->ID;
+  *pour = Crosshair.AttachedPour;
+  pour->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, pour);
+  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
+    SET_FLAG (FULLPOLYFLAG, pour);
+  memset (&Crosshair.AttachedPour, 0, sizeof (PourType));
+  SetPourBoundingBox (pour);
+  if (!CURRENT->pour_tree)
+    CURRENT->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->pour_tree, (BoxType *) pour, 0);
+  InitPourClip (PCB->Data, CURRENT, pour);
+//  DrawPolygon (CURRENT, polygon, 0);
+  DrawPour (CURRENT, pour, 0);
+  SetChangedFlag (true);
+
+  /* reset state of attached line */
+  Crosshair.AttachedLine.State = STATE_FIRST;
+  addedLines = 0;
+
+  /* add to undo list */
+  AddObjectToCreateUndoList (POUR_TYPE, CURRENT, pour, pour);
+  IncrementUndoSerialNumber ();
+}
+
+/*---------------------------------------- END OF NICE GENTLE UI DRIVEN PIECES OF THE POUR CODE --------------*/
+
+/*---------------------------------------- THIS CODE BELOW WILL MURDER SMALL ANIMALS THEN LAUGH --------------*/
+
+/* ---------------------------------------------------------------------------
+ * destroys a polygon from a pour
+ */
+static void *
+DestroyPolygonInPour (PourTypePtr pour, PolygonTypePtr polygon)
+{
+  r_delete_entry (pour->polygon_tree, (BoxTypePtr) polygon);
+
+  FreePolygonMemory (polygon);
+  *polygon = pour->Polygons[ --pour->PolygonN ];
+  r_substitute (pour->polygon_tree,
+                (BoxType *) & pour->Polygons[ pour->PolygonN ],
+                (BoxType *) polygon);
+  memset (&pour->Polygons[ pour->PolygonN ], 0, sizeof (PolygonType));
+  return (NULL);
+}
+
+static int
+subtract_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+  static int
+unite_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged = NULL;
+  int x;
+  assert (np);
+  assert (pg);
+//  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_UNITE);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+static int
+intersect_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_ISECT);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+
+static POLYAREA *
+get_subtract_pin_poly (DataType * d, PinType * pin, LayerType * l, PourType *pour)
+{
+  POLYAREA *np;
+  Cardinal i;
+
+  if (pin->Clearance == 0)
+    return NULL;
+
+  i = GetLayerNumber (d, l);
+  if (TEST_THERM (i, pin))
+    np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
+  else
+    np = PinPoly (pin, pin->Thickness, pin->Clearance);
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_line_poly (LineType *line, PourType *pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  return LinePoly (line, line->Thickness + line->Clearance);
+}
+
+static POLYAREA *
+get_subtract_arc_poly (ArcType * arc, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  return ArcPoly (arc, arc->Thickness + arc->Clearance);
+}
+
+static POLYAREA *
+get_subtract_text_poly (TextType * text, PourType * pour)
+{
+  const BoxType *b = &text->BoundingBox;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  return RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
+                    b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat);
+}
+
+static POLYAREA *
+get_subtract_pad_poly (PadType * pad, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (pad->Clearance == 0)
+    return NULL;
+
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    np = SquarePadPoly (pad, pad->Thickness + pad->Clearance);
+  else
+    np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance);
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_polygon_poly (PolygonType * polygon, PourType * pour)
+{
+  POLYAREA *np;
+
+  /* Don't subtract from ourselves! */
+  if (polygon->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, polygon))
+    return NULL;
+
+  poly_Copy0 (&np, polygon->Clipped);
+
+  return np;
+}
+
+struct cpInfo
+{
+  const BoxType *other;
+  DataType *data;
+  LayerType *layer;
+  PourType *pour;
+  bool solder;
+  POLYAREA *pg;
+  BoxType *region;
+  jmp_buf env;
+};
+
+static int
+pin_sub_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+
+  np = get_subtract_pin_poly (info->data, pin, info->layer, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+arc_sub_callback (const BoxType * b, void *cl)
+{
+  ArcTypePtr arc = (ArcTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return 0;
+
+  np = get_subtract_arc_poly (arc, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pad_sub_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), info->solder))
+    return 0;
+
+  np = get_subtract_pad_poly (pad, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+line_sub_callback (const BoxType * b, void *cl)
+{
+  LineTypePtr line = (LineTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return 0;
+
+  np = get_subtract_line_poly (line, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+
+static int
+text_sub_callback (const BoxType * b, void *cl)
+{
+  TextTypePtr text = (TextTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return 0;
+
+  np = get_subtract_text_poly (text, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+poly_sub_callback (const BoxType * b, void *cl)
+{
+  PolygonTypePtr poly = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, poly))
+    return 0;
+
+  np = get_subtract_polygon_poly (poly, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pour_sub_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  BoxType *region = info->region;
+
+  return r_search (pour->polygon_tree, region, NULL, poly_sub_callback, info);
+
+}
+
+static int
+Group (DataTypePtr Data, Cardinal layer)
+{
+  Cardinal i, j;
+  for (i = 0; i < max_group; i++)
+    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
+      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
+        return i;
+  return i;
+}
+
+/* NB: For convenience, we're passing the defined POLYAREA in here */
+static int
+ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
+           POLYAREA **pg, const BoxType * here, BDimension expand)
+{
+  int r = 0;
+  BoxType region;
+  struct cpInfo info;
+  Cardinal group;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, pour)
+      || GetLayerNumber (Data, Layer) >= max_copper_layer)
+    return 0;
+  group = Group (Data, GetLayerNumber (Data, Layer));
+  info.solder = (group == Group (Data, solder_silk_layer));
+  info.data = Data;
+  info.other = here;
+  info.layer = Layer;
+  info.pour = pour;
+  info.pg = *pg;
+  if (here)
+    region = clip_box (here, &pour->BoundingBox);
+  else
+    region = pour->BoundingBox;
+  region = bloat_box (&region, expand);
+  info.region = &region;
+
+  if (setjmp (info.env) == 0)
+    {
+      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      GROUP_LOOP (Data, group);
+      {
+        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+        r += r_search (layer->arc_tree,  &region, NULL, arc_sub_callback,  &info);
+        r += r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
+        r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
+      }
+      END_LOOP;
+      if (info.solder || group == Group (Data, component_silk_layer))
+        r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+    }
+
+  *pg = info.pg;
+
+  return r;
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
+  int count, count_all, count_added;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
+      break;
+    case ARC_TYPE:
+      np = get_subtract_arc_poly ((ArcTypePtr) ptr2, pour);
+      break;
+    case PAD_TYPE:
+      np = get_subtract_pad_poly ((PadTypePtr) ptr2, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to subtract, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  count = 0;
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, false))
+      {
+        count++;
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+  }
+  END_LOOP;
+//  printf ("Subtract counted %i touching children, now removed\n", count);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the subtract operation */
+
+  /* NB: Old *pg is freed inside subtract_poly */
+  subtract_poly (np, &pg);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death by subtracting\n");
+      return -1;
+    }
+
+#if 0
+  count = 0;
+  { POLYAREA *pg_start;
+  pg_start = pg;
+  do {
+    count++;
+  } while ((pg = pg->f) != pg_start);
+  }
+  printf ("After subtract, counted %i polygon pieces\n", count);
+#endif
+
+  count_all = count_added = 0;
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+  return 0;
+}
+
+static POLYAREA *
+get_unsubtract_pin_poly (PinType * pin, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_arc_poly (ArcType * arc, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_line_poly (LineType * line, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_text_poly (TextType * text, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_pad_poly (PadType * pad, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_polygon_poly (PolygonType * poly, LayerType * l, PourType * pour)
+{
+  /* Don't subtract from ourselves, or if CLEARLINEFLAG isn't set */
+  if (poly->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, poly))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+original_pour_poly (PourType * p)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Cardinal n;
+  Vector v;
+  int hole = 0;
+
+  if ((np = poly_Create ()) == NULL)
+    return NULL;
+
+  /* first make initial pour contour */
+  for (n = 0; n < p->PointN; n++)
+    {
+      /* No current contour? Make a new one starting at point */
+      /*   (or) Add point to existing contour */
+
+      v[0] = p->Points[n].X;
+      v[1] = p->Points[n].Y;
+      if (contour == NULL)
+        {
+          if ((contour = poly_NewContour (v)) == NULL)
+            return NULL;
+        }
+      else
+        {
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        }
+
+      /* Is current point last in contour? If so process it. */
+      if (n == p->PointN - 1 ||
+          (hole < p->HoleIndexN && n == p->HoleIndex[hole] - 1))
+        {
+          if (contour == NULL)
+            {
+              printf ("How did that escape - did the loop iterate zero times??\n");
+              POURPOINT_LOOP (p);
+                {
+                  printf ("Hello\n");
+                }
+              END_LOOP;
+              return NULL;
+            }
+          poly_PreContour (contour, TRUE);
+
+          /* make sure it is a positive contour (outer) or negative (hole) */
+          if (contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+            poly_InvContour (contour);
+          assert (contour->Flags.orient == (hole ? PLF_INV : PLF_DIR));
+
+          poly_InclContour (np, contour);
+          contour = NULL;
+          assert (poly_Valid (np));
+
+          hole++;
+        }
+    }
+  return np;
+}
+
+POLYAREA *
+PourToPoly (PourType *p)
+{
+  return original_pour_poly (p);
+}
+
+static int
+add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+          int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *tmp, *start_pg;
+  POLYAREA *orig_poly;
+  int count, count_all, count_added;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      break;
+    case ARC_TYPE:
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      break;
+    case PAD_TYPE:
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to add, so bailing\n");
+      return 0;
+    }
+
+  orig_poly = original_pour_poly (pour);
+  /* NB: orig_poly and old *pg are freed inside intersect_poly() */
+  intersect_poly (orig_poly, &np);
+
+  if (np == NULL)
+    {
+      printf ("POLYAREA to add got clipped away, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  count = 0;
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, false))
+      {
+        count++;
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+  }
+  END_LOOP;
+//  printf ("Unsubtract counted %i touching children, now removed\n", count);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in add_plow\n");
+//      poly_Free (&np);
+//      return -1;
+    }
+
+//  assert (poly_Valid (pg));
+
+  /* Perform the union operation */
+  /* NB: np and old *pg are freed inside union_poly() */
+  unite_poly (np, &pg);
+
+
+#if 0
+  count = 0;
+  { POLYAREA *pg_start;
+  pg_start = pg;
+  do {
+    count++;
+  } while ((pg = pg->f) != pg_start);
+  }
+  printf ("After unsubtract, counted %i polygon pieces\n", count);
+#endif
+
+  ClearPour (PCB->Data, Layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death somehow\n");
+      return -1;
+    }
+
+  /* For each piece of the clipped up polygon, create a new child */
+  count_all = count_added = 0;
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          printf ("Too small\n");
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+//  printf ("ClearPour counted %i polygon pieces, and added the biggest %i\n", count_all, count_added);
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------------------- */
+
+int
+InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
+{
+  POLYAREA *pg, *tmp, *start_pg;
+  int count_all, count_added;
+
+  /* Free any children we might have */
+  if (pour->PolygonN)
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+      END_LOOP;
+    }
+
+  pg = original_pour_poly (pour);
+  if (!pg)
+    {
+      printf ("Clipping returned NULL - can that be good?\n");
+      return 0;
+    }
+  if (!pg->contours)
+    {
+      printf ("Clipping returned NULL contours - can that be good?\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
+//  assert (poly_Valid (clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    {
+      /* Clip the pour against anything we can find in this layer */
+      ClearPour (Data, layer, pour, &pg, NULL, UNSUBTRACT_BLOAT);
+    }
+
+  if (pg == NULL)
+    {
+      printf ("Got pg == NULL for some reason\n");
+      return 0;
+    }
+
+  if (pg->contours == NULL)
+    {
+      printf ("Got pg->contours == NULL for some reason\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
+
+  count_all = count_added = 0;
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+  return 1;
+}
+
+struct plow_info
+{
+  int type;
+  void *ptr1, *ptr2;
+  LayerTypePtr layer;
+  DataTypePtr data;
+  int (*callback) (DataTypePtr, LayerTypePtr,
+                   PourTypePtr, int, void *, void *);
+};
+
+static int
+plow_callback (const BoxType * b, void *cl)
+{
+  struct plow_info *plow = (struct plow_info *) cl;
+  PourTypePtr pour = (PourTypePtr) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    return plow->callback (plow->data, plow->layer, pour,
+                           plow->type, plow->ptr1, plow->ptr2);
+  return 0;
+}
+
+int
+PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
+           int (*call_back) (DataTypePtr data, LayerTypePtr lay,
+                             PourTypePtr poly, int type,
+                             void *ptr1, void *ptr2))
+{
+  BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
+  int r = 0;
+  struct plow_info info;
+
+  info.type = type;
+  info.ptr1 = ptr1;
+  info.ptr2 = ptr2;
+  info.data = Data;
+  info.callback = call_back;
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      if (type == PIN_TYPE || ptr1 == ptr2 || ptr1 == NULL)
+        {
+          LAYER_LOOP (Data, max_copper_layer);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      else
+        {
+          int layer_no = GetLayerNumber (Data, ((LayerTypePtr) ptr1));
+          int group_no = GetLayerGroupNumberByNumber (layer_no);
+          GROUP_LOOP (Data, group_no);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      break;
+    case LINE_TYPE:
+    case ARC_TYPE:
+    case TEXT_TYPE:
+    case POLYGON_TYPE:
+      /* the cast works equally well for lines and arcs */
+      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+        return 0;
+      /* silk doesn't plow */
+      if (GetLayerNumber (Data, ptr1) >= max_copper_layer)
+        return 0;
+      GROUP_LOOP (Data, GetLayerGroupNumberByNumber (GetLayerNumber (Data,
+                                                                     ((LayerTypePtr) ptr1))));
+      {
+        info.layer = layer;
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+      }
+      END_LOOP;
+      break;
+    case PAD_TYPE:
+      {
+        Cardinal group = GetLayerGroupNumberByNumber (
+                            TEST_FLAG (ONSOLDERFLAG, (PadType *) ptr2) ?
+                              solder_silk_layer : component_silk_layer);
+        GROUP_LOOP (Data, group);
+        {
+          info.layer = layer;
+          r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+        }
+        END_LOOP;
+      }
+      break;
+
+    case ELEMENT_TYPE:
+      {
+        PIN_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+        }
+        END_LOOP;
+        PAD_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+        }
+        END_LOOP;
+      }
+      break;
+    }
+  return r;
+}
+
+void
+RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+#warning FIXME Later: Why do we need to do this?
+//      printf ("Calling InitPourClip from RestoreToPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, add_plow);
+}
+
+void
+ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+#warning FIXME Later: Why do we need to do this?
+//      printf ("Calling InitPourClip from ClearFromPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+}
+
+/* Convert a POLYAREA (and all linked POLYAREA) to
+ * raw PCB pours on the given layer.
+ */
+void
+PolyToPoursOnLayer (DataType *Destination, LayerType *Layer,
+                    POLYAREA *Input, FlagType Flags)
+{
+  PourType *Pour;
+  POLYAREA *pa;
+  PLINE *pline;
+  VNODE *node;
+  bool outer;
+
+  if (Input == NULL)
+    return;
+
+  pa = Input;
+  do
+    {
+      Pour = CreateNewPour (Layer, Flags);
+
+      pline = pa->contours;
+      outer = true;
+
+      do
+        {
+          if (!outer)
+            CreateNewHoleInPour (Pour);
+          outer = false;
+
+          node = &pline->head;
+          do
+            {
+              CreateNewPointInPour (Pour, node->point[0], node->point[1]);
+            }
+          while ((node = node->next) != &pline->head);
+
+        }
+      while ((pline = pline->next) != NULL);
+
+      SetPourBoundingBox (Pour);
+      if (!Layer->pour_tree)
+        Layer->pour_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+
+      InitPourClip (Destination, Layer, Pour);
+      DrawPour (Layer, Pour, 0);
+      /* add to undo list */
+      AddObjectToCreateUndoList (POLYGON_TYPE, Layer, Pour, Pour);
+    }
+  while ((pa = pa->f) != Input);
+
+  SetChangedFlag (true);
+}
diff --git a/src/pour.h b/src/pour.h
new file mode 100644
index 0000000..4711da7
--- /dev/null
+++ b/src/pour.h
@@ -0,0 +1,54 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ *  RCS: $Id$
+ */
+
+/* prototypes for pour editing routines
+ */
+
+#ifndef	__POUR_INCLUDED__
+#define	__POUR_INCLUDED__
+
+#include "global.h"
+
+Cardinal pour_point_idx (PourTypePtr, PointTypePtr);
+Cardinal pour_point_contour (PourTypePtr, Cardinal);
+Cardinal prev_contour_point (PourTypePtr, Cardinal);
+Cardinal next_contour_point (PourTypePtr, Cardinal);
+Cardinal GetLowestDistancePourPoint (PourTypePtr,
+					LocationType, LocationType);
+bool RemoveExcessPourPoints (LayerTypePtr, PourTypePtr);
+void GoToPreviousPourPoint (void);
+void ClosePour (void);
+void CopyAttachedPourToLayer (void);
+
+int InitPourClip(DataType *d, LayerType *l, PourType *p);
+void RestoreToPours(DataType *, int, void *, void *);
+void ClearFromPours(DataType *, int, void *, void *);
+
+POLYAREA * PourToPoly (PourType *);
+void PolyToPoursOnLayer (DataType *, LayerType *, POLYAREA *, FlagType);
+
+#endif /* __POUR_INCLUDED__ */
diff --git a/src/puller.c b/src/puller.c
index 66a5a03..d74a0ca 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -1704,6 +1704,8 @@ gp_text_cb (const BoxType *b, void *cb)
   return 0;
 }
 
+#warning FIXME Later: Really want to geometry of the clipped polygons
+#if 0
 static int
 gp_poly_cb (const BoxType *b, void *cb)
 {
@@ -1713,6 +1715,18 @@ gp_poly_cb (const BoxType *b, void *cb)
     gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
   return 0;
 }
+#endif
+
+#warning FIXME Later: Really want to geometry of the clipped polygons
+static int
+gp_pour_cb (const BoxType *b, void *cb)
+{
+  int i;
+  const PourTypePtr p = (PourTypePtr) b;
+  for (i=0; i<p->PointN; i++)
+    gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
+  return 0;
+}
 
 static int
 gp_pin_cb (const BoxType *b, void *cb)
@@ -2238,7 +2252,7 @@ maybe_pull_1 (LineTypePtr line)
   r_search(CURRENT->line_tree, &box, NULL, gp_line_cb, 0);
   r_search(CURRENT->arc_tree, &box, NULL, gp_arc_cb, 0);
   r_search(CURRENT->text_tree, &box, NULL, gp_text_cb, 0);
-  r_search(CURRENT->polygon_tree, &box, NULL, gp_poly_cb, 0);
+  r_search(CURRENT->pour_tree, &box, NULL, gp_pour_cb, 0);
   r_search(PCB->Data->pin_tree, &box, NULL, gp_pin_cb, 0);
   r_search(PCB->Data->via_tree, &box, NULL, gp_pin_cb, 0);
   r_search(PCB->Data->pad_tree, &box, NULL, gp_pad_cb, 0);
diff --git a/src/rats.c b/src/rats.c
index 5fe86cd..cc3d1ec 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -512,20 +512,24 @@ GatherSubnets (NetListTypePtr Netl, bool NoWarn, bool AndRats)
       }
       ENDALL_LOOP;
       /* add polygons so the auto-router can see them as targets */
-      ALLPOLYGON_LOOP (PCB->Data);
+      ALLPOUR_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  {
-	    conn = GetConnectionMemory (a);
-	    /* make point on a vertex */
-	    conn->X = polygon->Clipped->contours->head.point[0];
-	    conn->Y = polygon->Clipped->contours->head.point[1];
-	    conn->type = POLYGON_TYPE;
-	    conn->ptr1 = layer;
-	    conn->ptr2 = polygon;
-	    conn->group = GetLayerGroupNumberByPointer (layer);
-	    conn->menu = NULL;	/* agnostic view of where it belongs */
-	  }
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            {
+              conn = GetConnectionMemory (a);
+              /* make point on a vertex */
+              conn->X = polygon->Clipped->contours->head.point[0];
+              conn->Y = polygon->Clipped->contours->head.point[1];
+              conn->type = POLYGON_TYPE;
+              conn->ptr1 = layer;
+              conn->ptr2 = polygon;
+              conn->group = GetLayerGroupNumberByPointer (layer);
+              conn->menu = NULL;	/* agnostic view of where it belongs */
+            }
+        }
+        END_LOOP;
       }
       ENDALL_LOOP;
       VIA_LOOP (PCB->Data);
diff --git a/src/remove.c b/src/remove.c
index 8defaf4..92c0e11 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -45,7 +45,8 @@
 #include "misc.h"
 #include "move.h"
 #include "mymem.h"
-#include "polygon.h"
+//#include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -69,13 +70,13 @@ static void *DestroyRat (RatTypePtr);
 static void *DestroyLine (LayerTypePtr, LineTypePtr);
 static void *DestroyArc (LayerTypePtr, ArcTypePtr);
 static void *DestroyText (LayerTypePtr, TextTypePtr);
-static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *DestroyPour (LayerTypePtr, PourTypePtr);
 static void *DestroyElement (ElementTypePtr);
 static void *RemoveVia (PinTypePtr);
 static void *RemoveRat (RatTypePtr);
-static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
-static void *RemovePolygonContour (LayerTypePtr, PolygonTypePtr, Cardinal);
-static void *RemovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *DestroyPourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
+static void *RemovePourContour (LayerTypePtr, PourTypePtr, Cardinal);
+static void *RemovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -84,28 +85,30 @@ static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 static ObjectFunctionType RemoveFunctions = {
   RemoveLine,
   RemoveText,
-  RemovePolygon,
+  NULL,
+  RemovePour,
   RemoveVia,
   RemoveElement,
   NULL,
   NULL,
   NULL,
   RemoveLinePoint,
-  RemovePolygonPoint,
+  RemovePourPoint,
   RemoveArc,
   RemoveRat
 };
 static ObjectFunctionType DestroyFunctions = {
   DestroyLine,
   DestroyText,
-  DestroyPolygon,
+  NULL, //DestroyPolygon,
+  DestroyPour,
   DestroyVia,
   DestroyElement,
   NULL,
   NULL,
   NULL,
   NULL,
-  DestroyPolygonPoint,
+  DestroyPourPoint,
   DestroyArc,
   DestroyRat
 };
@@ -179,62 +182,66 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 }
 
 /* ---------------------------------------------------------------------------
- * destroys a polygon from a layer
+ * destroys a pour from a layer
  */
 static void *
-DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  FreePolygonMemory (Polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
+  Cardinal i;
+
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  FreePourMemory (Pour);
+  if (Pour != &Layer->Pour[--Layer->PourN])
     {
-      *Polygon = Layer->Polygon[Layer->PolygonN];
-      r_substitute (Layer->polygon_tree,
-		    (BoxType *) & Layer->Polygon[Layer->PolygonN],
-		    (BoxType *) Polygon);
+      *Pour = Layer->Pour[Layer->PourN];
+      r_substitute (Layer->pour_tree,
+                    (BoxType *) & Layer->Pour[Layer->PourN],
+                    (BoxType *) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
     }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   return (NULL);
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon-point from a polygon and destroys the data
+ * removes a pour-point from a pour and destroys the data
  */
 static void *
-DestroyPolygonPoint (LayerTypePtr Layer,
-		     PolygonTypePtr Polygon, PointTypePtr Point)
+DestroyPourPoint (LayerTypePtr Layer,
+                  PourTypePtr Pour, PointTypePtr Point)
 {
   Cardinal point_idx;
   Cardinal i;
   Cardinal contour;
   Cardinal contour_start, contour_end, contour_points;
 
-  point_idx = polygon_point_idx (Polygon, Point);
-  contour = polygon_point_contour (Polygon, point_idx);
-  contour_start = (contour == 0) ? 0 : Polygon->HoleIndex[contour - 1];
-  contour_end = (contour == Polygon->HoleIndexN) ? Polygon->PointN :
-                                                   Polygon->HoleIndex[contour];
+  point_idx = pour_point_idx (Pour, Point);
+  contour = pour_point_contour (Pour, point_idx);
+  contour_start = (contour == 0) ? 0 : Pour->HoleIndex[contour - 1];
+  contour_end = (contour == Pour->HoleIndexN) ? Pour->PointN :
+                                                Pour->HoleIndex[contour];
   contour_points = contour_end - contour_start;
 
   if (contour_points <= 3)
-    return RemovePolygonContour (Layer, Polygon, contour);
+    return RemovePourContour (Layer, Pour, contour);
 
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
 
   /* remove point from list, keep point order */
-  for (i = point_idx; i < Polygon->PointN - 1; i++)
-    Polygon->Points[i] = Polygon->Points[i + 1];
-  Polygon->PointN--;
+  for (i = point_idx; i < Pour->PointN - 1; i++)
+    Pour->Points[i] = Pour->Points[i + 1];
+  Pour->PointN--;
 
   /* Shift down indices of any holes */
-  for (i = 0; i < Polygon->HoleIndexN; i++)
-    if (Polygon->HoleIndex[i] > point_idx)
-      Polygon->HoleIndex[i]--;
-
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  return (Polygon);
+  for (i = 0; i < Pour->HoleIndexN; i++)
+    if (Pour->HoleIndex[i] > point_idx)
+      Pour->HoleIndex[i]--;
+
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  return (Pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -481,67 +488,67 @@ RemoveText (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon from a layer
+ * removes a pour from a layer
  */
 void *
-RemovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+RemovePour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   /* erase from screen */
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
       if (!Bulk)
 	Draw ();
     }
-  MoveObjectToRemoveUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
+  MoveObjectToRemoveUndoList (POUR_TYPE, Layer, Pour, Pour);
   return (NULL);
 }
 
 /* ---------------------------------------------------------------------------
- * removes a contour from a polygon.
- * If removing the outer contour, it removes the whole polygon.
+ * removes a contour from a pour.
+ * If removing the outer contour, it removes the whole pour.
  */
 static void *
-RemovePolygonContour (LayerTypePtr Layer,
-                      PolygonTypePtr Polygon,
-                      Cardinal contour)
+RemovePourContour (LayerTypePtr Layer,
+                   PourTypePtr Pour,
+                   Cardinal contour)
 {
   Cardinal contour_start, contour_end, contour_points;
   Cardinal i;
 
   if (contour == 0)
-    return RemovePolygon (Layer, Polygon);
+    return RemovePour (Layer, Pour);
 
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
       if (!Bulk)
         Draw ();
     }
 
-  /* Copy the polygon to the undo list */
-  AddObjectToRemoveContourUndoList (POLYGON_TYPE, Layer, Polygon);
+  /* Copy the pour to the undo list */
+  AddObjectToRemoveContourUndoList (POUR_TYPE, Layer, Pour);
 
-  contour_start = (contour == 0) ? 0 : Polygon->HoleIndex[contour - 1];
-  contour_end = (contour == Polygon->HoleIndexN) ? Polygon->PointN :
-                                                   Polygon->HoleIndex[contour];
+  contour_start = (contour == 0) ? 0 : Pour->HoleIndex[contour - 1];
+  contour_end = (contour == Pour->HoleIndexN) ? Pour->PointN :
+                                                Pour->HoleIndex[contour];
   contour_points = contour_end - contour_start;
 
   /* remove points from list, keep point order */
-  for (i = contour_start; i < Polygon->PointN - contour_points; i++)
-    Polygon->Points[i] = Polygon->Points[i + contour_points];
-  Polygon->PointN -= contour_points;
+  for (i = contour_start; i < Pour->PointN - contour_points; i++)
+    Pour->Points[i] = Pour->Points[i + contour_points];
+  Pour->PointN -= contour_points;
 
   /* remove hole from list and shift down remaining indices */
-  for (i = contour; i < Polygon->HoleIndexN; i++)
-    Polygon->HoleIndex[i - 1] = Polygon->HoleIndex[i] - contour_points;
-  Polygon->HoleIndexN--;
+  for (i = contour; i < Pour->HoleIndexN; i++)
+    Pour->HoleIndex[i - 1] = Pour->HoleIndex[i] - contour_points;
+  Pour->HoleIndexN--;
 
-  InitClip (PCB->Data, Layer, Polygon);
-  /* redraw polygon if necessary */
+  InitPourClip (PCB->Data, Layer, Pour);
+  /* redraw pour if necessary */
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       if (!Bulk)
         Draw ();
     }
@@ -549,53 +556,53 @@ RemovePolygonContour (LayerTypePtr Layer,
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon-point from a polygon
+ * removes a pour-point from a pour
  */
 static void *
-RemovePolygonPoint (LayerTypePtr Layer,
-		    PolygonTypePtr Polygon, PointTypePtr Point)
+RemovePourPoint (LayerTypePtr Layer,
+                 PourTypePtr Pour, PointTypePtr Point)
 {
   Cardinal point_idx;
   Cardinal i;
   Cardinal contour;
   Cardinal contour_start, contour_end, contour_points;
 
-  point_idx = polygon_point_idx (Polygon, Point);
-  contour = polygon_point_contour (Polygon, point_idx);
-  contour_start = (contour == 0) ? 0 : Polygon->HoleIndex[contour - 1];
-  contour_end = (contour == Polygon->HoleIndexN) ? Polygon->PointN :
-                                                   Polygon->HoleIndex[contour];
+  point_idx = pour_point_idx (Pour, Point);
+  contour = pour_point_contour (Pour, point_idx);
+  contour_start = (contour == 0) ? 0 : Pour->HoleIndex[contour - 1];
+  contour_end = (contour == Pour->HoleIndexN) ? Pour->PointN :
+                                                Pour->HoleIndex[contour];
   contour_points = contour_end - contour_start;
 
   if (contour_points <= 3)
-    return RemovePolygonContour (Layer, Polygon, contour);
+    return RemovePourContour (Layer, Pour, contour);
 
   if (Layer->On)
-    ErasePolygon (Polygon);
+    ErasePour (Pour);
 
-  /* insert the polygon-point into the undo list */
-  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Polygon, point_idx);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  /* insert the pour-point into the undo list */
+  AddObjectToRemovePointUndoList (POURPOINT_TYPE, Layer, Pour, point_idx);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
 
   /* remove point from list, keep point order */
-  for (i = point_idx; i < Polygon->PointN - 1; i++)
-    Polygon->Points[i] = Polygon->Points[i + 1];
-  Polygon->PointN--;
+  for (i = point_idx; i < Pour->PointN - 1; i++)
+    Pour->Points[i] = Pour->Points[i + 1];
+  Pour->PointN--;
 
   /* Shift down indices of any holes */
-  for (i = 0; i < Polygon->HoleIndexN; i++)
-    if (Polygon->HoleIndex[i] > point_idx)
-      Polygon->HoleIndex[i]--;
+  for (i = 0; i < Pour->HoleIndexN; i++)
+    if (Pour->HoleIndex[i] > point_idx)
+      Pour->HoleIndex[i]--;
 
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
 
-  /* redraw polygon if necessary */
+  /* redraw pour if necessary */
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       if (!Bulk)
 	Draw ();
     }
diff --git a/src/remove.h b/src/remove.h
index 9fd4625..07e158b 100644
--- a/src/remove.h
+++ b/src/remove.h
@@ -38,11 +38,11 @@
  */
 #define REMOVE_TYPES            \
 	(VIA_TYPE | LINEPOINT_TYPE | LINE_TYPE | TEXT_TYPE | ELEMENT_TYPE |	\
-	POLYGONPOINT_TYPE | POLYGON_TYPE | RATLINE_TYPE | ARC_TYPE)
+	POURPOINT_TYPE | POUR_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void *RemoveLine (LayerTypePtr, LineTypePtr);
 void *RemoveArc (LayerTypePtr, ArcTypePtr);
-void *RemovePolygon (LayerTypePtr, PolygonTypePtr);
+void *RemovePour (LayerTypePtr, PourTypePtr);
 void *RemoveText (LayerTypePtr, TextTypePtr);
 void *RemoveElement (ElementTypePtr);
 void ClearRemoveList (void);
diff --git a/src/report.c b/src/report.c
index be6d1e6..a975e1c 100644
--- a/src/report.c
+++ b/src/report.c
@@ -343,12 +343,43 @@ ReportDialog (int argc, char **argv, int x, int y)
 		 prec, units(Polygon->BoundingBox.Y1),
 		 prec, units(Polygon->BoundingBox.X2),
 		 prec, UNIT(Polygon->BoundingBox.Y2),
+     0, 0, 0,
+#warning FIXME Later
+#if 0
 		 Polygon->PointN, Polygon->PointMax - Polygon->PointN,
 		 Polygon->HoleIndexN,
+#endif
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
 		 TEST_FLAG (LOCKFLAG, Polygon) ? "It is LOCKED.\n" : "");
 	break;
       }
+    case POUR_TYPE:
+      {
+	PourTypePtr Pour;
+#ifndef NDEBUG
+	if (gui->shift_is_pressed ())
+	  {
+	    LayerTypePtr layer = (LayerTypePtr) ptr1;
+	    __r_dump_tree (layer->pour_tree->root, 0);
+	    return;
+	  }
+#endif
+	Pour = (PourTypePtr) ptr2;
+
+	sprintf (&report[0], "POUR ID# %ld   Flags:%s\n"
+		 "Its bounding box is (%d,%d) (%d,%d)\n"
+		 "It has %d points and could store %d more\n"
+		 "without using more memory.\n"
+		 "It resides on layer %d\n"
+		 "%s", Pour->ID,
+		 flags_to_string (Pour->Flags, POUR_TYPE),
+		 Pour->BoundingBox.X1, Pour->BoundingBox.Y1,
+		 Pour->BoundingBox.X2, Pour->BoundingBox.Y2,
+		 Pour->PointN, Pour->PointMax - Pour->PointN,
+		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
+		 TEST_FLAG (LOCKFLAG, Pour) ? "It is LOCKED\n" : "");
+	break;
+      }
     case PAD_TYPE:
       {
 	int len, dx, dy, mgap;
@@ -489,14 +520,14 @@ ReportDialog (int argc, char **argv, int x, int y)
 	break;
       }
     case LINEPOINT_TYPE:
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       {
 	PointTypePtr point = (PointTypePtr) ptr2;
 	sprintf (&report[0], "POINT ID# %ld.\n"
 		 "Located at (X,Y) = (%.*f,%.*f) %s.\n"
 		 "It belongs to a %s on layer %d.\n", point->ID,
 		 prec, units (point->X), prec, UNIT (point->Y),
-		 (type == LINEPOINT_TYPE) ? "line" : "polygon",
+		 (type == LINEPOINT_TYPE) ? "line" : "pour",
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1));
 	break;
       }
diff --git a/src/report.h b/src/report.h
index 7abbb79..39ce0ca 100644
--- a/src/report.h
+++ b/src/report.h
@@ -31,8 +31,8 @@
 #include "global.h"
 
 #define REPORT_TYPES \
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE | \
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POUR_TYPE | ELEMENT_TYPE | \
 	 RATLINE_TYPE | PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | ARC_TYPE \
-	 | POLYGONPOINT_TYPE | LINEPOINT_TYPE)
+	 | POURPOINT_TYPE | LINEPOINT_TYPE)
 
 #endif
diff --git a/src/rotate.c b/src/rotate.c
index 9e19581..229e705 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -44,6 +44,7 @@
 #include "error.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rotate.h"
 #include "rtree.h"
 #include "rubberband.h"
@@ -81,6 +82,7 @@ static ObjectFunctionType RotateFunctions = {
   RotateText,
   NULL,
   NULL,
+  NULL,
   RotateElement,
   RotateElementName,
   NULL,
@@ -158,18 +160,18 @@ RotateTextLowLevel (TextTypePtr Text, LocationType X, LocationType Y,
 }
 
 /* ---------------------------------------------------------------------------
- * rotates a polygon in 90 degree steps
+ * rotates a pour in 90 degree steps
  */
 void
-RotatePolygonLowLevel (PolygonTypePtr Polygon,
+RotatePourLowLevel (PourTypePtr Pour,
 		       LocationType X, LocationType Y, BYTE Number)
 {
-  POLYGONPOINT_LOOP (Polygon);
+  POURPOINT_LOOP (Pour);
   {
     ROTATE (point->X, point->Y, X, Y, Number);
   }
   END_LOOP;
-  RotateBoxLowLevel (&Polygon->BoundingBox, X, Y, Number);
+  RotateBoxLowLevel (&Pour->BoundingBox, X, Y, Number);
 }
 
 /* ---------------------------------------------------------------------------
@@ -179,11 +181,11 @@ static void *
 RotateText (LayerTypePtr Layer, TextTypePtr Text)
 {
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   RotateTextLowLevel (Text, CenterX, CenterY, Number);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   Draw ();
   return (Text);
@@ -241,7 +243,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     ROTATE_PIN_LOWLEVEL (pin, X, Y, Number);
   }
   END_LOOP;
@@ -250,7 +252,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     ROTATE_PAD_LOWLEVEL (pad, X, Y, Number);
   }
   END_LOOP;
@@ -262,7 +264,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
   ROTATE (Element->MarkX, Element->MarkY, X, Y, Number);
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -274,7 +276,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   EraseLine (Line);
   if (Layer)
     {
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
     }
   else
@@ -284,7 +286,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   if (Layer)
     {
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
     }
   else
@@ -388,7 +390,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       EraseLine (ptr->Line);
       if (ptr->Layer)
 	{
-	  RestoreToPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  RestoreToPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  r_delete_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line);
 	}
       else
@@ -398,7 +400,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       if (ptr->Layer)
 	{
 	  r_insert_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line, 0);
-	  ClearFromPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  ClearFromPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  DrawLine (ptr->Layer, ptr->Line, 0);
 	}
       else
diff --git a/src/rotate.h b/src/rotate.h
index f032fcb..8ad4f60 100644
--- a/src/rotate.h
+++ b/src/rotate.h
@@ -64,7 +64,7 @@ void RotateLineLowLevel (LineTypePtr, LocationType, LocationType, BYTE);
 void RotateArcLowLevel (ArcTypePtr, LocationType, LocationType, BYTE);
 void RotateBoxLowLevel (BoxTypePtr, LocationType, LocationType, BYTE);
 void RotateTextLowLevel (TextTypePtr, LocationType, LocationType, BYTE);
-void RotatePolygonLowLevel (PolygonTypePtr, LocationType, LocationType, BYTE);
+void RotatePourLowLevel (PourTypePtr, LocationType, LocationType, BYTE);
 void RotateElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			    LocationType, BYTE);
 void *RotateObject (int, void *, void *, void *, LocationType, LocationType,
diff --git a/src/search.c b/src/search.c
index 3fafcd4..584fbeb 100644
--- a/src/search.c
+++ b/src/search.c
@@ -80,6 +80,8 @@ static bool SearchTextByLocation (int, LayerTypePtr *, TextTypePtr *,
 				     TextTypePtr *);
 static bool SearchPolygonByLocation (int, LayerTypePtr *, PolygonTypePtr *,
 					PolygonTypePtr *);
+static bool SearchPourByLocation (int, LayerTypePtr *, PourTypePtr *,
+				  PourTypePtr *);
 static bool SearchPinByLocation (int, ElementTypePtr *, PinTypePtr *,
 				    PinTypePtr *);
 static bool SearchPadByLocation (int, ElementTypePtr *, PadTypePtr *,
@@ -91,8 +93,8 @@ static bool SearchElementNameByLocation (int, ElementTypePtr *,
 					    bool);
 static bool SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
 					  PointTypePtr *);
-static bool SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
-				      PointTypePtr *);
+static bool SearchPourPointByLocation (int, LayerTypePtr *, PourTypePtr *,
+				       PointTypePtr *);
 static bool SearchElementByLocation (int, ElementTypePtr *,
 					ElementTypePtr *, ElementTypePtr *,
 					bool);
@@ -105,6 +107,7 @@ struct ans_info
   void **ptr1, **ptr2, **ptr3;
   bool BackToo;
   float area;
+  BoxType *search_box;
   jmp_buf env;
   int locked;			/* This will be zero or LOCKFLAG */
 };
@@ -419,6 +422,14 @@ polygon_callback (const BoxType * box, void *cl)
   return 0;
 }
 
+static int
+pour_polygon_callback (const BoxType * box, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) box;
+  struct ans_info *i = (struct ans_info *) cl;
+
+  return r_search (pour->polygon_tree, &SearchBox, NULL, polygon_callback, i);
+}
 
 /* ---------------------------------------------------------------------------
  * searches a polygon on the SearchLayer 
@@ -436,13 +447,59 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
 
   if (setjmp (info.env) == 0)
     {
-      r_search (SearchLayer->polygon_tree, &SearchBox, NULL, polygon_callback,
+      r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback,
 		&info);
       return false;
     }
   return (true);
 }
 
+#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#if 0
+static int
+pour_callback (const BoxType * box, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) box;
+  struct ans_info *i = (struct ans_info *) cl;
+
+  if (TEST_FLAG (i->locked, pour))
+    return 0;
+
+  if (IsPointInPour (PosX, PosY, SearchRadius, pour))
+    {
+      *i->ptr2 = *i->ptr3 = pour;
+      longjmp (i->env, 1);
+    }
+  return 0;
+}
+#endif
+
+/* ---------------------------------------------------------------------------
+ * searches a pour on the SearchLayer 
+ */
+static bool
+SearchPourByLocation (int locked, LayerTypePtr * Layer,
+                      PourTypePtr * Pour, PourTypePtr * Dummy)
+{
+  struct ans_info info;
+
+  *Layer = SearchLayer;
+  info.ptr2 = (void **) Pour;
+  info.ptr3 = (void **) Dummy;
+  info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
+
+#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+  if (setjmp (info.env) == 0)
+    {
+      r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback, &info);
+      return false;
+    }
+
+  /* Make sure we return the pour, not the polygon */
+  *info.ptr2 = *info.ptr3 = ((PolygonTypePtr)*info.ptr2)->ParentPour;
+  return (true);
+}
+
 static int
 linepoint_callback (const BoxType * b, void *cl)
 {
@@ -498,27 +555,27 @@ SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
 }
 
 /* ---------------------------------------------------------------------------
- * searches a polygon-point on all layers that are switched on
+ * searches a pour-point on all layers that are switched on
  * in layerstack order
  */
 static bool
-SearchPointByLocation (int locked, LayerTypePtr * Layer,
-		       PolygonTypePtr * Polygon, PointTypePtr * Point)
+SearchPourPointByLocation (int locked, LayerTypePtr * Layer,
+		       PourTypePtr * Pour, PointTypePtr * Point)
 {
   float d, least;
   bool found = false;
 
-  least = SQUARE (SearchRadius + MAX_POLYGON_POINT_DISTANCE);
+  least = SQUARE (SearchRadius + MAX_POUR_POINT_DISTANCE);
   *Layer = SearchLayer;
-  POLYGON_LOOP (*Layer);
+  POUR_LOOP (*Layer);
   {
-    POLYGONPOINT_LOOP (polygon);
+    POURPOINT_LOOP (pour);
     {
       d = SQUARE (point->X - PosX) + SQUARE (point->Y - PosY);
       if (d < least)
 	{
 	  least = d;
-	  *Polygon = polygon;
+	  *Pour = pour;
 	  *Point = point;
 	  found = true;
 	}
@@ -1176,7 +1233,7 @@ SearchObjectByLocation (int Type,
     }
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
     {
-      Type &= ~POLYGON_TYPE;
+      Type &= ~(POLYGON_TYPE | POUR_TYPE);
     }
 
   if (Type & RATLINE_TYPE && PCB->RatOn &&
@@ -1241,12 +1298,12 @@ SearchObjectByLocation (int Type,
       if (SearchLayer->On)
 	{
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
-	      Type & POLYGONPOINT_TYPE &&
-	      SearchPointByLocation (locked,
-				     (LayerTypePtr *) Result1,
-				     (PolygonTypePtr *) Result2,
-				     (PointTypePtr *) Result3))
-	    return (POLYGONPOINT_TYPE);
+	      Type & POURPOINT_TYPE &&
+	      SearchPourPointByLocation (locked,
+					 (LayerTypePtr *) Result1,
+					 (PourTypePtr *) Result2,
+					 (PointTypePtr *) Result3))
+	    return (POURPOINT_TYPE);
 
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
 	      Type & LINEPOINT_TYPE &&
@@ -1297,6 +1354,27 @@ SearchObjectByLocation (int Type,
 	      else
 		return (POLYGON_TYPE);
 	    }
+
+	  if (Type & POUR_TYPE &&
+	      SearchPourByLocation (locked,
+				    (LayerTypePtr *) Result1,
+				    (PourTypePtr *) Result2,
+				    (PourTypePtr *) Result3))
+	    {
+	      if (HigherAvail)
+		{
+		  BoxTypePtr box =
+		    &(*(PourTypePtr *) Result2)->BoundingBox;
+		  float area =
+		    (float) (box->X2 - box->X1) * (float) (box->X2 - box->X1);
+		  if (HigherBound < area)
+		    break;
+		  else
+		    return (POUR_TYPE);
+		}
+	      else
+		return (POUR_TYPE);
+	    }
 	}
     }
   /* return any previously found objects */
@@ -1428,31 +1506,47 @@ SearchObjectByID (DataTypePtr Base,
       ENDALL_LOOP;
     }
 
-  if (type == POLYGON_TYPE || type == POLYGONPOINT_TYPE)
+  if (type == POUR_TYPE || type == POURPOINT_TYPE || type == POLYGON_TYPE)
     {
-      ALLPOLYGON_LOOP (Base);
+      ALLPOUR_LOOP (Base);
       {
-	if (polygon->ID == ID)
+	if (pour->ID == ID)
 	  {
 	    *Result1 = (void *) layer;
-	    *Result2 = *Result3 = (void *) polygon;
-	    return (POLYGON_TYPE);
+	    *Result2 = *Result3 = (void *) pour;
+	    return (POUR_TYPE);
 	  }
-	if (type == POLYGONPOINT_TYPE)
-	  POLYGONPOINT_LOOP (polygon);
-	{
-	  if (point->ID == ID)
-	    {
-	      *Result1 = (void *) layer;
-	      *Result2 = (void *) polygon;
-	      *Result3 = (void *) point;
-	      return (POLYGONPOINT_TYPE);
-	    }
-	}
-	END_LOOP;
+	if (type == POURPOINT_TYPE)
+          {
+            POURPOINT_LOOP (pour);
+            {
+              if (point->ID == ID)
+                {
+                  *Result1 = (void *) layer;
+                  *Result2 = (void *) pour;
+                  *Result3 = (void *) point;
+                  return (POURPOINT_TYPE);
+                }
+            }
+            END_LOOP;
+          }
+        else if (type == POLYGON_TYPE)
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (polygon->ID == ID)
+                {
+                  *Result1 = (void *) layer;
+                  *Result2 = *Result3 = (void *) polygon;
+                  return (POLYGON_TYPE);
+                }
+            }
+            END_LOOP;
+          }
       }
       ENDALL_LOOP;
     }
+
   if (type == VIA_TYPE)
     {
       VIA_LOOP (Base);
diff --git a/src/search.h b/src/search.h
index add5661..25d8103 100644
--- a/src/search.h
+++ b/src/search.h
@@ -59,8 +59,13 @@
 #define	TEXT_IN_BOX(t,b)	\
 	(BOX_IN_BOX(&((t)->BoundingBox), (b)))
 
+#if 0 // NOT USED
 #define	POLYGON_IN_BOX(p,b)	\
 	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
+#endif
+
+#define	POUR_IN_BOX(p,b)	\
+	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
 
 #define	ELEMENT_IN_BOX(e,b)	\
 	(BOX_IN_BOX(&((e)->BoundingBox), (b)))
diff --git a/src/select.c b/src/select.c
index c4b5e17..b8ecf86 100644
--- a/src/select.c
+++ b/src/select.c
@@ -182,6 +182,7 @@ SelectObject (void)
 	break;
       }
 
+#if 0
     case POLYGON_TYPE:
       {
 	PolygonType *poly = (PolygonTypePtr) ptr2;
@@ -193,6 +194,19 @@ SelectObject (void)
 	/* changing memory order no longer effects draw order */
 	break;
       }
+#endif
+
+    case POUR_TYPE:
+      {
+	PourType *pour = (PourTypePtr) ptr2;
+
+	layer = (LayerTypePtr) ptr1;
+	AddObjectToFlagUndoList (POUR_TYPE, ptr1, ptr2, ptr2);
+	TOGGLE_FLAG (SELECTEDFLAG, pour);
+	DrawPour (layer, pour, 0);
+	/* changing memory order no longer effects draw order */
+	break;
+      }
 
     case PIN_TYPE:
       AddObjectToFlagUndoList (PIN_TYPE, ptr1, ptr2, ptr2);
@@ -351,8 +365,20 @@ SelectBlock (BoxTypePtr Box, bool Flag)
 	}
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+    POUR_LOOP (layer);
     {
+#warning FIXME Later: Do we want to be able to select the polygon pieces?
+      if (POUR_IN_BOX (pour, Box)
+	  && !TEST_FLAG (LOCKFLAG, pour)
+	  && TEST_FLAG (SELECTEDFLAG, pour) != Flag)
+	{
+	  AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+	  ASSIGN_FLAG (SELECTEDFLAG, Flag, pour);
+	  if (layer->On)
+	    DrawPour (layer, pour, 0);
+	  changed = true;
+	}
+#if 0
       if (POLYGON_IN_BOX (polygon, Box)
 	  && !TEST_FLAG (LOCKFLAG, polygon)
 	  && TEST_FLAG (SELECTEDFLAG, polygon) != Flag)
@@ -363,6 +389,7 @@ SelectBlock (BoxTypePtr Box, bool Flag)
 	    DrawPolygon (layer, polygon, 0);
 	  changed = true;
 	}
+#endif
     }
     END_LOOP;
   }
@@ -523,9 +550,14 @@ ObjectOperation (ObjectFunctionTypePtr F,
 	return (F->Polygon ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2));
       break;
 
-    case POLYGONPOINT_TYPE:
-      if (F->Point)
-	return (F->Point ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+    case POUR_TYPE:
+      if (F->Pour)
+	return (F->Pour ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2));
+      break;
+
+    case POURPOINT_TYPE:
+      if (F->PourPoint)
+	return (F->PourPoint ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2,
 			  (PointTypePtr) Ptr3));
       break;
 
@@ -624,21 +656,44 @@ SelectedOperation (ObjectFunctionTypePtr F, bool Reset, int type)
   }
   ENDALL_LOOP;
 
+#if 0
   /* check polygons */
   if (type & POLYGON_TYPE && F->Polygon)
-    VISIBLEPOLYGON_LOOP (PCB->Data);
-  {
-    if (TEST_FLAG (SELECTEDFLAG, polygon))
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      POURPOLYGON_LOOP (pour);
       {
-	if (Reset)
-	  {
-	    AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	    CLEAR_FLAG (SELECTEDFLAG, polygon);
-	  }
-	F->Polygon (layer, polygon);
-	changed = true;
+        if (TEST_FLAG (SELECTEDFLAG, polygon))
+          {
+            if (Reset)
+              {
+                AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+                CLEAR_FLAG (SELECTEDFLAG, polygon);
+              }
+            F->Polygon (layer, polygon);
+            changed = true;
+          }
       }
-  }
+      END_LOOP;
+    }
+  ENDALL_LOOP;
+#endif
+
+  /* check pours */
+  if (type & POUR_TYPE && F->Pour)
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      if (TEST_FLAG (SELECTEDFLAG, pour))
+        {
+          if (Reset)
+            {
+              AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+              CLEAR_FLAG (SELECTEDFLAG, pour);
+            }
+          F->Pour (layer, pour);
+          changed = true;
+        }
+    }
   ENDALL_LOOP;
 
   /* elements silkscreen */
@@ -800,17 +855,23 @@ SelectConnection (bool Flag)
       }
   }
   ENDALL_LOOP;
-  VISIBLEPOLYGON_LOOP (PCB->Data);
+#if 0
+  VISIBLEPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	changed = true;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          changed = true;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
+#endif
 
   if (PCB->PinOn && PCB->ElementOn)
     {
diff --git a/src/select.h b/src/select.h
index e24ab82..36de895 100644
--- a/src/select.h
+++ b/src/select.h
@@ -34,7 +34,7 @@
 #include "global.h"
 
 #define SELECT_TYPES	\
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE |	\
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POUR_TYPE | ELEMENT_TYPE |	\
 	 PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void SelectPin (LibraryEntryTypePtr entry, bool toggle);
diff --git a/src/set.c b/src/set.c
index 7a41f73..4f2e591 100644
--- a/src/set.c
+++ b/src/set.c
@@ -248,12 +248,12 @@ SetMode (int Mode)
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
-  Crosshair.AttachedPolygon.PointN = 0;
+  Crosshair.AttachedPour.PointN = 0;
   if (PCB->RatDraw)
     {
       if (Mode == ARC_MODE || Mode == RECTANGLE_MODE ||
-	  Mode == VIA_MODE || Mode == POLYGON_MODE ||
-	  Mode == POLYGONHOLE_MODE ||
+	  Mode == VIA_MODE || Mode == POUR_MODE ||
+	  Mode == POURHOLE_MODE ||
 	  Mode == TEXT_MODE || Mode == INSERTPOINT_MODE ||
 	  Mode == THERMAL_MODE)
 	{
diff --git a/src/strflags.c b/src/strflags.c
index ac1fdcc..26a2405 100644
--- a/src/strflags.c
+++ b/src/strflags.c
@@ -95,7 +95,7 @@ static FlagBitsType object_flagbits[] = {
   { HOLEFLAG, N ("hole"), PIN_TYPES },
   { RATFLAG, N ("rat"), RATLINE_TYPE },
   { PININPOLYFLAG, N ("pininpoly"), PIN_TYPES | PAD_TYPE },
-  { CLEARPOLYFLAG, N ("clearpoly"), POLYGON_TYPE },
+  { CLEARPOLYFLAG, N ("clearpoly"), POUR_TYPE },
   { HIDENAMEFLAG, N ("hidename"), ELEMENT_TYPE },
   { DISPLAYNAMEFLAG, N ("showname"), ELEMENT_TYPE },
   { CLEARLINEFLAG, N ("clearline"), LINE_TYPE | ARC_TYPE | TEXT_TYPE },
@@ -110,7 +110,7 @@ static FlagBitsType object_flagbits[] = {
   { DRCFLAG, N ("drc"), ALL_TYPES },
   { LOCKFLAG, N ("lock"), ALL_TYPES },
   { EDGE2FLAG, N ("edge2"), ALL_TYPES },
-  { FULLPOLYFLAG, N ("fullpoly"), POLYGON_TYPE},
+  { FULLPOLYFLAG, N ("fullpoly"), POUR_TYPE},
   { NOPASTEFLAG, N ("nopaste"), PAD_TYPE }
 };
 
diff --git a/src/undo.c b/src/undo.c
index 5226c53..88b0d35 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -62,6 +62,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rotate.h"
 #include "rtree.h"
@@ -127,7 +128,7 @@ typedef struct			/* information about poly clear/restore */
   bool Clear;		/* true was clear, false was restore */
   LayerTypePtr Layer;
 }
-ClearPolyType, *ClearPolyTypePtr;
+ClearPourType, *ClearPourTypePtr;
 
 typedef struct			/* information about netlist lib changes */
 {
@@ -152,7 +153,7 @@ typedef struct			/* holds information about an operation */
     FlagType Flags;
     BDimension Size;
     LayerChangeType LayerChange;
-    ClearPolyType ClearPoly;
+    ClearPourType ClearPour;
     NetlistChangeType NetlistChange;
     long int CopyID;
   }
@@ -196,7 +197,7 @@ static bool UndoChange2ndSize (UndoListTypePtr);
 static bool UndoChangeAngles (UndoListTypePtr);
 static bool UndoChangeClearSize (UndoListTypePtr);
 static bool UndoChangeMaskSize (UndoListTypePtr);
-static bool UndoClearPoly (UndoListTypePtr);
+static bool UndoClearPour (UndoListTypePtr);
 static int PerformUndo (UndoListTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -271,7 +272,7 @@ GetUndoSlot (int CommandType, int ID, int Kind)
 static void
 DrawRecoveredObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
-  if (Type & (LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ARC_TYPE))
+  if (Type & (LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | POUR_TYPE | ARC_TYPE))
     {
       LayerTypePtr layer;
 
@@ -313,7 +314,7 @@ UndoRotate (UndoListTypePtr Entry)
  * returns true if anything has been recovered
  */
 static bool
-UndoClearPoly (UndoListTypePtr Entry)
+UndoClearPour (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
   int type;
@@ -322,11 +323,11 @@ UndoClearPoly (UndoListTypePtr Entry)
     SearchObjectByID (PCB->Data, &ptr1, &ptr2, &ptr3, Entry->ID, Entry->Kind);
   if (type != NO_TYPE)
     {
-      if (Entry->Data.ClearPoly.Clear)
-	RestoreToPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+      if (Entry->Data.ClearPour.Clear)
+	RestoreToPours (PCB->Data, type, Entry->Data.ClearPour.Layer, ptr3);
       else
-	ClearFromPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
-      Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
+	ClearFromPours (PCB->Data, type, Entry->Data.ClearPour.Layer, ptr3);
+      Entry->Data.ClearPour.Clear = !Entry->Data.ClearPour.Clear;
       return true;
     }
   return false;
@@ -439,11 +440,11 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
 	return (false);
       swap = ((PinTypePtr) ptr2)->Clearance;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Clearance = Entry->Data.Size;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
@@ -507,12 +508,12 @@ UndoChangeSize (UndoListTypePtr Entry)
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Thickness = Entry->Data.Size;
       Entry->Data.Size = swap;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
       return (true);
@@ -713,37 +714,37 @@ static bool
 UndoRemovePoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   void *ptr3;
   int type;
 
   /* lookup entry (polygon not point was saved) by it's ID */
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon, &ptr3,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour, &ptr3,
 		      Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGON_TYPE:		/* restore the removed point */
+    case POUR_TYPE:		/* restore the removed point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (false);
 	/* recover the point */
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
-	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
+	  ErasePour (pour);
+	InsertPointIntoObject (POUR_TYPE, layer, pour,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
 			       Entry->Data.RemovedPoint.Y, true,
 			       Entry->Data.RemovedPoint.last_in_contour);
 
-	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
+	pour->Points[Entry->Data.RemovedPoint.Index].ID =
 	  Entry->Data.RemovedPoint.ID;
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	Entry->Type = UNDO_INSERT_POINT;
 	Entry->ID = Entry->Data.RemovedPoint.ID;
-	Entry->Kind = POLYGONPOINT_TYPE;
+	Entry->Kind = POURPOINT_TYPE;
 	return (true);
       }
 
@@ -753,56 +754,56 @@ UndoRemovePoint (UndoListTypePtr Entry)
 }
 
 /* ---------------------------------------------------------------------------
- * recovers an inserted polygon point
+ * recovers an inserted pour point
  * returns true on success
  */
 static bool
 UndoInsertPoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   PointTypePtr pnt;
   int type;
   Cardinal point_idx;
   Cardinal hole;
   bool last_in_contour = false;
 
-  assert (Entry->Kind == POLYGONPOINT_TYPE);
+  assert (Entry->Kind == POURPOINT_TYPE);
   /* lookup entry by it's ID */
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour,
 		      (void *) &pnt, Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGONPOINT_TYPE:	/* removes an inserted polygon point */
+    case POURPOINT_TYPE:	/* removes an inserted pour point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (false);
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
+	  ErasePour (pour);
 
 	/* Check whether this point was at the end of its contour.
 	 * If so, we need to flag as such when re-adding the point
 	 * so it goes back in the correct place
 	 */
-	point_idx = polygon_point_idx (polygon, pnt);
-	for (hole = 0; hole < polygon->HoleIndexN; hole++)
-	  if (point_idx == polygon->HoleIndex[hole] - 1)
+	point_idx = pour_point_idx (pour, pnt);
+	for (hole = 0; hole < pour->HoleIndexN; hole++)
+	  if (point_idx == pour->HoleIndex[hole] - 1)
 	    last_in_contour = true;
-	if (point_idx == polygon->PointN - 1)
+	if (point_idx == pour->PointN - 1)
 	  last_in_contour = true;
 	Entry->Data.RemovedPoint.last_in_contour = last_in_contour;
 
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
-	Entry->ID = polygon->ID;
-	Entry->Kind = POLYGON_TYPE;
+	Entry->ID = pour->ID;
+	Entry->Kind = POUR_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
 	Entry->Data.RemovedPoint.Index = point_idx;
-	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
+	DestroyObject (PCB->Data, POURPOINT_TYPE, layer, pour, pnt);
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	return (true);
       }
 
@@ -846,8 +847,8 @@ UndoSwapCopiedObject (UndoListTypePtr Entry)
     DrawRecoveredObject (Entry->Kind, ptr1, ptr2, ptr3);
 
   obj = MoveObjectToBuffer (PCB->Data, RemoveList, type, ptr1, ptr2, ptr3);
-  if (Entry->Kind == POLYGON_TYPE)
-    InitClip (PCB->Data, ptr1b, (PolygonType *)obj);
+  if (Entry->Kind == POUR_TYPE)
+    InitPourClip (PCB->Data, ptr1b, (PourType *)obj);
   return (true);
 }
 
@@ -858,7 +859,7 @@ UndoSwapCopiedObject (UndoListTypePtr Entry)
 static bool
 UndoRemoveContour (UndoListTypePtr Entry)
 {
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   return UndoSwapCopiedObject (Entry);
 }
 
@@ -869,7 +870,7 @@ UndoRemoveContour (UndoListTypePtr Entry)
 static bool
 UndoInsertContour (UndoListTypePtr Entry)
 {
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   return UndoSwapCopiedObject (Entry);
 }
 
@@ -1060,7 +1061,7 @@ PerformUndo (UndoListTypePtr ptr)
       break;
 
     case UNDO_CLEAR:
-      if (UndoClearPoly (ptr))
+      if (UndoClearPour (ptr))
 	return (UNDO_CLEAR);
       break;
 
@@ -1233,7 +1234,7 @@ ClearUndoList (bool Force)
  * adds an object to the list of clearpoly objects
  */
 void
-AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
+AddObjectToClearPourUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			      bool clear)
 {
   UndoListTypePtr undo;
@@ -1241,8 +1242,8 @@ AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
   if (!Locked)
     {
       undo = GetUndoSlot (UNDO_CLEAR, OBJECT_ID (Ptr3), Type);
-      undo->Data.ClearPoly.Clear = clear;
-      undo->Data.ClearPoly.Layer = (LayerTypePtr) Ptr1;
+      undo->Data.ClearPour.Clear = clear;
+      undo->Data.ClearPour.Layer = (LayerTypePtr) Ptr1;
     }
 }
 
@@ -1308,7 +1309,7 @@ AddObjectToRemovePointUndoList (int Type,
 				void *Ptr1, void *Ptr2, Cardinal index)
 {
   UndoListTypePtr undo;
-  PolygonTypePtr polygon = (PolygonTypePtr) Ptr2;
+  PourTypePtr pour = (PourTypePtr) Ptr2;
   Cardinal hole;
   bool last_in_contour = false;
 
@@ -1316,27 +1317,27 @@ AddObjectToRemovePointUndoList (int Type,
     {
       switch (Type)
 	{
-	case POLYGONPOINT_TYPE:
+	case POURPOINT_TYPE:
 	  {
 	    /* save the ID of the parent object; else it will be
 	     * impossible to recover the point
 	     */
 	    undo =
-	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (polygon),
-			   POLYGON_TYPE);
-	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
-	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
-	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (pour),
+			   POUR_TYPE);
+	    undo->Data.RemovedPoint.X = pour->Points[index].X;
+	    undo->Data.RemovedPoint.Y = pour->Points[index].Y;
+	    undo->Data.RemovedPoint.ID = pour->Points[index].ID;
 	    undo->Data.RemovedPoint.Index = index;
 
 	    /* Check whether this point was at the end of its contour.
 	     * If so, we need to flag as such when re-adding the point
 	     * so it goes back in the correct place
 	     */
-	    for (hole = 0; hole < polygon->HoleIndexN; hole++)
-	      if (index == polygon->HoleIndex[hole] - 1)
+	    for (hole = 0; hole < pour->HoleIndexN; hole++)
+	      if (index == pour->HoleIndex[hole] - 1)
 		last_in_contour = true;
-	    if (index == polygon->PointN - 1)
+	    if (index == pour->PointN - 1)
 	      last_in_contour = true;
 	    undo->Data.RemovedPoint.last_in_contour = last_in_contour;
 	  }
@@ -1380,9 +1381,9 @@ CopyObjectToUndoList (int undo_type, int Type, void *Ptr1, void *Ptr2, void *Ptr
  */
 void
 AddObjectToRemoveContourUndoList (int Type,
-				  LayerType *Layer, PolygonType *Polygon)
+				  LayerType *Layer, PourType *Pour)
 {
-  CopyObjectToUndoList (UNDO_REMOVE_CONTOUR, Type, Layer, Polygon, NULL);
+  CopyObjectToUndoList (UNDO_REMOVE_CONTOUR, Type, Layer, Pour, NULL);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1455,7 +1456,7 @@ AddObjectToCreateUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
   if (!Locked)
     undo = GetUndoSlot (UNDO_CREATE, OBJECT_ID (Ptr3), Type);
-  ClearFromPolygon (PCB->Data, Type, Ptr1, Ptr2);
+  ClearFromPours (PCB->Data, Type, Ptr1, Ptr2);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/undo.h b/src/undo.h
index 0a4601f..b3c04d0 100644
--- a/src/undo.h
+++ b/src/undo.h
@@ -47,7 +47,7 @@ void ClearUndoList (bool);
 void MoveObjectToRemoveUndoList (int, void *, void *, void *);
 void AddObjectToRemovePointUndoList (int, void *, void *, Cardinal);
 void AddObjectToInsertPointUndoList (int, void *, void *, void *);
-void AddObjectToRemoveContourUndoList (int, LayerType *, PolygonType *);
+void AddObjectToRemoveContourUndoList (int, LayerType *, PourType *);
 void AddObjectToInsertContourUndoList (int, LayerType *, PolygonType *);
 void AddObjectToMoveUndoList (int, void *, void *, void *,
 			      LocationType, LocationType);
@@ -63,7 +63,7 @@ void AddObjectTo2ndSizeUndoList (int, void *, void *, void *);
 void AddObjectToClearSizeUndoList (int, void *, void *, void *);
 void AddObjectToMaskSizeUndoList (int, void *, void *, void *);
 void AddObjectToChangeAnglesUndoList (int, void *, void *, void *);
-void AddObjectToClearPolyUndoList (int, void *, void *, void *, bool);
+void AddObjectToClearPourUndoList (int, void *, void *, void *, bool);
 void AddLayerChangeToUndoList (int, int);
 void AddNetlistLibToUndoList (LibraryTypePtr);
 void LockUndo (void);
