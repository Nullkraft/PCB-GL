Bottom: cbf51552964be38ec1e9b54ae7636448fde77736
Top:    cc1217ac40594189fffb4eae7db8c3ca177c0023
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 15:55:57 +0000

Add support for arc segments in polygon object outline definitions

Test with a polygon like this:

  Polygon("clearpoly")
  (
    [5.0000mm 7.0000mm included_angle: 90] [7.0000mm 5.0000mm]
    [28.000mm 5.0000mm included_angle: 90] [30.000mm 7.0000mm]
    [30.000mm 28.000mm included_angle: 90] [28.000mm 30.000mm]
    [7.0000mm 30.000mm included_angle: 90] [5.0000mm 28.000mm]
  )


NOTE THAT THE ARC BOUNDS ARE NOT YET INCLUDED IN THE BOUNDING BOX CALCULATION,
SO THIS WILL BREAK VARIOUS THINGS PRETTY HORRIBLY IF AN ARC PROTRUDES AS AN
EXTREME FEATURE IN EITHER THE +/-X or +/-Y DIRECTIONS.


---

diff --git a/src/action.c b/src/action.c
index 7726be6..1616641 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1439,7 +1439,8 @@ NotifyMode (void)
 	  {
 	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+				     Crosshair.AttachedLine.Point2.Y,
+				     0);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1530,7 +1531,8 @@ NotifyMode (void)
 		{
 		  CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 					   Crosshair.AttachedLine.Point2.X,
-					   Crosshair.AttachedLine.Point2.Y);
+					   Crosshair.AttachedLine.Point2.Y,
+					   0);
 
 		  /* copy the coordinates */
 		  Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1753,13 +1755,13 @@ NotifyMode (void)
 	    InsertPointIntoObject (POLYGON_TYPE,
 				   Crosshair.AttachedObject.Ptr1, fake.poly,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, false, false);
+				   InsertedPoint.X, InsertedPoint.Y, 0, false, false);
 	  else
 	    InsertPointIntoObject (Crosshair.AttachedObject.Type,
 				   Crosshair.AttachedObject.Ptr1,
 				   Crosshair.AttachedObject.Ptr2,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, false, false);
+				   InsertedPoint.X, InsertedPoint.Y, 0, false, false);
 	  SetChangedFlag (true);
 
 	  /* reset identifiers */
diff --git a/src/copy.c b/src/copy.c
index 3e070e5..9b11e7d 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -106,7 +106,7 @@ CopyPolygonLowLevel (PolygonType *Dest, PolygonType *Src)
           CreateNewHoleInPolygon (Dest);
           hole++;
         }
-      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y);
+      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y, Src->Points[n].included_angle);
     }
   SetPolygonBoundingBox (Dest);
   Dest->Flags = Src->Flags;
diff --git a/src/create.c b/src/create.c
index 7341a0e..7d0a760 100644
--- a/src/create.c
+++ b/src/create.c
@@ -598,10 +598,10 @@ CreateNewPolygonFromRectangle (LayerType *Layer,
   if (!polygon)
     return (polygon);
 
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
+  CreateNewPointInPolygon (polygon, X1, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y2, 0);
+  CreateNewPointInPolygon (polygon, X1, Y2, 0);
   SetPolygonBoundingBox (polygon);
   if (!Layer->polygon_tree)
     Layer->polygon_tree = r_create_tree (NULL, 0, 0);
@@ -666,13 +666,14 @@ CreateNewPolygon (LayerType *Layer, FlagType Flags)
  * \brief Creates a new point in a polygon.
  */
 PointType *
-CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y)
+CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y, Angle included_angle)
 {
   PointType *point = GetPointMemoryInPolygon (Polygon);
 
   /* copy values */
   point->X = X;
   point->Y = Y;
+  point->included_angle = included_angle;
   point->ID = ID++;
   return (point);
 }
diff --git a/src/create.h b/src/create.h
index 4cf6b8f..aec69b8 100644
--- a/src/create.h
+++ b/src/create.h
@@ -49,7 +49,7 @@ ArcType * CreateNewArcOnLayer (LayerType *, Coord, Coord, Coord, Coord, Angle, A
 PolygonType * CreateNewPolygonFromRectangle (LayerType *, Coord, Coord, Coord, Coord, FlagType);
 TextType * CreateNewText (LayerType *, FontType *, Coord, Coord, unsigned, int, char *, FlagType);
 PolygonType * CreateNewPolygon (LayerType *, FlagType);
-PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord);
+PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord, Angle included_angle);
 PolygonType * CreateNewHoleInPolygon (PolygonType *polygon);
 ElementType * CreateNewElement (DataType *, FontType *, FlagType, char *, char *, char *, Coord, Coord, BYTE, int, FlagType, bool);
 LineType * CreateNewLineInElement (ElementType *, Coord, Coord, Coord, Coord, Coord);
diff --git a/src/global.h b/src/global.h
index b36aebf..a542ccf 100644
--- a/src/global.h
+++ b/src/global.h
@@ -236,8 +236,10 @@ typedef struct			/* a line/polygon point */
 {
   Coord X, Y, X2, Y2;	/* so Point type can be cast as BoxType */
   long int ID;
+  Angle included_angle;
 } PointType;
 
+
 /* Lines, rats, pads, etc.  */
 typedef struct {
   ANYLINEFIELDS;
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..51adc6c 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -782,10 +782,12 @@ fill_contour (hidGC gc, PLINE *contour)
   borast_traps_t traps;
 
   /* If the contour is round, then call hidgl_fill_circle to draw it. */
+#if 0
   if (contour->is_round) {
     hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius);
     return;
   }
+#endif
 
   /* If we don't have a cached set of tri-strips, compute them */
   if (contour->tristrip_vertices == NULL) {
diff --git a/src/insert.c b/src/insert.c
index a254998..e3721c4 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -65,6 +65,7 @@ static void *InsertPointIntoRat (RatType *);
  * some local identifiers
  */
 static Coord InsertX, InsertY;	/* used by local routines as offset */
+static Angle InsertIncludedAngle; /* Only used by polygon point insert */
 static Cardinal InsertAt;
 static bool InsertLast;
 static bool Forcible;
@@ -180,7 +181,7 @@ InsertPointIntoPolygon (LayerType *Layer, PolygonType *Polygon)
    */
   ErasePolygon (Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
+  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY, InsertIncludedAngle);
   for (n = Polygon->PointN - 1; n > InsertAt; n--)
     Polygon->Points[n] = Polygon->Points[n - 1];
 
@@ -211,7 +212,7 @@ InsertPointIntoPolygon (LayerType *Layer, PolygonType *Polygon)
  */
 void *
 InsertPointIntoObject (int Type, void *Ptr1, void *Ptr2, Cardinal * Ptr3,
-		       Coord DX, Coord DY, bool Force,
+		       Coord DX, Coord DY, Angle included_angle, bool Force,
 		       bool insert_last)
 {
   void *ptr;
@@ -219,6 +220,7 @@ InsertPointIntoObject (int Type, void *Ptr1, void *Ptr2, Cardinal * Ptr3,
   /* setup offset */
   InsertX = DX;
   InsertY = DY;
+  InsertIncludedAngle = included_angle;
   InsertAt = *Ptr3;
   InsertLast = insert_last;
   Forcible = Force;
diff --git a/src/insert.h b/src/insert.h
index 31fc6dc..6c530fb 100644
--- a/src/insert.h
+++ b/src/insert.h
@@ -38,7 +38,7 @@
  * prototypes
  */
 void *InsertPointIntoObject (int, void *, void *, Cardinal *, Coord,
-			     Coord, bool, bool);
+			     Coord, Angle, bool, bool);
 PointType * AdjustInsertPoint (void);
 
 #endif
diff --git a/src/parse_l.l b/src/parse_l.l
index 4f64880..a4e0a05 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -123,6 +123,7 @@ Groups		{ return(T_GROUPS); }
 Styles		{ return(T_STYLES); }
 Polygon		{ return(T_POLYGON); }
 Hole		{ return(T_POLYGON_HOLE); }
+included_angle: { return(T_INCLUDED_ANGLE); }
 Arc		{ return(T_ARC); }
 NetList		{ return(T_NETLIST); }
 Net		{ return(T_NET); }
diff --git a/src/parse_y.y b/src/parse_y.y
index c0350f8..79dc75b 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -118,7 +118,7 @@ static Coord new_units (PLMeasure m);
 
 %token	T_FILEVERSION T_PCB T_LAYER T_VIA T_RAT T_LINE T_ARC T_RECTANGLE T_TEXT T_ELEMENTLINE
 %token	T_ELEMENT T_PIN T_PAD T_GRID T_FLAGS T_SYMBOL T_SYMBOLLINE T_CURSOR
-%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_NETLIST T_NET T_CONN
+%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_INCLUDED_ANGLE T_NETLIST T_NET T_CONN
 %token	T_AREA T_THERMAL T_DRC T_ATTRIBUTE
 %token	T_UMIL T_CMIL T_MIL T_IN T_NM T_UM T_MM T_M T_KM T_PX
 %type	<integer>	symbolid
@@ -1182,11 +1182,15 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' measure measure ')'
 			{
-				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3));
+				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3), 0);
 			}
 		| '[' measure measure ']'
 			{
-				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3));
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), 0);
+			}
+		| '[' measure measure T_INCLUDED_ANGLE number ']'
+			{
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), $5);
 			}
 		;
 
diff --git a/src/polygon.c b/src/polygon.c
index b94fdb9..fe63a0d 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -111,6 +111,7 @@ dicer output is used for HIDs which cannot render things with holes
 #define SUBTRACT_LINE_BATCH_SIZE 20
 
 static double rotate_circle_seg[4];
+static double bw_rotate_circle_seg[4];
 
 void
 polygon_init (void)
@@ -120,6 +121,9 @@ polygon_init (void)
 
   rotate_circle_seg[0] = cos_ang;  rotate_circle_seg[1] = -sin_ang;
   rotate_circle_seg[2] = sin_ang;  rotate_circle_seg[3] =  cos_ang;
+
+  bw_rotate_circle_seg[0] =  cos_ang;  bw_rotate_circle_seg[1] =  sin_ang;
+  bw_rotate_circle_seg[2] = -sin_ang;  bw_rotate_circle_seg[3] =  cos_ang;
 }
 
 Cardinal
@@ -273,6 +277,51 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+static void
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First point, already laid by caller */, Angle sweep)
+{
+  /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
+  double e1, e2, t1;
+  int i, range;
+
+//  poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  /* move vector to origin */
+  e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
+  e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
+
+  if (sweep > 0)
+    {
+      /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
+      range = POLY_CIRC_SEGS * sweep / 360 - 1;
+      for (i = 0; i < range; i++)
+        {
+          /* rotate the vector */
+          t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
+          e2 = rotate_circle_seg[2] * e1 + rotate_circle_seg[3] * e2;
+          e1 = t1;
+          v[0] = X + ROUND (e1);
+          v[1] = Y + ROUND (e2);
+          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+        }
+    }
+  else
+    {
+      /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
+      range = POLY_CIRC_SEGS * -sweep / 360 - 1;
+      for (i = 0; i < range; i++)
+        {
+          /* rotate the vector */
+          t1 = bw_rotate_circle_seg[0] * e1 + bw_rotate_circle_seg[1] * e2;
+          e2 = bw_rotate_circle_seg[2] * e1 + bw_rotate_circle_seg[3] * e2;
+          e1 = t1;
+          v[0] = X + ROUND (e1);
+          v[1] = Y + ROUND (e2);
+          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+        }
+    }
+}
+
 static POLYAREA *
 original_poly (PolygonType * p)
 {
@@ -291,8 +340,7 @@ original_poly (PolygonType * p)
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
-      v[0] = p->Points[n].X;
-      v[1] = p->Points[n].Y;
+      v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
       if (contour == NULL)
         {
           if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
@@ -303,6 +351,77 @@ original_poly (PolygonType * p)
           poly_InclVertex (contour->head.prev, poly_CreateNode (v));
         }
 
+      if (p->Points[n].included_angle != 0)
+        {
+          Cardinal next_n;
+          Coord px, py;
+          Coord nx, ny;
+          Coord hx, hy;
+          Coord cx, cy;
+          double p_to_h_dist;
+          double c_to_h_dist;
+          double unit_hcx, unit_hcy;
+
+          next_n = n + 1;
+          if (next_n == p->PointN ||
+              (hole < p->HoleIndexN && next_n == p->HoleIndex[hole]))
+            next_n = (hole == 0) ? 0 : p->HoleIndex[hole - 1];
+
+          /* XXX: Compute center of arc */
+
+          px = p->Points[     n].X, py = p->Points[     n].Y;
+          nx = p->Points[next_n].X, ny = p->Points[next_n].Y;
+
+          /* Find the point halfway between the to points the arc spans */
+          hx = px + (nx - px) / 2;
+          hy = py + (ny - py) / 2;
+
+          /* The arc center lies on a line passing through hx, hy, perpendicular
+           * to the direction between our two end-points.
+           *
+           *              n
+           *            / |
+           *          /   |h
+           *    -----c----|-------------- line passing (hx, hy), perpendicular to p[n]-p[next_n]
+           *          \   |
+           *            \ |
+           *              p
+           *
+           *  Find cx, cy.
+           *
+           *  We know that c-p[n] = radius. (But we don't know that radius).
+           *  We have the included angle, /_ p[n].c.p[next_n]
+           *  |(hx,hy)-p[n]| = sin(angle/2) * radius
+           *
+           * tan(ang/2) = |(hx,hy)-p[n]| / |(hx,hy)-(cx,cy)|
+           *
+           * |(hx,hy)-(cx,cy)| = |(hx,hy)-p[n]| / tan(ang/2)
+           *
+           */
+
+          p_to_h_dist = sqrt (pow(nx - py, 2) + pow (ny - py, 2)) / 2.;
+          c_to_h_dist = p_to_h_dist / tan (TO_RADIANS (p->Points[n].included_angle) / 2.);
+
+          unit_hcx = (float)-(hy - py) / p_to_h_dist;
+          unit_hcy = (float)(hx - px) / p_to_h_dist;
+
+          cx = hx + unit_hcx * c_to_h_dist;
+          cy = hy + unit_hcy * c_to_h_dist;
+
+#if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          v[0] = cx, v[1] = cy;
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+#endif
+
+          degree_circle (contour, cx, cy, v, p->Points[n].included_angle);
+
+#if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          v[0] = cx, v[1] = cy;  /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+#endif
+        }
+
       /* Is current point last in contour? If so process it. */
       if (n == p->PointN - 1 ||
           (hole < p->HoleIndexN && n == p->HoleIndex[hole] - 1))
@@ -450,6 +569,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
     }
 }
 
+
 /* create a circle approximation from lines */
 POLYAREA *
 CirclePoly (Coord x, Coord y, Coord radius)
@@ -1294,7 +1414,8 @@ RemoveExcessPolygonPoints (LayerType *Layer, PolygonType *Polygon)
       line.Point1 = Polygon->Points[prev];
       line.Point2 = Polygon->Points[next];
       line.Thickness = 0;
-      if (IsPointOnLine (p->X, p->Y, 0.0, &line))
+      if (Polygon->Points[prev].included_angle == Polygon->Points[n].included_angle &&
+          IsPointOnLine (p->X, p->Y, 0.0, &line))
         {
           RemoveObject (POLYGONPOINT_TYPE, Layer, Polygon, p);
           changed = true;
@@ -1887,9 +2008,9 @@ MorphPolygon (LayerType *layer, PolygonType *poly)
             return false;
           many = true;
           v = &p->contours->head;
-          CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+          CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           for (v = v->next; v != &p->contours->head; v = v->next)
-            CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+            CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           newone->BoundingBox.X1 = p->contours->xmin;
           newone->BoundingBox.X2 = p->contours->xmax + 1;
           newone->BoundingBox.Y1 = p->contours->ymin;
@@ -2001,7 +2122,8 @@ PolyToPolygonsOnLayer (DataType *Destination, LayerType *Layer,
           do
             {
               CreateNewPointInPolygon (Polygon, node->point[0],
-                                                node->point[1]);
+                                                node->point[1],
+                                                0);
             }
           while ((node = node->next) != &pline->head);
 
diff --git a/src/undo.c b/src/undo.c
index 085fde6..6acdcb1 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -92,6 +92,7 @@ typedef struct			/* information about removed polygon points */
 {
   Coord X, Y;			/* data */
   int ID;
+  Angle IncludedAngle;
   Cardinal Index;		/* index in a polygons array of points */
   bool last_in_contour;		/* Whether the point was the last in its contour */
 } RemovedPointType;
@@ -699,7 +700,9 @@ UndoRemovePoint (UndoListType *Entry)
 	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
-			       Entry->Data.RemovedPoint.Y, true,
+			       Entry->Data.RemovedPoint.Y,
+			       Entry->Data.RemovedPoint.IncludedAngle,
+			       true,
 			       Entry->Data.RemovedPoint.last_in_contour);
 
 	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
@@ -759,6 +762,7 @@ UndoInsertPoint (UndoListType *Entry)
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
+	Entry->Data.RemovedPoint.IncludedAngle = pnt->included_angle;
 	Entry->ID = polygon->ID;
 	Entry->Kind = POLYGON_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
@@ -1339,6 +1343,7 @@ AddObjectToRemovePointUndoList (int Type,
 	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
 	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
 	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	    undo->Data.RemovedPoint.IncludedAngle = polygon->Points[index].included_angle;
 	    undo->Data.RemovedPoint.Index = index;
 
 	    /* Check whether this point was at the end of its contour.
