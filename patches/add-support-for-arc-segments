Bottom: 834e3225df9c16cc57b09f83861c93541d90a0ec
Top:    8fa9635567ea210315eff63f843ff4b7adb81b36
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-13 18:57:49 +0000

Add support for arc segments in polygon object outline definitions

Test with a polygon like this:

  Polygon("clearpoly")
  (
    [5.0000mm 7.0000mm included_angle: 90] [7.0000mm 5.0000mm]
    [28.000mm 5.0000mm included_angle: 90] [30.000mm 7.0000mm]
    [30.000mm 28.000mm included_angle: 90] [28.000mm 30.000mm]
    [7.0000mm 30.000mm included_angle: 90] [5.0000mm 28.000mm]
  )


NOTE THAT THE ARC BOUNDS ARE NOT YET INCLUDED IN THE BOUNDING BOX CALCULATION,
SO THIS WILL BREAK VARIOUS THINGS PRETTY HORRIBLY IF AN ARC PROTRUDES AS AN
EXTREME FEATURE IN EITHER THE +/-X or +/-Y DIRECTIONS.


---

diff --git a/src/action.c b/src/action.c
index 20e2895..388cddd 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1439,7 +1439,8 @@ NotifyMode (void)
 	  {
 	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+				     Crosshair.AttachedLine.Point2.Y,
+				     0);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1530,7 +1531,8 @@ NotifyMode (void)
 		{
 		  CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 					   Crosshair.AttachedLine.Point2.X,
-					   Crosshair.AttachedLine.Point2.Y);
+					   Crosshair.AttachedLine.Point2.Y,
+					   0);
 
 		  /* copy the coordinates */
 		  Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1753,13 +1755,13 @@ NotifyMode (void)
 	    InsertPointIntoObject (POLYGON_TYPE,
 				   Crosshair.AttachedObject.Ptr1, fake.poly,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, false, false);
+				   InsertedPoint.X, InsertedPoint.Y, 0, false, false);
 	  else
 	    InsertPointIntoObject (Crosshair.AttachedObject.Type,
 				   Crosshair.AttachedObject.Ptr1,
 				   Crosshair.AttachedObject.Ptr2,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, false, false);
+				   InsertedPoint.X, InsertedPoint.Y, 0, false, false);
 	  SetChangedFlag (true);
 
 	  /* reset identifiers */
diff --git a/src/copy.c b/src/copy.c
index 3e070e5..9b11e7d 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -106,7 +106,7 @@ CopyPolygonLowLevel (PolygonType *Dest, PolygonType *Src)
           CreateNewHoleInPolygon (Dest);
           hole++;
         }
-      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y);
+      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y, Src->Points[n].included_angle);
     }
   SetPolygonBoundingBox (Dest);
   Dest->Flags = Src->Flags;
diff --git a/src/create.c b/src/create.c
index 51435f4..adc32be 100644
--- a/src/create.c
+++ b/src/create.c
@@ -601,10 +601,10 @@ CreateNewPolygonFromRectangle (LayerType *Layer,
   if (!polygon)
     return (polygon);
 
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
+  CreateNewPointInPolygon (polygon, X1, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y2, 0);
+  CreateNewPointInPolygon (polygon, X1, Y2, 0);
   SetPolygonBoundingBox (polygon);
   if (!Layer->polygon_tree)
     Layer->polygon_tree = r_create_tree (NULL, 0, 0);
@@ -669,13 +669,14 @@ CreateNewPolygon (LayerType *Layer, FlagType Flags)
  * \brief Creates a new point in a polygon.
  */
 PointType *
-CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y)
+CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y, Angle included_angle)
 {
   PointType *point = GetPointMemoryInPolygon (Polygon);
 
   /* copy values */
   point->X = X;
   point->Y = Y;
+  point->included_angle = included_angle;
   point->ID = ID++;
   return (point);
 }
diff --git a/src/create.h b/src/create.h
index 76b5769..22404ac 100644
--- a/src/create.h
+++ b/src/create.h
@@ -49,7 +49,7 @@ ArcType * CreateNewArcOnLayer (LayerType *, Coord, Coord, Coord, Coord, Angle, A
 PolygonType * CreateNewPolygonFromRectangle (LayerType *, Coord, Coord, Coord, Coord, FlagType);
 TextType * CreateNewText (LayerType *, FontType *, Coord, Coord, unsigned, int, char *, FlagType);
 PolygonType * CreateNewPolygon (LayerType *, FlagType);
-PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord);
+PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord, Angle included_angle);
 PolygonType * CreateNewHoleInPolygon (PolygonType *polygon);
 void RefdesMapInit (void);
 ElementType * CreateNewElement (DataType *, FontType *, FlagType, char *, char *, char *, Coord, Coord, BYTE, int, FlagType, bool);
diff --git a/src/global.h b/src/global.h
index b36aebf..a542ccf 100644
--- a/src/global.h
+++ b/src/global.h
@@ -236,8 +236,10 @@ typedef struct			/* a line/polygon point */
 {
   Coord X, Y, X2, Y2;	/* so Point type can be cast as BoxType */
   long int ID;
+  Angle included_angle;
 } PointType;
 
+
 /* Lines, rats, pads, etc.  */
 typedef struct {
   ANYLINEFIELDS;
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..51adc6c 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -782,10 +782,12 @@ fill_contour (hidGC gc, PLINE *contour)
   borast_traps_t traps;
 
   /* If the contour is round, then call hidgl_fill_circle to draw it. */
+#if 0
   if (contour->is_round) {
     hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius);
     return;
   }
+#endif
 
   /* If we don't have a cached set of tri-strips, compute them */
   if (contour->tristrip_vertices == NULL) {
diff --git a/src/insert.c b/src/insert.c
index a254998..e3721c4 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -65,6 +65,7 @@ static void *InsertPointIntoRat (RatType *);
  * some local identifiers
  */
 static Coord InsertX, InsertY;	/* used by local routines as offset */
+static Angle InsertIncludedAngle; /* Only used by polygon point insert */
 static Cardinal InsertAt;
 static bool InsertLast;
 static bool Forcible;
@@ -180,7 +181,7 @@ InsertPointIntoPolygon (LayerType *Layer, PolygonType *Polygon)
    */
   ErasePolygon (Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
+  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY, InsertIncludedAngle);
   for (n = Polygon->PointN - 1; n > InsertAt; n--)
     Polygon->Points[n] = Polygon->Points[n - 1];
 
@@ -211,7 +212,7 @@ InsertPointIntoPolygon (LayerType *Layer, PolygonType *Polygon)
  */
 void *
 InsertPointIntoObject (int Type, void *Ptr1, void *Ptr2, Cardinal * Ptr3,
-		       Coord DX, Coord DY, bool Force,
+		       Coord DX, Coord DY, Angle included_angle, bool Force,
 		       bool insert_last)
 {
   void *ptr;
@@ -219,6 +220,7 @@ InsertPointIntoObject (int Type, void *Ptr1, void *Ptr2, Cardinal * Ptr3,
   /* setup offset */
   InsertX = DX;
   InsertY = DY;
+  InsertIncludedAngle = included_angle;
   InsertAt = *Ptr3;
   InsertLast = insert_last;
   Forcible = Force;
diff --git a/src/insert.h b/src/insert.h
index 31fc6dc..6c530fb 100644
--- a/src/insert.h
+++ b/src/insert.h
@@ -38,7 +38,7 @@
  * prototypes
  */
 void *InsertPointIntoObject (int, void *, void *, Cardinal *, Coord,
-			     Coord, bool, bool);
+			     Coord, Angle, bool, bool);
 PointType * AdjustInsertPoint (void);
 
 #endif
diff --git a/src/parse_l.l b/src/parse_l.l
index 4f64880..a4e0a05 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -123,6 +123,7 @@ Groups		{ return(T_GROUPS); }
 Styles		{ return(T_STYLES); }
 Polygon		{ return(T_POLYGON); }
 Hole		{ return(T_POLYGON_HOLE); }
+included_angle: { return(T_INCLUDED_ANGLE); }
 Arc		{ return(T_ARC); }
 NetList		{ return(T_NETLIST); }
 Net		{ return(T_NET); }
diff --git a/src/parse_y.y b/src/parse_y.y
index c0350f8..79dc75b 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -118,7 +118,7 @@ static Coord new_units (PLMeasure m);
 
 %token	T_FILEVERSION T_PCB T_LAYER T_VIA T_RAT T_LINE T_ARC T_RECTANGLE T_TEXT T_ELEMENTLINE
 %token	T_ELEMENT T_PIN T_PAD T_GRID T_FLAGS T_SYMBOL T_SYMBOLLINE T_CURSOR
-%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_NETLIST T_NET T_CONN
+%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_INCLUDED_ANGLE T_NETLIST T_NET T_CONN
 %token	T_AREA T_THERMAL T_DRC T_ATTRIBUTE
 %token	T_UMIL T_CMIL T_MIL T_IN T_NM T_UM T_MM T_M T_KM T_PX
 %type	<integer>	symbolid
@@ -1182,11 +1182,15 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' measure measure ')'
 			{
-				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3));
+				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3), 0);
 			}
 		| '[' measure measure ']'
 			{
-				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3));
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), 0);
+			}
+		| '[' measure measure T_INCLUDED_ANGLE number ']'
+			{
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), $5);
 			}
 		;
 
diff --git a/src/polygon.c b/src/polygon.c
index 0beae50..f1cf3eb 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -111,6 +111,7 @@ dicer output is used for HIDs which cannot render things with holes
 #define SUBTRACT_LINE_BATCH_SIZE 20
 
 static double rotate_circle_seg[4];
+static double bw_rotate_circle_seg[4];
 
 void
 polygon_init (void)
@@ -120,6 +121,9 @@ polygon_init (void)
 
   rotate_circle_seg[0] = cos_ang;  rotate_circle_seg[1] = -sin_ang;
   rotate_circle_seg[2] = sin_ang;  rotate_circle_seg[3] =  cos_ang;
+
+  bw_rotate_circle_seg[0] =  cos_ang;  bw_rotate_circle_seg[1] =  sin_ang;
+  bw_rotate_circle_seg[2] = -sin_ang;  bw_rotate_circle_seg[3] =  cos_ang;
 }
 
 Cardinal
@@ -273,6 +277,51 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+static void
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First point, already laid by caller */, Angle sweep)
+{
+  /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
+  double e1, e2, t1;
+  int i, range;
+
+//  poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  /* move vector to origin */
+  e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
+  e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
+
+  if (sweep > 0)
+    {
+      /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
+      range = POLY_CIRC_SEGS * sweep / 360 - 1;
+      for (i = 0; i < range; i++)
+        {
+          /* rotate the vector */
+          t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
+          e2 = rotate_circle_seg[2] * e1 + rotate_circle_seg[3] * e2;
+          e1 = t1;
+          v[0] = X + ROUND (e1);
+          v[1] = Y + ROUND (e2);
+          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+        }
+    }
+  else
+    {
+      /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
+      range = POLY_CIRC_SEGS * -sweep / 360 - 1;
+      for (i = 0; i < range; i++)
+        {
+          /* rotate the vector */
+          t1 = bw_rotate_circle_seg[0] * e1 + bw_rotate_circle_seg[1] * e2;
+          e2 = bw_rotate_circle_seg[2] * e1 + bw_rotate_circle_seg[3] * e2;
+          e1 = t1;
+          v[0] = X + ROUND (e1);
+          v[1] = Y + ROUND (e2);
+          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+        }
+    }
+}
+
 static POLYAREA *
 original_poly (PolygonType * p)
 {
@@ -291,8 +340,7 @@ original_poly (PolygonType * p)
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
-      v[0] = p->Points[n].X;
-      v[1] = p->Points[n].Y;
+      v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
       if (contour == NULL)
         {
           if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
@@ -303,6 +351,77 @@ original_poly (PolygonType * p)
           poly_InclVertex (contour->head.prev, poly_CreateNode (v));
         }
 
+      if (p->Points[n].included_angle != 0)
+        {
+          Cardinal next_n;
+          Coord px, py;
+          Coord nx, ny;
+          Coord hx, hy;
+          Coord cx, cy;
+          double p_to_h_dist;
+          double c_to_h_dist;
+          double unit_hcx, unit_hcy;
+
+          next_n = n + 1;
+          if (next_n == p->PointN ||
+              (hole < p->HoleIndexN && next_n == p->HoleIndex[hole]))
+            next_n = (hole == 0) ? 0 : p->HoleIndex[hole - 1];
+
+          /* XXX: Compute center of arc */
+
+          px = p->Points[     n].X, py = p->Points[     n].Y;
+          nx = p->Points[next_n].X, ny = p->Points[next_n].Y;
+
+          /* Find the point halfway between the to points the arc spans */
+          hx = px + (nx - px) / 2;
+          hy = py + (ny - py) / 2;
+
+          /* The arc center lies on a line passing through hx, hy, perpendicular
+           * to the direction between our two end-points.
+           *
+           *              n
+           *            / |
+           *          /   |h
+           *    -----c----|-------------- line passing (hx, hy), perpendicular to p[n]-p[next_n]
+           *          \   |
+           *            \ |
+           *              p
+           *
+           *  Find cx, cy.
+           *
+           *  We know that c-p[n] = radius. (But we don't know that radius).
+           *  We have the included angle, /_ p[n].c.p[next_n]
+           *  |(hx,hy)-p[n]| = sin(angle/2) * radius
+           *
+           * tan(ang/2) = |(hx,hy)-p[n]| / |(hx,hy)-(cx,cy)|
+           *
+           * |(hx,hy)-(cx,cy)| = |(hx,hy)-p[n]| / tan(ang/2)
+           *
+           */
+
+          p_to_h_dist = sqrt (pow(nx - py, 2) + pow (ny - py, 2)) / 2.;
+          c_to_h_dist = p_to_h_dist / tan (TO_RADIANS (p->Points[n].included_angle) / 2.);
+
+          unit_hcx = (float)-(hy - py) / p_to_h_dist;
+          unit_hcy = (float)(hx - px) / p_to_h_dist;
+
+          cx = hx + unit_hcx * c_to_h_dist;
+          cy = hy + unit_hcy * c_to_h_dist;
+
+#if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          v[0] = cx, v[1] = cy;
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+#endif
+
+          degree_circle (contour, cx, cy, v, p->Points[n].included_angle);
+
+#if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          v[0] = cx, v[1] = cy;  /* DEBUG TO SHOW THE CENTER OF THE ARC */
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+#endif
+        }
+
       /* Is current point last in contour? If so process it. */
       if (n == p->PointN - 1 ||
           (hole < p->HoleIndexN && n == p->HoleIndex[hole] - 1))
@@ -450,6 +569,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
     }
 }
 
+
 /* create a circle approximation from lines */
 POLYAREA *
 CirclePoly (Coord x, Coord y, Coord radius)
@@ -1294,7 +1414,8 @@ RemoveExcessPolygonPoints (LayerType *Layer, PolygonType *Polygon)
       line.Point1 = Polygon->Points[prev];
       line.Point2 = Polygon->Points[next];
       line.Thickness = 0;
-      if (IsPointOnLine (p->X, p->Y, 0.0, &line))
+      if (Polygon->Points[prev].included_angle == Polygon->Points[n].included_angle &&
+          IsPointOnLine (p->X, p->Y, 0.0, &line))
         {
           RemoveObject (POLYGONPOINT_TYPE, Layer, Polygon, p);
           changed = true;
@@ -1888,9 +2009,9 @@ MorphPolygon (LayerType *layer, PolygonType *poly)
             return false;
           many = true;
           v = &p->contours->head;
-          CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+          CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           for (v = v->next; v != &p->contours->head; v = v->next)
-            CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+            CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           newone->BoundingBox.X1 = p->contours->xmin;
           newone->BoundingBox.X2 = p->contours->xmax + 1;
           newone->BoundingBox.Y1 = p->contours->ymin;
@@ -2002,7 +2123,8 @@ PolyToPolygonsOnLayer (DataType *Destination, LayerType *Layer,
           do
             {
               CreateNewPointInPolygon (Polygon, node->point[0],
-                                                node->point[1]);
+                                                node->point[1],
+                                                0);
             }
           while ((node = node->next) != &pline->head);
 
diff --git a/src/polygon.h b/src/polygon.h
index a02fd99..369efea 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -37,11 +37,28 @@
 #define POLY_CIRC_SEGS 40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
+#if 0
+/* THIS IS BROKEN:
+ *
+ * IT BREAKS THE CIRCULARITY OF CIRULAR CONTORS, AS THE FIRST
+ * FIRST VERTEX ADDED BY CirclePoly IS NOT RADIUS ADJUSTED.
+ *
+ * IT BREAKS CIRCULARITY OF ALIGMENT BETWEEN A LINE AND ITS END-CAPS,
+ * LEADING TO MORE COMPLEX CONTOURS FOR COMMON LINE-LINE INTERSECTIONS,
+ * SUCH AS 90 AND 45 DEGREE ANGLES
+ *
+ * IT WAS INTENDED TO AVOID DRC ERRORS WITH "TOO-CLOSE" FEATURES,
+ * BUT COULD OTHERWISE CAUSE THEM FOR "TOO THIN" FEATURES - INSIDE/OUTSIDE
+ * CONTOUR APPROXIMATION NEEDS TO BE CONTROLED DEPENDING ON THE REQUIREMENT
+ */
 /* adjustment to make the segments outline the circle rather than connect
  * points on the circle: 1 - cos (\alpha / 2) < (\alpha / 2) ^ 2 / 2
  */
 #define POLY_CIRC_RADIUS_ADJ (1.0 + M_PI / POLY_CIRC_SEGS_F * \
                                     M_PI / POLY_CIRC_SEGS_F / 2.0)
+#else
+#define POLY_CIRC_RADIUS_ADJ 1.0
+#endif
 
 /* polygon diverges from modelled arc no more than MAX_ARC_DEVIATION * thick */
 #define POLY_ARC_MAX_DEVIATION 0.02
diff --git a/src/undo.c b/src/undo.c
index 085fde6..6acdcb1 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -92,6 +92,7 @@ typedef struct			/* information about removed polygon points */
 {
   Coord X, Y;			/* data */
   int ID;
+  Angle IncludedAngle;
   Cardinal Index;		/* index in a polygons array of points */
   bool last_in_contour;		/* Whether the point was the last in its contour */
 } RemovedPointType;
@@ -699,7 +700,9 @@ UndoRemovePoint (UndoListType *Entry)
 	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
-			       Entry->Data.RemovedPoint.Y, true,
+			       Entry->Data.RemovedPoint.Y,
+			       Entry->Data.RemovedPoint.IncludedAngle,
+			       true,
 			       Entry->Data.RemovedPoint.last_in_contour);
 
 	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
@@ -759,6 +762,7 @@ UndoInsertPoint (UndoListType *Entry)
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
+	Entry->Data.RemovedPoint.IncludedAngle = pnt->included_angle;
 	Entry->ID = polygon->ID;
 	Entry->Kind = POLYGON_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
@@ -1339,6 +1343,7 @@ AddObjectToRemovePointUndoList (int Type,
 	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
 	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
 	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	    undo->Data.RemovedPoint.IncludedAngle = polygon->Points[index].included_angle;
 	    undo->Data.RemovedPoint.Index = index;
 
 	    /* Check whether this point was at the end of its contour.
