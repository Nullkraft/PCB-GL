Bottom: 2cc0405c7d1f652fe83eed3caec7d2b923af056b
Top:    8689477a27f06497fae45286c91b4161ef191ae3
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-02 05:06:14 +0000

Improve GL stuff:

Use native coordinates, and GL Matrix etc..

Use VBO to try and avoid copying data


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index eea4f77..eb1044f 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -15,6 +15,12 @@
 #include <time.h>
 #include <assert.h>
 
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
 #include <GL/gl.h>
 #include <GL/glu.h>
 
@@ -41,8 +47,6 @@
 
 RCSID ("$Id: $");
 
-#define USE_GC(x)
-
 triangle_buffer buffer;
 
 #if 0
@@ -56,10 +60,28 @@ hidgl_new_triangle_array (void)
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, buffer->triangle_array);
+  GLenum errCode;
+  const GLubyte *errString;
+
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glGenBuffers (1, &buffer->vbo_name);
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_name);
+  glBufferData (GL_ARRAY_BUFFER, TRIANGLE_ARRAY_BYTES, NULL, GL_STATIC_DRAW);
+
+  buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "OpenGL Error: %s\n", errString);
+  }
+
+  if (buffer->triangle_array == NULL) {
+    printf ("Couldn't map VBO.. sorry, don't know how best to handle this gracefully\n");
+    exit (1);
+  }
 }
 
 void
@@ -68,9 +90,18 @@ hidgl_flush_triangles (triangle_buffer *buffer)
   if (buffer->triangle_count == 0)
     return;
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+
+  glVertexPointer (2, GL_FLOAT, 0, NULL); // buffer->triangle_array);
   glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+
+//  buffer->triangle_count = 0;
+//  buffer->coord_comp_count = 0;
+
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer->vbo_name);
+
+  hidgl_init_triangle_array (buffer);
 }
 
 void
@@ -260,87 +291,43 @@ hidgl_use_mask (int use_it)
 #endif
 
 
-typedef struct
-{
-  int color_set;
-//  GdkColor color;
-  int xor_set;
-//  GdkColor xor_color;
-  double red;
-  double green;
-  double blue;
-} ColorCache;
-
-
-void
-hidgl_set_draw_xor (hidGC gc, int xor)
-{
-  // printf ("hidgl_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
-  /* NOT IMPLEMENTED */
-
-  /* Only presently called when setting up a crosshair GC.
-   * We manage our own drawing model for that anyway. */
-}
-
-void
-hidgl_set_draw_faded (hidGC gc, int faded)
-{
-  printf ("hidgl_set_draw_faded(%p,%d) -- not implemented\n", gc, faded);
-}
-
-void
-hidgl_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
-{
-  printf ("hidgl_set_line_cap_angle() -- not implemented\n");
-}
-
-#if 0
-static void
-use_gc (hidGC gc)
+#define MIN_TRIANGLES_PER_CAP 3
+#define MAX_TRIANGLES_PER_CAP 90
+static void draw_cap (double width, int x, int y, double angle, double scale)
 {
-  static hidGC current_gc = NULL;
-
-  if (current_gc == gc)
-    return;
+  float last_capx, last_capy;
+  float capx, capy;
+  float radius = width / 2.;
+  int slices = M_PI * radius / scale / PIXELS_PER_CIRCLINE;
+  int i;
 
-  current_gc = gc;
+  if (slices < MIN_TRIANGLES_PER_CAP)
+    slices = MIN_TRIANGLES_PER_CAP;
 
-  hidgl_set_color (gc, gc->colorname);
-}
-#endif
+  if (slices > MAX_TRIANGLES_PER_CAP)
+    slices = MAX_TRIANGLES_PER_CAP;
 
-static void
-errorCallback(GLenum errorCode)
-{
-   const GLubyte *estring;
+  hidgl_ensure_triangle_space (&buffer, slices);
 
-   estring = gluErrorString(errorCode);
-   fprintf(stderr, "Quadric Error: %s\n", estring);
-//   exit(0);
+  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
+  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
+  for (i = 0; i < slices; i++) {
+    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
+    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
+    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
+    last_capx = capx;
+    last_capy = capy;
+  }
 }
 
-
 void
-hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2)
+hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale)
 {
-#define TRIANGLES_PER_CAP 15
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 1000
   double angle;
   float deltax, deltay, length;
   float wdx, wdy;
-  int slices;
   int circular_caps = 0;
 
-#if 0
-  if (! ClipLine (0, 0, gport->width, gport->height,
-  if (! ClipLine (0, 0, gport->width, gport->height,
-                  &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
-    return;
-#endif
-
-  USE_GC (gc);
-
   if (width == 0.0)
     width = 1.0;
 
@@ -350,9 +337,13 @@ hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2
   length = sqrt (deltax * deltax + deltay * deltay);
 
   if (length == 0) {
+    /* Assume the orientation of the line is horizontal */
     angle = 0;
     wdx = -width / 2.;
     wdy = 0;
+    length = 1.;
+    deltax = 1.;
+    deltay = 0.;
   } else {
     wdy = deltax * width / 2. / length;
     wdx = -deltay * width / 2. / length;
@@ -366,16 +357,6 @@ hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2
       angle += 180.;
   }
 
-  slices = M_PI * width / PIXELS_PER_CIRCLINE;
-
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-//  slices = TRIANGLES_PER_CAP;
-
   switch (cap) {
     case Trace_Cap:
     case Round_Cap:
@@ -398,111 +379,82 @@ hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2
   hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
                                x2 + wdx, y2 + wdy,
                                x1 + wdx, y1 + wdy);
-
-  if (circular_caps) {
-    int i;
-    float last_capx, last_capy;
-
-    hidgl_ensure_triangle_space (&buffer, 2 * slices);
-
-    last_capx = ((float)width) / 2. * cos (angle * M_PI / 180.) + x1;
-    last_capy = -((float)width) / 2. * sin (angle * M_PI / 180.) + y1;
-    for (i = 0; i < slices; i++) {
-      float capx, capy;
-      capx = ((float)width) / 2. * cos (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x1;
-      capy = -((float)width) / 2. * sin (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y1;
-      hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x1, y1);
-      last_capx = capx;
-      last_capy = capy;
-    }
-    last_capx = -((float)width) / 2. * cos (angle * M_PI / 180.) + x2;
-    last_capy = ((float)width) / 2. * sin (angle * M_PI / 180.) + y2;
-    for (i = 0; i < slices; i++) {
-      float capx, capy;
-      capx = -((float)width) / 2. * cos (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x2;
-      capy = ((float)width) / 2. * sin (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y2;
-      hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x2, y2);
-      last_capx = capx;
-      last_capy = capy;
+  if (circular_caps)
+    {
+      draw_cap (width, x1, y1, angle, scale);
+      draw_cap (width, x2, y2, angle + 180., scale);
     }
-  }
 }
 
+#define MIN_SLICES_PER_ARC 6
+#define MAX_SLICES_PER_ARC 360
 void
-hidgl_draw_arc (hidGC gc, double width, int vx, int vy,
-               int vrx, int vry, int start_angle, int delta_angle,
-               int flip_x, int flip_y)
+hidgl_draw_arc (double width, int x, int y, int rx, int ry,
+                int start_angle, int delta_angle, double scale)
 {
-#define MIN_SLICES_PER_ARC 10
+  float last_inner_x, last_inner_y;
+  float last_outer_x, last_outer_y;
+  float inner_x, inner_y;
+  float outer_x, outer_y;
+  float inner_r;
+  float outer_r;
+  float cos_ang, sin_ang;
+  float start_angle_rad;
+  float delta_angle_rad;
+  float angle_incr_rad;
   int slices;
-  GLUquadricObj *qobj;
-
-  USE_GC (gc);
+  int i;
 
   if (width == 0.0)
     width = 1.0;
 
-  if (flip_x)
-    {
-      start_angle = 180 - start_angle;
-      delta_angle = - delta_angle;
-    }
-  if (flip_y)
-    {
-      start_angle = - start_angle;
-      delta_angle = - delta_angle;
-    }
-  /* make sure we fall in the -180 to +180 range */
-  start_angle = (start_angle + 360 + 180) % 360 - 180;
-  start_angle = (start_angle + 360 + 180) % 360 - 180;
+  inner_r = rx - width / 2.;
+  outer_r = rx + width / 2.;
 
-  if (delta_angle < 0) {
-    start_angle += delta_angle;
-    delta_angle = - delta_angle;
-  }
-
-  slices = M_PI * (vrx + width / 2.) / PIXELS_PER_CIRCLINE;
+  slices = M_PI * (rx + width / 2.) / scale / PIXELS_PER_CIRCLINE;
 
   if (slices < MIN_SLICES_PER_ARC)
     slices = MIN_SLICES_PER_ARC;
 
-  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
-  qobj = gluNewQuadric ();
-  gluQuadricCallback (qobj, GLU_ERROR, errorCallback);
-  gluQuadricDrawStyle (qobj, GLU_FILL); /* smooth shaded */
-  gluQuadricNormals (qobj, GLU_SMOOTH);
-
-  glPushMatrix ();
-  glTranslatef (vx, vy, 0.0);
-  gluPartialDisk (qobj, vrx - width / 2, vrx + width / 2, slices, 1, 270 + start_angle, delta_angle);
-  glPopMatrix ();
-
-  slices = M_PI * width / PIXELS_PER_CIRCLINE;
-
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
+  if (slices > MAX_SLICES_PER_ARC)
+    slices = MAX_SLICES_PER_ARC;
+
+  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+
+  start_angle_rad = start_angle * M_PI / 180.;
+  delta_angle_rad = delta_angle * M_PI / 180.;
+  angle_incr_rad = delta_angle_rad / (float)slices;
+
+  cos_ang = cosf (start_angle_rad);
+  sin_ang = sinf (start_angle_rad);
+  last_inner_x = -inner_r * cos_ang + x;  last_inner_y = inner_r * sin_ang + y;
+  last_outer_x = -outer_r * cos_ang + x;  last_outer_y = outer_r * sin_ang + y;
+  for (i = 1; i <= slices; i++) {
+    cos_ang = cosf (start_angle_rad + ((float)(i)) * angle_incr_rad);
+    sin_ang = sinf (start_angle_rad + ((float)(i)) * angle_incr_rad);
+    inner_x = -inner_r * cos_ang + x;  inner_y = inner_r * sin_ang + y;
+    outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
+    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
+                                 last_outer_x, last_outer_y,
+                                 outer_x, outer_y);
+    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
+                                 inner_x, inner_y,
+                                 outer_x, outer_y);
+    last_inner_x = inner_x;  last_inner_y = inner_y;
+    last_outer_x = outer_x;  last_outer_y = outer_y;
+  }
 
-  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
-  glPushMatrix ();
-  glTranslatef (vx + vrx * -cos (M_PI / 180. * start_angle),
-                vy + vrx *  sin (M_PI / 180. * start_angle), 0.0);
-  gluPartialDisk (qobj, 0, width / 2, slices, 1, start_angle + 90., 180);
-  glPopMatrix ();
-
-  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
-  glPushMatrix ();
-  glTranslatef (vx + vrx * -cos (M_PI / 180. * (start_angle + delta_angle)),
-                vy + vrx *  sin (M_PI / 180. * (start_angle + delta_angle)), 0.0);
-  gluPartialDisk (qobj, 0, width / 2, slices, 1, start_angle + delta_angle + 270., 180);
-  glPopMatrix ();
-
-  gluDeleteQuadric (qobj);
+  draw_cap (width, x + rx * -cosf (start_angle_rad),
+                   y + rx *  sinf (start_angle_rad),
+                   start_angle, scale);
+  draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
+                   y + rx *  sinf (start_angle_rad + delta_angle_rad),
+                   start_angle + delta_angle + 180., scale);
 }
 
 void
-hidgl_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
-  USE_GC (gc);
   glBegin (GL_LINE_LOOP);
   glVertex2f (x1, y1);
   glVertex2f (x1, y2);
@@ -513,18 +465,16 @@ hidgl_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 
 
 void
-hidgl_fill_circle (hidGC gc, int vx, int vy, int vr)
+hidgl_fill_circle (int vx, int vy, int vr, double scale)
 {
-#define TRIANGLES_PER_CIRCLE 30
 #define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 2000
+#define MAX_TRIANGLES_PER_CIRCLE 360
   float last_x, last_y;
+  float radius = vr;
   int slices;
   int i;
 
-  USE_GC (gc);
-
-  slices = M_PI * 2 * vr / PIXELS_PER_CIRCLINE;
+  slices = M_PI * 2 * vr / scale / PIXELS_PER_CIRCLINE;
 
   if (slices < MIN_TRIANGLES_PER_CIRCLE)
     slices = MIN_TRIANGLES_PER_CIRCLE;
@@ -532,8 +482,6 @@ hidgl_fill_circle (hidGC gc, int vx, int vy, int vr)
   if (slices > MAX_TRIANGLES_PER_CIRCLE)
     slices = MAX_TRIANGLES_PER_CIRCLE;
 
-//  slices = TRIANGLES_PER_CIRCLE;
-
   hidgl_ensure_triangle_space (&buffer, slices);
 
   last_x = vx + vr;
@@ -541,8 +489,8 @@ hidgl_fill_circle (hidGC gc, int vx, int vy, int vr)
 
   for (i = 0; i < slices; i++) {
     float x, y;
-    x = ((float)vr) * cos (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = ((float)vr) * sin (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
     hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
     last_x = x;
     last_y = y;
@@ -664,14 +612,13 @@ myVertex (GLdouble *vertex_data)
 }
 
 void
-hidgl_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
+hidgl_fill_polygon (int n_coords, int *x, int *y)
 {
   int i;
-
   GLUtesselator *tobj;
   GLdouble *vertices;
 
-  USE_GC (gc);
+//  return;
 
   assert (n_coords > 0);
 
@@ -703,9 +650,8 @@ hidgl_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
-hidgl_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
-  USE_GC (gc);
   glBegin (GL_QUADS);
   glVertex2f (x1, y1);
   glVertex2f (x1, y2);
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 969cf91..f82056a 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -25,14 +25,17 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
-//#include <GL/gl.h>
-//#include <GL/glu.h>
-
-#define TRIANGLE_ARRAY_SIZE 5000
+//#define TRIANGLE_ARRAY_SIZE 5000
+#define TRIANGLE_ARRAY_SIZE 5461
+/* Assumes GLFloat is 4 bytes, and we have X,Y coords x3 for each triangle:
+   4 * 5461 * 2 * 3 = 109464 */
+#define TRIANGLE_ARRAY_BYTES 131072
 typedef struct {
-  GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+//  GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  GLuint vbo_name;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
@@ -59,15 +62,12 @@ hidgl_add_triangle (triangle_buffer *buffer,
 // void draw_grid ()
 // int hidgl_set_layer (const char *name, int group, int empty)
 // void hidgl_use_mask (int use_it)
-// void hidgl_set_draw_xor (hidGC gc, int xor)
-void hidgl_set_draw_faded (hidGC gc, int faded);
-void hidgl_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2);
-void hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2);
-void hidgl_draw_arc (hidGC gc, double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, int flip_x, int flip_y);
-void hidgl_draw_rect (hidGC gc, int x1, int y1, int x2, int y2);
-void hidgl_fill_circle (hidGC gc, int vx, int vy, int vr);
-void hidgl_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
-void hidgl_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
+void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
+void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
+void hidgl_draw_rect (int x1, int y1, int x2, int y2);
+void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_polygon (int n_coords, int *x, int *y);
+void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 1519f5d..3df3d4c 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -44,15 +44,13 @@
 #include <dmalloc.h>
 #endif
 
-#define PIXELS_PER_CIRCLINE 5.
-
 RCSID ("$Id: gtkhid-main.c,v 1.59 2008-12-27 19:06:04 djdelorie Exp $");
 
 
 extern HID ghid_hid;
 
 static int ghid_gui_is_up = 0;
-
+static hidGC current_gc = NULL;
 
 static void zoom_to (double factor, int x, int y);
 static void zoom_by (double factor, int x, int y);
@@ -469,7 +467,7 @@ draw_grid ()
 
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisable (GL_COLOR_LOGIC_OP);
-  glFlush ();
+//  glFlush ();
 }
 
 /* ------------------------------------------------------------ */
@@ -862,11 +860,15 @@ ghid_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
+void
+ghid_invalidate_current_gc (void)
+{
+  current_gc = NULL;
+}
+
 static void
 use_gc (hidGC gc)
 {
-  static hidGC current_gc = NULL;
-
   if (current_gc == gc)
     return;
 
@@ -875,82 +877,50 @@ use_gc (hidGC gc)
   ghid_set_color (gc, gc->colorname);
 }
 
+static inline double
+clamp_min_width (double width)
+{
+  double min_width = gport->zoom;
+
+  if (width < min_width)
+    return min_width;
+
+  return width;
+}
 
 void
 ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  double width = Vz (gc->width);
-
   USE_GC (gc);
 
-  hidgl_draw_line (gc, gc->cap, width, Vx (x1), Vy (y1), Vx (x2), Vy (y2));
+  hidgl_draw_line (gc->cap, clamp_min_width (gc->width), x1, y1, x2, y2, gport->zoom);
 }
 
 void
-ghid_draw_arc (hidGC gc, int cx, int cy,
-               int xradius, int yradius, int start_angle, int delta_angle)
-{
-  gint w, h, radius;
-  double width = Vz (gc->width);
-
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-  radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius 
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
-    return;
-
+ghid_draw_arc (hidGC gc, int cx, int cy, int xradius, int yradius,
+                         int start_angle, int delta_angle)
+{
   USE_GC (gc);
 
-  hidgl_draw_arc (gc, width, Vx (cx), Vy (cy),
-                  Vz (xradius), Vz (yradius),
-                  start_angle, delta_angle,
-                  ghid_flip_x, ghid_flip_y);
+  hidgl_draw_arc (clamp_min_width (gc->width), cx, cy, xradius, yradius,
+                  start_angle, delta_angle, gport->zoom);
 }
 
 void
 ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw;
-
-  lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-	  && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw 
-	  && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw 
-	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
-    return;
-
   USE_GC (gc);
 
-  hidgl_draw_rect (gc, Vx (x1), Vy (y1), Vx (x2), Vy (y2));
+  hidgl_draw_rect (x1, y1, x2, y2);
 }
 
 
 void
 ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
-  gint w, h;
-
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius 
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
-    return;
-
   USE_GC (gc);
 
-  hidgl_fill_circle (gc, Vx (cx), Vy (cy), Vz (radius));
+  hidgl_fill_circle (cx, cy, radius, gport->zoom);
 }
 
 
@@ -959,31 +929,15 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 {
   USE_GC (gc);
 
-  hidgl_fill_polygon (gc, n_coords, x, y);
+  hidgl_fill_polygon (n_coords, x, y);
 }
 
 void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw;
-
-  lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-          && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw
-          && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw
-          && SIDE_Y (y2) > gport->view_y0 + h + lw))
-    return;
-
   USE_GC (gc);
 
-  hidgl_fill_rect (gc, Vx (x1), Vy (y1), Vx (x2), Vy (y2));
+  hidgl_fill_rect (x1, y1, x2, y2);
 }
 
 void
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 8219579..17ecae2 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -1064,18 +1064,48 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   /* TODO: Background image */
 
   hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, &region, 0);
   hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
 
   draw_grid ();
 
   hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
   DrawAttached (TRUE);
   DrawMark (TRUE);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index 5134741..bebaf96 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -224,8 +224,21 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev)
 
   /* call the drawing routine */
   hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 08bb5a9..c51a0c9 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -35,9 +35,15 @@
 
 #include <gtk/gtk.h>
 
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
 #ifdef ENABLE_GL
-#  include <gtk/gtkgl.h>
+#  define GL_GLEXT_PROTOTYPES 1
 #  include <GL/gl.h>
+#  include <gtk/gtkgl.h>
 #  include "hid/common/hidgl.h"
 #endif
 
@@ -521,7 +527,9 @@ void ghid_logv (const char *fmt, va_list args);
 void ghid_pinout_window_show (GHidPort * out, ElementTypePtr Element);
 
 /* gtkhid-main.c */
+
 void ghid_invalidate_all ();
+void ghid_invalidate_current_gc ();
 void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);
