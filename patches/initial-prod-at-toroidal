Bottom: 375dc988bc7c5150a68eb4df5873cb7a158e0266
Top:    8d971fbe9b31e1a33a7d9b7f286d626d68f8ef48
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-26 04:12:55 +0000

Initial prod at toroidal surfaces

(Badly broken at the moment)


---

diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 725e08b..0f477ed 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -20,6 +20,11 @@ typedef struct {
   bool is_conical;
   double semi_angle;
 
+  /* For torioidal surfaces */
+  bool is_toroidal;
+  /* NB: Use radius above for major_radius */
+  double minor_radius;
+
   appearance *appear;
 
   /* XXX: STEP specific - breaks encapsulation */
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index 1e49158..52b4d87 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -113,6 +113,453 @@ emit_tristrip (face3d *face)
 //  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 }
 
+static void
+toroid_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double refx, refy, refz;
+  double ortx, orty, ortz;
+  double rayx, rayy, rayz;
+  double dot;
+  double vx, vy, vz;
+  double mx, my, mz;
+  double recip_length;
+  double cosu, sinu;
+  double cosv, sinv;
+
+  refx = face->rx;
+  refy = face->ry;
+  refz = face->rz;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  /* Magnitude of vector component between toroid center and (x,y,z) in axis direction */
+  dot = (x - face->ox) * face->ax +
+        (y - face->oy) * face->az +
+        (z - face->oz) * face->az;
+
+  /* Find the vector to x,y,z in the plane bisecting the toroid slice at z=0 */
+  rayx = x - face->ox - dot * face->ax;
+  rayy = y - face->oy - dot * face->ay;
+  rayz = z - face->oz - dot * face->az;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (rayx, rayy), rayz);
+  rayx *= recip_length;
+  rayy *= recip_length;
+  rayz *= recip_length;
+
+  /* Cosine is dot product of ref (normalised) and ray (normalised) */
+  cosu = refx * rayx + refy * rayy + refz * rayz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and ray (normalised) */
+  sinu = ortx * rayx + orty * rayy + ortz * rayz; // sin (phi) = cos (phi - 90)
+
+  /* U is the angle */
+  *u = atan2 (sinu, cosu);
+
+  /* Point at u, middle of toroid cross-section */
+  mx = rayx * face->radius;
+  my = rayy * face->radius;
+  mz = rayz * face->radius;
+
+  /* Find the vector to x,y,z in the plane cutting the toroid center, and passing through u */
+  vx = x - mx;
+  vy = y - my;
+  vz = z - mz;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (vx, vy), vz);
+  vx *= recip_length;
+  vy *= recip_length;
+  vz *= recip_length;
+
+  /* Now, our reference directions are different when calculating the v angle...
+   * what was ref above, points in direction from o->m. (ray)
+   * what was ort above, points in our axis direction
+   */
+
+  /* Cosine is dot product of ref (normalised) and v (normalised) */
+  cosv = rayx * vx + rayy * vy + rayz * vz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and v (normalised) */
+  sinv = face->ax * vx + face->ay * vy + face->az * vz; // sin (phi) = cos (phi - 90)
+
+  /* V is the angle */
+  *v = atan2 (sinv, cosv);
+
+  if (*u < 0.0)
+    *u += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *u *= 180. / M_PI;
+
+  if (*v < 0.0)
+    *v += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *v *= 180. / M_PI;
+}
+
+static void
+toroid_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z,
+                             float *nx, float *ny, float *nz)
+{
+  float ortx, orty, ortz;
+  double Rr;
+  double cosu, sinu;
+  double cosv, sinv;
+  double Rrcosu, Rrsinu;
+  double rcosv, rsinv;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  cosu = cos(u / 180. * M_PI);
+  sinu = sin(u / 180. * M_PI);
+  cosv = cos(v / 180. * M_PI);
+  sinv = sin(v / 180. * M_PI);
+
+  rcosv = face->minor_radius * cosv;
+  rsinv = face->minor_radius * sinv;
+
+  Rr = face->radius + rcosv;
+  Rrcosu = Rr * cosu;
+  Rrsinu = Rr * sinu;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + Rrcosu * face->rx + Rrsinu * ortx + rsinv * face->ax);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + Rrcosu * face->ry + Rrsinu * orty + rsinv * face->ay);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + Rrcosu * face->rz + Rrsinu * ortz + rsinv * face->az);
+
+  *nx =  (cosv * cosu * face->rx + cosv * sinu * ortx + sinv * face->ax);
+  *ny = -(cosv * cosu * face->ry + cosv * sinu * orty + sinv * face->ay); /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+  *nz =  (cosv * cosu * face->rz + cosv * sinu * ortz + sinv * face->az);
+
+  if (face->surface_orientation_reversed)
+    {
+      *nx = -*nx;
+      *ny = -*ny;
+      *nz = -*nz;
+    }
+}
+
+#warning NEED TO WRAP IN TWO DIMENSIONS, NOT JUST 1x
+static void
+toroid_bo_add_edge (borast_t *bo,
+                  double lu, double lv,
+                  double  u, double  v,
+                  bool is_outer)
+{
+  /* XXX: Not absolutely sure about this! */
+  if (fabs (u - lu) > fabs (u + 360.0f - lu))
+    {
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u + 360.0f),
+                   is_outer);
+#endif
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu - 360.0f),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+#endif
+    }
+  else if (fabs (u - lu) > fabs (u - 360.0f - lu))
+    {
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u - 360.0f),
+                   is_outer);
+#endif
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu + 360.0f),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+#endif
+    }
+  else
+    {
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+    }
+
+}
+static void
+toroid_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  borast_t *bo;
+  borast_traps_t traps;
+  int edge_count = 0;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_toroidal)
+    return;
+
+  /* Count up the number of edges space is required for */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+
+          edge_ensure_linearised (e);
+          edge_count += info->num_linearised_vertices;
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+    }
+
+  /* Worst case, we need 2x number of edges, since we repeat any which span the u=0, u=360 wrap-around. */
+  bo = bo_init (2 * edge_count);
+
+  /* Throw the edges to the rasteriser */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      float fu = 0.0f, fv = 0.0f;
+      float lu = 0.0f, lv = 0.0f;
+      float u, v;
+      bool first_vertex = true;
+      bool is_outer;
+
+      /* XXX: How can we tell if a contour is inner or outer??? */
+      is_outer = true;
+
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+              float x, y, z, nx, ny, nz;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              toroid_xyz_to_uv (face,
+                                info->linearised_vertices[vertex_idx * 3 + 0],
+                                info->linearised_vertices[vertex_idx * 3 + 1],
+                                info->linearised_vertices[vertex_idx * 3 + 2],
+                                &u, &v);
+
+              toroid_uv_to_xyz_and_normal (face, u, v, &x, &y, &z, &nx, &ny, &nz);
+              x = COORD_TO_STEP_X(PCB, x);
+              y = COORD_TO_STEP_Y(PCB, y);
+              z = COORD_TO_STEP_Z(PCB, z);
+
+              printf ("(%f, %f, %f) -> (%f, %f) -> (%f, %f, %f)  DELTA: (%f, %f, %f)\n",
+                      (double)info->linearised_vertices[vertex_idx * 3 + 0],
+                      (double)info->linearised_vertices[vertex_idx * 3 + 1],
+                      (double)info->linearised_vertices[vertex_idx * 3 + 2],
+                      u, v, x, y, z,
+                      (double)x - info->linearised_vertices[vertex_idx * 3 + 0],
+                      (double)y - info->linearised_vertices[vertex_idx * 3 + 1],
+                      (double)z - info->linearised_vertices[vertex_idx * 3 + 2]);
+
+              if (first_vertex)
+                {
+                  fu = u;
+                  fv = v;
+                }
+              else
+                {
+                  toroid_bo_add_edge (bo,
+                                      lu, lv,
+                                       u,  v,
+                                      is_outer);
+                }
+
+              lu = u;
+              lv = v;
+              first_vertex = false;
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      toroid_bo_add_edge (bo,
+                          lu, lv,
+                          fu, fv,
+                          is_outer);
+    }
+
+  _borast_traps_init (&traps);
+  bo_tesselate_to_traps (bo, false /* Don't combine adjacent y traps */,  &traps);
+
+  bo_free (bo);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  if (num_uv_points == 0) {
+    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    /* NB: ybot > ytop, as this is all derived from a screen-space rasteriser with 0,0 in the top left */
+
+    /* Exclude strips entirely above or below the 0 <= u <= 360 range */
+    if (y_bot < MM_TO_COORD (0.0f))
+      continue;
+
+    if (y_top > MM_TO_COORD (360.0f))
+      continue;
+
+    /* Clamp evaluation coordinates otherwise (strips straddling the boundary)
+     * NB: Due to input parameter-space geometry duplication, the bit we trim
+     *     here will be duplicated on the other side of the wrap-around anyway
+     */
+    y_top = MAX(MM_TO_COORD(0.0f), y_top);
+    y_bot = MIN(y_bot, MM_TO_COORD(360.0f));
+
+
+    if (face->surface_orientation_reversed)
+      {
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+    else
+      {
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+
+      num_uv_points += 6;
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+
+      num_uv_points += 6;
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+
+      num_uv_points += 6;
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      toroid_uv_to_xyz_and_normal (face,
+                                   /* uv */
+                                   COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                                   COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                                   /* xyz */
+                                   &face->tristrip_vertices[vertex_comp + 0],
+                                   &face->tristrip_vertices[vertex_comp + 1],
+                                   &face->tristrip_vertices[vertex_comp + 2],
+                                   /* Vertex normal */
+                                   &face->tristrip_vertices[vertex_comp + 3],
+                                   &face->tristrip_vertices[vertex_comp + 4],
+                                   &face->tristrip_vertices[vertex_comp + 5]);
+
+      vertex_comp += BUFFER_STRIDE;
+    }
+
+  g_free (uv_points);
+}
+
+
+
 
 static void
 cone_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
@@ -303,7 +750,6 @@ cone_ensure_tristrip (face3d *face)
       float u, v;
       bool first_vertex = true;
       bool is_outer;
-      float wobble = 0.0f;
 
       /* XXX: How can we tell if a contour is inner or outer??? */
       is_outer = true;
@@ -338,18 +784,18 @@ cone_ensure_tristrip (face3d *face)
               if (first_vertex)
                 {
                   fu = u;
-                  fv = v + wobble;
+                  fv = v;
                 }
               else
                 {
                   cone_bo_add_edge (bo,
                                     lu, lv,
-                                     u,  v + wobble,
+                                     u,  v,
                                     is_outer);
                 }
 
               lu = u;
-              lv = v + wobble;
+              lv = v;
               first_vertex = false;
             }
 
@@ -701,7 +1147,6 @@ cylinder_ensure_tristrip (face3d *face)
       float u, v;
       bool first_vertex = true;
       bool is_outer;
-      float wobble = 0.0f;
 
       /* XXX: How can we tell if a contour is inner or outer??? */
       is_outer = true;
@@ -736,27 +1181,25 @@ cylinder_ensure_tristrip (face3d *face)
               if (first_vertex)
                 {
                   fu = u;
-                  fv = v + wobble;
+                  fv = v;
                 }
               else
                 {
-//                  wobble = 0.1f - wobble;
 
                   cylinder_bo_add_edge (bo,
                                         lu, lv,
-                                         u,  v + wobble,
+                                         u,  v,
                                         is_outer);
                 }
 
               lu = u;
-              lv = v + wobble;
+              lv = v;
               first_vertex = false;
             }
 
         }
       while ((e = LNEXT(e)) != contour->first_edge);
 
-//      wobble = 0.1f - wobble;
 
       cylinder_bo_add_edge (bo,
                             lu, lv,
@@ -1530,15 +1973,19 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
 
   if (face->is_planar)
     {
-      plane_ensure_tristrip (face);
+//      plane_ensure_tristrip (face);
     }
   else if (face->is_cylindrical)
     {
-      cylinder_ensure_tristrip (face);
+//      cylinder_ensure_tristrip (face);
     }
   else if (face->is_conical)
     {
-      cone_ensure_tristrip (face);
+//      cone_ensure_tristrip (face);
+    }
+  else if (face->is_toroidal)
+    {
+      toroid_ensure_tristrip (face);
     }
   else
     {
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d3f2de5..200f126 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2788,7 +2788,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDepthFunc (GL_LESS);
   glDisable (GL_STENCIL_TEST);
 
-  glEnable (GL_CULL_FACE); /* XXX: Fix model face filling */
+//  glEnable (GL_CULL_FACE); /* XXX: Fix model face filling */
   glCullFace (GL_BACK);
 
   glEnable (GL_COLOR_MATERIAL);
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 78e57a9..5c35f1e 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -1720,7 +1720,48 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
             {
+              auto *toroid = dynamic_cast<SdaiToroidal_surface *>(surface);
 //              printf ("WARNING: toroidal surfaces are not supported yet\n");
+
+              unpack_axis_geom (toroid->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_toroidal = true;
+              info->current_face->radius = toroid->major_radius_ ();
+              info->current_face->minor_radius = toroid->minor_radius_ ();
+
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
+                {
+                  info->current_face->surface_orientation_reversed = true;
+                }
+
             }
           else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
             {
