Bottom: a8e7c75ef16e5e76ddfa9f8fb7718dcaeae566fd
Top:    012555c5d78eebf557839933360fcbfc00fe77a2
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-05-05 18:48:39 +0100

Add multi-clearance DRC (whilst drawing lines)

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 47a0a24..8c3d25a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -100,6 +100,8 @@ PCB_SRCS = \
 	mtspace.h \
 	mymem.c \
 	mymem.h \
+	netclass.c \
+	netclass.h \
 	netlist.c \
 	parse_l.h \
 	parse_l.l \
@@ -153,6 +155,8 @@ PCB_SRCS = \
 	hid/common/hidnogui.c \
 	hid/common/hidnogui.h \
 	hid/common/extents.c \
+	hid/common/draw_drc.c \
+	hid/common/draw_drc.h \
 	hid/common/draw_helpers.c \
 	hid/common/draw_helpers.h \
 	hid/common/hid_resource.c \
diff --git a/src/action.c b/src/action.c
index eeeb208..a9f7972 100644
--- a/src/action.c
+++ b/src/action.c
@@ -73,6 +73,7 @@
 #include "rtree.h"
 #include "macro.h"
 #include "pcb-printf.h"
+#include "netclass.h"
 
 #include <assert.h>
 #include <stdlib.h> /* rand() */
@@ -890,13 +891,19 @@ NotifyLine (void)
 	  gui->beep ();
 	  break;
 	}
-      if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
+      if (Settings.Mode == LINE_MODE)
 	{
-	  type = SearchScreen (Crosshair.X, Crosshair.Y,
-			       PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
-			       &ptr3);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false, true);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true, true);
+          if (TEST_FLAG (AUTODRCFLAG, PCB))
+            {
+              type = SearchScreen (Crosshair.X, Crosshair.Y,
+                                   PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
+                                   &ptr3);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false, true);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true, true);
+            }
+          /* XXX: NEED TO FIGURE OUT WHAT NET CLASS THIS IS, AND/OR STORE FOR USE WITH DRC */
+	  Crosshair.Netclass = get_netclass_at_xy (LAYER_ON_STACK(0), Crosshair.X, Crosshair.Y); /* XXX: Not sure about the layer! */
+	  PCB->Bloat = get_min_clearance_for_netclass (Crosshair.Netclass);
 	}
       if (type == PIN_TYPE || type == VIA_TYPE)
 	{
diff --git a/src/create.c b/src/create.c
index 7d0a760..4b00197 100644
--- a/src/create.c
+++ b/src/create.c
@@ -997,7 +997,7 @@ CreateNewRubberbandEntry (LayerType *Layer,
  * \brief Add a new net to the netlist menu.
  */
 LibraryMenuType *
-CreateNewNet (LibraryType *lib, char *name, char *style)
+CreateNewNet (LibraryType *lib, char *name, char *style, char *class)
 {
   LibraryMenuType *menu;
   char temp[64];
@@ -1010,6 +1010,7 @@ CreateNewNet (LibraryType *lib, char *name, char *style)
     menu->Style = NULL;
   else
     menu->Style = strdup (style);
+  menu->Netclass = STRDUP (class);
   return (menu);
 }
 
diff --git a/src/create.h b/src/create.h
index aec69b8..82124bf 100644
--- a/src/create.h
+++ b/src/create.h
@@ -59,7 +59,7 @@ PadType * CreateNewPad (ElementType *, Coord, Coord, Coord, Coord, Coord, Coord,
 LineType * CreateNewLineInSymbol (SymbolType *, Coord, Coord, Coord, Coord, Coord);
 void CreateDefaultFont (PCBType *);
 RubberbandType * CreateNewRubberbandEntry (LayerType *, LineType *, PointType *, bool);
-LibraryMenuType * CreateNewNet (LibraryType *, char *, char *);
+LibraryMenuType * CreateNewNet (LibraryType *, char *, char *, char *);
 LibraryEntryType * CreateNewConnection (LibraryMenuType *, char *);
 AttributeType * CreateNewAttribute (AttributeListType *list, char *name, char *value);
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 1d20765..274ce69 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -1320,7 +1320,7 @@ common_tail:
 
   if (Settings.Mode == LINE_MODE
       && Crosshair.AttachedLine.State != STATE_FIRST
-      && TEST_FLAG (AUTODRCFLAG, PCB))
+     )//      && TEST_FLAG (AUTODRCFLAG, PCB))
     EnforceLineDRC ();
 
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_DO_NOTHING);
diff --git a/src/file.c b/src/file.c
index 657efeb..6861569 100644
--- a/src/file.c
+++ b/src/file.c
@@ -664,6 +664,11 @@ WritePCBNetlistData (FILE * FP)
 	  PrintQuotedString(FP, &menu->Name[2]);
 	  fprintf (FP, " ");
 	  PrintQuotedString(FP, (char *)UNKNOWN (menu->Style));
+	  if (menu->Netclass != NULL)
+	    {
+	      fprintf (FP, " ");
+	      PrintQuotedString(FP, menu->Netclass);
+	    }
 	  fprintf (FP, ")\n\t(\n");
 	  for (p = 0; p < menu->EntryN; p++)
 	    {
diff --git a/src/find.c b/src/find.c
index c9b5c78..655d227 100644
--- a/src/find.c
+++ b/src/find.c
@@ -3109,6 +3109,38 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
 }
 
 /* ---------------------------------------------------------------------------
+ * looks up all connections from the object at the given coordinates
+ * the TheFlag (normally 'FOUNDFLAG') is set for all objects found
+ * the objects are re-drawn if AndDraw is true
+ * also the action is marked as undoable if AndDraw is true
+ */
+void
+LookupObject (int type, void *ptr1, void *ptr2, void *ptr3, bool AndDraw, int flag,
+                  bool AndRats, bool store_undo)
+{
+  reassign_no_drc_flags ();
+
+  User = store_undo;
+  InitConnectionLookup ();
+
+  /* now add the object to the appropriate list and start scanning
+   * This is step (1) from the description
+   */
+  ListStart (type, ptr1, ptr2, ptr3, flag);
+  DoIt (flag, AndRats, AndDraw);
+  if (store_undo)
+    IncrementUndoSerialNumber ();
+  User = false;
+
+  /* we are done */
+  if (AndDraw)
+    Draw ();
+  if (AndDraw && Settings.RingBellWhenFinished)
+    gui->beep ();
+  FreeConnectionLookupMemory ();
+}
+
+/* ---------------------------------------------------------------------------
  * find connections for rats nesting
  * assumes InitConnectionLookup() has already been done
  */
diff --git a/src/find.h b/src/find.h
index be25264..3a9c7d9 100644
--- a/src/find.h
+++ b/src/find.h
@@ -51,6 +51,7 @@ bool ArcPadIntersect (ArcType *, PadType *);
 void LookupElementConnections (ElementType *, FILE *);
 void LookupConnectionsToAllElements (FILE *);
 void LookupConnection (Coord, Coord, bool, Coord, int, bool AndRats, bool store_undo);
+void LookupObject (int, void *, void *, void *, bool, int, bool AndRats, bool store_undo);
 void LookupUnusedPins (FILE *);
 bool ClearFlagOnLinesAndPolygons (bool, int flag, bool store_undo);
 bool ClearFlagOnPinsViasAndPads (bool, int flag, bool store_undo);
diff --git a/src/global.h b/src/global.h
index a542ccf..d5d2f82 100644
--- a/src/global.h
+++ b/src/global.h
@@ -167,6 +167,7 @@ typedef struct
 	BoxType		BoundingBox;	\
 	long int	ID;		\
 	FlagType	Flags;		\
+	Coord		ExtraDrcClearance; \
 	//	struct LibraryEntryType *net
 
 /* Lines, pads, and rats all use this so they can be cross-cast.  */
@@ -459,7 +460,8 @@ typedef struct
 {
   char *Name,			/* name of the menu entry */
    *directory,			/* Directory name library elements are from */
-   *Style;			/* routing style */
+   *Style,			/* routing style */
+   *Netclass;			/* Net class */
   Cardinal EntryN,		/* number of objects */
     EntryMax;			/* number of reserved memory locations */
   LibraryEntryType *Entry;	/* the entries */
@@ -599,6 +601,7 @@ typedef struct			/* holds cursor information */
   PolygonType AttachedPolygon;
   AttachedObjectType AttachedObject;	/* data of attached objects */
   enum crosshair_shape shape; 	/* shape of crosshair */
+  char *Netclass;
 } CrosshairType;
 
 typedef struct
diff --git a/src/hid/common/draw_drc.c b/src/hid/common/draw_drc.c
new file mode 100644
index 0000000..f6f0fa3
--- /dev/null
+++ b/src/hid/common/draw_drc.c
@@ -0,0 +1,222 @@
+#include "global.h"
+#include "hid.h"
+#include "hid_draw.h"
+#include "data.h" /* For global "PCB" variable */
+#include "misc.h" /* For GetArcEnds() */
+#include "rotate.h" /* For RotateLineLowLevel() */
+#include "polygon.h"
+#include "draw_helpers.h"
+
+/* Hacky chaining of functions */
+static HID_DRAW_CLASS orig_class;
+
+
+/*-----------------------------------------------------------
+ * Draws the outline of a line
+ */
+static void
+thindraw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
+{
+  Coord dx, dy, ox, oy;
+  double h;
+
+  dx = x2 - x1;
+  dy = y2 - y1;
+  if (dx != 0 || dy != 0)
+    h = 0.5 * thick / sqrt (SQUARE (dx) + SQUARE (dy));
+  else
+    h = 0.0;
+  ox = dy * h + 0.5 * SGN (dy);
+  oy = -(dx * h + 0.5 * SGN (dx));
+  hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+  if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
+    {
+      Angle angle = atan2 (dx, dy) * 57.295779;
+      hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+      hid_draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
+      hid_draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
+    }
+}
+
+
+/*-----------------------------------------------------------
+ * Draws the outline of an arc
+ */
+static void
+thindraw_arc (hidGC gc, Coord X, Coord Y, Coord wx, Coord wy, Angle sa, Angle dir, Coord thick)
+{
+  ArcType arc;
+  BoxType *bx;
+  Coord wid = thick / 2;
+
+  arc.X = X;
+  arc.Y = Y;
+  arc.StartAngle = sa;
+  arc.Delta = dir;
+  arc.Width = wx;
+  arc.Height = wy;
+  bx = GetArcEnds (&arc);
+  /*  sa = sa - 180; */
+  hid_draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
+  hid_draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
+  hid_draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
+  hid_draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
+}
+
+
+static void
+common_drc_draw_pcb_line (hidGC gc, LineType *line)
+{
+  orig_class.draw_pcb_line (gc, line);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      line->ExtraDrcClearance == 0)
+    return;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_line (gc, line->Point1.X, line->Point1.Y,
+                     line->Point2.X, line->Point2.Y,
+                     line->Thickness + line->ExtraDrcClearance * 2);
+}
+
+static void
+common_drc_draw_pcb_arc (hidGC gc, ArcType *arc)
+{
+  orig_class.draw_pcb_arc (gc, arc);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      arc->ExtraDrcClearance == 0)
+    return;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta, arc->Thickness + arc->ExtraDrcClearance * 2);
+}
+
+#if 0
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
+ */
+static void
+common_drc_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+{
+  orig_class.draw_pcb_text (gc, Text, min_line_width);
+}
+#endif
+
+void
+common_drc_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+{
+  orig_class.draw_pcb_polygon (gc, polygon, clip_box);
+}
+
+void
+common_drc_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  orig_class.fill_pcb_polygon (gc, poly, clip_box);
+}
+
+void
+common_drc_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+                             const BoxType *clip_box)
+{
+  orig_class.thindraw_pcb_polygon (gc, poly, clip_box);
+}
+
+void
+common_drc_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  PadType drc_pad;
+
+  orig_class.thindraw_pcb_pad (gc, pad, clear, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
+
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
+}
+
+void
+common_drc_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  PadType drc_pad;
+
+  orig_class.fill_pcb_pad (gc, pad, clear, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
+
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
+}
+
+void
+common_drc_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+{
+  PinType drc_pv;
+
+  orig_class.fill_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
+
+  drc_pv = *pv;
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
+}
+
+void
+common_drc_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+{
+  PinType drc_pv;
+
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
+
+  drc_pv = *pv;
+  pcb_printf ("via clearance was %mn, extra %mn\n", drc_pv.Thickness, pv->ExtraDrcClearance);
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+  pcb_printf ("via clearance is now %mn\n", drc_pv.Thickness);
+
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
+}
+
+void
+common_draw_drc_class_init (HID_DRAW_CLASS *klass)
+{
+  orig_class = *klass; /* Copy function pointers from parent... allows chaining */
+
+  klass->draw_pcb_line        = common_drc_draw_pcb_line;
+  klass->draw_pcb_arc         = common_drc_draw_pcb_arc;
+  klass->draw_pcb_polygon     = common_drc_fill_pcb_polygon;
+//  klass->draw_pcb_text        = common_drc_fill_pcb_text;
+
+  klass->fill_pcb_polygon     = common_drc_fill_pcb_polygon;
+  klass->thindraw_pcb_polygon = common_drc_thindraw_pcb_polygon;
+  klass->fill_pcb_pad         = common_drc_fill_pcb_pad;
+  klass->thindraw_pcb_pad     = common_drc_thindraw_pcb_pad;
+  klass->fill_pcb_pv          = common_drc_fill_pcb_pv;
+  klass->thindraw_pcb_pv      = common_drc_thindraw_pcb_pv;
+}
+
+void
+common_draw_drc_init (HID_DRAW *graphics)
+{
+}
diff --git a/src/hid/common/draw_drc.h b/src/hid/common/draw_drc.h
new file mode 100644
index 0000000..8dab54d
--- /dev/null
+++ b/src/hid/common/draw_drc.h
@@ -0,0 +1,9 @@
+void common_drc_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
+void common_drc_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
+void common_drc_pcb_fill_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+void common_drc_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+void common_draw_drc_class_init (HID_DRAW_CLASS *klass);
+void common_draw_drc_init (HID_DRAW *graphics);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 763f493..488f530 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -17,6 +17,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "hid/common/hidnogui.h"
+#include "hid/common/draw_drc.h"
 #include "hid/common/draw_helpers.h"
 #include "pcb-printf.h"
 
@@ -2199,6 +2200,7 @@ hid_gtk_init ()
 
   common_nogui_graphics_class_init (&ghid_graphics_class);
   common_draw_helpers_class_init (&ghid_graphics_class);
+  common_draw_drc_class_init (&ghid_graphics_class); /* XXX: Some vfuncs are overridden below, and the drc helpers won't be drawn! */
 
   ghid_graphics_class.set_layer      = ghid_set_layer;
   ghid_graphics_class.make_gc        = ghid_make_gc;
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 71327b4..1fed021 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -45,6 +45,7 @@
 #include "find.h"
 #include "search.h"
 #include "rats.h"
+#include "netclass.h"
 #include "snavi.h"
 #include "gui-trackball.h"
 
@@ -400,6 +401,7 @@ describe_location (Coord X, Coord Y)
   char *elename = "";
   char *pinname;
   char *netname = NULL;
+  char *netclass = NULL;
   char *description;
 
   /* check if there are any pins or pads at that position */
@@ -438,6 +440,7 @@ describe_location (Coord X, Coord Y)
         netname = g_strdup (menu->Name);
         /* For some reason, the netname has spaces in front of it, strip them */
         g_strstrip (netname);
+        netclass = menu->Netclass;
         break;
       }
     }
@@ -450,10 +453,12 @@ describe_location (Coord X, Coord Y)
 
   description = g_strdup_printf (_("Element name: %s\n"
                                  "Pinname : %s\n"
-                                 "Netname : %s"),
+                                 "Netname : %s\n"
+                                 "Netclass : %s\n"),
                                  elename,
                                  (pinname != NULL) ? pinname : _("--"),
-                                 (netname != NULL) ? netname : _("--"));
+                                 (netname != NULL) ? netname : _("--"),
+                                 (netclass != NULL) ? netclass : _("--"));
 
   g_free (netname);
 
diff --git a/src/line.c b/src/line.c
index 469f0f6..4dde0ca 100644
--- a/src/line.c
+++ b/src/line.c
@@ -41,6 +41,8 @@
 #include "line.h"
 #include "misc.h"
 #include "rtree.h"
+#include "netclass.h"
+#include "draw.h" /* For Redraw */
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -231,6 +233,11 @@ struct drc_info
   bool bottom_side;
   bool top_side;
   jmp_buf env;
+  ElementType *element;
+  LayerType *layer;
+  char *drawn_line_netclass;
+  Coord drawn_line_clearance;
+  Coord max_clearance;
 };
 
 static int
@@ -238,9 +245,56 @@ drcVia_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
 
-  if (!TEST_FLAG (FOUNDFLAG, via) && PinLineIntersect (via, i->line))
-    longjmp (i->env, 1);
+  if (TEST_FLAG (FOUNDFLAG, via))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_via (via);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (via, i->line))
+    {
+      via->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", via->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
+  return 1;
+}
+
+static int
+drcPin_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, pin))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pin (pin);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (pin, i->line))
+    {
+      pin->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pin->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -249,10 +303,27 @@ drcPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
 
-  if (TEST_FLAG (ONSOLDERFLAG, pad) == i->bottom_side &&
-      !TEST_FLAG (FOUNDFLAG, pad) && LinePadIntersect (i->line, pad))
-    longjmp (i->env, 1);
+  if (TEST_FLAG (FOUNDFLAG, pad) || TEST_FLAG (ONSOLDERFLAG, pad) != i->bottom_side)
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pad (pad);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (LinePadIntersect (i->line, pad))
+    {
+      pad->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pad->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -261,9 +332,27 @@ drcLine_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, line))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_line (i->layer, line);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
 
-  if (!TEST_FLAG (FOUNDFLAG, line) && LineLineIntersect (line, i->line))
-    longjmp (i->env, 1);
+  if (LineLineIntersect (line, i->line))
+    {
+      line->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", line->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -272,9 +361,27 @@ drcArc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
 
-  if (!TEST_FLAG (FOUNDFLAG, arc) && LineArcIntersect (i->line, arc))
-    longjmp (i->env, 1);
+  if (TEST_FLAG (FOUNDFLAG, arc))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_arc (i->layer, arc);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (LineArcIntersect (i->line, arc))
+    {
+      arc->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", arc->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -300,11 +407,15 @@ drc_lines (PointType *end, bool way)
   bool two_lines, x_is_long, blocker;
   PointType ans;
 
+  info.drawn_line_netclass = Crosshair.Netclass;
+  info.drawn_line_clearance = PCB->Bloat; /* XXX: PICK THIS UP FROM MIN CLEARANCE IN line_netclass -> * */
+  info.max_clearance = get_max_clearance_for_netclass (info.drawn_line_netclass);
+
   f = 1.0;
   s = 0.5;
   last = -1;
   line1.Flags = line2.Flags = NoFlags ();
-  line1.Thickness = Settings.LineThickness + 2 * (PCB->Bloat + 1);
+  line1.Thickness = Settings.LineThickness + 2 * info.max_clearance;
   line2.Thickness = line1.Thickness;
   line1.Clearance = line2.Clearance = 0;
   line1.Point1.X = Crosshair.AttachedLine.Point1.X;
@@ -404,38 +515,29 @@ drc_lines (PointType *end, bool way)
 	  if (setjmp (info.env) == 0)
 	    {
 	      info.line = &line1;
-	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
-	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
+	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL, drcVia_callback, &info);
+	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL, drcPin_callback, &info);
 	      if (info.bottom_side || info.top_side)
-		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL,
-			  drcPad_callback, &info);
+		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL, drcPad_callback, &info);
 	      if (two_lines)
 		{
 		  info.line = &line2;
-		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
-		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
+		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL, drcVia_callback, &info);
+		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL, drcPin_callback, &info);
 		  if (info.bottom_side || info.top_side)
-		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL,
-			      drcPad_callback, &info);
+		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL, drcPad_callback, &info);
 		}
 	      GROUP_LOOP (PCB->Data, group);
 	      {
 		info.line = &line1;
-		r_search (layer->line_tree, &line1.BoundingBox, NULL,
-			  drcLine_callback, &info);
-		r_search (layer->arc_tree, &line1.BoundingBox, NULL,
-			  drcArc_callback, &info);
+		info.layer = layer;
+		r_search (layer->line_tree, &line1.BoundingBox, NULL, drcLine_callback, &info);
+		r_search (layer->arc_tree,  &line1.BoundingBox, NULL, drcArc_callback,  &info);
 		if (two_lines)
 		  {
 		    info.line = &line2;
-		    r_search (layer->line_tree, &line2.BoundingBox,
-			      NULL, drcLine_callback, &info);
-		    r_search (layer->arc_tree, &line2.BoundingBox,
-			      NULL, drcArc_callback, &info);
+		    r_search (layer->line_tree, &line2.BoundingBox, NULL, drcLine_callback, &info);
+		    r_search (layer->arc_tree,  &line2.BoundingBox, NULL, drcArc_callback,  &info);
 		  }
 	      }
 	      END_LOOP;
@@ -461,6 +563,11 @@ drc_lines (PointType *end, bool way)
 	    {
 	      /* bumped into something, back off */
 	      f2 -= s2;
+	      //SET_FLAG (WARNFLAG, info.object);
+//	      if (TEST_FLAG (AUTODRCFLAG, PCB))
+//	        info.object->ExtraDrcClearance = MM_TO_COORD (1.0);
+//	      Draw (type, info.ptr1, info.ptr2); /* XXX: Need info */
+//	      Redraw (); /* XXX: Sledgehammer */
 	    }
 	  s2 *= 0.5;
 	  length2 = MIN (f2 * temp2, temp2);
@@ -490,16 +597,79 @@ EnforceLineDRC (void)
   /* Silence a bogus compiler warning by storing this in a variable */
   int layer_idx = INDEXOFCURRENT;
 
+  if (!TEST_FLAG (AUTODRCFLAG, PCB) && !TEST_FLAG (SHOWDRCFLAG, PCB))
+    return;
+
   if ( gui->mod1_is_pressed() || gui->control_is_pressed () || PCB->RatDraw
       || layer_idx >= max_copper_layer)
     return;
 
+  /* Reset ExtraDrcClearance on all objects */
+  GROUP_LOOP (PCB->Data, GetLayerGroupNumberByNumber (INDEXOFCURRENT));
+    {
+      LINE_LOOP (layer);
+        {
+          line->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      ARC_LOOP (layer);
+        {
+          arc->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      POLYGON_LOOP (layer);
+        {
+          polygon->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      TEXT_LOOP (layer);
+        {
+          text->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          pin->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          pad->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  VIA_LOOP (PCB->Data);
+    {
+      via->ExtraDrcClearance = 0;
+    }
+  END_LOOP;
+
   rs.X = r45.X = Crosshair.X;
   rs.Y = r45.Y = Crosshair.Y;
+
+  if (!TEST_FLAG (AUTODRCFLAG, PCB))
+    {
+      if (TEST_FLAG (ALLDIRECTIONFLAG, PCB)) /* We don't have code to handle this case! */
+        return;
+
+      /* Just run drc_lines to update clearances, without accepting any of its adjustment, when AUTODRCFLAG is not set */
+      drc_lines (&rs, (PCB->Clipping == 2) != gui->shift_is_pressed ());
+      return;
+    }
+
+  if (TEST_FLAG (ALLDIRECTIONFLAG, PCB)) /* We don't have code to handle this case! */
+    return;
+
   /* first try starting straight */
-  r1 = drc_lines (&rs, false);
+  r1 = drc_lines (&rs, false);              /* XXX: This code doesn't cope well with all-direction lines (?) */
   /* then try starting at 45 */
-  r2 = drc_lines (&r45, true);
+  r2 = drc_lines (&r45, true);              /* XXX: This code doesn't cope well with all-direction lines (?) */
+
   shift = gui->shift_is_pressed ();
   if (XOR (r1 > r2, shift))
     {
diff --git a/src/netclass.c b/src/netclass.c
new file mode 100644
index 0000000..b81d0dc
--- /dev/null
+++ b/src/netclass.c
@@ -0,0 +1,349 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+//#include <stdio.h>
+#include <string.h>
+//#include <assert.h>
+
+#include "data.h"
+#include "rats.h"
+#include "find.h"
+#include "undo.h"
+#include "pcb-printf.h"
+#include "netclass.h"
+
+static int num_netclass = 10;
+
+static char *netclass_names[10] =
+  {
+    NULL,
+    "PE",
+    "DC+",
+    "BAT+",
+    "PHASE1",
+    "PHASE2",
+    "PHASE3",
+    "PHASE4",
+    "PHASE5",
+    "PHASE6"
+  };
+
+static Coord clearances[10][10] =
+  {
+    {MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2)}
+  };
+
+
+static int
+netclass_index (char *netclass)
+{
+  int i;
+
+  for (i = 0; i < num_netclass; i++)
+    if (netclass == NULL)
+      {
+        if (netclass_names[i] == NULL)
+          return i;
+      }
+    else if (netclass_names[i] != NULL && strcmp (netclass_names[i], netclass) == 0)
+      {
+        return i;
+      }
+
+  g_return_val_if_fail (netclass != NULL, 0);
+  g_warning ("Netclass '%s' not found, returning 0th (default) class", netclass);
+
+  return 0;
+}
+
+static Coord
+clearance_between_netclasses (int a, int b)
+{
+  g_return_val_if_fail (a >= 0 && a < num_netclass, 0);
+  g_return_val_if_fail (b >= 0 && b < num_netclass, 0);
+
+  return clearances[a][b];
+}
+
+Coord
+get_min_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord min_clearance = MAX_COORD;
+
+  for (i = 0; i < num_netclass; i++)
+    min_clearance = MIN (min_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up minimum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              min_clearance);
+#endif
+
+  return min_clearance;
+}
+
+Coord
+get_max_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord max_clearance = 0;
+
+  for (i = 0; i < num_netclass; i++)
+    max_clearance = MAX (max_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up maximum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              max_clearance);
+#endif
+
+  return max_clearance;
+}
+
+Coord
+get_clearance_between_netclasses (char *netclass_a, char *netclass_b)
+{
+  int a = netclass_index (netclass_a);
+  int b = netclass_index (netclass_b);
+  Coord clearance = clearance_between_netclasses (a, b);
+
+#if 0
+  pcb_printf ("Looking up clearance between netclass %s%s%s and %s%s%s, found '%mn'\n",
+              netclass_a != NULL ? "'" : "",
+              netclass_a != NULL ? netclass_a : "(NULL)",
+              netclass_a != NULL ? "'" : "",
+              netclass_b != NULL ? "'" : "",
+              netclass_b != NULL ? netclass_b : "(NULL)",
+              netclass_b != NULL ? "'" : "",
+              clearance);
+#endif
+
+  return clearance;
+}
+
+char *
+get_netclass_for_netname (char *netname)
+{
+  char *menu_netname;
+
+//  g_return_val_if_fail (netname != NULL, NULL);
+  if (netname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      menu_netname = g_strdup (menu->Name);
+      /* For some reason, the netname has spaces in front of it, strip them */
+      g_strstrip (menu_netname);
+      if (strcmp (menu_netname, netname) == 0) {
+        g_free (menu_netname);
+        return menu->Netclass;
+      }
+      g_free (menu_netname);
+    }
+    END_LOOP;
+  }
+  END_LOOP;
+
+  return NULL;
+}
+
+static char *
+g_strdup_netname_for_pinpad (int type, ElementType *ele, void *pinpad)
+{
+  char *pinname;
+  char *netname = NULL;
+
+  pinname = ConnectionName (type, ele, pinpad);
+
+  if (pinname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      if (strcmp (entry->ListEntry, pinname) == 0) {
+        netname = g_strdup (menu->Name);
+        /* For some reason, the netname has spaces in front of it, strip them */
+        g_strstrip (netname);
+        break;
+      }
+    }
+    END_LOOP;
+
+    if (netname != NULL)
+      break;
+  }
+  END_LOOP;
+
+  return netname;
+}
+
+char *
+get_netclass_for_via (PinType *via)
+{
+  char *netname = NULL;
+  char *netclass;
+
+//  netname = g_strdup_netname_for_via (pin->Element, via);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pin (PinType *pin)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+//  printf ("Looking up netname for pin, found '%s'\n", netname);
+  netclass = get_netclass_for_netname (netname);
+//  printf ("Looking up netclass for netname, found '%s'\n", netclass);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pad (PadType *pad)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+static char *
+find_first_flagged_netname (int flag)
+{
+  char *netname = NULL;
+
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pin))
+            {
+              netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pad))
+            {
+              netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      if (netname != NULL)
+        break;
+    }
+  END_LOOP;
+
+  return netname;
+}
+
+/* NB: THIS CALL IS EXPENSIVE!! */
+char *
+find_netname_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /* store_undo */);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupObject (type, ptr1, ptr2, ptr3, false /*AndDraw*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+static char *
+find_netname_at_xy (LayerType *layer, Coord x, Coord y)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /*store_undo*/);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupConnection (x, y, false /*AndDraw*/, 0 /*Range*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+char *
+get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname = NULL;
+
+  netname = find_netname_for_object (type, ptr1, ptr2, ptr3);
+
+  return get_netclass_for_netname (netname);
+}
+
+char *
+get_netclass_for_line (LayerType *layer, LineType *line)
+{
+  return get_netclass_for_object (LINE_TYPE, layer, line, NULL);
+}
+
+char *
+get_netclass_for_arc (LayerType *layer, ArcType *arc)
+{
+  return get_netclass_for_object (ARC_TYPE, layer, arc, NULL);
+}
+
+char *
+get_netclass_at_xy (LayerType *layer, Coord x, Coord y)
+{
+  char *netname = NULL;
+
+  netname = find_netname_at_xy (layer, x, y);
+
+  return get_netclass_for_netname (netname);
+}
diff --git a/src/netclass.h b/src/netclass.h
new file mode 100644
index 0000000..bb6f51c
--- /dev/null
+++ b/src/netclass.h
@@ -0,0 +1,11 @@
+
+Coord get_min_clearance_for_netclass (char *netclass);
+Coord get_max_clearance_for_netclass (char *netclass);
+Coord get_clearance_between_netclasses (char *netclass_a, char *netclass_b);
+char *get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3);
+char *get_netclass_for_via (PinType *via);
+char *get_netclass_for_pin (PinType *pin);
+char *get_netclass_for_pad (PadType *pad);
+char *get_netclass_for_line (LayerType *layer, LineType *line);
+char *get_netclass_for_arc (LayerType *layer, ArcType *arc);
+char *get_netclass_at_xy (LayerType *layer, Coord x, Coord y);
diff --git a/src/netlist.c b/src/netlist.c
index 9ac7667..7114ae0 100644
--- a/src/netlist.c
+++ b/src/netlist.c
@@ -241,10 +241,19 @@ netlist_style (LibraryMenuType *net, const char *style)
   net->Style = STRDUP ((char *)style);
 }
 
+#if 0
+static void
+netlist_netclass (LibraryMenuType *net, const char *netclass)
+{
+  free (net->Netclass);
+  net->Style = STRDUP ((char *)netclass);
+}
+#endif
+
 /* The primary purpose of this action is to rebuild a netlist from a
    script, in conjunction with the clear action above.  */
 static int
-netlist_add (const char *netname, const char *pinname)
+netlist_add (const char *netname, const char *pinname, const char *netclass)
 {
   int ni, pi;
   LibraryType *netlist = &PCB->NetlistLib;
@@ -259,7 +268,12 @@ netlist_add (const char *netname, const char *pinname)
       }
   if (net == NULL)
     {
-      net = CreateNewNet (netlist, (char *)netname, NULL);
+      net = CreateNewNet (netlist, (char *)netname, NULL, (char *)netclass); /* XXX: Only takes class from the first net */
+    }
+  else
+    {
+      if (strcmp (net->Netclass, netclass) != 0)
+        g_warning ("Netclass '%s' different to initial '%s'... being ignored", netclass, net->Netclass);
     }
 
   for (pi=0; pi<net->EntryN; pi++)
@@ -387,7 +401,7 @@ Netlist (int argc, char **argv, Coord x, Coord y)
   else if (strcasecmp (argv[0], "add") == 0)
     {
       /* Add is different, because the net/pin won't already exist.  */
-      return netlist_add (ARG(1), ARG(2));
+      return netlist_add (ARG(1), ARG(2), NULL); /* Net class? */
     }
   else if (strcasecmp (argv[0], "sort") == 0)
     {
diff --git a/src/parse_y.y b/src/parse_y.y
index 79dc75b..8c42d0f 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -1844,9 +1844,17 @@ The routing style that should be used when autorouting this net.
 
 net
 			/* name style pin pin ... */
-		: T_NET '(' STRING STRING ')' '('
+		: T_NET '(' STRING STRING STRING ')' '('
 			{
-				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4);
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, $5);
+				free ($3);
+				free ($4);
+				free ($5);
+			}
+		 connections ')'
+		| T_NET '(' STRING STRING ')' '('
+			{
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, NULL);
 				free ($3);
 				free ($4);
 			}
