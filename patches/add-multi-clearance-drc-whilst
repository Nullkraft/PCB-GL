Bottom: 29746e050a26a6af0e6c882436db38fa69637cec
Top:    46a346c7c65f204e67ea776c8e0358d3f03cf22c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-05-05 18:48:39 +0100

Add multi-clearance DRC (whilst drawing lines)

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 742c411..128d048 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -100,6 +100,8 @@ PCB_SRCS = \
 	mtspace.h \
 	mymem.c \
 	mymem.h \
+	netclass.c \
+	netclass.h \
 	netlist.c \
 	parse_l.h \
 	parse_l.l \
@@ -153,6 +155,8 @@ PCB_SRCS = \
 	hid/common/hidnogui.c \
 	hid/common/hidnogui.h \
 	hid/common/extents.c \
+	hid/common/draw_drc.c \
+	hid/common/draw_drc.h \
 	hid/common/draw_helpers.c \
 	hid/common/draw_helpers.h \
 	hid/common/hid_resource.c \
diff --git a/src/action.c b/src/action.c
index 7782164..a9f7972 100644
--- a/src/action.c
+++ b/src/action.c
@@ -73,6 +73,7 @@
 #include "rtree.h"
 #include "macro.h"
 #include "pcb-printf.h"
+#include "netclass.h"
 
 #include <assert.h>
 #include <stdlib.h> /* rand() */
@@ -890,13 +891,19 @@ NotifyLine (void)
 	  gui->beep ();
 	  break;
 	}
-      if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
+      if (Settings.Mode == LINE_MODE)
 	{
-	  type = SearchScreen (Crosshair.X, Crosshair.Y,
-			       PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
-			       &ptr3);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true);
+          if (TEST_FLAG (AUTODRCFLAG, PCB))
+            {
+              type = SearchScreen (Crosshair.X, Crosshair.Y,
+                                   PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
+                                   &ptr3);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false, true);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true, true);
+            }
+          /* XXX: NEED TO FIGURE OUT WHAT NET CLASS THIS IS, AND/OR STORE FOR USE WITH DRC */
+	  Crosshair.Netclass = get_netclass_at_xy (LAYER_ON_STACK(0), Crosshair.X, Crosshair.Y); /* XXX: Not sure about the layer! */
+	  PCB->Bloat = get_min_clearance_for_netclass (Crosshair.Netclass);
 	}
       if (type == PIN_TYPE || type == VIA_TYPE)
 	{
@@ -1343,7 +1350,7 @@ NotifyMode (void)
 		}
 	    }
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && !TEST_SILK_LAYER (CURRENT))
-	    LookupConnection (Note.X, Note.Y, true, 1, CONNECTEDFLAG, false);
+	    LookupConnection (Note.X, Note.Y, true, 1, CONNECTEDFLAG, false, true);
 	  Draw ();
 	}
       break;
@@ -2331,13 +2338,13 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	case F_Find:
 	  {
 	    gui->get_coords (_("Click on a connection"), &x, &y);
-	    LookupConnection (x, y, true, 1, CONNECTEDFLAG, false);
-	    LookupConnection (x, y, true, 1, FOUNDFLAG, true);
+	    LookupConnection (x, y, true, 1, CONNECTEDFLAG, false, true);
+	    LookupConnection (x, y, true, 1, FOUNDFLAG, true, true);
 	    break;
 	  }
 
 	case F_ResetLinesAndPolygons:
-	  if (ClearFlagOnLinesAndPolygons (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnLinesAndPolygons (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2345,7 +2352,7 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	  break;
 
 	case F_ResetPinsViasAndPads:
-	  if (ClearFlagOnPinsViasAndPads (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnPinsViasAndPads (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2353,7 +2360,7 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	  break;
 
 	case F_Reset:
-	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2790,7 +2797,7 @@ ActionDisplay (int argc, char **argv, Coord childX, Coord childY)
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
-	      if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	      if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 		{
 		  IncrementUndoSerialNumber ();
 		  Draw ();
@@ -2799,10 +2806,10 @@ ActionDisplay (int argc, char **argv, Coord childX, Coord childY)
 		{
 		  LookupConnection (Crosshair.AttachedLine.Point1.X,
 		                    Crosshair.AttachedLine.Point1.Y,
-		                    true, 1, CONNECTEDFLAG, false);
+		                    true, 1, CONNECTEDFLAG, false, true);
 		  LookupConnection (Crosshair.AttachedLine.Point1.X,
 		                    Crosshair.AttachedLine.Point1.Y,
-		                    true, 1, FOUNDFLAG, true);
+		                    true, 1, FOUNDFLAG, true, true);
 		}
 	    }
 	  notify_crosshair_change (true);
diff --git a/src/create.c b/src/create.c
index 7d0a760..4b00197 100644
--- a/src/create.c
+++ b/src/create.c
@@ -997,7 +997,7 @@ CreateNewRubberbandEntry (LayerType *Layer,
  * \brief Add a new net to the netlist menu.
  */
 LibraryMenuType *
-CreateNewNet (LibraryType *lib, char *name, char *style)
+CreateNewNet (LibraryType *lib, char *name, char *style, char *class)
 {
   LibraryMenuType *menu;
   char temp[64];
@@ -1010,6 +1010,7 @@ CreateNewNet (LibraryType *lib, char *name, char *style)
     menu->Style = NULL;
   else
     menu->Style = strdup (style);
+  menu->Netclass = STRDUP (class);
   return (menu);
 }
 
diff --git a/src/create.h b/src/create.h
index aec69b8..82124bf 100644
--- a/src/create.h
+++ b/src/create.h
@@ -59,7 +59,7 @@ PadType * CreateNewPad (ElementType *, Coord, Coord, Coord, Coord, Coord, Coord,
 LineType * CreateNewLineInSymbol (SymbolType *, Coord, Coord, Coord, Coord, Coord);
 void CreateDefaultFont (PCBType *);
 RubberbandType * CreateNewRubberbandEntry (LayerType *, LineType *, PointType *, bool);
-LibraryMenuType * CreateNewNet (LibraryType *, char *, char *);
+LibraryMenuType * CreateNewNet (LibraryType *, char *, char *, char *);
 LibraryEntryType * CreateNewConnection (LibraryMenuType *, char *);
 AttributeType * CreateNewAttribute (AttributeListType *list, char *name, char *value);
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 1d20765..274ce69 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -1320,7 +1320,7 @@ common_tail:
 
   if (Settings.Mode == LINE_MODE
       && Crosshair.AttachedLine.State != STATE_FIRST
-      && TEST_FLAG (AUTODRCFLAG, PCB))
+     )//      && TEST_FLAG (AUTODRCFLAG, PCB))
     EnforceLineDRC ();
 
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_DO_NOTHING);
diff --git a/src/find.c b/src/find.c
index 2b6496f..655d227 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2939,7 +2939,7 @@ LookupElementConnections (ElementType *Element, FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   InitConnectionLookup ();
   PrintElementConnections (Element, FP, FOUNDFLAG, true);
   SetChangedFlag (true);
@@ -2959,7 +2959,7 @@ LookupConnectionsToAllElements (FILE * FP)
 {
   /* reset all currently marked connections */
   User = false;
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
@@ -2969,12 +2969,12 @@ LookupConnectionsToAllElements (FILE * FP)
       break;
     SEPARATE (FP);
     if (Settings.ResetAfterElement && n != 1)
-      ClearFlagOnAllObjects (false, FOUNDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   }
   END_LOOP;
   if (Settings.RingBellWhenFinished)
     gui->beep ();
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   FreeConnectionLookupMemory ();
   Redraw ();
 }
@@ -3055,7 +3055,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3, int flag)
  */
 void
 LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
-                  bool AndRats)
+                  bool AndRats, bool store_undo)
 {
   void *ptr1, *ptr2, *ptr3;
   char *name;
@@ -3088,7 +3088,7 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
   name = ConnectionName (type, ptr1, ptr2);
   hid_actionl ("NetlistShow", name, NULL);
 
-  User = AndDraw;
+  User = store_undo;
   InitConnectionLookup ();
 
   /* now add the object to the appropriate list and start scanning
@@ -3096,7 +3096,39 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
    */
   ListStart (type, ptr1, ptr2, ptr3, flag);
   DoIt (flag, AndRats, AndDraw);
+  if (store_undo)
+    IncrementUndoSerialNumber ();
+  User = false;
+
+  /* we are done */
   if (AndDraw)
+    Draw ();
+  if (AndDraw && Settings.RingBellWhenFinished)
+    gui->beep ();
+  FreeConnectionLookupMemory ();
+}
+
+/* ---------------------------------------------------------------------------
+ * looks up all connections from the object at the given coordinates
+ * the TheFlag (normally 'FOUNDFLAG') is set for all objects found
+ * the objects are re-drawn if AndDraw is true
+ * also the action is marked as undoable if AndDraw is true
+ */
+void
+LookupObject (int type, void *ptr1, void *ptr2, void *ptr3, bool AndDraw, int flag,
+                  bool AndRats, bool store_undo)
+{
+  reassign_no_drc_flags ();
+
+  User = store_undo;
+  InitConnectionLookup ();
+
+  /* now add the object to the appropriate list and start scanning
+   * This is step (1) from the description
+   */
+  ListStart (type, ptr1, ptr2, ptr3, flag);
+  DoIt (flag, AndRats, AndDraw);
+  if (store_undo)
     IncrementUndoSerialNumber ();
   User = false;
 
@@ -3131,7 +3163,7 @@ LookupUnusedPins (FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
@@ -3156,7 +3188,7 @@ LookupUnusedPins (FILE * FP)
  * resets all used flags of pins and vias
  */
 bool
-ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
+ClearFlagOnPinsViasAndPads (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
@@ -3164,7 +3196,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, via))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
         CLEAR_FLAG (flag, via);
         if (AndDraw)
@@ -3179,7 +3211,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
     {
       if (TEST_FLAG (flag, pin))
         {
-          if (AndDraw)
+          if (store_undo)
             AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
           CLEAR_FLAG (flag, pin);
           if (AndDraw)
@@ -3192,7 +3224,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
     {
       if (TEST_FLAG (flag, pad))
         {
-          if (AndDraw)
+          if (store_undo)
             AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
           CLEAR_FLAG (flag, pad);
           if (AndDraw)
@@ -3212,7 +3244,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
  * resets all used flags of LOs
  */
 bool
-ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
+ClearFlagOnLinesAndPolygons (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
@@ -3220,7 +3252,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, line))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (RATLINE_TYPE, line, line, line);
         CLEAR_FLAG (flag, line);
         if (AndDraw)
@@ -3233,7 +3265,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, line))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (LINE_TYPE, layer, line, line);
         CLEAR_FLAG (flag, line);
         if (AndDraw)
@@ -3246,7 +3278,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, arc))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (ARC_TYPE, layer, arc, arc);
         CLEAR_FLAG (flag, arc);
         if (AndDraw)
@@ -3259,7 +3291,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, polygon))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
         CLEAR_FLAG (flag, polygon);
         if (AndDraw)
@@ -3277,12 +3309,12 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
  * resets all found connections
  */
 bool
-ClearFlagOnAllObjects (bool AndDraw, int flag)
+ClearFlagOnAllObjects (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
-  change = ClearFlagOnPinsViasAndPads  (AndDraw, flag) || change;
-  change = ClearFlagOnLinesAndPolygons (AndDraw, flag) || change;
+  change = ClearFlagOnPinsViasAndPads  (AndDraw, flag, store_undo) || change;
+  change = ClearFlagOnLinesAndPolygons (AndDraw, flag, store_undo) || change;
 
   return change;
 }
@@ -3364,7 +3396,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
         {
           DumpList ();
           /* make the flag changes undoable */
-          ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+          ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
           User = true;
           start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, true, -PCB->Shrink, false);
           start_do_it_and_dump (What, ptr1, ptr2, ptr3, FOUNDFLAG, true, 0, true);
@@ -3397,7 +3429,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
       DumpList ();
     }
   /* now check the bloated condition */
-  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
   start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, false, 0, false);
   flag = FOUNDFLAG;
   ListStart (What, ptr1, ptr2, ptr3, flag);
@@ -3407,7 +3439,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
     {
       DumpList ();
       /* make the flag changes undoable */
-      ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
       User = true;
       start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, true, 0, false);
       start_do_it_and_dump (What, ptr1, ptr2, ptr3, FOUNDFLAG, true, PCB->Bloat, true);
@@ -3444,7 +3476,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
     }
   drc = false;
   DumpList ();
-  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
   return (false);
 }
 
@@ -3580,7 +3612,7 @@ DRCAll (void)
   hid_action ("LayersChanged");
   InitConnectionLookup ();
 
-  if (ClearFlagOnAllObjects (true, FOUNDFLAG | DRCFLAG | SELECTEDFLAG))
+  if (ClearFlagOnAllObjects (true, FOUNDFLAG | DRCFLAG | SELECTEDFLAG, true))
     {
       IncrementUndoSerialNumber ();
       Draw ();
@@ -3633,7 +3665,7 @@ DRCAll (void)
   }
   END_LOOP;
 
-  ClearFlagOnAllObjects (false, IsBad ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG));
+  ClearFlagOnAllObjects (false, IsBad ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG), false);
   info.flag = SELECTEDFLAG;
   /* check minimum widths and polygon clearances */
   if (!IsBad)
diff --git a/src/find.h b/src/find.h
index 4cc68f8..3a9c7d9 100644
--- a/src/find.h
+++ b/src/find.h
@@ -50,11 +50,12 @@ bool LinePadIntersect (LineType *, PadType *);
 bool ArcPadIntersect (ArcType *, PadType *);
 void LookupElementConnections (ElementType *, FILE *);
 void LookupConnectionsToAllElements (FILE *);
-void LookupConnection (Coord, Coord, bool, Coord, int, bool AndRats);
+void LookupConnection (Coord, Coord, bool, Coord, int, bool AndRats, bool store_undo);
+void LookupObject (int, void *, void *, void *, bool, int, bool AndRats, bool store_undo);
 void LookupUnusedPins (FILE *);
-bool ClearFlagOnLinesAndPolygons (bool, int flag);
-bool ClearFlagOnPinsViasAndPads (bool, int flag);
-bool ClearFlagOnAllObjects (bool, int flag);
+bool ClearFlagOnLinesAndPolygons (bool, int flag, bool store_undo);
+bool ClearFlagOnPinsViasAndPads (bool, int flag, bool store_undo);
+bool ClearFlagOnAllObjects (bool, int flag, bool store_undo);
 void InitConnectionLookup (void);
 void FreeConnectionLookupMemory (void);
 void RatFindHook (int, void *, void *, void *, bool, int flag, bool);
diff --git a/src/global.h b/src/global.h
index a542ccf..d5d2f82 100644
--- a/src/global.h
+++ b/src/global.h
@@ -167,6 +167,7 @@ typedef struct
 	BoxType		BoundingBox;	\
 	long int	ID;		\
 	FlagType	Flags;		\
+	Coord		ExtraDrcClearance; \
 	//	struct LibraryEntryType *net
 
 /* Lines, pads, and rats all use this so they can be cross-cast.  */
@@ -459,7 +460,8 @@ typedef struct
 {
   char *Name,			/* name of the menu entry */
    *directory,			/* Directory name library elements are from */
-   *Style;			/* routing style */
+   *Style,			/* routing style */
+   *Netclass;			/* Net class */
   Cardinal EntryN,		/* number of objects */
     EntryMax;			/* number of reserved memory locations */
   LibraryEntryType *Entry;	/* the entries */
@@ -599,6 +601,7 @@ typedef struct			/* holds cursor information */
   PolygonType AttachedPolygon;
   AttachedObjectType AttachedObject;	/* data of attached objects */
   enum crosshair_shape shape; 	/* shape of crosshair */
+  char *Netclass;
 } CrosshairType;
 
 typedef struct
diff --git a/src/hid/common/draw_drc.c b/src/hid/common/draw_drc.c
new file mode 100644
index 0000000..f6f0fa3
--- /dev/null
+++ b/src/hid/common/draw_drc.c
@@ -0,0 +1,222 @@
+#include "global.h"
+#include "hid.h"
+#include "hid_draw.h"
+#include "data.h" /* For global "PCB" variable */
+#include "misc.h" /* For GetArcEnds() */
+#include "rotate.h" /* For RotateLineLowLevel() */
+#include "polygon.h"
+#include "draw_helpers.h"
+
+/* Hacky chaining of functions */
+static HID_DRAW_CLASS orig_class;
+
+
+/*-----------------------------------------------------------
+ * Draws the outline of a line
+ */
+static void
+thindraw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
+{
+  Coord dx, dy, ox, oy;
+  double h;
+
+  dx = x2 - x1;
+  dy = y2 - y1;
+  if (dx != 0 || dy != 0)
+    h = 0.5 * thick / sqrt (SQUARE (dx) + SQUARE (dy));
+  else
+    h = 0.0;
+  ox = dy * h + 0.5 * SGN (dy);
+  oy = -(dx * h + 0.5 * SGN (dx));
+  hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+  if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
+    {
+      Angle angle = atan2 (dx, dy) * 57.295779;
+      hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+      hid_draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
+      hid_draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
+    }
+}
+
+
+/*-----------------------------------------------------------
+ * Draws the outline of an arc
+ */
+static void
+thindraw_arc (hidGC gc, Coord X, Coord Y, Coord wx, Coord wy, Angle sa, Angle dir, Coord thick)
+{
+  ArcType arc;
+  BoxType *bx;
+  Coord wid = thick / 2;
+
+  arc.X = X;
+  arc.Y = Y;
+  arc.StartAngle = sa;
+  arc.Delta = dir;
+  arc.Width = wx;
+  arc.Height = wy;
+  bx = GetArcEnds (&arc);
+  /*  sa = sa - 180; */
+  hid_draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
+  hid_draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
+  hid_draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
+  hid_draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
+}
+
+
+static void
+common_drc_draw_pcb_line (hidGC gc, LineType *line)
+{
+  orig_class.draw_pcb_line (gc, line);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      line->ExtraDrcClearance == 0)
+    return;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_line (gc, line->Point1.X, line->Point1.Y,
+                     line->Point2.X, line->Point2.Y,
+                     line->Thickness + line->ExtraDrcClearance * 2);
+}
+
+static void
+common_drc_draw_pcb_arc (hidGC gc, ArcType *arc)
+{
+  orig_class.draw_pcb_arc (gc, arc);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      arc->ExtraDrcClearance == 0)
+    return;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta, arc->Thickness + arc->ExtraDrcClearance * 2);
+}
+
+#if 0
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
+ */
+static void
+common_drc_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+{
+  orig_class.draw_pcb_text (gc, Text, min_line_width);
+}
+#endif
+
+void
+common_drc_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+{
+  orig_class.draw_pcb_polygon (gc, polygon, clip_box);
+}
+
+void
+common_drc_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  orig_class.fill_pcb_polygon (gc, poly, clip_box);
+}
+
+void
+common_drc_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+                             const BoxType *clip_box)
+{
+  orig_class.thindraw_pcb_polygon (gc, poly, clip_box);
+}
+
+void
+common_drc_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  PadType drc_pad;
+
+  orig_class.thindraw_pcb_pad (gc, pad, clear, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
+
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
+}
+
+void
+common_drc_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  PadType drc_pad;
+
+  orig_class.fill_pcb_pad (gc, pad, clear, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
+
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
+}
+
+void
+common_drc_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+{
+  PinType drc_pv;
+
+  orig_class.fill_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
+
+  drc_pv = *pv;
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
+}
+
+void
+common_drc_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+{
+  PinType drc_pv;
+
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
+
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
+
+  drc_pv = *pv;
+  pcb_printf ("via clearance was %mn, extra %mn\n", drc_pv.Thickness, pv->ExtraDrcClearance);
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+  pcb_printf ("via clearance is now %mn\n", drc_pv.Thickness);
+
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
+}
+
+void
+common_draw_drc_class_init (HID_DRAW_CLASS *klass)
+{
+  orig_class = *klass; /* Copy function pointers from parent... allows chaining */
+
+  klass->draw_pcb_line        = common_drc_draw_pcb_line;
+  klass->draw_pcb_arc         = common_drc_draw_pcb_arc;
+  klass->draw_pcb_polygon     = common_drc_fill_pcb_polygon;
+//  klass->draw_pcb_text        = common_drc_fill_pcb_text;
+
+  klass->fill_pcb_polygon     = common_drc_fill_pcb_polygon;
+  klass->thindraw_pcb_polygon = common_drc_thindraw_pcb_polygon;
+  klass->fill_pcb_pad         = common_drc_fill_pcb_pad;
+  klass->thindraw_pcb_pad     = common_drc_thindraw_pcb_pad;
+  klass->fill_pcb_pv          = common_drc_fill_pcb_pv;
+  klass->thindraw_pcb_pv      = common_drc_thindraw_pcb_pv;
+}
+
+void
+common_draw_drc_init (HID_DRAW *graphics)
+{
+}
diff --git a/src/hid/common/draw_drc.h b/src/hid/common/draw_drc.h
new file mode 100644
index 0000000..8dab54d
--- /dev/null
+++ b/src/hid/common/draw_drc.h
@@ -0,0 +1,9 @@
+void common_drc_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_drc_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
+void common_drc_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
+void common_drc_pcb_fill_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+void common_drc_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+void common_draw_drc_class_init (HID_DRAW_CLASS *klass);
+void common_draw_drc_init (HID_DRAW *graphics);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 763f493..488f530 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -17,6 +17,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "hid/common/hidnogui.h"
+#include "hid/common/draw_drc.h"
 #include "hid/common/draw_helpers.h"
 #include "pcb-printf.h"
 
@@ -2199,6 +2200,7 @@ hid_gtk_init ()
 
   common_nogui_graphics_class_init (&ghid_graphics_class);
   common_draw_helpers_class_init (&ghid_graphics_class);
+  common_draw_drc_class_init (&ghid_graphics_class); /* XXX: Some vfuncs are overridden below, and the drc helpers won't be drawn! */
 
   ghid_graphics_class.set_layer      = ghid_set_layer;
   ghid_graphics_class.make_gc        = ghid_make_gc;
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index 8f5a352..29232bb 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -101,7 +101,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   if (!gtk_tree_selection_get_selected (selection, &model, &iter))
     {
-      if (ClearFlagOnAllObjects (true, FOUNDFLAG))
+      if (ClearFlagOnAllObjects (true, FOUNDFLAG, true))
         {
           IncrementUndoSerialNumber ();
           Draw ();
@@ -115,7 +115,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   gtk_tree_model_get (model, &iter, DRC_VIOLATION_OBJ_COL, &violation, -1);
 
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
 
   if (violation == NULL)
     return;
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index 089aa7c..7be1188 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -536,14 +536,14 @@ netlist_select_cb (GtkWidget * widget, gpointer data)
     node_selected_net = NULL;
 
   InitConnectionLookup ();
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
 
   for (i = selected_net->EntryN, entry = selected_net->Entry; i; i--, entry++)
     if (SeekPad (entry, &conn, false))
       RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, true, FOUNDFLAG, true);
 
   SelectByFlag (FOUNDFLAG, select_flag);
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
   Draw ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 71327b4..1fed021 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -45,6 +45,7 @@
 #include "find.h"
 #include "search.h"
 #include "rats.h"
+#include "netclass.h"
 #include "snavi.h"
 #include "gui-trackball.h"
 
@@ -400,6 +401,7 @@ describe_location (Coord X, Coord Y)
   char *elename = "";
   char *pinname;
   char *netname = NULL;
+  char *netclass = NULL;
   char *description;
 
   /* check if there are any pins or pads at that position */
@@ -438,6 +440,7 @@ describe_location (Coord X, Coord Y)
         netname = g_strdup (menu->Name);
         /* For some reason, the netname has spaces in front of it, strip them */
         g_strstrip (netname);
+        netclass = menu->Netclass;
         break;
       }
     }
@@ -450,10 +453,12 @@ describe_location (Coord X, Coord Y)
 
   description = g_strdup_printf (_("Element name: %s\n"
                                  "Pinname : %s\n"
-                                 "Netname : %s"),
+                                 "Netname : %s\n"
+                                 "Netclass : %s\n"),
                                  elename,
                                  (pinname != NULL) ? pinname : _("--"),
-                                 (netname != NULL) ? netname : _("--"));
+                                 (netname != NULL) ? netname : _("--"),
+                                 (netclass != NULL) ? netclass : _("--"));
 
   g_free (netname);
 
diff --git a/src/line.c b/src/line.c
index 469f0f6..abad924 100644
--- a/src/line.c
+++ b/src/line.c
@@ -41,6 +41,8 @@
 #include "line.h"
 #include "misc.h"
 #include "rtree.h"
+#include "netclass.h"
+#include "draw.h" /* For Redraw */
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -231,6 +233,11 @@ struct drc_info
   bool bottom_side;
   bool top_side;
   jmp_buf env;
+  ElementType *element;
+  LayerType *layer;
+  char *drawn_line_netclass;
+  Coord drawn_line_clearance;
+  Coord max_clearance;
 };
 
 static int
@@ -238,9 +245,56 @@ drcVia_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
 
-  if (!TEST_FLAG (FOUNDFLAG, via) && PinLineIntersect (via, i->line))
-    longjmp (i->env, 1);
+  if (TEST_FLAG (FOUNDFLAG, via))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_via (via);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (via, i->line))
+    {
+      via->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", via->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
+  return 1;
+}
+
+static int
+drcPin_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, pin))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pin (pin);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (pin, i->line))
+    {
+      pin->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pin->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -249,10 +303,27 @@ drcPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, pad) || TEST_FLAG (ONSOLDERFLAG, pad) != i->bottom_side)
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pad (pad);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
 
-  if (TEST_FLAG (ONSOLDERFLAG, pad) == i->bottom_side &&
-      !TEST_FLAG (FOUNDFLAG, pad) && LinePadIntersect (i->line, pad))
-    longjmp (i->env, 1);
+  if (LinePadIntersect (i->line, pad))
+    {
+      pad->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pad->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -261,9 +332,27 @@ drcLine_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, line))
+    return 1;
 
-  if (!TEST_FLAG (FOUNDFLAG, line) && LineLineIntersect (line, i->line))
-    longjmp (i->env, 1);
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_line (i->layer, line);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (LineLineIntersect (line, i->line))
+    {
+      line->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", line->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -272,9 +361,27 @@ drcArc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, arc))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_arc (i->layer, arc);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
 
-  if (!TEST_FLAG (FOUNDFLAG, arc) && LineArcIntersect (i->line, arc))
-    longjmp (i->env, 1);
+  if (LineArcIntersect (i->line, arc))
+    {
+      arc->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", arc->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -300,11 +407,15 @@ drc_lines (PointType *end, bool way)
   bool two_lines, x_is_long, blocker;
   PointType ans;
 
+  info.drawn_line_netclass = Crosshair.Netclass;
+  info.drawn_line_clearance = PCB->Bloat; /* XXX: PICK THIS UP FROM MIN CLEARANCE IN line_netclass -> * */
+  info.max_clearance = get_max_clearance_for_netclass (info.drawn_line_netclass);
+
   f = 1.0;
   s = 0.5;
   last = -1;
   line1.Flags = line2.Flags = NoFlags ();
-  line1.Thickness = Settings.LineThickness + 2 * (PCB->Bloat + 1);
+  line1.Thickness = Settings.LineThickness + 2 * info.max_clearance;
   line2.Thickness = line1.Thickness;
   line1.Clearance = line2.Clearance = 0;
   line1.Point1.X = Crosshair.AttachedLine.Point1.X;
@@ -404,38 +515,29 @@ drc_lines (PointType *end, bool way)
 	  if (setjmp (info.env) == 0)
 	    {
 	      info.line = &line1;
-	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
-	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
+	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL, drcVia_callback, &info);
+	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL, drcPin_callback, &info);
 	      if (info.bottom_side || info.top_side)
-		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL,
-			  drcPad_callback, &info);
+		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL, drcPad_callback, &info);
 	      if (two_lines)
 		{
 		  info.line = &line2;
-		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
-		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
+		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL, drcVia_callback, &info);
+		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL, drcPin_callback, &info);
 		  if (info.bottom_side || info.top_side)
-		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL,
-			      drcPad_callback, &info);
+		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL, drcPad_callback, &info);
 		}
 	      GROUP_LOOP (PCB->Data, group);
 	      {
 		info.line = &line1;
-		r_search (layer->line_tree, &line1.BoundingBox, NULL,
-			  drcLine_callback, &info);
-		r_search (layer->arc_tree, &line1.BoundingBox, NULL,
-			  drcArc_callback, &info);
+		info.layer = layer;
+		r_search (layer->line_tree, &line1.BoundingBox, NULL, drcLine_callback, &info);
+		r_search (layer->arc_tree,  &line1.BoundingBox, NULL, drcArc_callback,  &info);
 		if (two_lines)
 		  {
 		    info.line = &line2;
-		    r_search (layer->line_tree, &line2.BoundingBox,
-			      NULL, drcLine_callback, &info);
-		    r_search (layer->arc_tree, &line2.BoundingBox,
-			      NULL, drcArc_callback, &info);
+		    r_search (layer->line_tree, &line2.BoundingBox, NULL, drcLine_callback, &info);
+		    r_search (layer->arc_tree,  &line2.BoundingBox, NULL, drcArc_callback,  &info);
 		  }
 	      }
 	      END_LOOP;
@@ -461,6 +563,11 @@ drc_lines (PointType *end, bool way)
 	    {
 	      /* bumped into something, back off */
 	      f2 -= s2;
+	      //SET_FLAG (WARNFLAG, info.object);
+//	      if (TEST_FLAG (AUTODRCFLAG, PCB))
+//	        info.object->ExtraDrcClearance = MM_TO_COORD (1.0);
+//	      Draw (type, info.ptr1, info.ptr2); /* XXX: Need info */
+//	      Redraw (); /* XXX: Sledgehammer */
 	    }
 	  s2 *= 0.5;
 	  length2 = MIN (f2 * temp2, temp2);
@@ -490,16 +597,75 @@ EnforceLineDRC (void)
   /* Silence a bogus compiler warning by storing this in a variable */
   int layer_idx = INDEXOFCURRENT;
 
+  if (!TEST_FLAG (AUTODRCFLAG, PCB) && !TEST_FLAG (SHOWDRCFLAG, PCB))
+    return;
+
   if ( gui->mod1_is_pressed() || gui->control_is_pressed () || PCB->RatDraw
       || layer_idx >= max_copper_layer)
     return;
 
+  /* Reset ExtraDrcClearance on all objects */
+  GROUP_LOOP (PCB->Data, GetLayerGroupNumberByNumber (INDEXOFCURRENT));
+    {
+      LINE_LOOP (layer);
+        {
+          line->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      ARC_LOOP (layer);
+        {
+          arc->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      POLYGON_LOOP (layer);
+        {
+          polygon->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      TEXT_LOOP (layer);
+        {
+          text->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          pin->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          pad->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  VIA_LOOP (PCB->Data);
+    {
+      via->ExtraDrcClearance = 0;
+    }
+  END_LOOP;
+
   rs.X = r45.X = Crosshair.X;
   rs.Y = r45.Y = Crosshair.Y;
+
+  if (!TEST_FLAG (AUTODRCFLAG, PCB))
+    {
+      if (TEST_FLAG (ALLDIRECTIONFLAG, PCB)) /* We don't have code to handle this case! */
+        return;
+
+      drc_lines (&rs, (PCB->Clipping == 2) != gui->shift_is_pressed ());
+      return;
+    }
+
   /* first try starting straight */
-  r1 = drc_lines (&rs, false);
+  r1 = drc_lines (&rs, false);              /* XXX: This code doesn't cope well with all-direction lines (?) */
   /* then try starting at 45 */
-  r2 = drc_lines (&r45, true);
+  r2 = drc_lines (&r45, true);              /* XXX: This code doesn't cope well with all-direction lines (?) */
+
   shift = gui->shift_is_pressed ();
   if (XOR (r1 > r2, shift))
     {
diff --git a/src/netclass.c b/src/netclass.c
new file mode 100644
index 0000000..b81d0dc
--- /dev/null
+++ b/src/netclass.c
@@ -0,0 +1,349 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+//#include <stdio.h>
+#include <string.h>
+//#include <assert.h>
+
+#include "data.h"
+#include "rats.h"
+#include "find.h"
+#include "undo.h"
+#include "pcb-printf.h"
+#include "netclass.h"
+
+static int num_netclass = 10;
+
+static char *netclass_names[10] =
+  {
+    NULL,
+    "PE",
+    "DC+",
+    "BAT+",
+    "PHASE1",
+    "PHASE2",
+    "PHASE3",
+    "PHASE4",
+    "PHASE5",
+    "PHASE6"
+  };
+
+static Coord clearances[10][10] =
+  {
+    {MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2)}
+  };
+
+
+static int
+netclass_index (char *netclass)
+{
+  int i;
+
+  for (i = 0; i < num_netclass; i++)
+    if (netclass == NULL)
+      {
+        if (netclass_names[i] == NULL)
+          return i;
+      }
+    else if (netclass_names[i] != NULL && strcmp (netclass_names[i], netclass) == 0)
+      {
+        return i;
+      }
+
+  g_return_val_if_fail (netclass != NULL, 0);
+  g_warning ("Netclass '%s' not found, returning 0th (default) class", netclass);
+
+  return 0;
+}
+
+static Coord
+clearance_between_netclasses (int a, int b)
+{
+  g_return_val_if_fail (a >= 0 && a < num_netclass, 0);
+  g_return_val_if_fail (b >= 0 && b < num_netclass, 0);
+
+  return clearances[a][b];
+}
+
+Coord
+get_min_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord min_clearance = MAX_COORD;
+
+  for (i = 0; i < num_netclass; i++)
+    min_clearance = MIN (min_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up minimum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              min_clearance);
+#endif
+
+  return min_clearance;
+}
+
+Coord
+get_max_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord max_clearance = 0;
+
+  for (i = 0; i < num_netclass; i++)
+    max_clearance = MAX (max_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up maximum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              max_clearance);
+#endif
+
+  return max_clearance;
+}
+
+Coord
+get_clearance_between_netclasses (char *netclass_a, char *netclass_b)
+{
+  int a = netclass_index (netclass_a);
+  int b = netclass_index (netclass_b);
+  Coord clearance = clearance_between_netclasses (a, b);
+
+#if 0
+  pcb_printf ("Looking up clearance between netclass %s%s%s and %s%s%s, found '%mn'\n",
+              netclass_a != NULL ? "'" : "",
+              netclass_a != NULL ? netclass_a : "(NULL)",
+              netclass_a != NULL ? "'" : "",
+              netclass_b != NULL ? "'" : "",
+              netclass_b != NULL ? netclass_b : "(NULL)",
+              netclass_b != NULL ? "'" : "",
+              clearance);
+#endif
+
+  return clearance;
+}
+
+char *
+get_netclass_for_netname (char *netname)
+{
+  char *menu_netname;
+
+//  g_return_val_if_fail (netname != NULL, NULL);
+  if (netname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      menu_netname = g_strdup (menu->Name);
+      /* For some reason, the netname has spaces in front of it, strip them */
+      g_strstrip (menu_netname);
+      if (strcmp (menu_netname, netname) == 0) {
+        g_free (menu_netname);
+        return menu->Netclass;
+      }
+      g_free (menu_netname);
+    }
+    END_LOOP;
+  }
+  END_LOOP;
+
+  return NULL;
+}
+
+static char *
+g_strdup_netname_for_pinpad (int type, ElementType *ele, void *pinpad)
+{
+  char *pinname;
+  char *netname = NULL;
+
+  pinname = ConnectionName (type, ele, pinpad);
+
+  if (pinname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      if (strcmp (entry->ListEntry, pinname) == 0) {
+        netname = g_strdup (menu->Name);
+        /* For some reason, the netname has spaces in front of it, strip them */
+        g_strstrip (netname);
+        break;
+      }
+    }
+    END_LOOP;
+
+    if (netname != NULL)
+      break;
+  }
+  END_LOOP;
+
+  return netname;
+}
+
+char *
+get_netclass_for_via (PinType *via)
+{
+  char *netname = NULL;
+  char *netclass;
+
+//  netname = g_strdup_netname_for_via (pin->Element, via);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pin (PinType *pin)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+//  printf ("Looking up netname for pin, found '%s'\n", netname);
+  netclass = get_netclass_for_netname (netname);
+//  printf ("Looking up netclass for netname, found '%s'\n", netclass);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pad (PadType *pad)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+static char *
+find_first_flagged_netname (int flag)
+{
+  char *netname = NULL;
+
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pin))
+            {
+              netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pad))
+            {
+              netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      if (netname != NULL)
+        break;
+    }
+  END_LOOP;
+
+  return netname;
+}
+
+/* NB: THIS CALL IS EXPENSIVE!! */
+char *
+find_netname_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /* store_undo */);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupObject (type, ptr1, ptr2, ptr3, false /*AndDraw*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+static char *
+find_netname_at_xy (LayerType *layer, Coord x, Coord y)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /*store_undo*/);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupConnection (x, y, false /*AndDraw*/, 0 /*Range*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+char *
+get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname = NULL;
+
+  netname = find_netname_for_object (type, ptr1, ptr2, ptr3);
+
+  return get_netclass_for_netname (netname);
+}
+
+char *
+get_netclass_for_line (LayerType *layer, LineType *line)
+{
+  return get_netclass_for_object (LINE_TYPE, layer, line, NULL);
+}
+
+char *
+get_netclass_for_arc (LayerType *layer, ArcType *arc)
+{
+  return get_netclass_for_object (ARC_TYPE, layer, arc, NULL);
+}
+
+char *
+get_netclass_at_xy (LayerType *layer, Coord x, Coord y)
+{
+  char *netname = NULL;
+
+  netname = find_netname_at_xy (layer, x, y);
+
+  return get_netclass_for_netname (netname);
+}
diff --git a/src/netclass.h b/src/netclass.h
new file mode 100644
index 0000000..bb6f51c
--- /dev/null
+++ b/src/netclass.h
@@ -0,0 +1,11 @@
+
+Coord get_min_clearance_for_netclass (char *netclass);
+Coord get_max_clearance_for_netclass (char *netclass);
+Coord get_clearance_between_netclasses (char *netclass_a, char *netclass_b);
+char *get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3);
+char *get_netclass_for_via (PinType *via);
+char *get_netclass_for_pin (PinType *pin);
+char *get_netclass_for_pad (PadType *pad);
+char *get_netclass_for_line (LayerType *layer, LineType *line);
+char *get_netclass_for_arc (LayerType *layer, ArcType *arc);
+char *get_netclass_at_xy (LayerType *layer, Coord x, Coord y);
diff --git a/src/netlist.c b/src/netlist.c
index f420fac..7114ae0 100644
--- a/src/netlist.c
+++ b/src/netlist.c
@@ -163,7 +163,7 @@ netlist_find (LibraryMenuType * net, LibraryEntryType * pin)
   int x, y;
   if (pin_name_to_xy (net->Entry, &x, &y))
     return;
-  LookupConnection (x, y, 1, 1, FOUNDFLAG, true);
+  LookupConnection (x, y, 1, 1, FOUNDFLAG, true, true);
 }
 
 static void
@@ -172,7 +172,7 @@ netlist_select (LibraryMenuType * net, LibraryEntryType * pin)
   int x, y;
   if (pin_name_to_xy (net->Entry, &x, &y))
     return;
-  LookupConnection (x, y, 1, 1, SELECTEDFLAG, true);
+  LookupConnection (x, y, 1, 1, SELECTEDFLAG, true, true);
 }
 
 static void
@@ -241,10 +241,19 @@ netlist_style (LibraryMenuType *net, const char *style)
   net->Style = STRDUP ((char *)style);
 }
 
+#if 0
+static void
+netlist_netclass (LibraryMenuType *net, const char *netclass)
+{
+  free (net->Netclass);
+  net->Style = STRDUP ((char *)netclass);
+}
+#endif
+
 /* The primary purpose of this action is to rebuild a netlist from a
    script, in conjunction with the clear action above.  */
 static int
-netlist_add (const char *netname, const char *pinname)
+netlist_add (const char *netname, const char *pinname, const char *netclass)
 {
   int ni, pi;
   LibraryType *netlist = &PCB->NetlistLib;
@@ -259,7 +268,12 @@ netlist_add (const char *netname, const char *pinname)
       }
   if (net == NULL)
     {
-      net = CreateNewNet (netlist, (char *)netname, NULL);
+      net = CreateNewNet (netlist, (char *)netname, NULL, (char *)netclass); /* XXX: Only takes class from the first net */
+    }
+  else
+    {
+      if (strcmp (net->Netclass, netclass) != 0)
+        g_warning ("Netclass '%s' different to initial '%s'... being ignored", netclass, net->Netclass);
     }
 
   for (pi=0; pi<net->EntryN; pi++)
@@ -387,7 +401,7 @@ Netlist (int argc, char **argv, Coord x, Coord y)
   else if (strcasecmp (argv[0], "add") == 0)
     {
       /* Add is different, because the net/pin won't already exist.  */
-      return netlist_add (ARG(1), ARG(2));
+      return netlist_add (ARG(1), ARG(2), NULL); /* Net class? */
     }
   else if (strcasecmp (argv[0], "sort") == 0)
     {
diff --git a/src/parse_y.y b/src/parse_y.y
index 79dc75b..8c42d0f 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -1844,9 +1844,17 @@ The routing style that should be used when autorouting this net.
 
 net
 			/* name style pin pin ... */
-		: T_NET '(' STRING STRING ')' '('
+		: T_NET '(' STRING STRING STRING ')' '('
 			{
-				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4);
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, $5);
+				free ($3);
+				free ($4);
+				free ($5);
+			}
+		 connections ')'
+		| T_NET '(' STRING STRING ')' '('
+			{
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, NULL);
 				free ($3);
 				free ($4);
 			}
diff --git a/src/rats.c b/src/rats.c
index 5c48055..c35f515 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -458,7 +458,7 @@ GatherSubnets (NetListType *Netl, bool NoWarn, bool AndRats)
   for (m = 0; Netl->NetN > 0 && m < Netl->NetN; m++)
     {
       a = &Netl->Net[m];
-      ClearFlagOnAllObjects (false, DRCFLAG);
+      ClearFlagOnAllObjects (false, DRCFLAG, false);
       RatFindHook (a->Connection[0].type, a->Connection[0].ptr1,
                    a->Connection[0].ptr2, a->Connection[0].ptr2,
                    false, DRCFLAG, AndRats);
@@ -537,7 +537,7 @@ GatherSubnets (NetListType *Netl, bool NoWarn, bool AndRats)
       if (!NoWarn)
 	Warned |= CheckShorts (a->Connection[0].menu);
     }
-  ClearFlagOnAllObjects (false, DRCFLAG);
+  ClearFlagOnAllObjects (false, DRCFLAG, false);
   return (Warned);
 }
 
diff --git a/src/report.c b/src/report.c
index 1e49d9d..e9a1cba 100644
--- a/src/report.c
+++ b/src/report.c
@@ -569,7 +569,7 @@ XYtoNetLength (Coord x, Coord y, int *found)
   /* NB: The third argument here, 'false' ensures LookupConnection
    *     does not add its changes to the undo system.
    */
-  LookupConnection (x, y, false, PCB->Grid, FOUNDFLAG, true);
+  LookupConnection (x, y, false, PCB->Grid, FOUNDFLAG, true, false);
 
   ALLLINE_LOOP (PCB->Data);
   {
@@ -616,7 +616,7 @@ ReportAllNetLengths (int argc, char **argv, Coord x, Coord y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() at the end of the procedure.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   for (ni = 0; ni < PCB->NetlistLib.MenuN; ni++)
@@ -678,14 +678,14 @@ ReportAllNetLengths (int argc, char **argv, Coord x, Coord y)
           length = XYtoNetLength (x, y, &found);
 
           /* Reset connectors for the next lookup */
-          ClearFlagOnAllObjects (false, FOUNDFLAG);
+          ClearFlagOnAllObjects (false, FOUNDFLAG, false);
 
           pcb_snprintf(buf, sizeof (buf), _("%$m*"), units_name, length);
           gui->log(_("Net %s length %s\n"), netname, buf);
         }
     }
 
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
   return 0;
 }
@@ -707,14 +707,14 @@ ReportNetLength (int argc, char **argv, Coord x, Coord y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() at the end of the procedure.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   length = XYtoNetLength (x, y, &found);
 
   if (!found)
     {
-      ClearFlagOnAllObjects (false, FOUNDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG, false);
       Undo (true);
       gui->log (_("No net under cursor.\n"));
       return 1;
@@ -776,7 +776,7 @@ ReportNetLength (int argc, char **argv, Coord x, Coord y)
   END_LOOP;
 
 got_net_name:
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
 
   {
@@ -913,13 +913,13 @@ ReportNetLengthByName (char *tofind, int x, int y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() when we are finished.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   length = XYtoNetLength (x, y, &found);
   netname = net->Name + 2;
 
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
 
   if (!found)
diff --git a/src/select.c b/src/select.c
index 3e231d0..2c49342 100644
--- a/src/select.c
+++ b/src/select.c
@@ -976,7 +976,7 @@ SelectObjectByName (int Type, char *Pattern, bool select)
   if (Type & NET_TYPE)
     {
       InitConnectionLookup ();
-      changed = ClearFlagOnAllObjects (true, FOUNDFLAG) || changed;
+      changed = ClearFlagOnAllObjects (true, FOUNDFLAG, true) || changed;
 
       MENU_LOOP (&PCB->NetlistLib);
       {
@@ -997,7 +997,7 @@ SelectObjectByName (int Type, char *Pattern, bool select)
       END_LOOP;
 
       changed = SelectByFlag (FOUNDFLAG, select) || changed;
-      changed = ClearFlagOnAllObjects (false, FOUNDFLAG) || changed;
+      changed = ClearFlagOnAllObjects (false, FOUNDFLAG, false) || changed;
       FreeConnectionLookupMemory ();
     }
 
diff --git a/src/set.c b/src/set.c
index 9bf64b8..03b452a 100644
--- a/src/set.c
+++ b/src/set.c
@@ -300,7 +300,7 @@ SetMode (int Mode)
       Crosshair.AttachedLine.State = STATE_FIRST;
       if (Mode == LINE_MODE && TEST_FLAG (AUTODRCFLAG, PCB))
 	{
-	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
