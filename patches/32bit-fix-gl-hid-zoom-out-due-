Bottom: 41ca87786eb35653056f13eb21e793b17adacbf1
Top:    16b6f04fc0ea79ced90276164382971c6f1b7b0a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-07-05 17:01:18 +0100

32bit: Fix GL HID zoom out, due to over-shooting Coord data-type

Nasty NASTY hack this, but it gets me working again.


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 212814f..efe7076 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -61,6 +61,64 @@ hid_gc_struct;
 
 static void draw_lead_user (render_priv *priv);
 
+#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
+#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
+
+/* Coordinate conversions */
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (Coord x)
+{
+  int rv;
+  if (gport->view.flip_x)
+    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
+  else
+    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
+  return rv;
+}
+
+static inline int
+Vy (Coord y)
+{
+  int rv;
+  if (gport->view.flip_y)
+    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
+  else
+    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
+  return rv;
+}
+
+static inline int
+Vz (Coord z)
+{
+  return z / gport->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
+  if (gport->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
+  if (gport->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
+  return  rv;
+}
+
+static inline Coord
+Pz (int z)
+{
+  return (z * gport->view.coord_per_px);
+}
+
+
 /* Compute group visibility based upon on copper layers only */
 static bool
 is_layer_group_visible (int group)
@@ -1253,8 +1311,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
-  *pcb_x = EVENT_TO_PCB_X (event_x);
-  *pcb_y = EVENT_TO_PCB_Y (event_y);
+  *pcb_x = SIDE_X((gint)(event_x * gport->view.coord_per_px + gport->view.x0));
+  *pcb_y = SIDE_Y((gint)(event_y * gport->view.coord_per_px + gport->view.y0));
 
   return true;
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c7d894e..1987086 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -109,9 +109,51 @@ hid_gc_struct;
 
 
 static void draw_lead_user (render_priv *priv);
-static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
+static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_x, double *pcb_y);
 
 
+
+/* Coordinate conversions */
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (Coord z)
+{
+  return z / gport->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  double rv = (double)x * gport->view.coord_per_px + gport->view.x0;
+
+  if (gport->view.flip_x)
+    rv = PCB->MaxWidth - rv;
+
+  if (rv > G_MAXINT / 4)
+    rv = G_MAXINT / 4;
+
+  if (rv < -G_MAXINT / 4)
+    rv = -G_MAXINT / 4;
+
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  double rv = (double)y * gport->view.coord_per_px + gport->view.y0;
+  if (gport->view.flip_y)
+    rv = PCB->MaxHeight - rv;
+
+  if (rv > G_MAXINT / 4)
+    rv = G_MAXINT / 4;
+
+  if (rv < -G_MAXINT / 4)
+    rv = -G_MAXINT / 4;
+
+  return  rv;
+}
+
 #define BOARD_THICKNESS         MM_TO_COORD(1.60)
 #define MASK_COPPER_SPACING     MM_TO_COORD(0.05)
 #define SILK_MASK_SPACING       MM_TO_COORD(0.01)
@@ -2045,9 +2087,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   render_priv *priv = port->render_priv;
   GtkAllocation allocation;
   BoxType region;
-  Coord min_x, min_y;
-  Coord max_x, max_y;
-  Coord new_x, new_y;
+  double min_x, min_y;
+  double max_x, max_y;
+  double new_x, new_y;
   Coord min_depth;
   Coord max_depth;
   float aspect;
@@ -2232,6 +2274,15 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     max_y = PCB->MaxHeight;
   }
 
+  if (min_x < (double)-G_MAXINT / 4.) min_x = -G_MAXINT / 4;
+  if (min_y < (double)-G_MAXINT / 4.) min_y = -G_MAXINT / 4;
+  if (max_x < (double)-G_MAXINT / 4.) max_x = -G_MAXINT / 4;
+  if (max_y < (double)-G_MAXINT / 4.) max_y = -G_MAXINT / 4;
+  if (min_x > (double) G_MAXINT / 4.) min_x =  G_MAXINT / 4;
+  if (min_y > (double) G_MAXINT / 4.) min_y =  G_MAXINT / 4;
+  if (max_x > (double) G_MAXINT / 4.) max_x =  G_MAXINT / 4;
+  if (max_y > (double) G_MAXINT / 4.) max_y =  G_MAXINT / 4;
+
   region.X1 = min_x;  region.X2 = max_x + 1;
   region.Y1 = min_y;  region.Y2 = max_y + 1;
 
@@ -2296,7 +2347,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glColor3f (1., 1., 1.);
 
   if (0) {
-    Coord x, y;
+    double x, y;
     Coord z = max_depth;
 
     glBegin (GL_LINES);
@@ -2861,7 +2912,7 @@ invert_4x4 (float m[4][4], float out[4][4])
 
 
 static bool
-ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y)
+ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_x, double *pcb_y)
 {
   double mat[2][2];
   double inv_mat[2][2];
@@ -2933,8 +2984,11 @@ ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb
 //  if (fvx < (double)-G_MAXINT/5.) {fvx = (double)-G_MAXINT/5.; printf ("fvx underflow clamped\n"); }
 //  if (fvy < (double)-G_MAXINT/5.) {fvy = (double)-G_MAXINT/5.; printf ("fvy underflow clamped\n"); }
 
-  *pcb_x = (Coord)fvx;
-  *pcb_y = (Coord)fvy;
+//  *pcb_x = (Coord)fvx;
+//  *pcb_y = (Coord)fvy;
+
+  *pcb_x = fvx;
+  *pcb_y = fvy;
 
   {
     /* Reproject the computed board plane coordinates to eye space */
@@ -2963,7 +3017,15 @@ ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
-  return ghid_unproject_to_z_plane (event_x, event_y, global_depth, pcb_x, pcb_y);
+  double tmp_x, tmp_y;
+  bool retval;
+
+  retval = ghid_unproject_to_z_plane (event_x, event_y, global_depth, &tmp_x, &tmp_y);
+
+  *pcb_x = tmp_x;
+  *pcb_y = tmp_y;
+
+  return retval;
 }
 
 bool
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 0b5a516..9e5b15e 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -81,7 +81,7 @@ ghid_pan_view_rel (Coord dx, Coord dy)
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 static void
-ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+ghid_zoom_view_abs (double center_x, double center_y, double new_zoom)
 {
   double min_zoom, max_zoom;
   double xtmp, ytmp;
@@ -114,7 +114,7 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 }
 
 void
-ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+ghid_zoom_view_rel (double center_x, double center_y, double factor)
 {
   ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
 }
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 2918a50..bb5fedf 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -65,12 +65,6 @@
 #define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
 #define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
 
-#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
-#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
-
-#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
-#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -159,10 +153,10 @@ typedef struct
 {
   double coord_per_px; /* Zoom level described as PCB units per screen pixel */
 
-  Coord x0;
-  Coord y0;
-  Coord width;
-  Coord height;
+  double x0;
+  double y0;
+  double width;
+  double height;
 
   bool flip_x;
   bool flip_y;
@@ -521,7 +515,7 @@ void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);
 
 /* gtkhid-main.c */
-void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
+void ghid_zoom_view_rel (double center_x, double center_y, double factor);
 void ghid_pan_view_rel (Coord dx, Coord dy);
 void ghid_get_coords (const char *msg, Coord *x, Coord *y);
 gint PCBChanged (int argc, char **argv, Coord x, Coord y);
@@ -533,59 +527,4 @@ extern GdkPixmap *XC_hand_source, *XC_hand_mask;
 extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
-
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (Coord x)
-{
-  int rv;
-  if (gport->view.flip_x)
-    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (Coord y)
-{
-  int rv;
-  if (gport->view.flip_y)
-    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (Coord z)
-{
-  return z / gport->view.coord_per_px + 0.5;
-}
-
-static inline Coord
-Px (int x)
-{
-  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
-  if (gport->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
-  return  rv;
-}
-
-static inline Coord
-Py (int y)
-{
-  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
-  if (gport->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
-  return  rv;
-}
-
-static inline Coord
-Pz (int z)
-{
-  return (z * gport->view.coord_per_px);
-}
-
 #endif /* PCB_HID_GTK_GHID_H */
