Bottom: 4c7f4c75eb775b0d9f42f669d5baf42855019976
Top:    7cada5db3d247cf807b6cf835cd0e9e353f22bb9
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-23 10:39:17 +0000

Off to find burried treasure on polygon island

Add feature to remove islanded areas

Known bugs:

When dragging a via with a "solid" style thermal, a polygon piece
will not (always?) be un-flagged as an island. The same via as part
of a selection will re-create the polygon.


---

diff --git a/src/change.c b/src/change.c
index 62dd821..620e1f1 100644
--- a/src/change.c
+++ b/src/change.c
@@ -1177,10 +1177,12 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
-  {
-  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, true);
-  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
-  }
+    {
+      AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, true);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+    }
+  else
+    MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
   DrawLine (Layer, Line, 0);
   return (Line);
 }
@@ -1225,9 +1227,11 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
     {
-      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, true);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
     }
+  else
+    MarkPourIslands (PCB->Data, ARC_TYPE, Layer, Arc);
   DrawArc (Layer, Arc, 0);
   return (Arc);
 }
@@ -1271,10 +1275,12 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
-  {
-  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, true);
-  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
-  }
+    {
+      AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, true);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
+    }
+  else
+    MarkPourIslands (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (Text);
 }
@@ -1625,6 +1631,8 @@ ChangeHole (PinTypePtr Via)
     {
       AddObjectTo2ndSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->DrillingHole = Via->Thickness - MIN_PINORVIACOPPER;
+#warning FIXME Later: Come back to check this
+      MarkPourIslands (PCB->Data, VIA_TYPE, Via, Via);
     }
   DrawVia (Via, 0);
   Draw ();
diff --git a/src/draw.c b/src/draw.c
index a1914d1..af1a34b 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -2107,6 +2107,10 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   if (!Polygon->Clipped)
     return;
 
+  /* Re-use HOLEFLAG to cut out islands */
+  if (TEST_FLAG (HOLEFLAG, Polygon))
+    return;
+
   if (Gathering)
     {
       AddPart (Polygon);
diff --git a/src/find.c b/src/find.c
index 84216f8..6a00e8b 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2645,6 +2645,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 
   if (!Polygon->Clipped)
     return false;
+
   info.polygon = *Polygon;
   EXPAND_BOUNDS (&info.polygon);
   info.layer = LayerGroup;
@@ -3980,6 +3981,70 @@ doIsBad:
 }
 
 /*-----------------------------------------------------------------------------
+ * Check for islanding of a polygon
+ * by determining if any non-polygon objects are connected to it.
+ */
+int
+IsPolygonAnIsland (LayerType *layer, PolygonType *polygon)
+{
+  int connected_count = 0;
+  int any_more;
+  int i;
+
+  InitConnectionLookup ();
+
+  /* Need to ensure we don't set the SELECTED flag as we find
+   * things, otherwise we don't get our quick escape due to the
+   * "drc" magic.
+   *
+   * (The connection scanning code doesn't stop on objects which are
+   *  SELECTED, even if "drc" is true).
+   *
+   * Ideally we'd clear the SELECTED flag on all objects before we
+   * start, ensuring we exit when we first find connectivity, but
+   * that causes all manner of breakage. I upsets other logic in
+   * PCB if we change the selection during certain operations we're
+   * called during.
+   */
+  TheFlag = FOUNDFLAG | DRCFLAG;
+
+  ResetConnections (false, false);
+
+  /* Let the search stop if we find something we haven't yet seen */
+  drc = true;
+  User = false;
+
+  ListStart (POLYGON_TYPE, layer, polygon, polygon);
+
+  do
+    {
+      any_more = DoIt (false, false);
+
+      /* Check if we got any useful hits */
+      connected_count = 0;
+      for (i = 0; i < max_copper_layer; i++)
+        {
+          connected_count += LineList[ i ].Number;
+          /* No need to search all layers when one will do */
+          if (connected_count)
+            break;
+        }
+      connected_count += PadList[ COMPONENT_LAYER ].Number;
+      connected_count += PadList[ SOLDER_LAYER ].Number;
+      connected_count += PVList.Number;
+      if (connected_count)
+        break;
+    }
+  while (any_more);
+
+  drc = false;
+  ResetConnections (false, false);
+  FreeConnectionLookupMemory ();
+
+  return (connected_count == 0);
+}
+
+/*-----------------------------------------------------------------------------
  * Check for DRC violations
  * see if the connectivity changes when everything is bloated, or shrunk
  */
diff --git a/src/find.h b/src/find.h
index df5289d..f2b8b6b 100644
--- a/src/find.h
+++ b/src/find.h
@@ -66,6 +66,7 @@ void FreeLayoutLookupMemory (void);
 void RatFindHook (int, void *, void *, void *, bool, bool);
 void SaveFindFlag (int);
 void RestoreFindFlag (void);
+int IsPolygonAnIsland (LayerTypePtr, PolygonTypePtr);
 int DRCAll (void);
 bool lineClear (LineTypePtr, Cardinal);
 bool IsLineInPolygon (LineTypePtr, PolygonTypePtr);
diff --git a/src/move.c b/src/move.c
index 665d441..c64ad22 100644
--- a/src/move.c
+++ b/src/move.c
@@ -393,7 +393,10 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      if (TEST_FLAG (CLEARLINEFLAG, Line))
+        ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      else
+        MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
diff --git a/src/pour.c b/src/pour.c
index b8d9562..943e511 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -66,7 +66,7 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 100
+#define UNSUBTRACT_BLOAT 10
 #define SUBTRACT_PIN_VIA_BATCH_SIZE 100
 #define SUBTRACT_LINE_BATCH_SIZE 20
 
@@ -759,7 +759,36 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 }
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+check_polygon_island_cb (const BoxType * b, void *cl)
+{
+  PolygonTypePtr polygon = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+
+  ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (info->layer, polygon), polygon);
+  return 1;
+}
+
+static int
+mark_islands (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  struct cpInfo info;
+  BoxType region = ((PinTypePtr) ptr2)->BoundingBox;
+
+  region.X1 -= UNSUBTRACT_BLOAT;
+  region.Y1 -= UNSUBTRACT_BLOAT;
+  region.X2 += UNSUBTRACT_BLOAT;
+  region.Y2 += UNSUBTRACT_BLOAT;
+
+  info.region = &region;
+  info.layer = layer;
+
+  return r_search (pour->polygon_tree, info.region, NULL,
+                   check_polygon_island_cb, &info);
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
               int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
@@ -769,7 +798,7 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
       np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
@@ -783,6 +812,10 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     case POLYGON_TYPE:
       np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
       break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
+      break;
     case TEXT_TYPE:
       np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
       break;
@@ -900,6 +933,8 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
   return 0;
 }
 
@@ -1026,7 +1061,7 @@ PourToPoly (PourType *p)
 }
 
 static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+add_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
           int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *tmp, *start_pg;
@@ -1037,22 +1072,26 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
-      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, layer, pour);
       break;
     case ARC_TYPE:
-      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, layer, pour);
       break;
     case PAD_TYPE:
-      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, layer, pour);
       break;
     case POLYGON_TYPE:
-      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, layer, pour);
+      break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
       break;
     case TEXT_TYPE:
-      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, layer, pour);
       break;
     }
 
@@ -1139,7 +1178,7 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
   printf ("After unsubtract, counted %i polygon pieces\n", count);
 #endif
 
-  ClearPour (PCB->Data, Layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+  ClearPour (PCB->Data, layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
 
   if (pg == NULL)
     {
@@ -1180,6 +1219,8 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
 //  printf ("ClearPour counted %i polygon pieces, and added the biggest %i\n", count_all, count_added);
 
   return 0;
@@ -1270,6 +1311,12 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
     }
   while ((pg = tmp) != start_pg);
 
+  POURPOLYGON_LOOP (pour);
+  {
+    ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (layer, polygon), polygon);
+  }
+  END_LOOP;
+
   return 1;
 }
 
@@ -1299,7 +1346,8 @@ int
 PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
            int (*call_back) (DataTypePtr data, LayerTypePtr lay,
                              PourTypePtr poly, int type,
-                             void *ptr1, void *ptr2))
+                             void *ptr1, void *ptr2),
+           int ignore_clearflags)
 {
   BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
   int r = 0;
@@ -1339,8 +1387,10 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
     case ARC_TYPE:
     case TEXT_TYPE:
     case POLYGON_TYPE:
+    case POUR_TYPE:
       /* the cast works equally well for lines and arcs */
-      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+      if (!ignore_clearflags &&
+          !TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
         return 0;
       /* silk doesn't plow */
       if (GetLayerNumber (Data, ptr1) >= max_copper_layer)
@@ -1371,12 +1421,12 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
       {
         PIN_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back, ignore_clearflags);
         }
         END_LOOP;
         PAD_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back, ignore_clearflags);
         }
         END_LOOP;
       }
@@ -1396,7 +1446,7 @@ RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from RestoreToPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, add_plow);
+  PlowPours (Data, type, ptr1, ptr2, add_plow, false);
 }
 
 void
@@ -1410,7 +1460,7 @@ ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from ClearFromPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow, false);
 }
 
 /* Convert a POLYAREA (and all linked POLYAREA) to
@@ -1467,3 +1517,12 @@ PolyToPoursOnLayer (DataType *Destination, LayerType *Layer,
 
   SetChangedFlag (true);
 }
+
+#warning FIXME Later: We could perhaps reduce un-necessary computation by using this function
+void
+MarkPourIslands (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (!Data->ClipPours)
+    return;
+  PlowPours (Data, type, ptr1, ptr2, mark_islands, true);
+}
diff --git a/src/pour.h b/src/pour.h
index 4711da7..c2b1385 100644
--- a/src/pour.h
+++ b/src/pour.h
@@ -47,6 +47,7 @@ void CopyAttachedPourToLayer (void);
 int InitPourClip(DataType *d, LayerType *l, PourType *p);
 void RestoreToPours(DataType *, int, void *, void *);
 void ClearFromPours(DataType *, int, void *, void *);
+void MarkPourIslands(DataType *, int, void *, void *);
 
 POLYAREA * PourToPoly (PourType *);
 void PolyToPoursOnLayer (DataType *, LayerType *, POLYAREA *, FlagType);
diff --git a/src/search.c b/src/search.c
index 584fbeb..bef35eb 100644
--- a/src/search.c
+++ b/src/search.c
@@ -454,7 +454,7 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
   return (true);
 }
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
 #if 0
 static int
 pour_callback (const BoxType * box, void *cl)
@@ -488,7 +488,7 @@ SearchPourByLocation (int locked, LayerTypePtr * Layer,
   info.ptr3 = (void **) Dummy;
   info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
   if (setjmp (info.env) == 0)
     {
       r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback, &info);
