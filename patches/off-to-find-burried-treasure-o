Bottom: a9227f2be2bd41b524c3c4f97afb17788947b516
Top:    beddbd92b339322d05f8a6663b90a9c95524217f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-03 23:35:52 +0100

Off to find burried treasure on polygon island

Add feature to remove islanded areas

Known bugs:

When dragging a via with a "solid" style thermal, a polygon piece
will not (always?) be un-flagged as an island. The same via as part
of a selection will re-create the polygon.


---

diff --git a/src/buffer.c b/src/buffer.c
index a5992d8..5f9f4d0 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -390,7 +390,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   LayerTypePtr lay;
   PourTypePtr pour;
 
-  RestoreToPours (Source, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (Source, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   pour = GetPourMemory (lay);
@@ -407,7 +407,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   if (!lay->pour_tree)
     lay->pour_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
-  ClearFromPours (Source, POLYGON_TYPE, Layer, Pour);
+  ClearFromPours (Dest, POUR_TYPE, lay, Pour);
   return (pour);
 }
 
diff --git a/src/change.c b/src/change.c
index 3c4f926..2d45c7f 100644
--- a/src/change.c
+++ b/src/change.c
@@ -1180,10 +1180,12 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
-  {
-  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, true);
-  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
-  }
+    {
+      AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, true);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+    }
+  else
+    MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
   DrawLine (Layer, Line, 0);
   return (Line);
 }
@@ -1228,9 +1230,11 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
     {
-      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, true);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
     }
+  else
+    MarkPourIslands (PCB->Data, ARC_TYPE, Layer, Arc);
   DrawArc (Layer, Arc, 0);
   return (Arc);
 }
@@ -1274,10 +1278,12 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
-  {
-  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, true);
-  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
-  }
+    {
+      AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, true);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
+    }
+  else
+    MarkPourIslands (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (Text);
 }
@@ -1299,10 +1305,12 @@ ChangePourJoin (LayerTypePtr Layer, PourTypePtr pour)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, pour, pour);
   TOGGLE_FLAG (CLEARLINEFLAG, pour);
   if (TEST_FLAG(CLEARLINEFLAG, pour))
-  {
-  AddObjectToClearPourUndoList (POUR_TYPE, Layer, pour, pour, true);
-  ClearFromPours (PCB->Data, POUR_TYPE, Layer, pour);
-  }
+    {
+      AddObjectToClearPourUndoList (POUR_TYPE, Layer, pour, pour, true);
+      ClearFromPours (PCB->Data, POUR_TYPE, Layer, pour);
+    }
+  else
+    MarkPourIslands (PCB->Data, POUR_TYPE, Layer, pour);
   DrawPour (Layer, pour, 0);
   return (pour);
 }
@@ -1675,6 +1683,8 @@ ChangeHole (PinTypePtr Via)
     {
       AddObjectTo2ndSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->DrillingHole = Via->Thickness - MIN_PINORVIACOPPER;
+#warning FIXME Later: Come back to check this
+      MarkPourIslands (PCB->Data, VIA_TYPE, Via, Via);
     }
   DrawVia (Via, 0);
   Draw ();
diff --git a/src/draw.c b/src/draw.c
index 382ea63..a2547f3 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -2112,6 +2112,10 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   if (!Polygon->Clipped)
     return;
 
+  /* Re-use HOLEFLAG to cut out islands */
+  if (TEST_FLAG (HOLEFLAG, Polygon))
+    return;
+
   if (Gathering)
     {
       AddPart (Polygon);
diff --git a/src/find.c b/src/find.c
index d8a955f..af9103c 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2649,6 +2649,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 
   if (!Polygon->Clipped)
     return false;
+
   info.polygon = *Polygon;
   EXPAND_BOUNDS (&info.polygon);
   info.layer = LayerGroup;
@@ -4000,6 +4001,70 @@ doIsBad:
 }
 
 /*-----------------------------------------------------------------------------
+ * Check for islanding of a polygon
+ * by determining if any non-polygon objects are connected to it.
+ */
+int
+IsPolygonAnIsland (LayerType *layer, PolygonType *polygon)
+{
+  int connected_count = 0;
+  int any_more;
+  int i;
+
+  InitConnectionLookup ();
+
+  /* Need to ensure we don't set the SELECTED flag as we find
+   * things, otherwise we don't get our quick escape due to the
+   * "drc" magic.
+   *
+   * (The connection scanning code doesn't stop on objects which are
+   *  SELECTED, even if "drc" is true).
+   *
+   * Ideally we'd clear the SELECTED flag on all objects before we
+   * start, ensuring we exit when we first find connectivity, but
+   * that causes all manner of breakage. I upsets other logic in
+   * PCB if we change the selection during certain operations we're
+   * called during.
+   */
+  TheFlag = FOUNDFLAG | DRCFLAG;
+
+  ResetConnections (false);
+
+  /* Let the search stop if we find something we haven't yet seen */
+  drc = true;
+  User = false;
+
+  ListStart (POLYGON_TYPE, layer, polygon, polygon);
+
+  do
+    {
+      any_more = DoIt (false, false);
+
+      /* Check if we got any useful hits */
+      connected_count = 0;
+      for (i = 0; i < max_layer; i++)
+        {
+          connected_count += LineList[ i ].Number;
+          /* No need to search all layers when one will do */
+          if (connected_count)
+            break;
+        }
+      connected_count += PadList[ COMPONENT_LAYER ].Number;
+      connected_count += PadList[ SOLDER_LAYER ].Number;
+      connected_count += PVList.Number;
+      if (connected_count)
+        break;
+    }
+  while (any_more);
+
+  drc = false;
+  ResetConnections (false);
+  FreeConnectionLookupMemory ();
+
+  return (connected_count == 0);
+}
+
+/*-----------------------------------------------------------------------------
  * Check for DRC violations
  * see if the connectivity changes when everything is bloated, or shrunk
  */
diff --git a/src/find.h b/src/find.h
index f93fca1..0e0e1c9 100644
--- a/src/find.h
+++ b/src/find.h
@@ -65,6 +65,7 @@ void FreeLayoutLookupMemory (void);
 void RatFindHook (int, void *, void *, void *, bool, bool);
 void SaveFindFlag (int);
 void RestoreFindFlag (void);
+int IsPolygonAnIsland (LayerTypePtr, PolygonTypePtr);
 int DRCAll (void);
 bool lineClear (LineTypePtr, Cardinal);
 bool IsLineInPolygon (LineTypePtr, PolygonTypePtr);
diff --git a/src/move.c b/src/move.c
index d2431c5..a9ec320 100644
--- a/src/move.c
+++ b/src/move.c
@@ -366,12 +366,12 @@ MovePour (LayerTypePtr Layer, PourTypePtr Pour)
     {
       ErasePour (Pour);
     }
-  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (PCB->Data, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MovePourLowLevel (Pour, DeltaX, DeltaY);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   InitPourClip (PCB->Data, Layer, Pour);
-  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  ClearFromPours (PCB->Data, POUR_TYPE, Layer, Pour);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
@@ -395,7 +395,10 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      if (TEST_FLAG (CLEARLINEFLAG, Line))
+        ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      else
+        MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -430,14 +433,17 @@ MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
     {
       ErasePour (Pour);
     }
-  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (PCB->Data, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
   SetPourBoundingBox (Pour);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   RemoveExcessPourPoints (Layer, Pour);
   InitPourClip (PCB->Data, Layer, Pour);
-  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  if (!TEST_FLAG (CLEARPOLYFLAG, Pour))
+    ClearFromPours (PCB->Data, POUR_TYPE, Layer, Pour);
+  else
+    MarkPourIslands (PCB->Data, POUR_TYPE, Layer, Pour);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
diff --git a/src/pour.c b/src/pour.c
index ec6c09f..9108506 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -66,7 +66,7 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 100
+#define UNSUBTRACT_BLOAT 10
 #define SUBTRACT_PIN_VIA_BATCH_SIZE 100
 #define SUBTRACT_LINE_BATCH_SIZE 20
 
@@ -691,7 +691,36 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 }
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+check_polygon_island_cb (const BoxType * b, void *cl)
+{
+  PolygonTypePtr polygon = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+
+  ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (info->layer, polygon), polygon);
+  return 1;
+}
+
+static int
+mark_islands (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  struct cpInfo info;
+  BoxType region = ((PinTypePtr) ptr2)->BoundingBox;
+
+  region.X1 -= UNSUBTRACT_BLOAT;
+  region.Y1 -= UNSUBTRACT_BLOAT;
+  region.X2 += UNSUBTRACT_BLOAT;
+  region.Y2 += UNSUBTRACT_BLOAT;
+
+  info.region = &region;
+  info.layer = layer;
+
+  return r_search (pour->polygon_tree, info.region, NULL,
+                   check_polygon_island_cb, &info);
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
               int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
@@ -701,7 +730,7 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
       np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
@@ -715,6 +744,10 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     case POLYGON_TYPE:
       np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
       break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
+      break;
     case TEXT_TYPE:
       np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
       break;
@@ -832,6 +865,8 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
   return 0;
 }
 
@@ -934,7 +969,7 @@ original_pour_poly (PourType * p)
 }
 
 static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+add_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
           int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *tmp, *start_pg;
@@ -945,22 +980,26 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
-      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, layer, pour);
       break;
     case ARC_TYPE:
-      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, layer, pour);
       break;
     case PAD_TYPE:
-      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, layer, pour);
       break;
     case POLYGON_TYPE:
-      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, layer, pour);
+      break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
       break;
     case TEXT_TYPE:
-      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, layer, pour);
       break;
     }
 
@@ -1047,7 +1086,7 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
   printf ("After unsubtract, counted %i polygon pieces\n", count);
 #endif
 
-  ClearPour (PCB->Data, Layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+  ClearPour (PCB->Data, layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
 
   if (pg == NULL)
     {
@@ -1088,6 +1127,8 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
 //  printf ("ClearPour counted %i polygon pieces, and added the biggest %i\n", count_all, count_added);
 
   return 0;
@@ -1165,6 +1206,12 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
     }
   while ((pg = tmp) != start_pg);
 
+  POURPOLYGON_LOOP (pour);
+  {
+    ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (layer, polygon), polygon);
+  }
+  END_LOOP;
+
   return 1;
 }
 
@@ -1194,7 +1241,8 @@ int
 PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
            int (*call_back) (DataTypePtr data, LayerTypePtr lay,
                              PourTypePtr poly, int type,
-                             void *ptr1, void *ptr2))
+                             void *ptr1, void *ptr2),
+           int ignore_clearflags)
 {
   BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
   int r = 0;
@@ -1234,8 +1282,10 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
     case ARC_TYPE:
     case TEXT_TYPE:
     case POLYGON_TYPE:
+    case POUR_TYPE:
       /* the cast works equally well for lines and arcs */
-      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+      if (!ignore_clearflags &&
+          !TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
         return 0;
       /* silk doesn't plow */
       if (GetLayerNumber (Data, ptr1) >= max_layer)
@@ -1267,12 +1317,12 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
       {
         PIN_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back, ignore_clearflags);
         }
         END_LOOP;
         PAD_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back, ignore_clearflags);
         }
         END_LOOP;
       }
@@ -1292,7 +1342,7 @@ RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from RestoreToPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, add_plow);
+  PlowPours (Data, type, ptr1, ptr2, add_plow, false);
 }
 
 void
@@ -1306,6 +1356,14 @@ ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from ClearFromPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow, false);
 }
 
+#warning FIXME Later: We could perhaps reduce un-necessary computation by using this function
+void
+MarkPourIslands (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (!Data->ClipPours)
+    return;
+  PlowPours (Data, type, ptr1, ptr2, mark_islands, true);
+}
diff --git a/src/pour.h b/src/pour.h
index 79bebc2..f51a071 100644
--- a/src/pour.h
+++ b/src/pour.h
@@ -43,5 +43,6 @@ void CopyAttachedPourToLayer (void);
 int InitPourClip(DataType *d, LayerType *l, PourType *p);
 void RestoreToPours(DataType *, int, void *, void *);
 void ClearFromPours(DataType *, int, void *, void *);
+void MarkPourIslands(DataType *, int, void *, void *);
 
 #endif /* __POUR_INCLUDED__ */
diff --git a/src/search.c b/src/search.c
index 69f260f..b61b008 100644
--- a/src/search.c
+++ b/src/search.c
@@ -454,7 +454,7 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
   return (true);
 }
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
 #if 0
 static int
 pour_callback (const BoxType * box, void *cl)
@@ -488,7 +488,7 @@ SearchPourByLocation (int locked, LayerTypePtr * Layer,
   info.ptr3 = (void **) Dummy;
   info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
   if (setjmp (info.env) == 0)
     {
       r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback, &info);
