Bottom: baed2244fa1f5dcba2471a9e48e2c179c135660a
Top:    8e7122456d35407ec766118f3c25b6dd9407e14b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-28 21:27:32 +0000

Work on trying to fix the STEP export to be correct (cf. Solidworks BREP mapping)


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index f99c308..3ce98ae 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -300,7 +300,7 @@ get_contour_edge_n_round_geometry_in_step_mm (PLINE *contour, int n, double *cx,
       *cx = COORD_TO_STEP_X (PCB, contour->cx);
       *cy = COORD_TO_STEP_Y (PCB, contour->cy);
       *r = COORD_TO_MM (contour->radius);
-      *cw = (contour->Flags.orient != PLF_DIR);
+      *cw = (contour->Flags.orient == PLF_INV);
       return;
     }
 #endif
@@ -316,7 +316,7 @@ get_contour_edge_n_round_geometry_in_step_mm (PLINE *contour, int n, double *cx,
   *cx = COORD_TO_STEP_X (PCB, edge->cx);
   *cy = COORD_TO_STEP_Y (PCB, edge->cy);
   *r = COORD_TO_MM (edge->radius);
-  *cw = (compare_ccw_cw (EDGE_BACKWARD_VERTEX (edge)->point, center, EDGE_FORWARD_VERTEX (edge)->point) > 0);
+  *cw = (compare_ccw_cw (EDGE_BACKWARD_VERTEX (edge)->point, center, EDGE_FORWARD_VERTEX (edge)->point) < 0);
 }
 
 typedef struct
@@ -531,6 +531,8 @@ object3d_from_contours (POLYAREA *contours,
           LDATA (edges[              i]) = faces[npoints];
           RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
           LDATA (edges[1 * npoints + i]) = faces[i];
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
         }
       else
         {
@@ -538,15 +540,6 @@ object3d_from_contours (POLYAREA *contours,
           RDATA (edges[              i]) = faces[npoints];
           LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
           RDATA (edges[1 * npoints + i]) = faces[i];
-        }
-
-      if (invert)
-        {
-          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          LDATA (edges[2 * npoints + i]) = faces[i];
-        }
-      else
-        {
           LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
           RDATA (edges[2 * npoints + i]) = faces[i];
         }
@@ -640,6 +633,7 @@ object3d_from_contours (POLYAREA *contours,
 #ifdef REVERSED_PCB_CONTOURS
         normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
+        /* XXX: NOT SURE THIS IS CORRECT! */
         normal_z = cw ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #endif
 
@@ -1993,7 +1987,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 #endif
     }
 
-  if (1) /* Drill holes */
+  if (0) /* Drill holes */
     {
       Coord top_depth;
       Coord bottom_depth;
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 5b2cd40..97b3201 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -259,7 +259,7 @@ object3d_to_step_body_fragment (step_file *step,
     step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
 
     /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
-    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, /*true*/ !info->is_round);
     step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
     step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
   }
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 2bb9bfd..ac61199 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -202,7 +202,7 @@ step_do_export (HID_Attr_Val * options)
         poly_DelContour (&curc);
       }
 
-#if 1
+#if 0
     mask_objects = object3d_from_soldermask_within_area (piece, TOP_SIDE);
     board_outline_list = g_list_concat (board_outline_list, mask_objects);
 
@@ -210,8 +210,10 @@ step_do_export (HID_Attr_Val * options)
     board_outline_list = g_list_concat (board_outline_list, mask_objects);
 #endif
 
+#if 0
     copper_layer_objects = object3d_from_copper_layers_within_area (piece);
     board_outline_list = g_list_concat (board_outline_list, copper_layer_objects);
+#endif
 
   } while ((piece = piece->f) != board_outline);
   poly_Free (&board_outline);
diff --git a/src/polygon.c b/src/polygon.c
index f587028..c62a56c 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -303,7 +303,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector
       c->head.prev->point[1] == v[1])
     {
       /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
-      c->head.prev->is_round = true;
+//      c->head.prev->is_round = true;
       c->head.prev->cx = X;
       c->head.prev->cy = Y;
       c->head.prev->radius = radius;
@@ -525,7 +525,7 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       c->head.prev->point[1] == v[1])
     {
       /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
-      c->head.prev->is_round = true;
+//      c->head.prev->is_round = true;
       c->head.prev->cx = X;
       c->head.prev->cy = Y;
       c->head.prev->radius = radius;
@@ -573,7 +573,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       c->head.prev->point[1] == v[1])
     {
       /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
-      c->head.prev->is_round = true;
+//      c->head.prev->is_round = true;
       c->head.prev->cx = X;
       c->head.prev->cy = Y;
       c->head.prev->radius = radius;
@@ -619,7 +619,7 @@ CirclePoly (Coord x, Coord y, Coord radius, char *name)
   if ((contour = poly_NewContour (poly_CreateNodeArcApproximation (v, x, y, radius))) == NULL)
     return NULL;
   frac_circle2 (contour, x, y, v, 1);
-  contour->is_round = TRUE;
+  contour->is_round = false;// TRUE;
   contour->cx = x;
   contour->cy = y;
   contour->radius = radius;
diff --git a/src/polygon1.c b/src/polygon1.c
index 9427dc5..bfcac68 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -200,7 +200,7 @@ poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
   *c++ = *v++;
   *c = *v;
 
-  res->is_round = is_round;
+  res->is_round = false;// is_round;
   res->cx = cx;
   res->cy = cy;
   res->radius = radius;
