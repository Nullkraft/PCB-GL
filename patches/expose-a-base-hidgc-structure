Bottom: 02941366b997ce7bc6b13f5e478f8fb1f77c3030
Top:    8a7caffa3134c478cc0766e66ef54bc5bcef2e7d
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-06 17:22:51 +0000

Expose a base hidGC structure for HIDs to inherit from.

Have each HID inherit from a common base structure, which will later allow us
to store enough reference to the HID / HID_DRAW code owning the hidGC to
wrap up the API calls (rather than calling directly into the vfunc table).


---

diff --git a/src/hid.h b/src/hid.h
index 43451c4..5ff0c2c 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -54,9 +54,11 @@ extern "C"
     void *ptr;
   } hidval;
 
-/* This graphics context is an opaque pointer defined by the HID.  GCs
-   are HID-specific; attempts to use one HID's GC for a different HID
-   will result in a fatal error.  */
+/* This graphics context is an semi-opaque pointer defined by the HID.
+   GCs are HID-specific; attempts to use one HID's GC for a different
+   HID will result in a fatal error. Certain elements are defined in
+   hid_draw.h are visible for use in draw.c, but the full structure
+   size may not be determined from that definition. */
   typedef struct hid_gc_struct *hidGC;
 
 #define HIDCONCAT(a,b) a##b
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index 3714dfe..e807d9c 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -29,10 +29,6 @@
 /* This is a text-line "batch" HID, which exists for scripting and
    non-GUI needs.  */
 
-typedef struct hid_gc_struct
-{
-  int nothing_interesting_here;
-} hid_gc_struct;
 
 static HID_Attribute *
 batch_get_export_options (int *n_ret)
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 432e374..fa608fc 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -21,10 +21,12 @@
 
 static BoxType box;
 
-typedef struct hid_gc_struct
+typedef struct extents_gc_struct
 {
+  struct hid_gc_struct hid_gc; /* Parent */
+
   int width;
-} hid_gc_struct;
+} *extentsGC;
 
 static int
 extents_set_layer (const char *name, int group, int empty)
@@ -56,9 +58,9 @@ extents_set_layer (const char *name, int group, int empty)
 static hidGC
 extents_make_gc (void)
 {
-  hidGC rv = (hidGC)malloc (sizeof (hid_gc_struct));
-  memset (rv, 0, sizeof (hid_gc_struct));
-  return rv;
+  hidGC gc = (hidGC)calloc (1, sizeof (struct extents_gc_struct));
+
+  return gc;
 }
 
 static void
@@ -85,7 +87,9 @@ extents_set_line_cap (hidGC gc, EndCapStyle style)
 static void
 extents_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  extentsGC extents_gc = (extentsGC)gc;
+
+  extents_gc->width = width;
 }
 
 static void
@@ -101,28 +105,34 @@ extents_set_draw_xor (hidGC gc, int xor_)
 static void
 extents_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  PEX (x1, gc->width);
-  PEY (y1, gc->width);
-  PEX (x2, gc->width);
-  PEY (y2, gc->width);
+  extentsGC extents_gc = (extentsGC)gc;
+
+  PEX (x1, extents_gc->width);
+  PEY (y1, extents_gc->width);
+  PEX (x2, extents_gc->width);
+  PEY (y2, extents_gc->width);
 }
 
 static void
 extents_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 		  Angle start_angle, Angle end_angle)
 {
+  extentsGC extents_gc = (extentsGC)gc;
+
   /* Naive but good enough.  */
-  PEX (cx, width + gc->width);
-  PEY (cy, height + gc->width);
+  PEX (cx, width + extents_gc->width);
+  PEY (cy, height + extents_gc->width);
 }
 
 static void
 extents_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  PEX (x1, gc->width);
-  PEY (y1, gc->width);
-  PEX (x2, gc->width);
-  PEY (y2, gc->width);
+  extentsGC extents_gc = (extentsGC)gc;
+
+  PEX (x1, extents_gc->width);
+  PEY (y1, extents_gc->width);
+  PEX (x2, extents_gc->width);
+  PEY (y2, extents_gc->width);
 }
 
 static void
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 2e09138..ed45bad 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -22,11 +22,6 @@
 
 #define CRASH fprintf(stderr, "HID error: pcb called GUI function %s without having a GUI available.\n", __FUNCTION__); abort()
 
-typedef struct hid_gc_struct
-{
-  int nothing_interesting_here;
-} hid_gc_struct;
-
 static HID_Attribute *
 nogui_get_export_options (int *n_ret)
 {
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 2030fe8..3b2f01e 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -88,16 +88,17 @@ struct color_struct
   unsigned int r, g, b;
 };
 
-struct hid_gc_struct
+typedef struct gcode_gc_struct
 {
-  HID *me_pointer;
+  struct hid_gc_struct hid_gc; /* Parent */
+
   EndCapStyle cap;
   int width;
   unsigned char r, g, b;
   int erase;
   struct color_struct *color;
   gdImagePtr brush;
-};
+} *gcodeGC;
 
 static struct color_struct *black = NULL, *white = NULL;
 static int linewidth = -1;
@@ -1173,14 +1174,18 @@ gcode_set_layer (const char *name, int group, int empty)
 static hidGC
 gcode_make_gc (void)
 {
-  hidGC rv = (hidGC) malloc (sizeof (struct hid_gc_struct));
-  rv->me_pointer = &gcode_hid;
-  rv->cap = Trace_Cap;
-  rv->width = 1;
-  rv->color = (struct color_struct *) malloc (sizeof (*rv->color));
-  rv->color->r = rv->color->g = rv->color->b = 0;
-  rv->color->c = 0;
-  return rv;
+  hidGC gc = (hidGC) calloc (1, sizeof (struct gcode_gc_struct));
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
+  gc->me_pointer = &gcode_hid;
+
+  gcode_gc->cap = Trace_Cap;
+  gcode_gc->width = 1;
+  gcode_gc->color = (struct color_struct *) malloc (sizeof (*gcode_gc->color));
+  gcode_gc->color->r = gcode_gc->color->g = gcode_gc->color->b = 0;
+  gcode_gc->color->c = 0;
+
+  return gc;
 }
 
 static void
@@ -1198,6 +1203,8 @@ gcode_use_mask (enum mask_mode mode)
 static void
 gcode_set_color (hidGC gc, const char *name)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   if (gcode_im == NULL)
     {
       return;
@@ -1208,32 +1215,36 @@ gcode_set_color (hidGC gc, const char *name)
     }
   if (!strcmp (name, "drill"))
     {
-      gc->color = black;
-      gc->erase = 0;
+      gcode_gc->color = black;
+      gcode_gc->erase = 0;
       return;
     }
   if (!strcmp (name, "erase"))
     {
       /* FIXME -- should be background, not white */
-      gc->color = white;
-      gc->erase = 1;
+      gcode_gc->color = white;
+      gcode_gc->erase = 1;
       return;
     }
-  gc->color = black;
-  gc->erase = 0;
+  gcode_gc->color = black;
+  gcode_gc->erase = 0;
   return;
 }
 
 static void
 gcode_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
+  gcode_gc->cap = style;
 }
 
 static void
 gcode_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
+  gcode_gc->width = width;
 }
 
 static void
@@ -1250,6 +1261,8 @@ gcode_set_draw_faded (hidGC gc, int faded)
 static void
 use_gc (hidGC gc)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   int need_brush = 0;
 
   if (gc->me_pointer != &gcode_hid)
@@ -1257,20 +1270,20 @@ use_gc (hidGC gc)
       fprintf (stderr, "Fatal: GC from another HID passed to gcode HID\n");
       abort ();
     }
-  if (linewidth != gc->width)
+  if (linewidth != gcode_gc->width)
     {
       /* Make sure the scaling doesn't erase lines completely */
       /*
-         if (SCALE (gc->width) == 0 && gc->width > 0)
+         if (SCALE (gcode_gc->width) == 0 && gcode_gc->width > 0)
          gdImageSetThickness (im, 1);
          else
        */
       gdImageSetThickness (gcode_im,
-                           pcb_to_gcode (gc->width + 2 * gcode_toolradius));
-      linewidth = gc->width;
+                           pcb_to_gcode (gcode_gc->width + 2 * gcode_toolradius));
+      linewidth = gcode_gc->width;
       need_brush = 1;
     }
-  if (lastbrush != gc->brush || need_brush)
+  if (lastbrush != gcode_gc->brush || need_brush)
     {
       static void *bcache = 0;
       hidval bval;
@@ -1278,58 +1291,58 @@ use_gc (hidGC gc)
       char type;
       int r;
 
-      switch (gc->cap)
+      switch (gcode_gc->cap)
         {
         case Round_Cap:
         case Trace_Cap:
           type = 'C';
-          r = pcb_to_gcode (gc->width / 2 + gcode_toolradius);
+          r = pcb_to_gcode (gcode_gc->width / 2 + gcode_toolradius);
           break;
         default:
         case Square_Cap:
-          r = pcb_to_gcode (gc->width + gcode_toolradius * 2);
+          r = pcb_to_gcode (gcode_gc->width + gcode_toolradius * 2);
           type = 'S';
           break;
         }
-      sprintf (name, "#%.2x%.2x%.2x_%c_%d", gc->color->r, gc->color->g,
-               gc->color->b, type, r);
+      sprintf (name, "#%.2x%.2x%.2x_%c_%d", gcode_gc->color->r, gcode_gc->color->g,
+               gcode_gc->color->b, type, r);
 
       if (hid_cache_color (0, name, &bval, &bcache))
         {
-          gc->brush = (gdImagePtr)bval.ptr;
+          gcode_gc->brush = (gdImagePtr)bval.ptr;
         }
       else
         {
           int bg, fg;
           if (type == 'C')
-            gc->brush = gdImageCreate (2 * r + 1, 2 * r + 1);
+            gcode_gc->brush = gdImageCreate (2 * r + 1, 2 * r + 1);
           else
-            gc->brush = gdImageCreate (r + 1, r + 1);
-          bg = gdImageColorAllocate (gc->brush, 255, 255, 255);
+            gcode_gc->brush = gdImageCreate (r + 1, r + 1);
+          bg = gdImageColorAllocate (gcode_gc->brush, 255, 255, 255);
           fg =
-            gdImageColorAllocate (gc->brush, gc->color->r, gc->color->g,
-                                  gc->color->b);
-          gdImageColorTransparent (gc->brush, bg);
+            gdImageColorAllocate (gcode_gc->brush, gcode_gc->color->r, gcode_gc->color->g,
+                                  gcode_gc->color->b);
+          gdImageColorTransparent (gcode_gc->brush, bg);
 
           /*
            * if we shrunk to a radius/box width of zero, then just use
            * a single pixel to draw with.
            */
           if (r == 0)
-            gdImageFilledRectangle (gc->brush, 0, 0, 0, 0, fg);
+            gdImageFilledRectangle (gcode_gc->brush, 0, 0, 0, 0, fg);
           else
             {
               if (type == 'C')
-                gdImageFilledEllipse (gc->brush, r, r, 2 * r, 2 * r, fg);
+                gdImageFilledEllipse (gcode_gc->brush, r, r, 2 * r, 2 * r, fg);
               else
-                gdImageFilledRectangle (gc->brush, 0, 0, r, r, fg);
+                gdImageFilledRectangle (gcode_gc->brush, 0, 0, r, r, fg);
             }
-          bval.ptr = gc->brush;
+          bval.ptr = gcode_gc->brush;
           hid_cache_color (1, name, &bval, &bcache);
         }
 
-      gdImageSetBrush (gcode_im, gc->brush);
-      lastbrush = gc->brush;
+      gdImageSetBrush (gcode_im, gcode_gc->brush);
+      lastbrush = gcode_gc->brush;
 
     }
 }
@@ -1337,19 +1350,23 @@ use_gc (hidGC gc)
 static void
 gcode_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   use_gc (gc);
   gdImageRectangle (gcode_im,
                     pcb_to_gcode (x1 - gcode_toolradius),
                     pcb_to_gcode (y1 - gcode_toolradius),
                     pcb_to_gcode (x2 + gcode_toolradius),
                     pcb_to_gcode (y2 + gcode_toolradius),
-                    gc->color->c);
+                    gcode_gc->color->c);
 /*      printf("Rect %d %d %d %d\n",x1,y1,x2,y2); */
 }
 
 static void
 gcode_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   use_gc (gc);
   gdImageSetThickness (gcode_im, 0);
   linewidth = 0;
@@ -1358,16 +1375,18 @@ gcode_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
                       pcb_to_gcode (y1 - gcode_toolradius),
                       pcb_to_gcode (x2 + gcode_toolradius),
                       pcb_to_gcode (y2 + gcode_toolradius),
-                      gc->color->c);
+                      gcode_gc->color->c);
 /*      printf("FillRect %d %d %d %d\n",x1,y1,x2,y2); */
 }
 
 static void
 gcode_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   if (x1 == x2 && y1 == y2)
     {
-      Coord w = gc->width / 2;
+      Coord w = gcode_gc->width / 2;
       gcode_fill_rect (gc,
                        x1 - w, y1 - w,
                        x1 + w, y1 + w);
@@ -1420,7 +1439,7 @@ gcode_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
           cx, cy, width, height, start_angle, delta_angle, sa, ea);
   printf ("gdImageArc (%p, %d, %d, %d, %d, %d, %d, %d)\n",
           im, SCALE_X (cx), SCALE_Y (cy),
-          SCALE (width), SCALE (height), sa, ea, gc->color->c);
+          SCALE (width), SCALE (height), sa, ea, gcode_gc->color->c);
 #endif
   use_gc (gc);
   gdImageSetThickness (gcode_im, 0);
@@ -1513,6 +1532,8 @@ add_hole (struct single_size_drills* drill,
 static void
 gcode_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
+
   use_gc (gc);
 
   gdImageSetThickness (gcode_im, 0);
@@ -1522,7 +1543,7 @@ gcode_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
                         pcb_to_gcode (cy),
                         pcb_to_gcode (2 * radius + gcode_toolradius * 2),
                         pcb_to_gcode (2 * radius + gcode_toolradius * 2),
-                        gc->color->c);
+                        gcode_gc->color->c);
   if (save_drill && is_drill)
     {
       double diameter_inches = COORD_TO_INCH(radius*2);
@@ -1539,6 +1560,7 @@ gcode_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 static void
 gcode_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
+  gcodeGC gcode_gc = (gcodeGC)gc;
   int i;
   gdPoint *points;
 
@@ -1556,7 +1578,7 @@ gcode_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
     }
   gdImageSetThickness (gcode_im, 0);
   linewidth = 0;
-  gdImageFilledPolygon (gcode_im, points, n_coords, gc->color->c);
+  gdImageFilledPolygon (gcode_im, points, n_coords, gcode_gc->color->c);
   free (points);
 /*      printf("FillPoly\n"); */
 }
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 31b8c90..b450568 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -293,14 +293,16 @@ setLayerApertureList (int layer_idx)
 static HID gerber_hid;
 static HID_DRAW gerber_graphics;
 
-typedef struct hid_gc_struct
+typedef struct gerber_gc_struct
 {
+  struct hid_gc_struct hid_gc; /* Parent */
+
   EndCapStyle cap;
   int width;
   int color;
   int erase;
   int drill;
-} hid_gc_struct;
+} *gerberGC;
 
 static FILE *f = NULL;
 static char *filename = NULL;
@@ -935,9 +937,14 @@ gerber_set_layer (const char *name, int group, int empty)
 static hidGC
 gerber_make_gc (void)
 {
-  hidGC rv = (hidGC) calloc (1, sizeof (*rv));
-  rv->cap = Trace_Cap;
-  return rv;
+  hidGC gc = (hidGC) calloc (1, sizeof (struct gerber_gc_struct));
+  gerberGC gerber_gc = (gerberGC)gc;
+
+  gc->me_pointer = &gerber_hid;
+
+  gerber_gc->cap = Trace_Cap;
+
+  return gc;
 }
 
 static void
@@ -955,36 +962,42 @@ gerber_use_mask (enum mask_mode mode)
 static void
 gerber_set_color (hidGC gc, const char *name)
 {
+  gerberGC gerber_gc = (gerberGC)gc;
+
   if (strcmp (name, "erase") == 0)
     {
-      gc->color = 1;
-      gc->erase = 1;
-      gc->drill = 0;
+      gerber_gc->color = 1;
+      gerber_gc->erase = 1;
+      gerber_gc->drill = 0;
     }
   else if (strcmp (name, "drill") == 0)
     {
-      gc->color = 1;
-      gc->erase = 0;
-      gc->drill = 1;
+      gerber_gc->color = 1;
+      gerber_gc->erase = 0;
+      gerber_gc->drill = 1;
     }
   else
     {
-      gc->color = 0;
-      gc->erase = 0;
-      gc->drill = 0;
+      gerber_gc->color = 0;
+      gerber_gc->erase = 0;
+      gerber_gc->drill = 0;
     }
 }
 
 static void
 gerber_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  gerberGC gerber_gc = (gerberGC)gc;
+
+  gerber_gc->cap = style;
 }
 
 static void
 gerber_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  gerberGC gerber_gc = (gerberGC)gc;
+
+  gerber_gc->width = width;
 }
 
 static void
@@ -996,6 +1009,8 @@ gerber_set_draw_xor (hidGC gc, int xor_)
 static void
 use_gc (hidGC gc, int radius)
 {
+  gerberGC gerber_gc = (gerberGC)gc;
+
   if (radius)
     {
       radius *= 2;
@@ -1010,14 +1025,14 @@ use_gc (hidGC gc, int radius)
 	  lastcap = Round_Cap;
 	}
     }
-  else if (linewidth != gc->width || lastcap != gc->cap)
+  else if (linewidth != gerber_gc->width || lastcap != gerber_gc->cap)
     {
       Aperture *aptr;
       ApertureShape shape;
 
-      linewidth = gc->width;
-      lastcap = gc->cap;
-      switch (gc->cap)
+      linewidth = gerber_gc->width;
+      lastcap = gerber_gc->cap;
+      switch (gerber_gc->cap)
 	{
 	case Round_Cap:
 	case Trace_Cap:
@@ -1049,9 +1064,10 @@ gerber_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 static void
 gerber_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gerberGC gerber_gc = (gerberGC)gc;
   bool m = false;
 
-  if (x1 != x2 && y1 != y2 && gc->cap == Square_Cap)
+  if (x1 != x2 && y1 != y2 && gerber_gc->cap == Square_Cap)
     {
       Coord x[5], y[5];
       double tx, ty, theta;
@@ -1060,8 +1076,8 @@ gerber_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 
       /* T is a vector half a thickness long, in the direction of
 	 one of the corners.  */
-      tx = gc->width / 2.0 * cos (theta + M_PI/4) * sqrt(2.0);
-      ty = gc->width / 2.0 * sin (theta + M_PI/4) * sqrt(2.0);
+      tx = gerber_gc->width / 2.0 * cos (theta + M_PI/4) * sqrt(2.0);
+      ty = gerber_gc->width / 2.0 * sin (theta + M_PI/4) * sqrt(2.0);
 
       x[0] = x1 - tx;      y[0] = y1 - ty;
       x[1] = x2 + ty;      y[1] = y2 - tx;
@@ -1114,11 +1130,12 @@ static void
 gerber_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 		 Angle start_angle, Angle delta_angle)
 {
+  gerberGC gerber_gc = (gerberGC)gc;
   bool m = false;
   double arcStartX, arcStopX, arcStartY, arcStopY;
 
   /* we never draw zero-width lines */
-  if (gc->width == 0)
+  if (gerber_gc->width == 0)
     return;
 
   use_gc (gc, 0);
@@ -1137,7 +1154,7 @@ gerber_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
     {
       double step, angle;
       Coord max = width > height ? width : height;
-      Coord minr = max - gc->width / 10;
+      Coord minr = max - gerber_gc->width / 10;
       int nsteps;
       Coord x0, y0, x1, y1;
 
@@ -1195,6 +1212,8 @@ gerber_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 gerber_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  gerberGC gerber_gc = (gerberGC)gc;
+
   if (radius <= 0)
     return;
   if (is_drill)
@@ -1217,7 +1236,7 @@ gerber_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
       n_pending_drills++;
       return;
     }
-  else if (gc->drill && !flash_drills)
+  else if (gerber_gc->drill && !flash_drills)
     return;
   if (cx != lastX)
     {
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index dcaf26d..9b679e5 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -15,6 +15,7 @@
 #endif
 
 extern HID ghid_hid;
+extern HID_DRAW ghid_graphics;
 
 /* Sets priv->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -46,18 +47,18 @@ typedef struct render_priv {
 } render_priv;
 
 
-typedef struct hid_gc_struct
+typedef struct gtk_gc_struct
 {
-  HID *me_pointer;
-  GdkGC *gc;
+  struct hid_gc_struct hid_gc; /* Parent */
+
+  GdkGC *gdk_gc;
 
   gchar *colorname;
   Coord width;
   gint cap, join;
   gchar xor_mask;
   gint mask_seq;
-}
-hid_gc_struct;
+} *gtkGC;
 
 
 static void draw_lead_user (render_priv *priv);
@@ -111,20 +112,24 @@ ghid_set_layer (const char *name, int group, int empty)
 void
 ghid_destroy_gc (hidGC gc)
 {
-  if (gc->gc)
-    g_object_unref (gc->gc);
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  if (gtk_gc->gdk_gc)
+    g_object_unref (gtk_gc->gdk_gc);
   g_free (gc);
 }
 
 hidGC
 ghid_make_gc (void)
 {
-  hidGC rv;
+  hidGC gc = (hidGC)g_new0 (struct gtk_gc_struct, 1);
+  gtkGC gtk_gc = (gtkGC)gc;
 
-  rv = g_new0 (hid_gc_struct, 1);
-  rv->me_pointer = &ghid_hid;
-  rv->colorname = Settings.BackgroundColor;
-  return rv;
+  gc->me_pointer = &ghid_hid;
+
+  gtk_gc->colorname = Settings.BackgroundColor;
+
+  return gc;
 }
 
 static void
@@ -256,7 +261,7 @@ ghid_draw_bg_image (void)
 				   w - x, h - y, GDK_RGB_DITHER_NORMAL, 0, 0);
 }
 
-#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? priv->mask_gc : (gc)->gc)
+#define WHICH_GC(gtk_gc) (cur_mask == HID_MASK_CLEAR ? priv->mask_gc : (gtk_gc)->gdk_gc)
 
 void
 ghid_use_mask (enum mask_mode mode)
@@ -368,6 +373,7 @@ ghid_set_special_colors (HID_Attribute * ha)
 void
 ghid_set_color (hidGC gc, const char *name)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   static void *cache = 0;
   hidval cval;
 
@@ -378,19 +384,19 @@ ghid_set_color (hidGC gc, const char *name)
       name = "magenta";
     }
 
-  gc->colorname = (char *) name;
-  if (!gc->gc)
+  gtk_gc->colorname = (char *) name;
+  if (!gtk_gc->gdk_gc)
     return;
   if (gport->colormap == 0)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
 
   if (strcmp (name, "erase") == 0)
     {
-      gdk_gc_set_foreground (gc->gc, &gport->bg_color);
+      gdk_gc_set_foreground (gtk_gc->gdk_gc, &gport->bg_color);
     }
   else if (strcmp (name, "drill") == 0)
     {
-      gdk_gc_set_foreground (gc->gc, &gport->offlimits_color);
+      gdk_gc_set_foreground (gtk_gc->gdk_gc, &gport->offlimits_color);
     }
   else
     {
@@ -413,7 +419,7 @@ ghid_set_color (hidGC gc, const char *name)
 	    gdk_color_white (gport->colormap, &cc->color);
 	  cc->color_set = 1;
 	}
-      if (gc->xor_mask)
+      if (gtk_gc->xor_mask)
 	{
 	  if (!cc->xor_set)
 	    {
@@ -423,11 +429,11 @@ ghid_set_color (hidGC gc, const char *name)
 	      gdk_color_alloc (gport->colormap, &cc->xor_color);
 	      cc->xor_set = 1;
 	    }
-	  gdk_gc_set_foreground (gc->gc, &cc->xor_color);
+	  gdk_gc_set_foreground (gtk_gc->gdk_gc, &cc->xor_color);
 	}
       else
 	{
-	  gdk_gc_set_foreground (gc->gc, &cc->color);
+	  gdk_gc_set_foreground (gtk_gc->gdk_gc, &cc->color);
 	}
     }
 }
@@ -435,52 +441,57 @@ ghid_set_color (hidGC gc, const char *name)
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   render_priv *priv = gport->render_priv;
 
   switch (style)
     {
     case Trace_Cap:
     case Round_Cap:
-      gc->cap = GDK_CAP_ROUND;
-      gc->join = GDK_JOIN_ROUND;
+      gtk_gc->cap = GDK_CAP_ROUND;
+      gtk_gc->join = GDK_JOIN_ROUND;
       break;
     case Square_Cap:
     case Beveled_Cap:
-      gc->cap = GDK_CAP_PROJECTING;
-      gc->join = GDK_JOIN_MITER;
+      gtk_gc->cap = GDK_CAP_PROJECTING;
+      gtk_gc->join = GDK_JOIN_MITER;
       break;
     }
-  if (gc->gc)
-    gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
-				(GdkCapStyle)gc->cap, (GdkJoinStyle)gc->join);
+  if (gtk_gc->gdk_gc)
+    gdk_gc_set_line_attributes (WHICH_GC (gtk_gc),
+                                Vz (gtk_gc->width), GDK_LINE_SOLID,
+                                (GdkCapStyle)gtk_gc->cap, (GdkJoinStyle)gtk_gc->join);
 }
 
 void
 ghid_set_line_width (hidGC gc, Coord width)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   render_priv *priv = gport->render_priv;
 
-  gc->width = width;
-  if (gc->gc)
-    gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
-				(GdkCapStyle)gc->cap, (GdkJoinStyle)gc->join);
+  gtk_gc->width = width;
+  if (gtk_gc->gdk_gc)
+    gdk_gc_set_line_attributes (WHICH_GC (gtk_gc),
+                                Vz (gtk_gc->width), GDK_LINE_SOLID,
+                                (GdkCapStyle)gtk_gc->cap, (GdkJoinStyle)gtk_gc->join);
 }
 
 void
 ghid_set_draw_xor (hidGC gc, int xor_mask)
 {
-  gc->xor_mask = xor_mask;
-  if (!gc->gc)
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->xor_mask = xor_mask;
+  if (!gtk_gc->gdk_gc)
     return;
-  gdk_gc_set_function (gc->gc, xor_mask ? GDK_XOR : GDK_COPY);
-  ghid_set_color (gc, gc->colorname);
+  gdk_gc_set_function (gtk_gc->gdk_gc, xor_mask ? GDK_XOR : GDK_COPY);
+  ghid_set_color (gc, gtk_gc->colorname);
 }
 
 static int
 use_gc (hidGC gc)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->top_window);
 
@@ -492,30 +503,31 @@ use_gc (hidGC gc)
 
   if (!gport->pixmap)
     return 0;
-  if (!gc->gc)
+  if (!gtk_gc->gdk_gc)
     {
-      gc->gc = gdk_gc_new (window);
-      ghid_set_color (gc, gc->colorname);
-      ghid_set_line_width (gc, gc->width);
-      ghid_set_line_cap (gc, (EndCapStyle)gc->cap);
-      ghid_set_draw_xor (gc, gc->xor_mask);
-      gdk_gc_set_clip_origin (gc->gc, 0, 0);
+      gtk_gc->gdk_gc = gdk_gc_new (window);
+      ghid_set_color (gc, gtk_gc->colorname);
+      ghid_set_line_width (gc, gtk_gc->width);
+      ghid_set_line_cap (gc, (EndCapStyle)gtk_gc->cap);
+      ghid_set_draw_xor (gc, gtk_gc->xor_mask);
+      gdk_gc_set_clip_origin (gtk_gc->gdk_gc, 0, 0);
     }
-  if (gc->mask_seq != mask_seq)
+  if (gtk_gc->mask_seq != mask_seq)
     {
       if (mask_seq)
-	gdk_gc_set_clip_mask (gc->gc, gport->mask);
+        gdk_gc_set_clip_mask (gtk_gc->gdk_gc, gport->mask);
       else
-	set_clip (priv, gc->gc);
-      gc->mask_seq = mask_seq;
+        set_clip (priv, gtk_gc->gdk_gc);
+      gtk_gc->mask_seq = mask_seq;
     }
-  priv->u_gc = WHICH_GC (gc);
+  priv->u_gc = WHICH_GC (gtk_gc);
   return 1;
 }
 
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   double dx1, dy1, dx2, dy2;
   render_priv *priv = gport->render_priv;
 
@@ -525,7 +537,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dy2 = Vy ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
+                 &dx1, &dy1, &dx2, &dy2, gtk_gc->width / gport->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -575,10 +587,11 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
 void
 ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   gint w, h, lw;
   render_priv *priv = gport->render_priv;
 
-  lw = gc->width;
+  lw = gtk_gc->width;
   w = gport->width * gport->view.coord_per_px;
   h = gport->height * gport->view.coord_per_px;
 
@@ -661,10 +674,11 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 void
 ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   gint w, h, lw, xx, yy;
   render_priv *priv = gport->render_priv;
 
-  lw = gc->width;
+  lw = gtk_gc->width;
   w = gport->width * gport->view.coord_per_px;
   h = gport->height * gport->view.coord_per_px;
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cfb647e..6f551c8 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -73,18 +73,15 @@ typedef struct render_priv {
   hidGC crosshair_gc;
 } render_priv;
 
-
-typedef struct hid_gc_struct
+typedef struct gtk_gc_struct
 {
-  HID *me_pointer;
+  struct hid_gc_struct hid_gc; /* Parent */
 
   const char *colorname;
   double alpha_mult;
   Coord width;
   gint cap, join;
-}
-hid_gc_struct;
-
+} *gtkGC;
 
 static void draw_lead_user (render_priv *priv);
 static void ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
@@ -197,13 +194,15 @@ ghid_destroy_gc (hidGC gc)
 hidGC
 ghid_make_gc (void)
 {
-  hidGC rv;
+  hidGC gc = (hidGC) g_new0 (struct gtk_gc_struct, 1);
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gc->me_pointer = &ghid_hid;
+
+  gtk_gc->colorname = Settings.BackgroundColor;
+  gtk_gc->alpha_mult = 1.0;
 
-  rv = g_new0 (hid_gc_struct, 1);
-  rv->me_pointer = &ghid_hid;
-  rv->colorname = Settings.BackgroundColor;
-  rv->alpha_mult = 1.0;
-  return rv;
+  return gc;
 }
 
 static void
@@ -378,6 +377,7 @@ typedef struct
 static void
 set_gl_color_for_gc (hidGC gc)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   render_priv *priv = gport->render_priv;
   static void *cache = NULL;
   hidval cval;
@@ -385,24 +385,24 @@ set_gl_color_for_gc (hidGC gc)
   double r, g, b, a;
 
   if (priv->current_colorname != NULL &&
-      strcmp (priv->current_colorname, gc->colorname) == 0 &&
-      priv->current_alpha_mult == gc->alpha_mult)
+      strcmp (priv->current_colorname, gtk_gc->colorname) == 0 &&
+      priv->current_alpha_mult == gtk_gc->alpha_mult)
     return;
 
   free (priv->current_colorname);
-  priv->current_colorname = strdup (gc->colorname);
-  priv->current_alpha_mult = gc->alpha_mult;
+  priv->current_colorname = strdup (gtk_gc->colorname);
+  priv->current_alpha_mult = gtk_gc->alpha_mult;
 
   if (gport->colormap == NULL)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
-  if (strcmp (gc->colorname, "erase") == 0)
+  if (strcmp (gtk_gc->colorname, "erase") == 0)
     {
       r = gport->bg_color.red   / 65535.;
       g = gport->bg_color.green / 65535.;
       b = gport->bg_color.blue  / 65535.;
       a = 1.0;
     }
-  else if (strcmp (gc->colorname, "drill") == 0)
+  else if (strcmp (gtk_gc->colorname, "drill") == 0)
     {
       r = gport->offlimits_color.red   / 65535.;
       g = gport->offlimits_color.green / 65535.;
@@ -411,19 +411,19 @@ set_gl_color_for_gc (hidGC gc)
     }
   else
     {
-      if (hid_cache_color (0, gc->colorname, &cval, &cache))
+      if (hid_cache_color (0, gtk_gc->colorname, &cval, &cache))
         cc = (ColorCache *) cval.ptr;
       else
         {
           cc = (ColorCache *) malloc (sizeof (ColorCache));
           memset (cc, 0, sizeof (*cc));
           cval.ptr = cc;
-          hid_cache_color (1, gc->colorname, &cval, &cache);
+          hid_cache_color (1, gtk_gc->colorname, &cval, &cache);
         }
 
       if (!cc->color_set)
         {
-          if (gdk_color_parse (gc->colorname, &cc->color))
+          if (gdk_color_parse (gtk_gc->colorname, &cc->color))
             gdk_color_alloc (gport->colormap, &cc->color);
           else
             gdk_color_white (gport->colormap, &cc->color);
@@ -439,7 +439,7 @@ set_gl_color_for_gc (hidGC gc)
     }
   if (1) {
     double maxi, mult;
-    a *= gc->alpha_mult;
+    a *= gtk_gc->alpha_mult;
     if (!priv->trans_lines)
       a = 1.0;
     maxi = r;
@@ -463,27 +463,35 @@ set_gl_color_for_gc (hidGC gc)
 void
 ghid_set_color (hidGC gc, const char *name)
 {
-  gc->colorname = name;
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->colorname = name;
   set_gl_color_for_gc (gc);
 }
 
 void
 ghid_set_alpha_mult (hidGC gc, double alpha_mult)
 {
-  gc->alpha_mult = alpha_mult;
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->alpha_mult = alpha_mult;
   set_gl_color_for_gc (gc);
 }
 
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->cap = style;
 }
 
 void
 ghid_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->width = width;
 }
 
 
@@ -535,18 +543,20 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gtk_gc->cap, gtk_gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
                          Angle start_angle, Angle delta_angle)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
+  hidgl_draw_arc (gtk_gc->width, cx, cy, xradius, yradius,
                   start_angle, delta_angle, gport->view.coord_per_px);
 }
 
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c351a48..bf35ffa 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -46,16 +46,17 @@
 #define MAX_ZOOM_SCALE	10
 #define UUNIT	Settings.grid_unit->allow
 
-typedef struct hid_gc_struct
+typedef struct lesstif_gc_struct
 {
-  HID *me_pointer;
+  struct hid_gc_struct hid_gc /* Parent */;
+
   Pixel color;
   const char *colorname;
   int width;
   EndCapStyle cap;
   char xor_set;
   char erase;
-} hid_gc_struct;
+} *lesstifGC;
 
 static HID lesstif_hid;
 static HID_DRAW lesstif_graphics;
@@ -3056,10 +3057,11 @@ lesstif_set_layer (const char *name, int group, int empty)
 static hidGC
 lesstif_make_gc (void)
 {
-  hidGC rv = (hid_gc_struct *) malloc (sizeof (hid_gc_struct));
-  memset (rv, 0, sizeof (hid_gc_struct));
-  rv->me_pointer = &lesstif_hid;
-  return rv;
+  hidGC gc = (hidGC)calloc (1, sizeof (struct lesstif_gc_struct));
+
+  gc->me_pointer = &lesstif_hid;
+
+  return gc;
 }
 
 static void
@@ -3125,6 +3127,7 @@ lesstif_use_mask (enum mask_mode mode)
 static void
 lesstif_set_color (hidGC gc, const char *name)
 {
+  lesstifGC lesstif_gc = (lesstifGC)gc;
   static void *cache = 0;
   hidval cval;
   static XColor color, exact_color;
@@ -3133,21 +3136,21 @@ lesstif_set_color (hidGC gc, const char *name)
     return;
   if (!name)
     name = "red";
-  gc->colorname = name;
+  lesstif_gc->colorname = name;
   if (strcmp (name, "erase") == 0)
     {
-      gc->color = bgcolor;
-      gc->erase = 1;
+      lesstif_gc->color = bgcolor;
+      lesstif_gc->erase = 1;
     }
   else if (strcmp (name, "drill") == 0)
     {
-      gc->color = offlimit_color;
-      gc->erase = 0;
+      lesstif_gc->color = offlimit_color;
+      lesstif_gc->erase = 0;
     }
   else if (hid_cache_color (0, name, &cval, &cache))
     {
-      gc->color = cval.lval;
-      gc->erase = 0;
+      lesstif_gc->color = cval.lval;
+      lesstif_gc->erase = 0;
     }
   else
     {
@@ -3157,26 +3160,26 @@ lesstif_set_color (hidGC gc, const char *name)
       printf ("lesstif_set_color `%s' %08x rgb/%d/%d/%d\n",
 	      name, color.pixel, color.red, color.green, color.blue);
 #endif
-      cval.lval = gc->color = color.pixel;
+      cval.lval = lesstif_gc->color = color.pixel;
       hid_cache_color (1, name, &cval, &cache);
-      gc->erase = 0;
+      lesstif_gc->erase = 0;
     }
   if (autofade)
     {
       static int lastcolor = -1, lastfade = -1;
-      if (gc->color == lastcolor)
-	gc->color = lastfade;
+      if (lesstif_gc->color == lastcolor)
+	lesstif_gc->color = lastfade;
       else
 	{
-	  lastcolor = gc->color;
-	  color.pixel = gc->color;
+	  lastcolor = lesstif_gc->color;
+	  color.pixel = lesstif_gc->color;
 
 	  XQueryColor (display, colormap, &color);
 	  color.red = (bgred + color.red) / 2;
 	  color.green = (bggreen + color.green) / 2;
 	  color.blue = (bgblue + color.blue) / 2;
 	  XAllocColor (display, colormap, &color);
-	  lastfade = gc->color = color.pixel;
+	  lastfade = lesstif_gc->color = color.pixel;
 	}
     }
 }
@@ -3184,6 +3187,7 @@ lesstif_set_color (hidGC gc, const char *name)
 static void
 set_gc (hidGC gc)
 {
+  lesstifGC lesstif_gc = (lesstifGC)gc;
   int cap, join, width;
   if (gc->me_pointer != &lesstif_hid)
     {
@@ -3192,9 +3196,9 @@ set_gc (hidGC gc)
     }
 #if 0
   pcb_printf ("set_gc c%s %08lx w%#mS c%d x%d e%d\n",
-	  gc->colorname, gc->color, gc->width, gc->cap, gc->xor_set, gc->erase);
+	  lesstif_gc->colorname, lesstif_gc->color, lesstif_gc->width, lesstif_gc->cap, lesstif_gc->xor_set, lesstif_gc->erase);
 #endif
-  switch (gc->cap)
+  switch (lesstif_gc->cap)
     {
     case Square_Cap:
       cap = CapProjecting;
@@ -3214,12 +3218,12 @@ set_gc (hidGC gc)
       join = JoinBevel;
       break;
     }
-  if (gc->xor_set)
+  if (lesstif_gc->xor_set)
     {
       XSetFunction (display, my_gc, GXxor);
-      XSetForeground (display, my_gc, gc->color ^ bgcolor);
+      XSetForeground (display, my_gc, lesstif_gc->color ^ bgcolor);
     }
-  else if (gc->erase)
+  else if (lesstif_gc->erase)
     {
       XSetFunction (display, my_gc, GXcopy);
       XSetForeground (display, my_gc, offlimit_color);
@@ -3227,20 +3231,20 @@ set_gc (hidGC gc)
   else
     {
       XSetFunction (display, my_gc, GXcopy);
-      XSetForeground (display, my_gc, gc->color);
+      XSetForeground (display, my_gc, lesstif_gc->color);
     }
-  width = Vz (gc->width);
+  width = Vz (lesstif_gc->width);
   if (width < 0)
     width = 0;
   XSetLineAttributes (display, my_gc, width, LineSolid, cap,
 		      join);
   if (use_mask)
     {
-      if (gc->erase)
+      if (lesstif_gc->erase)
 	mask_gc = bclear_gc;
       else
 	mask_gc = bset_gc;
-      XSetLineAttributes (display, mask_gc, Vz (gc->width), LineSolid, cap,
+      XSetLineAttributes (display, mask_gc, Vz (lesstif_gc->width), LineSolid, cap,
 			  join);
     }
 }
@@ -3248,19 +3252,25 @@ set_gc (hidGC gc)
 static void
 lesstif_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+
+  lesstif_gc->cap = style;
 }
 
 static void
 lesstif_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+
+  lesstif_gc->width = width;
 }
 
 static void
 lesstif_set_draw_xor (hidGC gc, int xor_set)
 {
-  gc->xor_set = xor_set;
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+
+  lesstif_gc->xor_set = xor_set;
 }
 
 #define ISORT(a,b) if (a>b) { a^=b; b^=a; a^=b; }
@@ -3268,19 +3278,20 @@ lesstif_set_draw_xor (hidGC gc, int xor_set)
 static void
 lesstif_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  lesstifGC lesstif_gc = (lesstifGC)gc;
   double dx1, dy1, dx2, dy2;
-  int vw = Vz (gc->width);
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && gc->erase)
+  int vw = Vz (lesstif_gc->width);
+  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && lesstif_gc->erase)
     return;
 #if 0
-  pcb_printf ("draw_line %#mD-%#mD @%#mS", x1, y1, x2, y2, gc->width);
+  pcb_printf ("draw_line %#mD-%#mD @%#mS", x1, y1, x2, y2, lesstif_gc->width);
 #endif
   dx1 = Vx (x1);
   dy1 = Vy (y1);
   dx2 = Vx (x2);
   dy2 = Vy (y2);
 #if 0
-  pcb_printf (" = %#mD-%#mD %s\n", x1, y1, x2, y2, gc->colorname);
+  pcb_printf (" = %#mD-%#mD %s\n", x1, y1, x2, y2, lesstif_gc->colorname);
 #endif
 
 #if 1
@@ -3295,7 +3306,7 @@ lesstif_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   y2 = dy2;
 
   set_gc (gc);
-  if (gc->cap == Square_Cap && x1 == x2 && y1 == y2)
+  if (lesstif_gc->cap == Square_Cap && x1 == x2 && y1 == y2)
     {
       XFillRectangle (display, pixmap, my_gc, x1 - vw / 2, y1 - vw / 2, vw,
 		      vw);
@@ -3315,7 +3326,9 @@ static void
 lesstif_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 		  Angle start_angle, Angle delta_angle)
 {
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && gc->erase)
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+
+  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
     return;
 #if 0
   pcb_printf ("draw_arc %#mD %#mSx%#mS s %d d %d", cx, cy, width, height, start_angle, delta_angle);
@@ -3338,8 +3351,8 @@ lesstif_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
   if (start_angle >= 180)
     start_angle -= 360;
 #if 0
-  pcb_printf (" = %#mD %#mSx%#mS %d %s\n", cx, cy, width, height, gc->width,
-	  gc->colorname);
+  pcb_printf (" = %#mD %#mSx%#mS %d %s\n", cx, cy, width, height, lesstif_gc->width,
+	  lesstif_gc->colorname);
 #endif
   set_gc (gc);
   XDrawArc (display, pixmap, my_gc, cx, cy,
@@ -3370,8 +3383,10 @@ lesstif_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 lesstif_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  int vw = Vz (gc->width);
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && gc->erase)
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+  int vw = Vz (lesstif_gc->width);
+
+  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
     return;
   x1 = Vx (x1);
   y1 = Vy (y1);
@@ -3397,9 +3412,11 @@ lesstif_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 static void
 lesstif_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
-  if (pinout && use_mask && gc->erase)
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+
+  if (pinout && use_mask && lesstif_gc->erase)
     return;
-  if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && gc->erase)
+  if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && lesstif_gc->erase)
     return;
 #if 0
   pcb_printf ("fill_circle %#mD %#mS", cx, cy, radius);
@@ -3412,7 +3429,7 @@ lesstif_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   if (cy < -2 * radius || cy > view_height)
     return;
 #if 0
-  pcb_printf (" = %#mD %#mS %lx %s\n", cx, cy, radius, gc->color, gc->colorname);
+  pcb_printf (" = %#mD %#mS %lx %s\n", cx, cy, radius, lesstif_gc->color, lesstif_gc->colorname);
 #endif
   set_gc (gc);
   XFillArc (display, pixmap, my_gc, cx, cy,
@@ -3457,8 +3474,10 @@ lesstif_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 static void
 lesstif_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  int vw = Vz (gc->width);
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && gc->erase)
+  lesstifGC lesstif_gc = (lesstifGC)gc;
+  int vw = Vz (lesstif_gc->width);
+
+  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
     return;
   x1 = Vx (x1);
   y1 = Vy (y1);
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 2e814de..90afd96 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -95,15 +95,16 @@ struct color_struct {
 	unsigned int    r, g, b;
 };
 
-struct hid_gc_struct {
-	HID            *me_pointer;
+typedef struct nelma_gc_struct {
+	struct hid_gc_struct hid_gc; /* Parent */
+
 	EndCapStyle     cap;
 	Coord           width;
 	unsigned char   r, g, b;
 	int             erase;
 	struct color_struct *color;
 	gdImagePtr      brush;
-};
+} *nelmaGC;
 
 static HID nelma_hid;
 static HID_DRAW nelma_graphics;
@@ -761,14 +762,18 @@ nelma_set_layer(const char *name, int group, int empty)
 static hidGC 
 nelma_make_gc(void)
 {
-	hidGC           rv = (hidGC) malloc(sizeof(struct hid_gc_struct));
-	rv->me_pointer = &nelma_hid;
-	rv->cap = Trace_Cap;
-	rv->width = 1;
-	rv->color = (struct color_struct *) malloc(sizeof(*rv->color));
-	rv->color->r = rv->color->g = rv->color->b = 0;
-	rv->color->c = 0;
-	return rv;
+	hidGC gc = (hidGC) calloc (1, sizeof(struct hid_gc_struct));
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
+	gc->me_pointer = &nelma_hid;
+
+	nelma_gc->cap = Trace_Cap;
+	nelma_gc->width = 1;
+	nelma_gc->color = (struct color_struct *) malloc(sizeof(*nelma_gc->color));
+	nelma_gc->color->r = nelma_gc->color->g = nelma_gc->color->b = 0;
+	nelma_gc->color->c = 0;
+
+	return gc;
 }
 
 static void 
@@ -786,6 +791,8 @@ nelma_use_mask(enum mask_mode mode)
 static void 
 nelma_set_color(hidGC gc, const char *name)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
 	if (nelma_im == NULL) {
 		return;
 	}
@@ -793,31 +800,35 @@ nelma_set_color(hidGC gc, const char *name)
 		name = "#ff0000";
 	}
 	if (!strcmp(name, "drill")) {
-		gc->color = black;
-		gc->erase = 0;
+		nelma_gc->color = black;
+		nelma_gc->erase = 0;
 		return;
 	}
 	if (!strcmp(name, "erase")) {
 		/* FIXME -- should be background, not white */
-		gc->color = white;
-		gc->erase = 1;
+		nelma_gc->color = white;
+		nelma_gc->erase = 1;
 		return;
 	}
-	gc->color = black;
-	gc->erase = 0;
+	nelma_gc->color = black;
+	nelma_gc->erase = 0;
 	return;
 }
 
 static void
 nelma_set_line_cap(hidGC gc, EndCapStyle style)
 {
-	gc->cap = style;
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
+	nelma_gc->cap = style;
 }
 
 static void
 nelma_set_line_width(hidGC gc, Coord width)
 {
-	gc->width = width;
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
+	nelma_gc->width = width;
 }
 
 static void
@@ -834,77 +845,78 @@ nelma_set_draw_faded(hidGC gc, int faded)
 static void
 use_gc(hidGC gc)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
 	int             need_brush = 0;
 
 	if (gc->me_pointer != &nelma_hid) {
 		fprintf(stderr, "Fatal: GC from another HID passed to nelma HID\n");
 		abort();
 	}
-	if (linewidth != gc->width) {
+	if (linewidth != nelma_gc->width) {
 		/* Make sure the scaling doesn't erase lines completely */
 		/*
-	        if (SCALE (gc->width) == 0 && gc->width > 0)
+	        if (SCALE (nelma_gc->width) == 0 && nelma_gc->width > 0)
 		  gdImageSetThickness (im, 1);
 	        else
 	        */
-		gdImageSetThickness(nelma_im, pcb_to_nelma(gc->width));
-		linewidth = gc->width;
+		gdImageSetThickness(nelma_im, pcb_to_nelma(nelma_gc->width));
+		linewidth = nelma_gc->width;
 		need_brush = 1;
 	}
-	if (lastbrush != gc->brush || need_brush) {
+	if (lastbrush != nelma_gc->brush || need_brush) {
 		static void    *bcache = 0;
 		hidval          bval;
 		char            name[256];
 		char            type;
 		int             r;
 
-		switch (gc->cap) {
+		switch (nelma_gc->cap) {
 		case Round_Cap:
 		case Trace_Cap:
 			type = 'C';
-			r = pcb_to_nelma(gc->width / 2);
+			r = pcb_to_nelma(nelma_gc->width / 2);
 			break;
 		default:
 		case Square_Cap:
-			r = pcb_to_nelma(gc->width);
+			r = pcb_to_nelma(nelma_gc->width);
 			type = 'S';
 			break;
 		}
-		sprintf(name, "#%.2x%.2x%.2x_%c_%d", gc->color->r, gc->color->g,
-			gc->color->b, type, r);
+		sprintf(name, "#%.2x%.2x%.2x_%c_%d", nelma_gc->color->r, nelma_gc->color->g,
+			nelma_gc->color->b, type, r);
 
 		if (hid_cache_color(0, name, &bval, &bcache)) {
-		  gc->brush = (gdImagePtr)bval.ptr;
+		  nelma_gc->brush = (gdImagePtr)bval.ptr;
 		} else {
 			int             bg, fg;
 			if (type == 'C')
-				gc->brush = gdImageCreate(2 * r + 1, 2 * r + 1);
+				nelma_gc->brush = gdImageCreate(2 * r + 1, 2 * r + 1);
 			else
-				gc->brush = gdImageCreate(r + 1, r + 1);
-			bg = gdImageColorAllocate(gc->brush, 255, 255, 255);
+				nelma_gc->brush = gdImageCreate(r + 1, r + 1);
+			bg = gdImageColorAllocate(nelma_gc->brush, 255, 255, 255);
 			fg =
-				gdImageColorAllocate(gc->brush, gc->color->r, gc->color->g,
-						     gc->color->b);
-			gdImageColorTransparent(gc->brush, bg);
+				gdImageColorAllocate(nelma_gc->brush, nelma_gc->color->r, nelma_gc->color->g,
+						     nelma_gc->color->b);
+			gdImageColorTransparent(nelma_gc->brush, bg);
 
 			/*
 		         * if we shrunk to a radius/box width of zero, then just use
 		         * a single pixel to draw with.
 		         */
 			if (r == 0)
-				gdImageFilledRectangle(gc->brush, 0, 0, 0, 0, fg);
+				gdImageFilledRectangle(nelma_gc->brush, 0, 0, 0, 0, fg);
 			else {
 				if (type == 'C')
-					gdImageFilledEllipse(gc->brush, r, r, 2 * r, 2 * r, fg);
+					gdImageFilledEllipse(nelma_gc->brush, r, r, 2 * r, 2 * r, fg);
 				else
-					gdImageFilledRectangle(gc->brush, 0, 0, r, r, fg);
+					gdImageFilledRectangle(nelma_gc->brush, 0, 0, r, r, fg);
 			}
-			bval.ptr = gc->brush;
+			bval.ptr = nelma_gc->brush;
 			hid_cache_color(1, name, &bval, &bcache);
 		}
 
-		gdImageSetBrush(nelma_im, gc->brush);
-		lastbrush = gc->brush;
+		gdImageSetBrush(nelma_im, nelma_gc->brush);
+		lastbrush = nelma_gc->brush;
 
 	}
 }
@@ -912,27 +924,33 @@ use_gc(hidGC gc)
 static void
 nelma_draw_rect(hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
 	use_gc(gc);
 	gdImageRectangle(nelma_im,
 			 pcb_to_nelma(x1), pcb_to_nelma(y1),
-			 pcb_to_nelma(x2), pcb_to_nelma(y2), gc->color->c);
+			 pcb_to_nelma(x2), pcb_to_nelma(y2), nelma_gc->color->c);
 }
 
 static void
 nelma_fill_rect(hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
 	use_gc(gc);
 	gdImageSetThickness(nelma_im, 0);
 	linewidth = 0;
 	gdImageFilledRectangle(nelma_im, pcb_to_nelma(x1), pcb_to_nelma(y1),
-			  pcb_to_nelma(x2), pcb_to_nelma(y2), gc->color->c);
+			  pcb_to_nelma(x2), pcb_to_nelma(y2), nelma_gc->color->c);
 }
 
 static void
 nelma_draw_line(hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
 	if (x1 == x2 && y1 == y2) {
-		Coord             w = gc->width / 2;
+		Coord             w = nelma_gc->width / 2;
 		nelma_fill_rect(gc, x1 - w, y1 - w, x1 + w, y1 + w);
 		return;
 	}
@@ -976,7 +994,7 @@ nelma_draw_arc(hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 	       cx, cy, width, height, start_angle, delta_angle, sa, ea);
 	printf("gdImageArc (%p, %d, %d, %d, %d, %d, %d, %d)\n",
 	       im, SCALE_X(cx), SCALE_Y(cy),
-	       SCALE(width), SCALE(height), sa, ea, gc->color->c);
+	       SCALE(width), SCALE(height), sa, ea, nelma_gc->color->c);
 #endif
 	use_gc(gc);
 	gdImageSetThickness(nelma_im, 0);
@@ -988,18 +1006,21 @@ nelma_draw_arc(hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 nelma_fill_circle(hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
+
 	use_gc(gc);
 
 	gdImageSetThickness(nelma_im, 0);
 	linewidth = 0;
 	gdImageFilledEllipse(nelma_im, pcb_to_nelma(cx), pcb_to_nelma(cy),
-	  pcb_to_nelma(2 * radius), pcb_to_nelma(2 * radius), gc->color->c);
+	  pcb_to_nelma(2 * radius), pcb_to_nelma(2 * radius), nelma_gc->color->c);
 
 }
 
 static void
 nelma_fill_polygon(hidGC gc, int n_coords, Coord *x, Coord *y)
 {
+	nelmaGC nelma_gc = (nelmaGC)gc;
 	int             i;
 	gdPoint        *points;
 
@@ -1015,7 +1036,7 @@ nelma_fill_polygon(hidGC gc, int n_coords, Coord *x, Coord *y)
 	}
 	gdImageSetThickness(nelma_im, 0);
 	linewidth = 0;
-	gdImageFilledPolygon(nelma_im, points, n_coords, gc->color->c);
+	gdImageFilledPolygon(nelma_im, points, n_coords, nelma_gc->color->c);
 	free(points);
 }
 
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 2f1590b..5f315e2 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -94,16 +94,17 @@ typedef struct color_struct
 
 } color_struct;
 
-typedef struct hid_gc_struct
+typedef struct png_gc_struct
 {
-  HID *me_pointer;
+  struct hid_gc_struct hid_gc; /* Parent */
+
   EndCapStyle cap;
   int width;
   unsigned char r, g, b;
   color_struct *color;
   gdImagePtr brush;
   int is_erase;
-} hid_gc_struct;
+} *pngGC;
 
 static color_struct *black = NULL, *white = NULL;
 static gdImagePtr im = NULL, master_im, mask_im = NULL;
@@ -1348,15 +1349,19 @@ png_set_layer (const char *name, int group, int empty)
 static hidGC
 png_make_gc (void)
 {
-  hidGC rv = (hidGC) malloc (sizeof (hid_gc_struct));
-  rv->me_pointer = &png_hid;
-  rv->cap = Trace_Cap;
-  rv->width = 1;
-  rv->color = (color_struct *) malloc (sizeof (color_struct));
-  rv->color->r = rv->color->g = rv->color->b = rv->color->a = 0;
-  rv->color->c = 0;
-  rv->is_erase = 0;
-  return rv;
+  hidGC gc = (hidGC) calloc (1, sizeof (struct png_gc_struct));
+  pngGC png_gc = (pngGC)gc;
+
+  gc->me_pointer = &png_hid;
+
+  png_gc->cap = Trace_Cap;
+  png_gc->width = 1;
+  png_gc->color = (color_struct *) malloc (sizeof (color_struct));
+  png_gc->color->r = png_gc->color->g = png_gc->color->b = png_gc->color->a = 0;
+  png_gc->color->c = 0;
+  png_gc->is_erase = 0;
+
+  return gc;
 }
 
 static void
@@ -1410,6 +1415,7 @@ png_use_mask (enum mask_mode mode)
 static void
 png_set_color (hidGC gc, const char *name)
 {
+  pngGC png_gc = (pngGC)gc;
   hidval cval;
 
   if (im == NULL)
@@ -1420,41 +1426,41 @@ png_set_color (hidGC gc, const char *name)
 
   if (strcmp (name, "erase") == 0 || strcmp (name, "drill") == 0)
     {
-      gc->color = white;
-      gc->is_erase = 1;
+      png_gc->color = white;
+      png_gc->is_erase = 1;
       return;
     }
-  gc->is_erase = 0;
+  png_gc->is_erase = 0;
 
   if (in_mono || (strcmp (name, "#000000") == 0))
     {
-      gc->color = black;
+      png_gc->color = black;
       return;
     }
 
   if (hid_cache_color (0, name, &cval, &color_cache))
     {
-      gc->color = (color_struct *)cval.ptr;
+      png_gc->color = (color_struct *)cval.ptr;
     }
   else if (name[0] == '#')
     {
-      gc->color = (color_struct *) malloc (sizeof (color_struct));
-      sscanf (name + 1, "%2x%2x%2x", &(gc->color->r), &(gc->color->g),
-	      &(gc->color->b));
-      gc->color->c =
-	gdImageColorAllocate (master_im, gc->color->r, gc->color->g, gc->color->b);
-      if (gc->color->c == BADC) 
+      png_gc->color = (color_struct *) malloc (sizeof (color_struct));
+      sscanf (name + 1, "%2x%2x%2x", &(png_gc->color->r), &(png_gc->color->g),
+	      &(png_gc->color->b));
+      png_gc->color->c =
+	gdImageColorAllocate (master_im, png_gc->color->r, png_gc->color->g, png_gc->color->b);
+      if (png_gc->color->c == BADC)
 	{
 	  Message ("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n", __FUNCTION__);
 	  return;
 	}
-      cval.ptr = gc->color;
+      cval.ptr = png_gc->color;
       hid_cache_color (1, name, &cval, &color_cache);
     }
   else
     {
       printf ("WE SHOULD NOT BE HERE!!!\n");
-      gc->color = black;
+      png_gc->color = black;
     }
 
 }
@@ -1462,13 +1468,17 @@ png_set_color (hidGC gc, const char *name)
 static void
 png_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  pngGC png_gc = (pngGC)gc;
+
+  png_gc->cap = style;
 }
 
 static void
 png_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  pngGC png_gc = (pngGC)gc;
+
+  png_gc->width = width;
 }
 
 static void
@@ -1480,6 +1490,8 @@ png_set_draw_xor (hidGC gc, int xor_)
 static void
 use_gc (hidGC gc)
 {
+  pngGC png_gc = (pngGC)gc;
+
   int need_brush = 0;
 
   if (gc->me_pointer != &png_hid)
@@ -1488,25 +1500,25 @@ use_gc (hidGC gc)
       abort ();
     }
 
-  if (linewidth != gc->width)
+  if (linewidth != png_gc->width)
     {
       /* Make sure the scaling doesn't erase lines completely */
-      if (SCALE (gc->width) == 0 && gc->width > 0)
+      if (SCALE (png_gc->width) == 0 && png_gc->width > 0)
 	gdImageSetThickness (im, 1);
       else
-	gdImageSetThickness (im, SCALE (gc->width + 2*bloat));
-      linewidth = gc->width;
+	gdImageSetThickness (im, SCALE (png_gc->width + 2*bloat));
+      linewidth = png_gc->width;
       need_brush = 1;
     }
 
-  if (lastbrush != gc->brush || need_brush)
+  if (lastbrush != png_gc->brush || need_brush)
     {
       hidval bval;
       char name[256];
       char type;
       int r;
 
-      switch (gc->cap)
+      switch (png_gc->cap)
         {
         case Round_Cap:
         case Trace_Cap:
@@ -1517,8 +1529,8 @@ use_gc (hidGC gc)
           type = 'S';
           break;
         }
-      if (gc->width)
-	r = SCALE (gc->width + 2*bloat);
+      if (png_gc->width)
+	r = SCALE (png_gc->width + 2*bloat);
       else
 	r = 1;
 
@@ -1528,65 +1540,64 @@ use_gc (hidGC gc)
 	  r = 1;
         }
 
-      sprintf (name, "#%.2x%.2x%.2x_%c_%d", gc->color->r, gc->color->g,
-	       gc->color->b, type, r);
+      sprintf (name, "#%.2x%.2x%.2x_%c_%d", png_gc->color->r, png_gc->color->g,
+	       png_gc->color->b, type, r);
 
       if (hid_cache_color (0, name, &bval, &brush_cache))
 	{
-	  gc->brush = (gdImagePtr)bval.ptr;
+	  png_gc->brush = (gdImagePtr)bval.ptr;
 	}
       else
 	{
 	  int bg, fg;
-	  gc->brush = gdImageCreate (r, r);
-	  if (gc->brush == NULL) 
+	  png_gc->brush = gdImageCreate (r, r);
+	  if (png_gc->brush == NULL)
 	    {
 	      Message ("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n", __FUNCTION__, r, r);
 	      return;
 	    }
 
-	  bg = gdImageColorAllocate (gc->brush, 255, 255, 255);
+	  bg = gdImageColorAllocate (png_gc->brush, 255, 255, 255);
 	  if (bg == BADC) 
 	    {
 	      Message ("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n", __FUNCTION__);
 	      return;
 	    }
 	  fg =
-	    gdImageColorAllocateAlpha (gc->brush, gc->color->r, gc->color->g,
-				       gc->color->b, 0); 
+	    gdImageColorAllocateAlpha (png_gc->brush, png_gc->color->r, png_gc->color->g, png_gc->color->b, 0);
 	  if (fg == BADC) 
 	    {
 	      Message ("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n", __FUNCTION__);
 	      return;
 	    }
-	  gdImageColorTransparent (gc->brush, bg);
+	  gdImageColorTransparent (png_gc->brush, bg);
 
 	  /*
 	   * if we shrunk to a radius/box width of zero, then just use
 	   * a single pixel to draw with.
 	   */
 	  if (r <= 1)
-	    gdImageFilledRectangle (gc->brush, 0, 0, 0, 0, fg);
+	    gdImageFilledRectangle (png_gc->brush, 0, 0, 0, 0, fg);
 	  else
 	    {
 	      if (type == 'C')
 		{
-		  gdImageFilledEllipse (gc->brush, r/2, r/2, r, r, fg);
+		  gdImageFilledEllipse (png_gc->brush, r/2, r/2, r, r, fg);
 		  /* Make sure the ellipse is the right exact size.  */
-		  gdImageSetPixel (gc->brush, 0, r/2, fg);
-		  gdImageSetPixel (gc->brush, r-1, r/2, fg);
-		  gdImageSetPixel (gc->brush, r/2, 0, fg);
-		  gdImageSetPixel (gc->brush, r/2, r-1, fg);
+		  gdImageSetPixel (png_gc->brush, 0, r/2, fg);
+		  gdImageSetPixel (png_gc->brush, r-1, r/2, fg);
+		  gdImageSetPixel (png_gc->brush, r/2, 0, fg);
+		  gdImageSetPixel (png_gc->brush, r/2, r-1, fg);
 		}
 	      else
-		gdImageFilledRectangle (gc->brush, 0, 0, r-1, r-1, fg);
+		gdImageFilledRectangle (png_gc->brush, 0, 0, r-1, r-1, fg);
 	    }
-	  bval.ptr = gc->brush;
+	  bval.ptr = png_gc->brush;
 	  hid_cache_color (1, name, &bval, &brush_cache);
 	}
 
-      gdImageSetBrush (im, gc->brush);
-      lastbrush = gc->brush;
+      gdImageSetBrush (im, png_gc->brush);
+      lastbrush = png_gc->brush;
 
     }
 }
@@ -1594,15 +1605,19 @@ use_gc (hidGC gc)
 static void
 png_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  pngGC png_gc = (pngGC)gc;
+
   use_gc (gc);
   gdImageRectangle (im,
 		    SCALE_X (x1), SCALE_Y (y1),
-		    SCALE_X (x2), SCALE_Y (y2), gc->color->c);
+		    SCALE_X (x2), SCALE_Y (y2), png_gc->color->c);
 }
 
 static void
 png_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  pngGC png_gc = (pngGC)gc;
+
   use_gc (gc);
   gdImageSetThickness (im, 0);
   linewidth = 0;
@@ -1612,17 +1627,19 @@ png_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   SWAP_IF_SOLDER (y1, y2);
 
   gdImageFilledRectangle (im, SCALE_X (x1-bloat), SCALE_Y (y1),
-			  SCALE_X (x2+bloat)-1, SCALE_Y (y2)-1, gc->color->c);
+			  SCALE_X (x2+bloat)-1, SCALE_Y (y2)-1, png_gc->color->c);
   have_outline |= doing_outline;
 }
 
 static void
 png_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  pngGC png_gc = (pngGC)gc;
+
   if (x1 == x2 && y1 == y2)
     {
-      Coord w = gc->width / 2;
-      if (gc->cap != Square_Cap)
+      Coord w = png_gc->width / 2;
+      if (png_gc->cap != Square_Cap)
 	png_fill_circle (gc, x1, y1, w);
       else
 	png_fill_rect (gc, x1 - w, y1 - w, x1 + w, y1 + w);
@@ -1651,7 +1668,7 @@ png_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 
   gdImageSetThickness (im, 0);
   linewidth = 0;
-  if(gc->cap != Square_Cap || x1 == x2 || y1 == y2 )
+  if(png_gc->cap != Square_Cap || x1 == x2 || y1 == y2 )
     {
       gdImageLine (im, SCALE_X (x1), SCALE_Y (y1),
 		   SCALE_X (x2), SCALE_Y (y2), gdBrushed);
@@ -1663,9 +1680,9 @@ png_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
        * not purely horizontal or vertical, then we need to draw
        * it as a filled polygon.
        */
-      int fg = gdImageColorResolve (im, gc->color->r, gc->color->g,
-				    gc->color->b);
-      Coord w = gc->width;
+      int fg = gdImageColorResolve (im, png_gc->color->r, png_gc->color->g,
+				    png_gc->color->b);
+      Coord w = png_gc->width;
       Coord dwx, dwy;
 
       gdPoint p[4];
@@ -1685,6 +1702,7 @@ static void
 png_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 	      Angle start_angle, Angle delta_angle)
 {
+  pngGC png_gc = (pngGC)gc;
   Angle sa, ea;
 
   /*
@@ -1696,7 +1714,7 @@ png_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
     Coord y = (width * sin (start_angle * M_PI / 180));
     x = cx - x;
     y = cy + y;
-    png_fill_circle (gc, x, y, gc->width / 2);
+    png_fill_circle (gc, x, y, png_gc->width / 2);
     return;
   }
 
@@ -1736,7 +1754,7 @@ png_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 	  cx, cy, width, height, start_angle, delta_angle, sa, ea);
   printf ("gdImageArc (%p, %d, %d, %d, %d, %d, %d, %d)\n",
 	  im, SCALE_X (cx), SCALE_Y (cy),
-	  SCALE (width), SCALE (height), sa, ea, gc->color->c);
+	  SCALE (width), SCALE (height), sa, ea, png_gc->color->c);
 #endif
   use_gc (gc);
   gdImageSetThickness (im, 0);
@@ -1748,14 +1766,15 @@ png_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 png_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  pngGC png_gc = (pngGC)gc;
   Coord my_bloat;
 
   use_gc (gc);
 
-  if (fill_holes && gc->is_erase && is_copper)
+  if (fill_holes && png_gc->is_erase && is_copper)
     return;
 
-  if (gc->is_erase)
+  if (png_gc->is_erase)
     my_bloat = -2 * bloat;
   else
     my_bloat = 2 * bloat;
@@ -1766,13 +1785,14 @@ png_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gdImageSetThickness (im, 0);
   linewidth = 0;
   gdImageFilledEllipse (im, SCALE_X (cx), SCALE_Y (cy),
-			SCALE (2 * radius + my_bloat), SCALE (2 * radius + my_bloat), gc->color->c);
+			SCALE (2 * radius + my_bloat), SCALE (2 * radius + my_bloat), png_gc->color->c);
 
 }
 
 static void
 png_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
+  pngGC png_gc = (pngGC)gc;
   int i;
   gdPoint *points;
 
@@ -1793,7 +1813,7 @@ png_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
     }
   gdImageSetThickness (im, 0);
   linewidth = 0;
-  gdImageFilledPolygon (im, points, n_coords, gc->color->c);
+  gdImageFilledPolygon (im, points, n_coords, png_gc->color->c);
   free (points);
 }
 
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index cff21e3..ea7dd55 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -51,13 +51,15 @@ static void eps_calibrate (double xval, double yval);
 static void eps_set_crosshair (int x, int y, int action);
 /*----------------------------------------------------------------------------*/
 
-typedef struct hid_gc_struct
+typedef struct eps_gc_struct
 {
+  struct hid_gc_struct hid_gc; /* Parent */
+
   EndCapStyle cap;
   Coord width;
   int color;
   int erase;
-} hid_gc_struct;
+} *epsGC;
 
 static HID eps_hid;
 static HID_DRAW eps_graphics;
@@ -419,11 +421,16 @@ eps_set_layer (const char *name, int group, int empty)
 static hidGC
 eps_make_gc (void)
 {
-  hidGC rv = (hidGC) malloc (sizeof (hid_gc_struct));
-  rv->cap = Trace_Cap;
-  rv->width = 0;
-  rv->color = 0;
-  return rv;
+  hidGC gc = (hidGC) calloc (1, sizeof (struct eps_gc_struct));
+  epsGC eps_gc = (epsGC)gc;
+
+  gc->me_pointer = &eps_hid;
+
+  eps_gc->cap = Trace_Cap;
+  eps_gc->width = 0;
+  eps_gc->color = 0;
+
+  return gc;
 }
 
 static void
@@ -462,50 +469,55 @@ eps_use_mask (enum mask_mode mode)
 static void
 eps_set_color (hidGC gc, const char *name)
 {
+  epsGC eps_gc = (epsGC)gc;
   static void *cache = 0;
   hidval cval;
 
   if (strcmp (name, "erase") == 0)
     {
-      gc->color = 0xffffff;
-      gc->erase = fast_erase ? 0 : 1;
+      eps_gc->color = 0xffffff;
+      eps_gc->erase = fast_erase ? 0 : 1;
       return;
     }
   if (strcmp (name, "drill") == 0)
     {
-      gc->color = 0xffffff;
-      gc->erase = 0;
+      eps_gc->color = 0xffffff;
+      eps_gc->erase = 0;
       return;
     }
-  gc->erase = 0;
+  eps_gc->erase = 0;
   if (hid_cache_color (0, name, &cval, &cache))
     {
-      gc->color = cval.lval;
+      eps_gc->color = cval.lval;
     }
   else if (in_mono)
     {
-      gc->color = 0;
+      eps_gc->color = 0;
     }
   else if (name[0] == '#')
     {
       unsigned int r, g, b;
       sscanf (name + 1, "%2x%2x%2x", &r, &g, &b);
-      gc->color = (r << 16) + (g << 8) + b;
+      eps_gc->color = (r << 16) + (g << 8) + b;
     }
   else
-    gc->color = 0;
+    eps_gc->color = 0;
 }
 
 static void
 eps_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  epsGC eps_gc = (epsGC)gc;
+
+  eps_gc->cap = style;
 }
 
 static void
 eps_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  epsGC eps_gc = (epsGC)gc;
+
+  eps_gc->width = width;
 }
 
 static void
@@ -517,15 +529,17 @@ eps_set_draw_xor (hidGC gc, int xor_)
 static void
 use_gc (hidGC gc)
 {
-  if (linewidth != gc->width)
+  epsGC eps_gc = (epsGC)gc;
+
+  if (linewidth != eps_gc->width)
     {
-      pcb_fprintf (f, "%mi setlinewidth\n", gc->width);
-      linewidth = gc->width;
+      pcb_fprintf (f, "%mi setlinewidth\n", eps_gc->width);
+      linewidth = eps_gc->width;
     }
-  if (lastcap != gc->cap)
+  if (lastcap != eps_gc->cap)
     {
       int c;
-      switch (gc->cap)
+      switch (eps_gc->cap)
 	{
 	case Round_Cap:
 	case Trace_Cap:
@@ -537,14 +551,14 @@ use_gc (hidGC gc)
 	  break;
 	}
       fprintf (f, "%d setlinecap\n", c);
-      lastcap = gc->cap;
+      lastcap = eps_gc->cap;
     }
-  if (lastcolor != gc->color)
+  if (lastcolor != eps_gc->color)
     {
-      int c = gc->color;
+      int c = eps_gc->color;
 #define CV(x,b) (((x>>b)&0xff)/255.0)
       fprintf (f, "%g %g %g setrgbcolor\n", CV (c, 16), CV (c, 8), CV (c, 0));
-      lastcolor = gc->color;
+      lastcolor = eps_gc->color;
     }
 }
 
@@ -561,17 +575,19 @@ eps_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 static void
 eps_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  Coord w = gc->width / 2;
+  epsGC eps_gc = (epsGC)gc;
+  Coord w = eps_gc->width / 2;
+
   if (x1 == x2 && y1 == y2)
     {
-      if (gc->cap == Square_Cap)
+      if (eps_gc->cap == Square_Cap)
 	eps_fill_rect (gc, x1 - w, y1 - w, x1 + w, y1 + w);
       else
 	eps_fill_circle (gc, x1, y1, w);
       return;
     }
   use_gc (gc);
-  if (gc->erase && gc->cap != Square_Cap)
+  if (eps_gc->erase && eps_gc->cap != Square_Cap)
     {
       double ang = atan2 (y2 - y1, x2 - x1);
       double dx = w * sin (ang);
@@ -587,7 +603,7 @@ eps_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 
       return;
     }
-  pcb_fprintf (f, "%mi %mi %mi %mi %s\n", x1, y1, x2, y2, gc->erase ? "tc" : "t");
+  pcb_fprintf (f, "%mi %mi %mi %mi %s\n", x1, y1, x2, y2, eps_gc->erase ? "tc" : "t");
 }
 
 static void
@@ -617,8 +633,10 @@ eps_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 eps_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  epsGC eps_gc = (epsGC)gc;
+
   use_gc (gc);
-  pcb_fprintf (f, "%mi %mi %mi %s\n", cx, cy, radius, gc->erase ? "cc" : "c");
+  pcb_fprintf (f, "%mi %mi %mi %s\n", cx, cy, radius, eps_gc->erase ? "cc" : "c");
 }
 
 static void
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 690697a..96a00fb 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -34,15 +34,16 @@
 static int ps_set_layer (const char *name, int group, int empty);
 static void use_gc (hidGC gc);
 
-typedef struct hid_gc_struct
+typedef struct ps_gc_struct
 {
-  HID *me_pointer;
+  struct hid_gc_struct hid_gc; /* Parent */
+
   EndCapStyle cap;
   Coord width;
   unsigned char r, g, b;
   int erase;
   int faded;
-} hid_gc_struct;
+} *psGC;
 
 static const char *medias[] = {
   "A0", "A1", "A2", "A3", "A4", "A5",
@@ -1011,10 +1012,13 @@ ps_set_layer (const char *name, int group, int empty)
 static hidGC
 ps_make_gc (void)
 {
-  hidGC rv = (hidGC) calloc (1, sizeof (hid_gc_struct));
-  rv->me_pointer = &ps_hid;
-  rv->cap = Trace_Cap;
-  return rv;
+  hidGC gc = (hidGC) calloc (1, sizeof (struct ps_gc_struct));
+  psGC ps_gc = (psGC)gc;
+
+  gc->me_pointer = &ps_hid;
+  ps_gc->cap = Trace_Cap;
+
+  return gc;
 }
 
 static void
@@ -1032,37 +1036,43 @@ ps_use_mask (enum mask_mode mode)
 static void
 ps_set_color (hidGC gc, const char *name)
 {
+  psGC ps_gc = (psGC)gc;
+
   if (strcmp (name, "erase") == 0 || strcmp (name, "drill") == 0)
     {
-      gc->r = gc->g = gc->b = 255;
-      gc->erase = 1;
+      ps_gc->r = ps_gc->g = ps_gc->b = 255;
+      ps_gc->erase = 1;
     }
   else if (global.incolor)
     {
       int r, g, b;
       sscanf (name + 1, "%02x%02x%02x", &r, &g, &b);
-      gc->r = r;
-      gc->g = g;
-      gc->b = b;
-      gc->erase = 0;
+      ps_gc->r = r;
+      ps_gc->g = g;
+      ps_gc->b = b;
+      ps_gc->erase = 0;
     }
   else
     {
-      gc->r = gc->g = gc->b = 0;
-      gc->erase = 0;
+      ps_gc->r = ps_gc->g = ps_gc->b = 0;
+      ps_gc->erase = 0;
     }
 }
 
 static void
 ps_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  gc->cap = style;
+  psGC ps_gc = (psGC)gc;
+
+  ps_gc->cap = style;
 }
 
 static void
 ps_set_line_width (hidGC gc, Coord width)
 {
-  gc->width = width;
+  psGC ps_gc = (psGC)gc;
+
+  ps_gc->width = width;
 }
 
 static void
@@ -1074,12 +1084,15 @@ ps_set_draw_xor (hidGC gc, int xor_)
 static void
 ps_set_draw_faded (hidGC gc, int faded)
 {
-  gc->faded = faded;
+  psGC ps_gc = (psGC)gc;
+
+  ps_gc->faded = faded;
 }
 
 static void
 use_gc (hidGC gc)
 {
+  psGC ps_gc = (psGC)gc;
   static int lastcap = -1;
   static int lastcolor = -1;
 
@@ -1093,16 +1106,16 @@ use_gc (hidGC gc)
       fprintf (stderr, "Fatal: GC from another HID passed to ps HID\n");
       abort ();
     }
-  if (global.linewidth != gc->width)
+  if (global.linewidth != ps_gc->width)
     {
       pcb_fprintf (global.f, "%mi setlinewidth\n",
-                   gc->width + (gc->erase ? -2 : 2) * global.bloat);
-      global.linewidth = gc->width;
+                   ps_gc->width + (ps_gc->erase ? -2 : 2) * global.bloat);
+      global.linewidth = ps_gc->width;
     }
-  if (lastcap != gc->cap)
+  if (lastcap != ps_gc->cap)
     {
       int c;
-      switch (gc->cap)
+      switch (ps_gc->cap)
 	{
 	case Round_Cap:
 	case Trace_Cap:
@@ -1114,29 +1127,29 @@ use_gc (hidGC gc)
 	  break;
 	}
       fprintf (global.f, "%d setlinecap %d setlinejoin\n", c, c);
-      lastcap = gc->cap;
+      lastcap = ps_gc->cap;
     }
-#define CBLEND(gc) (((gc->r)<<24)|((gc->g)<<16)|((gc->b)<<8)|(gc->faded))
+#define CBLEND(gc) (((ps_gc->r)<<24)|((ps_gc->g)<<16)|((ps_gc->b)<<8)|(ps_gc->faded))
   if (lastcolor != CBLEND (gc))
     {
       if (global.is_drill || global.is_mask)
 	{
-	  fprintf (global.f, "%d gray\n", gc->erase ? 0 : 1);
+	  fprintf (global.f, "%d gray\n", ps_gc->erase ? 0 : 1);
 	  lastcolor = 0;
 	}
       else
 	{
 	  double r, g, b;
-	  r = gc->r;
-	  g = gc->g;
-	  b = gc->b;
-	  if (gc->faded)
+	  r = ps_gc->r;
+	  g = ps_gc->g;
+	  b = ps_gc->b;
+	  if (ps_gc->faded)
 	    {
 	      r = (1 - global.fade_ratio) * 255 + global.fade_ratio * r;
 	      g = (1 - global.fade_ratio) * 255 + global.fade_ratio * g;
 	      b = (1 - global.fade_ratio) * 255 + global.fade_ratio * b;
 	    }
-	  if (gc->r == gc->g && gc->g == gc->b)
+	  if (ps_gc->r == ps_gc->g && ps_gc->g == ps_gc->b)
 	    fprintf (global.f, "%g gray\n", r / 255.0);
 	  else
 	    fprintf (global.f, "%g %g %g rgb\n", r / 255.0, g / 255.0, b / 255.0);
@@ -1158,11 +1171,13 @@ static void ps_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius);
 static void
 ps_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  psGC ps_gc = (psGC)gc;
+
 #if 0
   /* If you're etching your own paste mask, this will reduce the
      amount of brass you need to etch by drawing outlines for large
      pads.  See also ps_fill_rect.  */
-  if (is_paste && gc->width > 2500 && gc->cap == Square_Cap
+  if (is_paste && ps_gc->width > 2500 && ps_gc->cap == Square_Cap
       && (x1 == x2 || y1 == y2))
     {
       Coord t, w;
@@ -1170,15 +1185,15 @@ ps_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 	{ t = x1; x1 = x2; x2 = t; }
       if (y1 > y2)
 	{ t = y1; y1 = y2; y2 = t; }
-      w = gc->width/2;
+      w = ps_gc->width/2;
       ps_fill_rect (gc, x1-w, y1-w, x2+w, y2+w);
       return;
     }
 #endif
   if (x1 == x2 && y1 == y2)
     {
-      Coord w = gc->width / 2;
-      if (gc->cap == Square_Cap)
+      Coord w = ps_gc->width / 2;
+      if (ps_gc->cap == Square_Cap)
 	ps_fill_rect (gc, x1 - w, y1 - w, x1 + w, y1 + w);
       else
 	ps_fill_circle (gc, x1, y1, w);
@@ -1216,14 +1231,16 @@ ps_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
 static void
 ps_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  psGC ps_gc = (psGC)gc;
+
   use_gc (gc);
-  if (!gc->erase || !global.is_copper || global.drillcopper)
+  if (!ps_gc->erase || !global.is_copper || global.drillcopper)
     {
-      if (gc->erase && global.is_copper && global.drill_helper
+      if (ps_gc->erase && global.is_copper && global.drill_helper
 	  && radius >= PCB->minDrill / 4)
 	radius = PCB->minDrill / 4;
       pcb_fprintf (global.f, "%mi %mi %mi c\n",
-                   cx, cy, radius + (gc->erase ? -1 : 1) * global.bloat);
+                   cx, cy, radius + (ps_gc->erase ? -1 : 1) * global.bloat);
     }
 }
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index b65d804..30e770c 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -64,3 +64,8 @@ struct hid_draw_st
   void (*thindraw_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
 
 };
+
+/* Base hidGC elements visible to any module */
+struct hid_gc_struct {
+  HID *me_pointer;   /* Used by HIDs to validate the GCs passed belong to them */
+};
