Bottom: ed28b1d26d8189be843305c1aa0082ca8248d735
Top:    275ad72745612aba7c47ffb70a06d468fa83a986
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-09 18:40:43 +0000

Add polygon parentage tree debug view

NB: Also contains some probably bug fixes for PBO operations,
in particular - relating to bad exit codes when a NULL poly is
copied.


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index da7344b..7ff4d7c 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2629,6 +2629,16 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   DrawMark (Output.fgGC);
   hidgl_flush_triangles (priv->hidgl);
 
+  if (ghidgui->debugged_polyarea != NULL) {
+    PolygonType dummy_poly;
+    dummy_poly.Clipped = ghidgui->debugged_polyarea;
+    dummy_poly.Flags = NoFlags ();
+    SET_FLAG (FULLPOLYFLAG, &dummy_poly);
+
+    common_thindraw_pcb_polygon (Output.fgGC, &dummy_poly, &region);
+    hidgl_flush_triangles (priv->hidgl);
+  }
+
   glEnable (GL_LIGHTING);
 
   glShadeModel (GL_SMOOTH);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index ca4b069..316cb55 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -119,6 +119,8 @@ a zoom in/out.
 #include "gui-trackball.h"
 #include "snavi.h"
 
+#include "polyarea.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -1260,6 +1262,30 @@ fix_topbar_theming (void)
                     G_CALLBACK (do_fix_topbar_theming), NULL);
 }
 
+static void
+ghid_polygon_debug_selection_changed_cb (GtkTreeSelection *treeselection, gpointer user_data)
+{
+//  GHidPort *port = user_data;
+  GtkTreeModel *model;
+  GtkTreeIter iter;
+
+  if (!gtk_tree_selection_get_selected (treeselection, &model, &iter)) {
+    ghidgui->debugged_polyarea = NULL;
+    return;
+  }
+
+  gtk_tree_model_get (model, &iter,
+                      POLYGON_DEBUG_COLUMN_POLYAREA, &ghidgui->debugged_polyarea,
+                      -1);
+
+  if (ghidgui->debugged_polyarea != NULL) {
+    fprintf (stderr, "Printing polyarea %p\n", ghidgui->debugged_polyarea);
+    poly_dump (ghidgui->debugged_polyarea);
+  }
+
+  ghid_invalidate_all ();
+}
+
 /* 
  * Create the top_window contents.  The config settings should be loaded
  * before this is called.
@@ -1271,6 +1297,8 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *hbox_middle, *hbox;
   GtkWidget *vbox, *frame;
   GtkWidget *label;
+  GtkTreeViewColumn *column;
+  GtkTreeIter iter;
   /* FIXME: IFDEF HACK */
 #ifdef ENABLE_GL
   GtkWidget *trackball;
@@ -1431,6 +1459,34 @@ ghid_build_pcb_top_window (void)
   g_signal_connect (G_OBJECT (ghidgui->h_adjustment), "value_changed",
 		    G_CALLBACK (h_adjustment_changed_cb), ghidgui);
 
+  /* Polygon debug */
+  ghidgui->polygon_debug_ts = gtk_tree_store_new (N_POLYGON_DEBUG_COLUMNS,
+                                                  G_TYPE_STRING,
+                                                  G_TYPE_POINTER);
+
+  gtk_tree_store_append (ghidgui->polygon_debug_ts, &iter, NULL);
+  gtk_tree_store_set (ghidgui->polygon_debug_ts,
+                      &iter,
+                      POLYGON_DEBUG_COLUMN_TEXT,     "Hello world",
+                      POLYGON_DEBUG_COLUMN_POLYAREA, NULL,
+                      -1);
+
+  ghidgui->polygon_debug_tv = gtk_tree_view_new_with_model (GTK_TREE_MODEL (ghidgui->polygon_debug_ts));
+
+  column = gtk_tree_view_column_new_with_attributes ("Polygon",
+                                                     gtk_cell_renderer_text_new (),
+                                                     "text", POLYGON_DEBUG_COLUMN_TEXT,
+                                                     NULL);
+
+  gtk_tree_view_append_column (GTK_TREE_VIEW (ghidgui->polygon_debug_tv), column);
+
+  gtk_box_pack_end (GTK_BOX (hbox_middle),
+                    ghidgui->polygon_debug_tv, TRUE, TRUE, 0);
+
+  g_signal_connect (G_OBJECT (gtk_tree_view_get_selection (GTK_TREE_VIEW (ghidgui->polygon_debug_tv))),
+                    "changed",
+                    G_CALLBACK (ghid_polygon_debug_selection_changed_cb), port);
+
   /* -- The bottom status line label */
   ghidgui->status_line_hbox = gtk_hbox_new (FALSE, 0);
   gtk_box_pack_start (GTK_BOX (ghidgui->vbox_middle),
@@ -1492,6 +1548,76 @@ ghid_build_pcb_top_window (void)
   port->tooltip_update_timeout_id = 0;
 }
 
+static const char *
+pbo_operation_string (int action)
+{
+  switch (action) {
+    case PBO_NONE:
+      return "PBO_NONE";
+    case PBO_UNITE:
+      return "PBO_UNITE";
+    case PBO_ISECT:
+      return "PBO_ISECT";
+    case PBO_SUB:
+      return "PBO_SUB";
+    case PBO_XOR:
+      return "PBO_XOR";
+    default:
+      return "UNKNOWN POLYGON OPERATION";
+  }
+}
+
+static void
+recurse_populate_parentage (const char *prefix_string, GtkTreeIter *parent_iter, POLYAREA *pa)
+{
+  char *text;
+  GtkTreeIter iter;
+
+  if (pa == NULL || pa->parentage.immaculate_conception)
+    text = g_strdup_printf ("%s%s", prefix_string, (pa == NULL) ? "NULL" : "Input polygon");
+  else
+    text = g_strdup_printf ("%s%s", prefix_string, pbo_operation_string (pa->parentage.action));
+
+  gtk_tree_store_set (ghidgui->polygon_debug_ts,
+                      parent_iter,
+                      POLYGON_DEBUG_COLUMN_TEXT,     text,
+                      POLYGON_DEBUG_COLUMN_POLYAREA, pa,
+                      -1);
+  g_free (text);
+
+  if (pa == NULL || pa->parentage.immaculate_conception)
+    return;
+
+  gtk_tree_store_append (ghidgui->polygon_debug_ts, &iter, parent_iter);
+  recurse_populate_parentage ("A: ", &iter, pa->parentage.a);
+
+  gtk_tree_store_append (ghidgui->polygon_debug_ts, &iter, parent_iter);
+  recurse_populate_parentage ("B: ", &iter, pa->parentage.b);
+}
+
+void
+ghid_populate_polygon_parentage (PolygonType *polygon)
+{
+  POLYAREA *root = polygon->Clipped;
+  GtkTreeIter iter;
+
+  gtk_tree_store_clear (ghidgui->polygon_debug_ts);
+  gtk_tree_store_append (ghidgui->polygon_debug_ts, &iter, NULL);
+
+  recurse_populate_parentage ("", &iter, root);
+
+  ghidgui->debugged_polygon = polygon;
+  ghidgui->debugged_polyarea = NULL;
+}
+
+void
+ghid_notify_polygon_changed (PolygonType *polygon)
+{
+  if (ghidgui->debugged_polygon == polygon) {
+    ghid_populate_polygon_parentage (polygon);
+  }
+
+}
 
   /* Connect and disconnect just the signals a g_main_loop() will need.
      |  Cursor and motion events still need to be handled by the top level
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index de062d8..d858a74 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -114,6 +114,11 @@ typedef struct
   GtkWidget *h_range, *v_range;
   GtkObject *h_adjustment, *v_adjustment;
 
+  GtkWidget *polygon_debug_tv;
+  GtkTreeStore *polygon_debug_ts;
+  PolygonType *debugged_polygon;
+  POLYAREA *debugged_polyarea;
+
   GdkPixbuf *bg_pixbuf;
 
   gchar *name_label_string;
@@ -150,6 +155,14 @@ typedef struct
 }
 GhidGui;
 
+
+enum {
+  POLYGON_DEBUG_COLUMN_TEXT,
+  POLYGON_DEBUG_COLUMN_POLYAREA,
+  N_POLYGON_DEBUG_COLUMNS
+};
+
+
 extern GhidGui _ghidgui, *ghidgui;
 
 typedef struct
diff --git a/src/polyarea.h b/src/polyarea.h
index fc6a63d..86bf9c3 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -132,14 +132,35 @@ void poly_ExclVertex(VNODE * node);
 
 /**********************************************************************/
 
+enum PolygonBooleanOperation {
+	PBO_NONE,
+	PBO_UNITE,
+	PBO_ISECT,
+	PBO_SUB,
+	PBO_XOR
+};
+
 typedef struct POLYAREA POLYAREA;
+typedef struct POLYPARENTAGE POLYPARENTAGE;
+
+struct POLYPARENTAGE
+{
+  bool immaculate_conception;
+  enum PolygonBooleanOperation action;
+  POLYAREA *a;
+  POLYAREA *b;
+};
+
 struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
     rtree_t *contour_tree;
+    POLYPARENTAGE parentage;
 };
 
+void poly_dump (POLYAREA *p);
+
 BOOLp poly_M_Copy0(POLYAREA ** dst, const POLYAREA * srcfst);
 void poly_M_Incl(POLYAREA **list, POLYAREA *a);
 
@@ -170,13 +191,6 @@ void poly_Init(POLYAREA  *p);
 void poly_FreeContours(PLINE **pl);
 BOOLp poly_Valid(POLYAREA *p);
 
-enum PolygonBooleanOperation {
-	PBO_UNITE,
-	PBO_ISECT,
-	PBO_SUB,
-	PBO_XOR
-};
-
 double vect_dist2 (Vector v1, Vector v2);
 double vect_det2 (Vector v1, Vector v2);
 double vect_len2 (Vector v1);
diff --git a/src/polygon.c b/src/polygon.c
index eabb6b5..8a36e84 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -104,6 +104,9 @@ dicer output is used for HIDs which cannot render things with holes
 #include <dmalloc.h>
 #endif
 
+/* For getrlimit, setrlimit */
+#include <sys/time.h>
+#include <sys/resource.h>
 
 #undef DEBUG_CIRCSEGS
 
@@ -120,6 +123,8 @@ static double bw_rotate_circle_seg[4];
 void
 polygon_init (void)
 {
+  struct rlimit limit;
+
   double cos_ang = cos (2.0 * M_PI / POLY_CIRC_SEGS_F);
   double sin_ang = sin (2.0 * M_PI / POLY_CIRC_SEGS_F);
 
@@ -128,6 +133,12 @@ polygon_init (void)
 
   bw_rotate_circle_seg[0] =  cos_ang;  bw_rotate_circle_seg[1] =  sin_ang;
   bw_rotate_circle_seg[2] = -sin_ang;  bw_rotate_circle_seg[3] =  cos_ang;
+
+  /* DEBUG - AVOID PCB running the system out of memory! */
+  getrlimit (RLIMIT_AS, &limit);
+  limit.rlim_cur = MIN (limit.rlim_cur, 2000 * 1024 * 1024 /* 2000 GiB limit to virtual memory size */);
+  setrlimit (RLIMIT_AS, &limit);
+
 }
 
 Cardinal
@@ -932,6 +943,8 @@ SquarePadPoly (PadType * pad, Coord clear)
   return np;
 }
 
+/* HACK */ extern void ghid_notify_polygon_changed (PolygonType *);
+
 /* clear np1 from the polygon */
 static int
 Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
@@ -961,11 +974,13 @@ Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
       fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
       poly_Free (&merged);
       p->Clipped = NULL;
+      /* HACK */ ghid_notify_polygon_changed (p);
       if (p->NoHoles) printf ("Just leaked in Subtract\n");
       p->NoHoles = NULL;
       return -1;
     }
   p->Clipped = biggest (merged);
+  /* HACK */ ghid_notify_polygon_changed (p);
   assert (!p->Clipped || poly_Valid (p->Clipped));
   if (!p->Clipped)
     Message ("Polygon cleared out of existence near (%d, %d)\n",
@@ -1086,6 +1101,7 @@ SubtractPad (PadType * pad, PolygonType * p)
           (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
         return -1;
     }
+
   return Subtract (np, p, true);
 }
 
@@ -1288,15 +1304,19 @@ clearPoly (DataType *Data, LayerType *Layer, PolygonType * polygon,
           r_search (layer->line_tree, &region, NULL, line_sub_callback,
                     &info);
         subtract_accumulated (&info, polygon);
+#if 0
         r +=
           r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
 	r +=
           r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
+#endif
       }
       END_LOOP;
+#if 0
       r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
       r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
       subtract_accumulated (&info, polygon);
+#endif
     }
   polygon->NoHolesValid = 0;
   return r;
@@ -1329,11 +1349,13 @@ Unsubtract (POLYAREA * np1, PolygonType * p)
       goto fail;
     }
   p->Clipped = biggest (merged);
+  /* HACK */ ghid_notify_polygon_changed (p);
   assert (!p->Clipped || poly_Valid (p->Clipped));
   return 1;
 
 fail:
   p->Clipped = NULL;
+  /* HACK */ ghid_notify_polygon_changed (p);
   if (p->NoHoles) printf ("Just leaked in Unsubtract\n");
   p->NoHoles = NULL;
   return 0;
@@ -1438,6 +1460,7 @@ InitClip (DataType *Data, LayerType *layer, PolygonType * p)
   if (p->Clipped)
     poly_Free (&p->Clipped);
   p->Clipped = original_poly (p);
+  /* HACK */ ghid_notify_polygon_changed (p);
   poly_FreeContours (&p->NoHoles);
   if (!p->Clipped)
     return 0;
@@ -1754,8 +1777,11 @@ plow_callback (const BoxType * b, void *cl)
   PolygonType *polygon = (PolygonType *) b;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
-    return plow->callback (plow->data, plow->layer, polygon, plow->type,
-                           plow->ptr1, plow->ptr2, plow->userdata);
+    {
+      return plow->callback (plow->data, plow->layer, polygon, plow->type,
+                             plow->ptr1, plow->ptr2, plow->userdata);
+//      /* HACK */ ghid_notify_polygon_changed (polygon);
+    }
   return 0;
 }
 
@@ -1869,7 +1895,10 @@ RestoreToPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
     }
 
   if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerType *) ptr1, (PolygonType *) ptr2);
+    {
+      InitClip (PCB->Data, (LayerType *) ptr1, (PolygonType *) ptr2);
+//      /* HACK */ ghid_notify_polygon_changed (ptr2);
+    }
   else
     PlowsPolygon (Data, type, ptr1, ptr2, add_plow, NULL);
 }
@@ -2058,6 +2087,7 @@ MorphPolygon (LayerType *layer, PolygonType *poly)
    * we do this dirty work.
    */
   poly->Clipped = NULL;
+  /* HACK */ ghid_notify_polygon_changed (poly);
   if (poly->NoHoles) printf ("Just leaked in MorpyPolygon\n");
   poly->NoHoles = NULL;
   flags = poly->Flags;
diff --git a/src/polygon1.c b/src/polygon1.c
index 5f2686a..80ed032 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -133,6 +133,13 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 	t = (a)[1], (a)[1] = (b)[1], (b)[1] = t; \
 }
 
+static POLYPARENTAGE no_parentage = {
+  .immaculate_conception = true,
+  .action = PBO_NONE,
+  .a = NULL,
+  .b = NULL
+};
+
 #ifdef DEBUG
 static char *theState (VNODE * v);
 
@@ -152,7 +159,7 @@ pline_dump (VNODE * v)
   while ((v = NEXT_VERTEX(v)) != s);
 }
 
-static void
+/*static */void
 poly_dump (POLYAREA * p)
 {
   POLYAREA *f = p;
@@ -1969,6 +1976,9 @@ remove_polyarea (POLYAREA ** list, POLYAREA * piece)
   piece->b->f = piece->f;
   piece->f->b = piece->b;
   piece->f = piece->b = piece;
+
+  /* Reset parentage information */
+  piece->parentage = no_parentage;
 }
 
 static void
@@ -2408,6 +2418,22 @@ poly_Boolean (const POLYAREA * a_org, const POLYAREA * b_org,
   return poly_Boolean_free (a, b, res, action);
 }				/* poly_Boolean */
 
+static void
+M_Set_Parentage (POLYAREA *poly, POLYPARENTAGE parentage)
+{
+  POLYAREA *piece = poly;
+
+  if (poly == NULL)
+    return;
+
+  do
+    {
+      piece->parentage = parentage;
+    }
+  while ((piece = piece->f) != poly);
+
+}
+
 static void test_polyInvContour (void);
 
 /* just like poly_Boolean but frees the input polys */
@@ -2419,11 +2445,29 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
   PLINE *p, *holes = NULL;
   jmp_buf e;
   int code;
-
-  test_polyInvContour ();
+  POLYAREA *a_copy, *b_copy;
 
   *res = NULL;
 
+  /* Make copies for tracking polygon parentage (DEBUG) */
+  if (!poly_M_Copy0 (&a_copy, a) || !poly_M_Copy0 (&b_copy, b))
+      return err_no_memory;
+
+  /* Move the parentage information over onto the copy */
+  if (a_copy != NULL)
+    {
+      M_Set_Parentage (a_copy, a->parentage);
+      M_Set_Parentage (a, no_parentage);
+    }
+
+  if (b_copy != NULL)
+    {
+      M_Set_Parentage (b_copy, b->parentage);
+      M_Set_Parentage (b, no_parentage);
+    }
+
+  test_polyInvContour ();
+
   if (!a)
     {
       switch (action)
@@ -2431,12 +2475,14 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 	case PBO_XOR:
 	case PBO_UNITE:
 	  *res = bi;
-	  return err_ok;
+	  code = err_ok;
+	  goto out;
 	case PBO_SUB:
 	case PBO_ISECT:
 	  if (b != NULL)
 	    poly_Free (&b);
-	  return err_ok;
+	  code = err_ok;
+	  goto out;
 	}
     }
   if (!b)
@@ -2447,11 +2493,13 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 	case PBO_XOR:
 	case PBO_UNITE:
 	  *res = ai;
-	  return err_ok;
+	  code = err_ok;
+	  goto out;
 	case PBO_ISECT:
 	  if (a != NULL)
 	    poly_Free (&a);
-	  return err_ok;
+	  code = err_ok;
+	  goto out;
 	}
     }
 
@@ -2499,7 +2547,23 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       poly_Free (res);
       return code;
     }
+
+out:
   assert (!*res || poly_Valid (*res));
+
+  /* Store perantage information */
+  if (*res != NULL)
+    {
+      POLYPARENTAGE parentage;
+
+      parentage.immaculate_conception = false;
+      parentage.action = action;
+      parentage.a = a_copy;
+      parentage.b = b_copy;
+
+      M_Set_Parentage (*res, parentage);
+    }
+
   return code;
 }				/* poly_Boolean_free */
 
@@ -2990,12 +3054,23 @@ poly_Copy1 (POLYAREA * dst, const POLYAREA * src)
 BOOLp
 poly_Copy0 (POLYAREA ** dst, const POLYAREA * src)
 {
+  POLYPARENTAGE parentage;
+
   *dst = NULL;
   if (src == NULL)
     return TRUE;
 
+#if 0
+  /* Copy parentage information */
+  parentage.immaculate_conception = src->parentage.immaculate_conception;
+  parentage.action = src->parentage.action;
+  poly_M_Copy0 (&parentage.a, src->parentage.a);
+  poly_M_Copy0 (&parentage.b, src->parentage.b);
+#endif
+
   if ((*dst = poly_Create ()) == NULL || !poly_Copy1 (*dst, src))
     return FALSE;
+  (*dst)->parentage = parentage;
 
   return TRUE;
 }
@@ -3326,6 +3401,7 @@ poly_Init (POLYAREA * p)
   p->f = p->b = p;
   p->contours = NULL;
   p->contour_tree = r_create_tree (NULL, 0, 0);
+  p->parentage = no_parentage;
 }
 
 POLYAREA *
@@ -3367,6 +3443,13 @@ poly_Free (POLYAREA ** p)
     }
   poly_FreeContours (&cur->contours);
   r_destroy_tree (&cur->contour_tree);
+
+  /* Free parentage information - assume all linked polygons share this, so only need to do it for the past polygon */
+  if ((*p)->parentage.a != NULL)
+    poly_Free (&(*p)->parentage.a);
+  if ((*p)->parentage.b != NULL)
+    poly_Free (&(*p)->parentage.b);
+
   free (*p), *p = NULL;
 }
 
diff --git a/src/select.c b/src/select.c
index f130b07..3e231d0 100644
--- a/src/select.c
+++ b/src/select.c
@@ -127,6 +127,7 @@ SelectObject (void)
 
     case POLYGON_TYPE:
       {
+	/* HACK */ extern void ghid_populate_polygon_parentage (PolygonType *);
 	PolygonType *poly = (PolygonType *) ptr2;
 
 	layer = (LayerType *) ptr1;
@@ -134,6 +135,9 @@ SelectObject (void)
 	TOGGLE_FLAG (SELECTEDFLAG, poly);
 	DrawPolygon (layer, poly);
 	/* changing memory order no longer effects draw order */
+
+	/* HACK */ ghid_populate_polygon_parentage (poly);
+
 	break;
       }
