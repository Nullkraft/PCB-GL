Bottom: 4491c6d4e820a54f426a8fd1611aab46478a3c47
Top:    e7bf65043e8329805e6ddd2bd3163d4ece3c2e68
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-07 01:33:10 +0000

Move arc from included angle calculation into misc.c

Also add computation of radius and start/end angle

Compute the correct boundingbox for a polygon with arc segments.


---

diff --git a/src/misc.c b/src/misc.c
index 0cab234..13245e2 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -355,6 +355,69 @@ SetLineBoundingBox (LineType *Line)
 }
 
 /* ---------------------------------------------------------------------------
+ * calculates an arc center and radius for the arc described by
+ * two points, and an included angle between them. Return locations for
+ * cx, cy are required. radius, start_angle and delta_angle are optional
+ * and may be NULL if not required.
+ */
+void
+calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle,
+                                         Coord *cx, Coord *cy, Coord *radius,
+                                         Angle *start_angle, Angle *delta_angle)
+{
+  Coord hx, hy;
+  double p_to_h_dist;
+  double c_to_h_dist;
+  double unit_hcx, unit_hcy;
+
+  /* The arc center lies on a line passing through hx, hy, perpendicular
+   * to the direction between our two end-points.
+   *
+   *              p2
+   *            / |
+   *          /   |h
+   *    -----c----|-------------- line passing (hx, hy), perpendicular to p1-p2
+   *          \   |
+   *            \ |
+   *              p1
+   *
+   *  Find cx, cy.
+   *
+   *  We know that c-p1 = radius. (But we don't know that radius).
+   *  We have the included angle, /_ p1.c.p2
+   *  |(hx,hy)-p1| = sin(angle/2) * radius
+   *
+   * tan(ang/2) = |(hx,hy)-p1| / |(hx,hy)-(cx,cy)|
+   *
+   * |(hx,hy)-(cx,cy)| = |(hx,hy)-p1| / tan(ang/2)
+   *
+   */
+
+  /* Find the point halfway between the two points the arc spans */
+  hx = p1->X + (p2->X - p1->X) / 2;
+  hy = p1->Y + (p2->Y - p1->Y) / 2;
+
+  p_to_h_dist = sqrt (pow(p2->X - p1->Y, 2) + pow (p2->Y - p1->Y, 2)) / 2.;
+  c_to_h_dist = p_to_h_dist / tan (TO_RADIANS (included_angle) / 2.);
+
+  unit_hcx = (float)-(hy - p1->Y) / p_to_h_dist;
+  unit_hcy = (float) (hx - p1->X) / p_to_h_dist;
+
+  *cx = hx + unit_hcx * c_to_h_dist;
+  *cy = hy + unit_hcy * c_to_h_dist;
+
+  if (radius != NULL)
+    *radius = sqrt ((p1->X - *cx) * (p1->X - *cx) +
+                    (p1->Y - *cy) * (p1->Y - *cy));
+
+  if (start_angle != NULL)
+    *start_angle = atan2 ((p1->Y - *cy), -(p1->X - *cx)) / M180;
+
+  if (delta_angle != NULL)
+    *delta_angle = included_angle;
+}
+
+/* ---------------------------------------------------------------------------
  * sets the bounding box of a polygons
  */
 void
@@ -368,6 +431,27 @@ SetPolygonBoundingBox (PolygonType *Polygon)
     MAKEMIN (Polygon->BoundingBox.Y1, point->Y);
     MAKEMAX (Polygon->BoundingBox.X2, point->X);
     MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
+
+    if (point->included_angle != 0)
+      {
+        BoxType arc_bound;
+        Coord cx, cy, radius;
+        Angle start_angle, delta_angle;
+        PointType *next_point;
+
+        /* NB: This next line uses the polygon point index, n, defined by POLYGON_POINT_LOOP */
+        next_point = &Polygon->Points[next_contour_point (Polygon, n)];
+
+        calc_arc_from_points_and_included_angle (point, next_point, point->included_angle,
+                                                 &cx, &cy, &radius, &start_angle, &delta_angle);
+
+        arc_bound = calc_thin_arc_bounds (cx, cy, radius, radius, start_angle, delta_angle);
+
+        MAKEMIN (Polygon->BoundingBox.X1, arc_bound.X1);
+        MAKEMIN (Polygon->BoundingBox.Y1, arc_bound.Y1);
+        MAKEMAX (Polygon->BoundingBox.X2, arc_bound.X2);
+        MAKEMAX (Polygon->BoundingBox.Y2, arc_bound.Y2);
+      }
   }
   /* boxes don't include the lower right corner */
   close_box(&Polygon->BoundingBox);
diff --git a/src/misc.h b/src/misc.h
index 860cfa7..84f62ed 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -53,6 +53,7 @@ void SetArcEndpoints (ArcType *);
 void SetPointBoundingBox (PointType *);
 void SetPinBoundingBox (PinType *);
 void SetPadBoundingBox (PadType *);
+void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, Coord *cx, Coord *cy, Coord *radius, Angle *start_angle, Angle *delta_angle);
 void SetPolygonBoundingBox (PolygonType *);
 void SetElementBoundingBox (DataType *, ElementType *, FontType *);
 bool IsDataEmpty (DataType *);
diff --git a/src/polygon.c b/src/polygon.c
index 5397e4f..99c1d73 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -354,13 +354,7 @@ original_poly (PolygonType * p)
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
-          Coord px, py;
-          Coord nx, ny;
-          Coord hx, hy;
           Coord cx, cy;
-          double p_to_h_dist;
-          double c_to_h_dist;
-          double unit_hcx, unit_hcy;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -369,44 +363,9 @@ original_poly (PolygonType * p)
 
           /* XXX: Compute center of arc */
 
-          px = p->Points[     n].X, py = p->Points[     n].Y;
-          nx = p->Points[next_n].X, ny = p->Points[next_n].Y;
-
-          /* Find the point halfway between the to points the arc spans */
-          hx = px + (nx - px) / 2;
-          hy = py + (ny - py) / 2;
-
-          /* The arc center lies on a line passing through hx, hy, perpendicular
-           * to the direction between our two end-points.
-           *
-           *              n
-           *            / |
-           *          /   |h
-           *    -----c----|-------------- line passing (hx, hy), perpendicular to p[n]-p[next_n]
-           *          \   |
-           *            \ |
-           *              p
-           *
-           *  Find cx, cy.
-           *
-           *  We know that c-p[n] = radius. (But we don't know that radius).
-           *  We have the included angle, /_ p[n].c.p[next_n]
-           *  |(hx,hy)-p[n]| = sin(angle/2) * radius
-           *
-           * tan(ang/2) = |(hx,hy)-p[n]| / |(hx,hy)-(cx,cy)|
-           *
-           * |(hx,hy)-(cx,cy)| = |(hx,hy)-p[n]| / tan(ang/2)
-           *
-           */
-
-          p_to_h_dist = sqrt (pow(nx - py, 2) + pow (ny - py, 2)) / 2.;
-          c_to_h_dist = p_to_h_dist / tan (TO_RADIANS (p->Points[n].included_angle) / 2.);
-
-          unit_hcx = (float)-(hy - py) / p_to_h_dist;
-          unit_hcy = (float)(hx - px) / p_to_h_dist;
-
-          cx = hx + unit_hcx * c_to_h_dist;
-          cy = hy + unit_hcy * c_to_h_dist;
+
+          calc_arc_from_points_and_included_angle (&p->Points[n], &p->Points[next_n], p->Points[n].included_angle,
+                                                   &cx, &cy, NULL, NULL, NULL);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;
