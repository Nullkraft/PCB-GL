Bottom: 06b9edbbec0bcb4c9b3cdb8be3c676da5a125d36
Top:    b4be4cf86a17b86204313505866daaabbe586217
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-06 17:22:52 +0000

Pass a HID_DRAW * instance to hid_expose_callback() rather than a HID * pointer

Drawing should eventually be independent of the HID


---

diff --git a/src/draw.c b/src/draw.c
index 16d209b..0cfa13d 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -74,6 +74,7 @@ static BoxType Block = {MAXINT, MAXINT, -MAXINT, -MAXINT};
 
 static int doing_pinout = 0;
 static bool doing_assy = false;
+static HID_DRAW *hid_draw = NULL;
 
 /* ---------------------------------------------------------------------------
  * some local prototypes
@@ -176,10 +177,10 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  if (hid_draw_is_gui (gui->graphics))
+  if (hid_draw_is_gui (hid_draw))
     doing_pinout++;
   hid_draw_pcb_text (Output.fgGC, &text, 0);
-  if (hid_draw_is_gui (gui->graphics))
+  if (hid_draw_is_gui (hid_draw))
     doing_pinout--;
 }
 
@@ -320,7 +321,7 @@ pad_callback (const BoxType * b, void *cl)
 static void
 draw_element_name (ElementType *element)
 {
-  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (gui->graphics)) ||
+  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
   if (doing_pinout || doing_assy)
@@ -566,7 +567,7 @@ DrawEverything (const BoxType *drawn_area)
    * first draw all 'invisible' stuff
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
-      && hid_draw_set_layer (gui->graphics, "invisible", SL (INVISIBLE, 0), 0))
+      && hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0))
     {
       side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
@@ -576,7 +577,7 @@ DrawEverything (const BoxType *drawn_area)
 	  DrawLayer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area);
 	}
       r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
   /* draw all layers in layerstack order */
@@ -584,105 +585,105 @@ DrawEverything (const BoxType *drawn_area)
     {
       int group = drawn_groups[i];
 
-      if (hid_draw_set_layer (gui->graphics, 0, group, 0))
+      if (hid_draw_set_layer (hid_draw, 0, group, 0))
         {
           DrawLayerGroup (group, drawn_area);
-          hid_draw_end_layer (gui->graphics);
+          hid_draw_end_layer (hid_draw);
         }
     }
 
-  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && hid_draw_is_gui (gui->graphics))
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && hid_draw_is_gui (hid_draw))
     return;
 
   /* Draw pins, pads, vias below silk */
-  if (hid_draw_is_gui (gui->graphics))
+  if (hid_draw_is_gui (hid_draw))
     DrawPPV (SWAP_IDENT ? bottom_group : top_group, drawn_area);
   else
     {
       CountHoles (&plated, &unplated, drawn_area);
 
-      if (plated && hid_draw_set_layer (gui->graphics, "plated-drill", SL (PDRILL, 0), 0))
+      if (plated && hid_draw_set_layer (hid_draw, "plated-drill", SL (PDRILL, 0), 0))
         {
           DrawHoles (true, false, drawn_area);
-          hid_draw_end_layer (gui->graphics);
+          hid_draw_end_layer (hid_draw);
         }
 
-      if (unplated && hid_draw_set_layer (gui->graphics, "unplated-drill", SL (UDRILL, 0), 0))
+      if (unplated && hid_draw_set_layer (hid_draw, "unplated-drill", SL (UDRILL, 0), 0))
         {
           DrawHoles (false, true, drawn_area);
-          hid_draw_end_layer (gui->graphics);
+          hid_draw_end_layer (hid_draw);
         }
     }
 
   /* Draw the solder mask if turned on */
-  if (hid_draw_set_layer (gui->graphics, "componentmask", SL (MASK, TOP), 0))
+  if (hid_draw_set_layer (hid_draw, "componentmask", SL (MASK, TOP), 0))
     {
       DrawMask (TOP_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "soldermask", SL (MASK, BOTTOM), 0))
+  if (hid_draw_set_layer (hid_draw, "soldermask", SL (MASK, BOTTOM), 0))
     {
       DrawMask (BOTTOM_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "topsilk", SL (SILK, TOP), 0))
+  if (hid_draw_set_layer (hid_draw, "topsilk", SL (SILK, TOP), 0))
     {
       DrawSilk (TOP_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "bottomsilk", SL (SILK, BOTTOM), 0))
+  if (hid_draw_set_layer (hid_draw, "bottomsilk", SL (SILK, BOTTOM), 0))
     {
       DrawSilk (BOTTOM_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_is_gui (gui->graphics))
+  if (hid_draw_is_gui (hid_draw))
     {
       /* Draw element Marks */
       if (PCB->PinOn)
 	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
 		  NULL);
       /* Draw rat lines on top */
-      if (hid_draw_set_layer (gui->graphics, "rats", SL (RATS, 0), 0))
+      if (hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0))
         {
           DrawRats(drawn_area);
-          hid_draw_end_layer (gui->graphics);
+          hid_draw_end_layer (hid_draw);
         }
     }
 
   paste_empty = IsPasteEmpty (TOP_SIDE);
-  if (hid_draw_set_layer (gui->graphics, "toppaste", SL (PASTE, TOP), paste_empty))
+  if (hid_draw_set_layer (hid_draw, "toppaste", SL (PASTE, TOP), paste_empty))
     {
       DrawPaste (TOP_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
-  if (hid_draw_set_layer (gui->graphics, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
+  if (hid_draw_set_layer (hid_draw, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
       DrawPaste (BOTTOM_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "topassembly", SL (ASSY, TOP), 0))
+  if (hid_draw_set_layer (hid_draw, "topassembly", SL (ASSY, TOP), 0))
     {
       PrintAssembly (TOP_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "bottomassembly", SL (ASSY, BOTTOM), 0))
+  if (hid_draw_set_layer (hid_draw, "bottomassembly", SL (ASSY, BOTTOM), 0))
     {
       PrintAssembly (BOTTOM_SIDE, drawn_area);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 
-  if (hid_draw_set_layer (gui->graphics, "fab", SL (FAB, 0), 0))
+  if (hid_draw_set_layer (hid_draw, "fab", SL (FAB, 0), 0))
     {
       PrintFab (Output.fgGC);
-      hid_draw_end_layer (gui->graphics);
+      hid_draw_end_layer (hid_draw);
     }
 }
 
@@ -740,7 +741,7 @@ DrawPPV (int group, const BoxType *drawn_area)
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int side;
 
-  if (PCB->PinOn || !hid_draw_is_gui (gui->graphics))
+  if (PCB->PinOn || !hid_draw_is_gui (hid_draw))
     {
       /* draw element pins */
       r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
@@ -760,7 +761,7 @@ DrawPPV (int group, const BoxType *drawn_area)
     }
 
   /* draw vias */
-  if (PCB->ViaOn || !hid_draw_is_gui (gui->graphics))
+  if (PCB->ViaOn || !hid_draw_is_gui (hid_draw))
     {
       r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
       r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
@@ -822,9 +823,9 @@ DrawSilk (int side, const BoxType * drawn_area)
 #endif
 
 #if 0
-  if (gui->graphics->poly_before)
+  if (hid_draw->poly_before)
     {
-      hid_draw_use_mask (gui->graphics, HID_MASK_BEFORE);
+      hid_draw_use_mask (hid_draw, HID_MASK_BEFORE);
 #endif
       DrawLayer (LAYER_PTR (max_copper_layer + side), drawn_area);
       /* draw package */
@@ -833,20 +834,20 @@ DrawSilk (int side, const BoxType * drawn_area)
 #if 0
     }
 
-  hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
+  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
   r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, NULL);
   r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, NULL);
   r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &side);
 
-  if (gui->graphics->poly_after)
+  if (hid_draw->poly_after)
     {
-      hid_draw_use_mask (gui->graphics, HID_MASK_AFTER);
+      hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
       DrawLayer (LAYER_PTR (max_copper_layer + layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
     }
-  hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
+  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 #endif
 }
 
@@ -855,11 +856,11 @@ static void
 DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
 {
   /* Skip the mask drawing if the GUI doesn't want this type */
-  if ((mask_type == HID_MASK_BEFORE && !gui->graphics->poly_before) ||
-      (mask_type == HID_MASK_AFTER  && !gui->graphics->poly_after))
+  if ((mask_type == HID_MASK_BEFORE && !hid_draw->poly_before) ||
+      (mask_type == HID_MASK_AFTER  && !hid_draw->poly_after))
     return;
 
-  hid_draw_use_mask (gui->graphics, mask_type);
+  hid_draw_use_mask (hid_draw, mask_type);
   hid_draw_set_color (Output.fgGC, PCB->MaskColor);
   if (drawn_area == NULL)
     hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
@@ -881,7 +882,7 @@ DrawMask (int side, const BoxType *screen)
   else
     {
       DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
+      hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
     }
 
   r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
@@ -893,7 +894,7 @@ DrawMask (int side, const BoxType *screen)
   else
     {
       DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
+      hid_draw_use_mask (hid_draw, HID_MASK_OFF);
     }
 }
 
@@ -926,11 +927,11 @@ DrawRats (const BoxType *drawn_area)
    * XXX using the mask here is to get rat transparency
    */
 
-  if (hid_draw_can_draw_in_mask_clear (gui->graphics))
-    hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
+  if (hid_draw_can_draw_in_mask_clear (hid_draw))
+    hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
   r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
-  if (hid_draw_can_draw_in_mask_clear (gui->graphics))
-    hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
+  if (hid_draw_can_draw_in_mask_clear (hid_draw))
+    hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 }
 
 static int
@@ -973,7 +974,7 @@ DrawLayer (LayerType *Layer, const BoxType *screen)
   /* draw the layer text on screen */
   r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
 
-  /* We should check for hid_draw_is_gui (gui->graphics) here, but it's kinda cool seeing the
+  /* We should check for hid_draw_is_gui (hid_draw) here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
      the "outline" layer.  */
   if (IsLayerEmpty (Layer)
@@ -1012,7 +1013,7 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
   if (n_entries > 1)
     rv = 1;
 
-  if (rv && !hid_draw_is_gui (gui->graphics))
+  if (rv && !hid_draw_is_gui (hid_draw))
     DrawPPV (group, drawn_area);
 }
 
@@ -1532,14 +1533,12 @@ draw_element (ElementType *element)
  */
 
 void
-hid_expose_callback (HID * hid, BoxType * region, void *item)
+hid_expose_callback (HID_DRAW *expose_hid_draw, BoxType *region, void *item)
 {
-  HID *old_gui = gui;
-
-  gui = hid;
-  Output.fgGC = hid_draw_make_gc (hid->graphics);
-  Output.bgGC = hid_draw_make_gc (hid->graphics);
-  Output.pmGC = hid_draw_make_gc (hid->graphics);
+  hid_draw = expose_hid_draw;
+  Output.fgGC = hid_draw_make_gc (hid_draw);
+  Output.bgGC = hid_draw_make_gc (hid_draw);
+  Output.pmGC = hid_draw_make_gc (hid_draw);
 
   hid_draw_set_color (Output.pmGC, "erase");
   hid_draw_set_color (Output.bgGC, "drill");
@@ -1556,5 +1555,5 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   hid_draw_destroy_gc (Output.fgGC);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
-  gui = old_gui;
+  hid_draw = NULL;
 }
diff --git a/src/hid.h b/src/hid.h
index 26d7edc..ed921db 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -530,7 +530,7 @@ typedef enum
 
    Do *not* assume that the hid that is passed is the GUI hid.  This
    callback is also used for printing and exporting. */
-  void hid_expose_callback (HID * hid_, struct BoxType *region_, void *item_);
+  void hid_expose_callback (HID_DRAW *hid_draw, struct BoxType *region_, void *item_);
 
 /* This is initially set to a "no-gui" gui, and later reset by
    main. hid_expose_callback also temporarily set it for drawing. */
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 1b4746f..7014af5 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -226,7 +226,7 @@ hid_get_extents (void *item)
   region.Y1 = -COORD_MAX - 1;
   region.X2 = COORD_MAX;
   region.Y2 = COORD_MAX;
-  hid_expose_callback (&extents_hid, &region, item);
+  hid_expose_callback (&extents_graphics, &region, item);
 
   return &box;
 }
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 3a7c0c2..a4bdd9d 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -470,7 +470,7 @@ gcode_start_png_export ()
   linewidth = -1;
   lastbrush = (gdImagePtr)((void *) -1);
 
-  hid_expose_callback (&gcode_hid, &region, 0);
+  hid_expose_callback (&gcode_graphics, &region, 0);
 }
 
 static FILE *
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 88393ef..0f8f287 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -683,11 +683,11 @@ gerber_do_export (HID_Attr_Val * options)
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  hid_expose_callback (&gerber_graphics, &region, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  hid_expose_callback (&gerber_graphics, &region, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index ff31cbe..705b45b 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -801,7 +801,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_graphics, &region, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1179,7 +1179,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_hid, NULL, pinout->element);
+  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1236,7 +1236,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+  hid_expose_callback (&ghid_graphics, &region, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c7197d4..32a125d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1039,7 +1039,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_draw_bg_image ();
 
   ghid_invalidate_current_gc ();
-  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_graphics, &region, 0);
   hidgl_flush_triangles (priv->hidgl);
 
   ghid_draw_grid (priv->crosshair_gc, &region);
@@ -1193,7 +1193,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_hid, NULL, pinout->element);
+  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
   hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
@@ -1307,7 +1307,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+  hid_expose_callback (&ghid_graphics, &region, NULL);
   hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index f828343..c099230 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -831,7 +831,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_hid, &region, 0);
+      hid_expose_callback (&lesstif_graphics, &region, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2579,7 +2579,7 @@ idle_proc (XtPointer dummy)
 	    }
 	}
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_hid, &region, 0);
+      hid_expose_callback (&lesstif_graphics, &region, 0);
       draw_grid ();
       lesstif_use_mask (HID_MASK_OFF);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
@@ -3803,7 +3803,7 @@ pinout_callback (Widget da, PinoutData * pd,
   region.Y2 = PCB->MaxHeight;
 
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_hid, &region, pd->item);
+  hid_expose_callback (&lesstif_graphics, &region, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 8940a70..a460e95 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -649,7 +649,7 @@ nelma_start_png_export()
 	linewidth = -1;
 	lastbrush = (gdImagePtr)((void *) -1);
 
-	hid_expose_callback(&nelma_hid, &region, 0);
+	hid_expose_callback(&nelma_graphics, &region, 0);
 }
 
 static void 
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 1260d70..8a72345 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -655,7 +655,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_hid, bounds, 0);
+  hid_expose_callback (&png_graphics, bounds, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 5bf65c8..3f46376 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -303,7 +303,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_hid, bounds, 0);
+  hid_expose_callback (&eps_graphics, bounds, 0);
 
   fprintf (f, "showpage\n");
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index f8df547..248831f 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -693,13 +693,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+      hid_expose_callback (&ps_graphics, &global.region, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+  hid_expose_callback (&ps_graphics, &global.region, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
