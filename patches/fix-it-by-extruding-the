Bottom: 381665d7043ede2192438430871e1df55e0dbfc0
Top:    1f40370ca147f04991ac74adccb8701ef3c88645
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-26 22:05:32 +0000

Fix it by extruding the contours pre-inside-out...

Doing it this way hurts my brain less than trying to figure out how to
selectively reverse edges in a quad-edge data-structure.

Works in FreeCAD
_NEARLY_ works in OnShape - it doesn't like when we employ purely circular contours


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 2591490..aa11c96 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -335,7 +335,9 @@ object3d_from_contours (POLYAREA *contours,
                         double zbot,
                         double ztop,
                         const appearance *master_object_appearance,
-                        const appearance *master_top_bot_appearance)
+                        const appearance *master_top_bot_appearance,
+                        bool sides_inverted,   /* true for extruding positive contours which are to become holes. */
+                        bool top_bot_inverted) /* true if the top and bottom are to be spliced as an inner contour of another face */
 {
   GList *objects = NULL;
   object3d *object;
@@ -354,6 +356,7 @@ object3d_from_contours (POLYAREA *contours,
   int offset_in_ct;
   int ct_npoints;
   polygon_3d_link *link;
+  bool invert;
 
   if (contours == NULL)
     return NULL;
@@ -431,39 +434,56 @@ object3d_from_contours (POLYAREA *contours,
       object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
-      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+      invert = sides_inverted ? false : true;
 #else
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+      invert = sides_inverted ? true : false;
 #endif
+      if (invert)
+        face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+      else
+        face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
     }
 
-    faces[npoints] = make_face3d (); /* bottom_face */
-#ifdef REVERSED_PCB_CONTOURS
-    face3d_set_normal (faces[npoints], 0., 0., -1.);
-#else
-    face3d_set_normal (faces[npoints], 0., 0., 1.);
-#endif
-    face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (object, faces[npoints]);
-
+    faces[npoints    ] = make_face3d (); /* bottom_face */
     faces[npoints + 1] = make_face3d (); /* top_face */
 #ifdef REVERSED_PCB_CONTOURS
-    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+    invert = top_bot_inverted ? false : true;
 #else
-    face3d_set_normal (faces[npoints + 1], 0., 0., -1.);
+    invert = top_bot_inverted ? true : false;
 #endif
+    if (invert)
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0., -1.); /* bottom_face */
+        face3d_set_normal (faces[npoints + 1], 0., 0.,  1.); /* top_face */
+      }
+    else
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0.,  1.); /* bottom_face */
+        face3d_set_normal (faces[npoints + 1], 0., 0., -1.); /* top_face */
+      }
+    face3d_set_appearance (faces[npoints    ], top_bot_appearance);
     face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints    ]);
     object3d_add_face (object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
-    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+      invert = top_bot_inverted ? false : true;
 #else
-    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+      invert = top_bot_inverted ? true : false;
 #endif
 
+    if (invert)
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+      }
+    else
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[0])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+      }
+
     ct = contour;
     start_of_ct = 0;
     offset_in_ct = 0;
@@ -481,13 +501,22 @@ object3d_from_contours (POLYAREA *contours,
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+        /* XXX: Haven't properly thought through how (if) inverting works with multiple contours */
 #ifdef REVERSED_PCB_CONTOURS
-        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+        invert = top_bot_inverted ? false : true;
 #else
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        invert = top_bot_inverted ? true : false;
 #endif
+      if (invert)
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+        }
+      else
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        }
       }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -496,13 +525,17 @@ object3d_from_contours (POLYAREA *contours,
       /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
       /* Define the (non-normalized) face normal to point to the outside of the contour */
 #if REVERSED_PCB_CONTOURS
-      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
-      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
-                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+      invert = sides_inverted ? false : true;
 #else
-      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+      invert = sides_inverted ? true : false;
 #endif
+      if (invert)
+        /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+        face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                      (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+      else
+        face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                     -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
 
       /* Assign the appropriate vertex geometric data to each edge end */
       ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -511,6 +544,45 @@ object3d_from_contours (POLYAREA *contours,
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+      /* XXX: Do we need to differently with this for inverted sides / top? */
+
+#if REVERSED_PCB_CONTOURS
+      invert = top_bot_inverted ? false : true;
+#else
+      invert = top_bot_inverted ? true : false;
+#endif
+      if (invert)
+        {
+          RDATA (edges[              i]) = faces[i];
+          LDATA (edges[              i]) = faces[npoints];
+          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          LDATA (edges[1 * npoints + i]) = faces[i];
+        }
+      else
+        {
+          LDATA (edges[              i]) = faces[i];
+          RDATA (edges[              i]) = faces[npoints];
+          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          RDATA (edges[1 * npoints + i]) = faces[i];
+        }
+
+#if REVERSED_PCB_CONTOURS
+      invert = sides_inverted ? false : true;
+#else
+      invert = sides_inverted ? true : false;
+#endif
+      if (invert)
+        {
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
+        }
+      else
+        {
+          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          RDATA (edges[2 * npoints + i]) = faces[i];
+        }
+
+#if 0
 #if REVERSED_PCB_CONTOURS
       RDATA (edges[              i]) = faces[i];
       LDATA (edges[              i]) = faces[npoints];
@@ -526,6 +598,7 @@ object3d_from_contours (POLYAREA *contours,
       LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
       RDATA (edges[2 * npoints + i]) = faces[i];
 #endif
+#endif
 
       /* NB: Contours are counter clockwise in XY plane.
        *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
@@ -534,21 +607,63 @@ object3d_from_contours (POLYAREA *contours,
        */
 
 #ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], edges[i]);
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+      if (!top_bot_inverted && !sides_inverted)
+        {
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[i]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+        }
+      else if (top_bot_inverted && !sides_inverted)
+        {
+          /* XXX: CANT BE BOTHERED RIGHT NOW - NOT IMPLEMENTED */
+          g_assert_not_reached ();
+        }
+      else if (top_bot_inverted && sides_inverted)
+        {
+          /* XXX: CANT BE BOTHERED RIGHT NOW - NOT IMPLEMENTED */
+          g_assert_not_reached ();
+        }
+      else
+        {
+          /* XXX: THIS COMBINATION IS CURRENTLY NOT USED */
+          g_assert_not_reached ();
+        }
 #else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+      if (!top_bot_inverted && !sides_inverted)
+        {
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (edges[i], edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+        }
+      else if (top_bot_inverted && !sides_inverted)
+        {
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[i]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[prev_i_around_ct]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + prev_i_around_ct], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]),  SYM(edges[npoints + i]));
+        }
+      else if (top_bot_inverted && sides_inverted)
+        {
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[i]), SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), edges[prev_i_around_ct]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + prev_i_around_ct], edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i],  SYM(edges[npoints + i]));
+        }
+      else
+        {
+          /* XXX: THIS COMBINATION IS CURRENTLY NOT USED */
+          g_assert_not_reached ();
+        }
 #endif
 
       if (get_contour_edge_n_is_round (ct, offset_in_ct)) {
@@ -560,17 +675,23 @@ object3d_from_contours (POLYAREA *contours,
 
         get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
 
+        /* AXIS DIRECTON NOT DEPEND ON WHETHER WE INVERT THE TOP/BOT CONTOUR.. THE EDGE LOOP IS APPROPRIATE ALREADY */
         face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1., /* Direction of the cylindrical axis */
+                                          0., 0., /*sides_inverted ? -1. :*/ 1., /* Direction of the cylindrical axis */
                                           radius);
 
         /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
-        if (ct->Flags.orient == PLF_INV)
+        /* XXX: SURFACE ORIENTATION IS ONLY FIXED UP DURING EMISSION IF WE FLAG THE NEED HERE..
+         *      CYLINDRICAL SURFACE ORIENTATION IS ALWAYS POINTING OUTWARD FROM ITS AXIS, SO
+         *      ORIENTATION REVERSED IS USED FOR HOLES
+         */
+        if ((ct->Flags.orient == PLF_INV) != sides_inverted)
           face3d_set_surface_orientation_reversed (faces[i]);
 
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
+        /* DOES NOT DEPEND ON WHETHER WE INVERT THE TOP/BOT CONTOUR.. THE EDGE TRAVERSAL IS REVERSED DURING EMISSION */
 #ifdef REVERSED_PCB_CONTOURS
         normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
@@ -685,8 +806,6 @@ object3d_from_contours (POLYAREA *contours,
     link = malloc (sizeof (polygon_3d_link));
     pa->user_data = link;
     link->object = object;
-//    link->top_face = faces[npoints];
-//    link->bottom_face = faces[npoints + 1];
     link->bottom_face = faces[npoints];
     link->top_face = faces[npoints + 1];
 
@@ -717,19 +836,17 @@ object3d_from_board_outline (void)
   appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
 //  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (board_outline,
+#ifdef REVERSED_PCB_CONTOURS
                                     -HACK_BOARD_THICKNESS, /* Bottom */
                                     0                    ,  /* Top */
-                                    board_appearance,
-                                    top_bot_appearance);
 #else
-  objects = object3d_from_contours (board_outline,
                                      HACK_BOARD_THICKNESS / 2, /* Bottom */
                                     -HACK_BOARD_THICKNESS / 2, /* Top */
-                                    board_appearance,
-                                    top_bot_appearance);
 #endif
+                                    board_appearance,
+                                    top_bot_appearance,
+                                    false, false);
 
   destroy_appearance (board_appearance);
   destroy_appearance (top_bot_appearance);
@@ -1002,19 +1119,17 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
   mask_appearance = make_appearance ();
   appearance_set_color (mask_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (info.poly,
+#ifdef REVERSED_PCB_CONTOURS
                                     (side == TOP_SIDE) ? 0                   - HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
                                     (side == TOP_SIDE) ? HACK_MASK_THICKNESS - HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS,                       /* Top */
-                                    mask_appearance,
-                                    NULL);
 #else
-  objects = object3d_from_contours (info.poly,
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS                       : HACK_BOARD_THICKNESS / 2 + HACK_COPPER_THICKNESS + HACK_MASK_THICKNESS, /* Bottom */
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2 + HACK_COPPER_THICKNESS, /* Top */
-                                    mask_appearance,
-                                    NULL);
 #endif
+                                    mask_appearance,
+                                    NULL,
+                                    false, false);
 
   destroy_appearance (mask_appearance);
 
@@ -1199,6 +1314,7 @@ old_object3d_from_board_outline (void)
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+
 #if REVERSED_PCB_CONTOURS
       RDATA (edges[              i]) = faces[i];
       LDATA (edges[              i]) = faces[npoints];
@@ -1708,7 +1824,8 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
                                 -depth - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Top */
 #endif
                                 copper_appearance,
-                                NULL));
+                                NULL,
+                                false, false));
 
       group_m_polyarea[group] = info.poly;
     }
@@ -1768,7 +1885,8 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
                                                -top_depth    - HACK_BOARD_THICKNESS / 2,                         /* Top */
 #endif
                                                copper_appearance,
-                                               NULL);
+                                               NULL,
+                                               false, true);
 
 /* Connect the via barrels in this block of code */
 #if 1
@@ -1844,7 +1962,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           e = barrel_top_face_first_edge;
           do
             {
-              edge_info *info = UNDIR_DATA (e);
+//              edge_info *info = UNDIR_DATA (e);
 //              face3d *side_face = RDATA (e);
 
               /* Check and reassign the edge */
@@ -1858,34 +1976,34 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 //                  edge_face->az = -edge_face->az;
 //                }
 
-              if (info->is_round)
-                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
 
               /* XXX: Also need to flip this edge!... CHEAT, and just flip the object3d edge bucket references...
                * XXX: Leaves the quad-edges WRONG!
                */
-              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)e);
-              object3d_add_edge (barrel_object, SYM (e));
+//              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)e);
+//              object3d_add_edge (barrel_object, SYM (e));
             }
           while ((e = LNEXT (e)) != barrel_top_face_first_edge);
 
           e = barrel_bottom_face_first_edge;
           do
             {
-              edge_info *info = UNDIR_DATA (e);
+//              edge_info *info = UNDIR_DATA (e);
 
               /* Check and reassign the edge */
               g_assert (LDATA (e) == barrel_bottom_face);
               LDATA (e) = bottom_group_face;
 
-              if (info->is_round)
-                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
-
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+//
               /* XXX: Also need to flip this edge!... CHEAT, and just flip the object3d edge bucket references...
                * XXX: Leaves the quad-edges WRONG!
                */
-              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)SYM (e));
-              object3d_add_edge (barrel_object, e);
+//              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)SYM (e));
+//              object3d_add_edge (barrel_object, e);
             }
           while ((e = LNEXT (e)) != barrel_bottom_face_first_edge);
 
@@ -1930,7 +2048,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 #endif
     }
 
-  if (0) /* Drill barrels */
+  if (1) /* Drill holes */
     {
       Coord top_depth;
       Coord bottom_depth;
@@ -1946,15 +2064,15 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 
       drill_objects = object3d_from_contours (drill_m_polyarea,
 #ifdef REVERSED_PCB_CONTOURS
-                                              top_depth - HACK_BOARD_THICKNESS + HACK_COPPER_THICKNESS, /* Bottom */
-                                              bottom_depth    - HACK_BOARD_THICKNESS + HACK_COPPER_THICKNESS, /* Top */
+                                               bottom_depth - HACK_BOARD_THICKNESS + HACK_COPPER_THICKNESS,     /* Bottom */
+                                               top_depth    - HACK_BOARD_THICKNESS + HACK_COPPER_THICKNESS,     /* Top */
 #else
-                                              /* NB: We're extruding this inside out, so the contour directions match up nicely (?) */
-                                              -top_depth    - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Bottom */
-                                              -bottom_depth - HACK_BOARD_THICKNESS / 2,                         /* Top */
+                                              -bottom_depth - HACK_BOARD_THICKNESS / 2,                         /* Bottom */
+                                              -top_depth    - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Top */
 #endif
                                               copper_appearance,
-                                              NULL);
+                                              NULL,
+                                              true, true);
 
 /* Connect the via drill holes in this block of code */
 #if 1
@@ -1972,8 +2090,8 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           object3d *bottom_group_object = bottom_link->object;
 
           face3d *top_group_face    = top_link->top_face;
-          face3d *drill_top_face    = drill_link->bottom_face; /* Remember we extruded this upside down (inside out) */
-          face3d *drill_bottom_face = drill_link->top_face;    /* Remember we extruded this upside down (inside out) */
+          face3d *drill_top_face    = drill_link->top_face;
+          face3d *drill_bottom_face = drill_link->bottom_face;
           face3d *bottom_group_face = bottom_link->bottom_face;
 
           edge_ref drill_top_face_first_edge = ((contour3d *)drill_top_face->contours->data)->first_edge;
@@ -1994,18 +2112,18 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           face3d_add_contour (top_group_face,    make_contour3d (drill_top_face_first_edge));
           face3d_add_contour (bottom_group_face, make_contour3d (drill_bottom_face_first_edge));
 
-          if (1)
-            {
-              edge_info *info;
-
-              info = UNDIR_DATA (drill_top_face_first_edge);
-              if (info->is_round)
-                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
-
-              info = UNDIR_DATA (drill_bottom_face_first_edge);
-              if (info->is_round)
-                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
-            }
+//          if (1)
+//            {
+//              edge_info *info;
+//
+//              info = UNDIR_DATA (drill_top_face_first_edge);
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+//
+//              info = UNDIR_DATA (drill_bottom_face_first_edge);
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+//            }
 
           /* XXX: Need to flip the edge wall orientations too - particularly considering cylindrical edges */
 
@@ -2040,6 +2158,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 
           /* Steal the data from the drill object */
           steal_object_geometry (top_group_object, drill_object);
+          destroy_object3d (drill_object);
 
           free (pa->user_data);
         }
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 2768a71..7d444cb 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -15,7 +15,7 @@ void object3d_set_appearance (object3d *object, appearance *appear);
 void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
-GList *object3d_from_contours (POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance);
+GList *object3d_from_contours (POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance, bool sides_inverted, bool top_bot_inverted);
 GList *object3d_from_board_outline (void);
 GList *object3d_from_soldermask_within_area (POLYAREA *area, int side);
 GList *object3d_from_copper_layers_within_area (POLYAREA *area);
