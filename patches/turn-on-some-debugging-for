Bottom: 5ccaeec40d1b1768e96c148d3975327122ae1a26
Top:    5e49a6445de7ae0449665b73f67a67fab6df14cc
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-14 00:50:26 +0000

Turn on some debugging for intersections..

Have seen some use-after free corruption in a few places, and this was
aimed at testing whether or not the culprit was performing multiple
intersections on the same segment. (When we perform the deferred work
to split that segment, any later intersections will not point at the
correct seg structure - which has been free'd during the first splitting.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index f4dc990..fd269e9 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -39,6 +39,7 @@
       are marked
 */
 
+#undef NDEBUG
 #include	<assert.h>
 #include	<stdlib.h>
 #include	<stdio.h>
@@ -938,6 +939,7 @@ insert_vertex_in_seg (struct info *i, struct seg *s, Vector v, double param)
   DEBUGP ("new intersection on segment \"i\" at %#mD\n", v[0], v[1]);
 #endif
   i->node_insert_list = prepend_insert_node_task (i->node_insert_list, s, new_node, param);
+  assert (!s->intersected);
   s->intersected = 1;
   return true;
 }
@@ -1292,6 +1294,8 @@ seg_in_seg_arc_arc (struct info *i, struct seg *s1, struct seg *s2)
       s1->v->radius == s2->v->radius)
     {
       printf ("Cop-out for co-circular arcs for now - they will be better handled by their line approximations. <<<<<<<<<<\n");
+      s1->v->is_round = false;
+      s2->v->is_round = false;
       return seg_in_seg_line_line (i, s1, s2);
     }
 #endif
