Bottom: 8fda9c038ada8092f8d85dfcd9b343c0da982d42
Top:    8da51b54c9aa4fb8cc5f06235f673925ea40cab0
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 15:56:03 +0000

Well on the way to completely messing up the STEP code, just by flipping the Y coord!


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index c516e04..2f9f22d 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -15,6 +15,28 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -131,12 +153,12 @@ draw_quad_edge (edge_ref e, void *data)
           for (i = 0; i < CIRC_SEGS; i++)
             {
               /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
             }
           glEnd ();
           return;
@@ -144,8 +166,12 @@ draw_quad_edge (edge_ref e, void *data)
     }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -177,7 +203,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -189,8 +215,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -201,8 +227,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
       n--;
     }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
 GList *
@@ -277,9 +303,10 @@ object3d_from_board_outline (void)
               ct_npoints = get_contour_npoints (ct);
             }
 
-          get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+          get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+
+          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
           object3d_add_vertex (object, vertices[i]);
           object3d_add_vertex (object, vertices[npoints + i]);
@@ -300,7 +327,11 @@ object3d_from_board_outline (void)
 
           object3d_add_face (object, faces[i]);
           /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+          face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
           face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
         }
 
       faces[npoints] = make_face3d (); /* bottom_face */
@@ -314,8 +345,13 @@ object3d_from_board_outline (void)
       object3d_add_face (object, faces[npoints + 1]);
 
       /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
       face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
       face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
 
       ct = contour;
       start_of_ct = 0;
@@ -336,8 +372,13 @@ object3d_from_board_outline (void)
               ct_npoints = get_contour_npoints (ct);
 
               /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+              face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+              face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
               face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
               face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
             }
 
           next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -345,8 +386,14 @@ object3d_from_board_outline (void)
 
           /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
           /* Define the (non-normalized) face normal to point to the outside of the contour */
-          face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                      -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#if REVERSED_PCB_CONTOURS
+          /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+          face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                        (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+          face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                       -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
           /* Assign the appropriate vertex geometric data to each edge end */
           ODATA (edges[              i]) = vertices[i];
@@ -355,12 +402,21 @@ object3d_from_board_outline (void)
           DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
           ODATA (edges[2 * npoints + i]) = vertices[i];
           DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+          RDATA (edges[              i]) = faces[i];
+          LDATA (edges[              i]) = faces[npoints];
+          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          LDATA (edges[1 * npoints + i]) = faces[i];
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
+#else
           LDATA (edges[              i]) = faces[i];
           RDATA (edges[              i]) = faces[npoints];
           LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
           RDATA (edges[1 * npoints + i]) = faces[i];
           LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
           RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
           /* NB: Contours are counter clockwise in XY plane.
            *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
@@ -368,30 +424,49 @@ object3d_from_board_outline (void)
            *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
            */
 
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[i]);
+
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
           /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
           splice (edges[i], edges[2 * npoints + i]);
           splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
           /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
 
           if (ct->is_round)
             {
               face3d_set_cylindrical (faces[i],
-                                      COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                      0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                      COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                      0., 0., 1.,                                                       /* Direction of the cylindrical axis */
                                       COORD_TO_MM (ct->radius));
               face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
               face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                         /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
+#ifdef REVERSED_PCB_CONTOURS
+              edge_info_set_round (UNDIR_DATA (edges[i]),
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                                   0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                                   0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
               edge_info_set_round (UNDIR_DATA (edges[i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
                                    0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
               edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
                                    0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
               edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
             }
 
@@ -408,18 +483,25 @@ object3d_from_board_outline (void)
           /* Edge on top of board */
           cylinder_edges[0] = make_edge ();
           UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
           edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               45., 45., 0., /* Center of circle */
-                                0.,  0., 1., /* Normal */
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);          /* Radius */
+#else
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
                                 5.);         /* Radius */
+#endif
           object3d_add_edge (object, cylinder_edges[0]);
 
           /* Edge on top of cylinder */
           cylinder_edges[1] = make_edge ();
           UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
           edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                               45., 45., 10., /* Center of circle */
-                                0.,  0., 1.,  /* Normal */
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                                0.,   0., 1.,  /* Normal */
                                 5.);          /* Radius */
           object3d_add_edge (object, cylinder_edges[1]);
 
@@ -430,17 +512,17 @@ object3d_from_board_outline (void)
           object3d_add_edge (object, cylinder_edges[2]);
 
           /* Vertex on board top surface */
-          cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
           object3d_add_vertex (object, cylinder_vertices[0]);
 
           /* Vertex on cylinder top surface */
-          cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
           object3d_add_vertex (object, cylinder_vertices[1]);
 
           /* Cylindrical face */
           cylinder_faces[0] = make_face3d ();
-          face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,            /* Direction of the cylindrical axis */
+          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,             /* Direction of the cylindrical axis */
                                             5.);                   /* Radius of cylinder */
           face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
                                        /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 866121a..3d20de9 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -20,6 +20,20 @@
 #include "object3d_step.h"
 
 
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#endif
+
+
 static step_id_list
 presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
 {
@@ -144,6 +158,20 @@ object3d_export_to_step (object3d *object, const char *filename)
           vertex3d *ov = ODATA (outer_contour->first_edge);
           vertex3d *dv = DDATA (outer_contour->first_edge);
 
+          double rx, ry, rz;
+
+          rx = dv->x - ov->x;
+          ry = dv->y - ov->y;
+          rz = dv->z - ov->z;
+
+          /* Catch the circular face case where the start and end vertices are identical */
+          if (rx < EPSILON && -rx < EPSILON &&
+              ry < EPSILON && -ry < EPSILON &&
+              rz < EPSILON && -rz < EPSILON)
+            {
+              rx = 1., ry = 0., rz = 0.;
+            }
+
           face->surface_identifier =
             step_plane (step, "NONE",
                         step_axis2_placement_3d (step, "NONE",
@@ -151,9 +179,9 @@ object3d_export_to_step (object3d *object, const char *filename)
                                                                                      ov->y,      /* Set this to the origin vertex of the first edge */
                                                                                      ov->z),     /* this contour links to in the quad edge structure. */
                                                        step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                       step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                     dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                     dv->z - ov->z)));      /* contour links to in the quad edge structure */
+                                                       step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                     ry,         /* Define this to be along the first edge this */
+                                                                                     rz)));      /* contour links to in the quad edge structure */
         }
     }
 
@@ -178,14 +206,31 @@ object3d_export_to_step (object3d *object, const char *filename)
           vertex3d *ov = ODATA (edge);
           vertex3d *dv = DDATA (edge);
 
+          double dir_x, dir_y, dir_z;
+
+          dir_x = dv->x - ov->x;
+          dir_y = dv->y - ov->y;
+          dir_z = dv->z - ov->z;
+
+#if 1
+          /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+          if (dir_x < EPSILON && -dir_x < EPSILON &&
+              dir_y < EPSILON && -dir_y < EPSILON &&
+              dir_z < EPSILON && -dir_z < EPSILON)
+            {
+              printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+              pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+              dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+            }
+#endif
+
           info->infinite_line_identifier =
             step_line (step, "NONE",
                        step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
                        step_vector (step, "NONE",
-                                    step_direction (step, "NONE", dv->x - ov->x,
-                                                                  dv->y - ov->y,
-                                                                  dv->z - ov->z),  // <--- Direction along the line
+                                    step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
                                     1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
         }
     }
