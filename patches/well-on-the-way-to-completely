Bottom: 722a48430a4d1db811fa307158797393fdb49c2c
Top:    979adf0e0133ec7162c04c19e7b54b6ebf042652
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:26:00 +0000

Well on the way to completely messing up the STEP code, just by flipping the Y coord!


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 9271c79..bcf5d47 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -16,6 +16,28 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -93,7 +115,7 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -132,12 +154,12 @@ draw_quad_edge (edge_ref e, void *data)
           for (i = 0; i < CIRC_SEGS; i++)
             {
               /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
             }
           glEnd ();
           return;
@@ -145,8 +167,12 @@ draw_quad_edge (edge_ref e, void *data)
     }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -178,7 +204,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -190,8 +216,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -202,8 +228,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
       n--;
     }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
 GList *
@@ -234,255 +260,303 @@ object3d_from_board_outline (void)
 
   /* Loop over all board outline pieces */
   pa = board_outline;
-  do
-    {
-
-      contour = pa->contours;
-      ncontours = 0;
-      npoints = 0;
-
-      ct = contour;
-      while (ct != NULL)
-        {
-          ncontours ++;
-          npoints += get_contour_npoints (ct);
-          ct = ct->next;
-        }
-
-      object = make_object3d (PCB->Name);
-      board_appearance = make_appearance ();
-      top_bot_appearance = make_appearance ();
-      appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-      appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-      object3d_set_appearance (object, board_appearance);
-
-      vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
-      edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
-      faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
+  do {
+
+    contour = pa->contours;
+    ncontours = 0;
+    npoints = 0;
+
+    ct = contour;
+    while (ct != NULL)
+      {
+        ncontours ++;
+        npoints += get_contour_npoints (ct);
+        ct = ct->next;
+      }
+
+    object = make_object3d (PCB->Name);
+    board_appearance = make_appearance ();
+    top_bot_appearance = make_appearance ();
+    appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+    appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+
+    object3d_set_appearance (object, board_appearance);
+
+    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
+    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
+    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
+
+    /* Define the vertices */
+    ct = contour;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++)
+      {
+        double x1, y1;
+
+        /* Update which contour we're looking at */
+        if (offset_in_ct == ct_npoints)
+          {
+            offset_in_ct = 0;
+            ct = ct->next;
+            ct_npoints = get_contour_npoints (ct);
+          }
+
+        get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+        vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+        vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
+
+        object3d_add_vertex (object, vertices[i]);
+        object3d_add_vertex (object, vertices[npoints + i]);
+      }
+
+    /* Define the edges */
+    for (i = 0; i < 3 * npoints; i++)
+      {
+        edges[i] = make_edge ();
+        UNDIR_DATA (edges[i]) = make_edge_info ();
+        object3d_add_edge (object, edges[i]);
+      }
+
+    /* Define the faces */
+    for (i = 0; i < npoints; i++)
+      {
+        faces[i] = make_face3d ();
+
+        object3d_add_face (object, faces[i]);
+        /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
+        face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
+      }
+
+    faces[npoints] = make_face3d (); /* bottom_face */
+    face3d_set_normal (faces[npoints], 0., 0., -1.);
+    face3d_set_appearance (faces[npoints], top_bot_appearance);
+    object3d_add_face (object, faces[npoints]);
+
+    faces[npoints + 1] = make_face3d (); /* top_face */
+    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints + 1]);
+
+    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
+    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
 
-      /* Define the vertices */
-      ct = contour;
-      offset_in_ct = 0;
-      ct_npoints = get_contour_npoints (ct);
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
+      }
 
-      for (i = 0; i < npoints; i++, offset_in_ct++)
-        {
-          double x1, y1;
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-          /* Update which contour we're looking at */
-          if (offset_in_ct == ct_npoints)
-            {
-              offset_in_ct = 0;
-              ct = ct->next;
-              ct_npoints = get_contour_npoints (ct);
-            }
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+#if REVERSED_PCB_CONTOURS
+      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
-          get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#else
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
-          object3d_add_vertex (object, vertices[i]);
-          object3d_add_vertex (object, vertices[npoints + i]);
-        }
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
 
-      /* Define the edges */
-      for (i = 0; i < 3 * npoints; i++)
-        {
-          edges[i] = make_edge ();
-          UNDIR_DATA (edges[i]) = make_edge_info ();
-          object3d_add_edge (object, edges[i]);
-        }
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
 
-      /* Define the faces */
-      for (i = 0; i < npoints; i++)
+      if (ct->is_round)
         {
-          faces[i] = make_face3d ();
-
-          object3d_add_face (object, faces[i]);
-          /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-          face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+          face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,                                                       /* Direction of the cylindrical axis */
+                                            COORD_TO_MM (ct->radius));
+          face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+#ifdef REVERSED_PCB_CONTOURS
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
         }
 
-      faces[npoints] = make_face3d (); /* bottom_face */
-      face3d_set_normal (faces[npoints], 0., 0., -1.);
-      face3d_set_appearance (faces[npoints], top_bot_appearance);
-      object3d_add_face (object, faces[npoints]);
-
-      faces[npoints + 1] = make_face3d (); /* top_face */
-      face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-      face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-      object3d_add_face (object, faces[npoints + 1]);
-
-      /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-      ct = contour;
-      start_of_ct = 0;
-      offset_in_ct = 0;
-      ct_npoints = get_contour_npoints (ct);
-
-      for (i = 0; i < npoints; i++, offset_in_ct++)
-        {
-          int next_i_around_ct;
-          int prev_i_around_ct;
-
-          /* Update which contour we're looking at */
-          if (offset_in_ct == ct_npoints)
-            {
-              start_of_ct = i;
-              offset_in_ct = 0;
-              ct = ct->next;
-              ct_npoints = get_contour_npoints (ct);
-
-              /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-              face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-              face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-            }
-
-          next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-          prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-          /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-          /* Define the (non-normalized) face normal to point to the outside of the contour */
-          face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                      -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-          /* Assign the appropriate vertex geometric data to each edge end */
-          ODATA (edges[              i]) = vertices[0 * npoints + i];
-          DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-          ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-          DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-          ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-          DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-          LDATA (edges[              i]) = faces[i];
-          RDATA (edges[              i]) = faces[npoints];
-          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          RDATA (edges[1 * npoints + i]) = faces[i];
-          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          RDATA (edges[2 * npoints + i]) = faces[i];
-
-          /* NB: Contours are counter clockwise in XY plane.
-           *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-           *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-           *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-           */
-
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (edges[i], edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-          if (ct->is_round)
-            {
-
-              face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                                0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                                COORD_TO_MM (ct->radius));
-              face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
-              face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                        /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-
-              edge_info_set_round (UNDIR_DATA (edges[i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                                   0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                                   0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-              edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-            }
-
-        }
+    }
 
-      if (1)
-        {
-          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
-
-          edge_ref cylinder_edges[3];
-          vertex3d *cylinder_vertices[2];
-          face3d *cylinder_faces[2];
-
-          /* Edge on top of board */
-          cylinder_edges[0] = make_edge ();
-          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               45., 45., 0., /* Center of circle */
-                                0.,  0., 1., /* Normal */
-                                5.);         /* Radius */
-          object3d_add_edge (object, cylinder_edges[0]);
-
-          /* Edge on top of cylinder */
-          cylinder_edges[1] = make_edge ();
-          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                               45., 45., 10., /* Center of circle */
-                                0.,  0., 1.,  /* Normal */
-                                5.);          /* Radius */
-          object3d_add_edge (object, cylinder_edges[1]);
-
-          /* Edge stitching cylinder */
-          cylinder_edges[2] = make_edge ();
-          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-          object3d_add_edge (object, cylinder_edges[2]);
-
-          /* Vertex on board top surface */
-          cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
-          object3d_add_vertex (object, cylinder_vertices[0]);
-
-          /* Vertex on cylinder top surface */
-          cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
-          object3d_add_vertex (object, cylinder_vertices[1]);
-
-          /* Cylindrical face */
-          cylinder_faces[0] = make_face3d ();
-          face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,            /* Direction of the cylindrical axis */
-                                            5.);                   /* Radius of cylinder */
-          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-          object3d_add_face (object, cylinder_faces[0]);
-          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-          /* Top face of cylinder */
-          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-          object3d_add_face (object, cylinder_faces[1]);
-          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-          /* Splice onto board */
-          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-          /* Assign the appropriate vertex geometric data to each edge end */
-          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-          LDATA (cylinder_edges[0]) = cylinder_faces[0];
-          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-          LDATA (cylinder_edges[1]) = cylinder_faces[1];
-          RDATA (cylinder_edges[1]) = cylinder_faces[0];
-          LDATA (cylinder_edges[2]) = cylinder_faces[0];
-          RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-          /* Splice things together.... */
-
-          /* Link edges orbiting the cylinder bottom vertex */
-          splice (cylinder_edges[0], cylinder_edges[2]);
-          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-          /* Link edges orbiting the cylinder top vertex */
-          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-        }
+    if (1) {
+      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+      edge_ref cylinder_edges[3];
+      vertex3d *cylinder_vertices[2];
+      face3d *cylinder_faces[2];
+
+      /* Edge on top of board */
+      cylinder_edges[0] = make_edge ();
+      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
+#else
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);         /* Radius */
+#endif
+      object3d_add_edge (board_object, cylinder_edges[0]);
+
+      /* Edge on top of cylinder */
+      cylinder_edges[1] = make_edge ();
+      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
+                            5.);          /* Radius */
+      object3d_add_edge (board_object, cylinder_edges[1]);
+
+      /* Edge stitching cylinder */
+      cylinder_edges[2] = make_edge ();
+      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+      object3d_add_edge (board_object, cylinder_edges[2]);
+
+      /* Vertex on board top surface */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+      object3d_add_vertex (board_object, cylinder_vertices[0]);
+
+      /* Vertex on cylinder top surface */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+      object3d_add_vertex (board_object, cylinder_vertices[1]);
+
+      /* Cylindrical face */
+      cylinder_faces[0] = make_face3d ();
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
+                                        5.);                   /* Radius of cylinder */
+      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+      object3d_add_face (board_object, cylinder_faces[0]);
+      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+      /* Top face of cylinder */
+      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+      object3d_add_face (board_object, cylinder_faces[1]);
+      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+      /* Splice onto board */
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+      LDATA (cylinder_edges[0]) = cylinder_faces[0];
+      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+      LDATA (cylinder_edges[1]) = cylinder_faces[1];
+      RDATA (cylinder_edges[1]) = cylinder_faces[0];
+      LDATA (cylinder_edges[2]) = cylinder_faces[0];
+      RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+      /* Splice things together.... */
+
+      /* Link edges orbiting the cylinder bottom vertex */
+      splice (cylinder_edges[0], cylinder_edges[2]);
+      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+      /* Link edges orbiting the cylinder top vertex */
+      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+    }
 
       objects = g_list_append (objects, object);
 
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 573a12c..a2df888 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -23,6 +23,20 @@
 #include "object3d_step.h"
 
 
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#endif
+
+
 static step_id_list
 presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
 {
@@ -143,6 +157,19 @@ object3d_export_to_step (object3d *object, const char *filename)
       vertex3d *ov = ODATA (outer_contour->first_edge);
       vertex3d *dv = DDATA (outer_contour->first_edge);
 
+      double rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
       face->surface_identifier =
         step_plane (step, "NONE",
                     step_axis2_placement_3d (step, "NONE",
@@ -150,9 +177,9 @@ object3d_export_to_step (object3d *object, const char *filename)
                                                                                  ov->y,      /* Set this to the origin vertex of the first edge */
                                                                                  ov->z),     /* this contour links to in the quad edge structure. */
                                                    step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                   step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                 dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                 dv->z - ov->z)));      /* contour links to in the quad edge structure */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
     }
   }
 
@@ -173,14 +200,30 @@ object3d_export_to_step (object3d *object, const char *filename)
       vertex3d *ov = ODATA (edge);
       vertex3d *dv = DDATA (edge);
 
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
       info->infinite_line_identifier =
         step_line (step, "NONE",
                    step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
                    step_vector (step, "NONE",
-                                step_direction (step, "NONE", dv->x - ov->x,
-                                                              dv->y - ov->y,
-                                                              dv->z - ov->z),  // <--- Direction along the line
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
                                 1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
     }
   }
 
@@ -242,14 +285,13 @@ object3d_export_to_step (object3d *object, const char *filename)
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
 
+#if 1
   /* Body style */
-  if (1) {
-    /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
-    brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
-    step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-    styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
-  }
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
   /* Face styles */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
@@ -265,6 +307,7 @@ object3d_export_to_step (object3d *object, const char *filename)
 
   /* Emit references to the styled and over_ridden styled items */
   step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
 
   shape_representation_identifier =
     step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 79c492f..9c5b301 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -147,7 +147,7 @@ step_vertex_point (step_file *file, char *name, step_id pnt)
 step_id
 step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense)
 {
-  fprintf (file->f, "#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ;\n",
+  fprintf (file->f, "\n#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ; ",
                     file->next_id, name, edge_start, edge_end, edge_geometry, step_bool (same_sense));
   return file->next_id++;
 }
@@ -155,7 +155,7 @@ step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_e
 step_id
 step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation)
 {
-  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ; ",
                     file->next_id, name, edge_element, step_bool (orientation));
   return file->next_id++;
 }
@@ -174,7 +174,7 @@ step_edge_loop (step_file *file, char *name, step_id_list edge_list)
 step_id
 step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
 {
-  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ; ",
                     file->next_id, name, bound, step_bool (orientation));
 
   return file->next_id++;
@@ -194,7 +194,7 @@ step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id fa
 {
   fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, bounds);
-  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
   destroy_step_id_list (bounds);
 
   return file->next_id++;
