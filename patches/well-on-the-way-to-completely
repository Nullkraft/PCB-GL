Bottom: a6ec2587f3cb2c6fc4b92388c8f9f1b8ed51a9df
Top:    1e763784adb58abb432b2f5a2e644d00b2731893
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:26:00 +0000

Well on the way to completely messing up the STEP code, just by flipping the Y coord!


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 9271c79..6e2bf29 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -16,6 +16,28 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -93,7 +115,7 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -132,12 +154,12 @@ draw_quad_edge (edge_ref e, void *data)
           for (i = 0; i < CIRC_SEGS; i++)
             {
               /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
-              glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                          STEP_Z_TO_COORD (PCB, info->cz));
             }
           glEnd ();
           return;
@@ -145,8 +167,12 @@ draw_quad_edge (edge_ref e, void *data)
     }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -178,7 +204,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -190,8 +216,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -202,8 +228,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
       n--;
     }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
 GList *
@@ -278,9 +304,9 @@ object3d_from_board_outline (void)
               ct_npoints = get_contour_npoints (ct);
             }
 
-          get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+          get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
           object3d_add_vertex (object, vertices[i]);
           object3d_add_vertex (object, vertices[npoints + i]);
@@ -301,7 +327,11 @@ object3d_from_board_outline (void)
 
           object3d_add_face (object, faces[i]);
           /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+          face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
           face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
         }
 
       faces[npoints] = make_face3d (); /* bottom_face */
@@ -315,8 +345,13 @@ object3d_from_board_outline (void)
       object3d_add_face (object, faces[npoints + 1]);
 
       /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
       face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
       face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
 
       ct = contour;
       start_of_ct = 0;
@@ -337,8 +372,13 @@ object3d_from_board_outline (void)
               ct_npoints = get_contour_npoints (ct);
 
               /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+              face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+              face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
               face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
               face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
             }
 
           next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -346,8 +386,14 @@ object3d_from_board_outline (void)
 
           /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
           /* Define the (non-normalized) face normal to point to the outside of the contour */
-          face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                      -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#if REVERSED_PCB_CONTOURS
+          /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+          face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                        (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+          face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                       -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
           /* Assign the appropriate vertex geometric data to each edge end */
           ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -356,12 +402,21 @@ object3d_from_board_outline (void)
           DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
           ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
           DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+          RDATA (edges[              i]) = faces[i];
+          LDATA (edges[              i]) = faces[npoints];
+          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          LDATA (edges[1 * npoints + i]) = faces[i];
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
+#else
           LDATA (edges[              i]) = faces[i];
           RDATA (edges[              i]) = faces[npoints];
           LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
           RDATA (edges[1 * npoints + i]) = faces[i];
           LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
           RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
           /* NB: Contours are counter clockwise in XY plane.
            *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
@@ -369,31 +424,48 @@ object3d_from_board_outline (void)
            *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
            */
 
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[i]);
+
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
           /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
           splice (edges[i], edges[2 * npoints + i]);
           splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
           /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
 
           if (ct->is_round)
             {
-
-              face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                                0., 0., 1.,                                     /* Direction of the cylindrical axis */
+              face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                                0., 0., 1.,                                                       /* Direction of the cylindrical axis */
                                                 COORD_TO_MM (ct->radius));
               face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
               face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                         /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
-
+#ifdef REVERSED_PCB_CONTOURS
+              edge_info_set_round (UNDIR_DATA (edges[i]),
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                                   0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                                   0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
               edge_info_set_round (UNDIR_DATA (edges[i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
                                    0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
               edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                                   COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
                                    0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
               edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
             }
 
@@ -410,18 +482,25 @@ object3d_from_board_outline (void)
           /* Edge on top of board */
           cylinder_edges[0] = make_edge ();
           UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
           edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               45., 45., 0., /* Center of circle */
-                                0.,  0., 1., /* Normal */
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);          /* Radius */
+#else
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
                                 5.);         /* Radius */
+#endif
           object3d_add_edge (object, cylinder_edges[0]);
 
           /* Edge on top of cylinder */
           cylinder_edges[1] = make_edge ();
           UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
           edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                               45., 45., 10., /* Center of circle */
-                                0.,  0., 1.,  /* Normal */
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                                0.,   0., 1.,  /* Normal */
                                 5.);          /* Radius */
           object3d_add_edge (object, cylinder_edges[1]);
 
@@ -432,17 +511,17 @@ object3d_from_board_outline (void)
           object3d_add_edge (object, cylinder_edges[2]);
 
           /* Vertex on board top surface */
-          cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
           object3d_add_vertex (object, cylinder_vertices[0]);
 
           /* Vertex on cylinder top surface */
-          cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
           object3d_add_vertex (object, cylinder_vertices[1]);
 
           /* Cylindrical face */
           cylinder_faces[0] = make_face3d ();
-          face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,            /* Direction of the cylindrical axis */
+          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,             /* Direction of the cylindrical axis */
                                             5.);                   /* Radius of cylinder */
           face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
                                        /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 1687042..c3dafff 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -23,6 +23,20 @@
 #include "object3d_step.h"
 
 
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#endif
+
+
 static step_id_list
 presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
 {
@@ -124,72 +138,91 @@ object3d_export_to_step (object3d *object, const char *filename)
 #define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
 
   /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
-    {
-      face3d *face = face_iter->data;
-
-      if (face->is_cylindrical)
-        {
-          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
-           * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
-           */
-          face->surface_identifier =
-            step_cylindrical_surface (step, "NONE",
-                                      step_axis2_placement_3d (step, "NONE",
-                                                               step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
-                                                                     step_direction (step, "NONE", face->ax, face->ay, face->az),
-                                                                     step_direction (step, "NONE", face->nx, face->ny, face->nz)),
-                                      face->radius);
-        }
-      else
-        {
-          contour3d *outer_contour = face->contours->data;
-          vertex3d *ov = ODATA (outer_contour->first_edge);
-          vertex3d *dv = DDATA (outer_contour->first_edge);
-
-          face->surface_identifier =
-            step_plane (step, "NONE",
-                        step_axis2_placement_3d (step, "NONE",
-                                                 step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
-                                                                                     ov->y,      /* Set this to the origin vertex of the first edge */
-                                                                                     ov->z),     /* this contour links to in the quad edge structure. */
-                                                       step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                       step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                     dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                     dv->z - ov->z)));      /* contour links to in the quad edge structure */
-        }
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+
+    if (face->is_cylindrical) {
+      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+       */
+      face->surface_identifier =
+        step_cylindrical_surface (step, "NONE",
+                                  step_axis2_placement_3d (step, "NONE",
+                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                  face->radius);
+    } else {
+      contour3d *outer_contour = face->contours->data;
+      vertex3d *ov = ODATA (outer_contour->first_edge);
+      vertex3d *dv = DDATA (outer_contour->first_edge);
+
+      double rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
+      face->surface_identifier =
+        step_plane (step, "NONE",
+                    step_axis2_placement_3d (step, "NONE",
+                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
+                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
+                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
     }
 
   /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
-    {
-      edge_ref edge = (edge_ref)edge_iter->data;
-      edge_info *info = UNDIR_DATA (edge);
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+
+    if (info->is_round) {
+      info->infinite_line_identifier =
+        step_circle (step, "NONE",
+                     step_axis2_placement_3d (step, "NONE",
+                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                    info->radius);
+    } else {
+      vertex3d *ov = ODATA (edge);
+      vertex3d *dv = DDATA (edge);
+
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
+      info->infinite_line_identifier =
+        step_line (step, "NONE",
+                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                   step_vector (step, "NONE",
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
+                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
 
-      if (info->is_round)
-        {
-          info->infinite_line_identifier =
-            step_circle (step, "NONE",
-                         step_axis2_placement_3d (step, "NONE",
-                                                  step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
-                                                        step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
-                                                        step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
-                                                        info->radius);
-        }
-      else
-        {
-          vertex3d *ov = ODATA (edge);
-          vertex3d *dv = DDATA (edge);
-
-          info->infinite_line_identifier =
-            step_line (step, "NONE",
-                       step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
-                       step_vector (step, "NONE",
-                                    step_direction (step, "NONE", dv->x - ov->x,
-                                                                  dv->y - ov->y,
-                                                                  dv->z - ov->z),  // <--- Direction along the line
-                                    1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
-        }
     }
 
   /* Define the vertices */
@@ -256,15 +289,13 @@ object3d_export_to_step (object3d *object, const char *filename)
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
 
+#if 1
   /* Body style */
-  if (1)
-    {
-      /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
-      brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
-      step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
-    }
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
   /* Face styles */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
@@ -282,6 +313,7 @@ object3d_export_to_step (object3d *object, const char *filename)
 
   /* Emit references to the styled and over_ridden styled items */
   step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
 
   shape_representation_identifier =
     step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 54f7210..ca7fa92 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -149,7 +149,7 @@ step_vertex_point (step_file *file, char *name, step_id pnt)
 step_id
 step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense)
 {
-  fprintf (file->f, "#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ;\n",
+  fprintf (file->f, "\n#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ; ",
                     file->next_id, name, edge_start, edge_end, edge_geometry, step_bool (same_sense));
   return file->next_id++;
 }
@@ -157,7 +157,7 @@ step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_e
 step_id
 step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation)
 {
-  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ; ",
                     file->next_id, name, edge_element, step_bool (orientation));
   return file->next_id++;
 }
@@ -176,7 +176,7 @@ step_edge_loop (step_file *file, char *name, step_id_list edge_list)
 step_id
 step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
 {
-  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ; ",
                     file->next_id, name, bound, step_bool (orientation));
 
   return file->next_id++;
@@ -196,7 +196,7 @@ step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id fa
 {
   fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, bounds);
-  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
   destroy_step_id_list (bounds);
 
   return file->next_id++;
