Bottom: fc5beae6ce707ddd4309d55f3a60bb459cc61785
Top:    9beb36702bf1115e9a680bafb92b4a4f62785f91
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:26:00 +0000

Well on the way to completely messing up the STEP code, just by flipping the Y coord!


---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index c67fa95..23e335e 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -17,7 +17,7 @@ make_edge_info (void)
 }
 
 void
-edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius)
+edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius)
 {
   info->is_round = true;
   info->cx = cx;
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 696ace3..38fd6c1 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -5,13 +5,13 @@ typedef struct
 
   /* For circular curves */
   bool is_round;
-  float cx;
-  float cy;
-  float cz;
-  float nx;
-  float ny;
-  float nz;
-  float radius;
+  double cx;
+  double cy;
+  double cz;
+  double nx;
+  double ny;
+  double nz;
+  double radius;
 
   /* STEP crap - to hell with encapsulation */
   step_id infinite_line_identifier;
@@ -19,6 +19,6 @@ typedef struct
 } edge_info;
 
 edge_info *make_edge_info (void);
-void edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius);
+void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index 0f9f327..13d7501 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -38,7 +38,7 @@ face3d_set_appearance (face3d *face, appearance *appear)
 }
 
 void
-face3d_set_normal (face3d *face, float nx, float ny, float nz)
+face3d_set_normal (face3d *face, double nx, double ny, double nz)
 {
   face->nx = nx;
   face->ny = ny;
@@ -46,7 +46,7 @@ face3d_set_normal (face3d *face, float nx, float ny, float nz)
 }
 
 void
-face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius)
+face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius)
 {
   face->is_cylindrical = true;
   face->cx = cx;
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 44f6e88..0998a22 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,12 +1,12 @@
 typedef struct {
-  float nx, ny, nz; /* Face normal?*/
+  double nx, ny, nz; /* Face normal?*/
   GList *contours;
 
   /* For cylindrical surfaces */
   bool is_cylindrical;
-  float cx, cy, cz; /* A point on the axis */
-  float ax, ay, az; /* Direction of the axis */
-  float radius;
+  double cx, cy, cz; /* A point on the axis */
+  double ax, ay, az; /* Direction of the axis */
+  double radius;
 
   appearance *appear;
 
@@ -21,6 +21,6 @@ face3d *make_face3d (void);
 void destroy_face3d (face3d *face);
 void face3d_add_contour (face3d *face, contour3d *contour);
 void face3d_set_appearance (face3d *face, appearance *appear);
-void face3d_set_normal (face3d *face, float nx, float ny, float nz);
-void face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius);
+void face3d_set_normal (face3d *face, double nx, double ny, double nz);
+void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
 void face3d_set_surface_orientation_reversed (face3d *face);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 150b09a..84a4b26 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -16,6 +16,28 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -93,7 +115,7 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -129,12 +151,12 @@ draw_quad_edge (edge_ref e, void *data)
       glBegin (GL_LINES);
       for (i = 0; i < CIRC_SEGS; i++) {
         /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
       }
       glEnd ();
       return;
@@ -142,8 +164,12 @@ draw_quad_edge (edge_ref e, void *data)
   }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -175,7 +201,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -187,8 +213,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -198,8 +224,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
     n--;
   }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
 GList *
@@ -270,9 +296,9 @@ object3d_from_board_outline (void)
         ct_npoints = get_contour_npoints (ct);
       }
 
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
       object3d_add_vertex (board_object, vertices[i]);
       object3d_add_vertex (board_object, vertices[npoints + i]);
@@ -291,7 +317,11 @@ object3d_from_board_outline (void)
 
       object3d_add_face (board_object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
       face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
     }
 
     faces[npoints] = make_face3d (); /* bottom_face */
@@ -305,8 +335,13 @@ object3d_from_board_outline (void)
     object3d_add_face (board_object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
     face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
     face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
 
     ct = contour;
     start_of_ct = 0;
@@ -325,8 +360,13 @@ object3d_from_board_outline (void)
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
         face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
         face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
       }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -334,8 +374,14 @@ object3d_from_board_outline (void)
 
       /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
       /* Define the (non-normalized) face normal to point to the outside of the contour */
-      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#if REVERSED_PCB_CONTOURS
+      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
       /* Assign the appropriate vertex geometric data to each edge end */
       ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -344,12 +390,21 @@ object3d_from_board_outline (void)
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#else
       LDATA (edges[              i]) = faces[i];
       RDATA (edges[              i]) = faces[npoints];
       LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
       RDATA (edges[1 * npoints + i]) = faces[i];
       LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
       RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
       /* NB: Contours are counter clockwise in XY plane.
        *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
@@ -357,30 +412,48 @@ object3d_from_board_outline (void)
        *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
        */
 
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
       /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
       splice (edges[i], edges[2 * npoints + i]);
       splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
       /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
 
       if (ct->is_round) {
 
-        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
+        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
                                           COORD_TO_MM (ct->radius));
         face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
-
+#ifdef REVERSED_PCB_CONTOURS
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
         edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
                              0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
         edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
                              0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
         edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
       }
 
@@ -396,18 +469,25 @@ object3d_from_board_outline (void)
       /* Edge on top of board */
       cylinder_edges[0] = make_edge ();
       UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
       edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                           45., 45., 0., /* Center of circle */
-                            0.,  0., 1., /* Normal */
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
+#else
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
                             5.);         /* Radius */
+#endif
       object3d_add_edge (board_object, cylinder_edges[0]);
 
       /* Edge on top of cylinder */
       cylinder_edges[1] = make_edge ();
       UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
       edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                           45., 45., 10., /* Center of circle */
-                            0.,  0., 1.,  /* Normal */
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
                             5.);          /* Radius */
       object3d_add_edge (board_object, cylinder_edges[1]);
 
@@ -418,17 +498,17 @@ object3d_from_board_outline (void)
       object3d_add_edge (board_object, cylinder_edges[2]);
 
       /* Vertex on board top surface */
-      cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
       object3d_add_vertex (board_object, cylinder_vertices[0]);
 
       /* Vertex on cylinder top surface */
-      cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
       object3d_add_vertex (board_object, cylinder_vertices[1]);
 
       /* Cylindrical face */
       cylinder_faces[0] = make_face3d ();
-      face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,            /* Direction of the cylindrical axis */
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
                                         5.);                   /* Radius of cylinder */
       face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
diff --git a/src/hid/common/vertex3d.c b/src/hid/common/vertex3d.c
index ff3ab98..cf20fb2 100644
--- a/src/hid/common/vertex3d.c
+++ b/src/hid/common/vertex3d.c
@@ -9,7 +9,7 @@
 static int global_vertex3d_count;
 
 vertex3d *
-make_vertex3d (float x, float y, float z)
+make_vertex3d (double x, double y, double z)
 {
   vertex3d *v;
 
diff --git a/src/hid/common/vertex3d.h b/src/hid/common/vertex3d.h
index a150934..cad586d 100644
--- a/src/hid/common/vertex3d.h
+++ b/src/hid/common/vertex3d.h
@@ -1,13 +1,13 @@
 typedef struct
 {
-  float x;
-  float y;
-  float z;
+  double x;
+  double y;
+  double z;
   int id;
 
   /* STEP crap - to hell with encapsulation */
   step_id vertex_identifier;
 } vertex3d;
 
-vertex3d *make_vertex3d (float x, float y, float z);
+vertex3d *make_vertex3d (double x, double y, double z);
 void destroy_vertex3d (vertex3d *v);
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 3464ff2..8440a48 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -23,6 +23,20 @@
 #include "object3d_step.h"
 
 
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#endif
+
+
 static step_id_list
 presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
 {
@@ -143,6 +157,19 @@ object3d_export_to_step (object3d *object, const char *filename)
       vertex3d *ov = ODATA (outer_contour->first_edge);
       vertex3d *dv = DDATA (outer_contour->first_edge);
 
+      double rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
       face->surface_identifier =
         step_plane (step, "NONE",
                     step_axis2_placement_3d (step, "NONE",
@@ -150,9 +177,9 @@ object3d_export_to_step (object3d *object, const char *filename)
                                                                                  ov->y,      /* Set this to the origin vertex of the first edge */
                                                                                  ov->z),     /* this contour links to in the quad edge structure. */
                                                    step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                   step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                 dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                 dv->z - ov->z)));      /* contour links to in the quad edge structure */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
     }
   }
 
@@ -173,14 +200,30 @@ object3d_export_to_step (object3d *object, const char *filename)
       vertex3d *ov = ODATA (edge);
       vertex3d *dv = DDATA (edge);
 
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
       info->infinite_line_identifier =
         step_line (step, "NONE",
                    step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
                    step_vector (step, "NONE",
-                                step_direction (step, "NONE", dv->x - ov->x,
-                                                              dv->y - ov->y,
-                                                              dv->z - ov->z),  // <--- Direction along the line
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
                                 1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
     }
   }
 
@@ -242,14 +285,13 @@ object3d_export_to_step (object3d *object, const char *filename)
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
 
+#if 1
   /* Body style */
-  if (1) {
-    /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
-    brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
-    step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-    styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
-  }
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
   /* Face styles */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
@@ -265,6 +307,7 @@ object3d_export_to_step (object3d *object, const char *filename)
 
   /* Emit references to the styled and over_ridden styled items */
   step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
 
   shape_representation_identifier =
     step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 0a04ea0..33a3d4a 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -144,7 +144,7 @@ step_vertex_point (step_file *file, char *name, step_id pnt)
 step_id
 step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense)
 {
-  fprintf (file->f, "#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ;\n",
+  fprintf (file->f, "\n#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ; ",
                     file->next_id, name, edge_start, edge_end, edge_geometry, step_bool (same_sense));
   return file->next_id++;
 }
@@ -152,7 +152,7 @@ step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_e
 step_id
 step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation)
 {
-  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ; ",
                     file->next_id, name, edge_element, step_bool (orientation));
   return file->next_id++;
 }
@@ -171,7 +171,7 @@ step_edge_loop (step_file *file, char *name, step_id_list edge_list)
 step_id
 step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
 {
-  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ; ",
                     file->next_id, name, bound, step_bool (orientation));
 
   return file->next_id++;
@@ -191,7 +191,7 @@ step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id fa
 {
   fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, bounds);
-  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
   destroy_step_id_list (bounds);
 
   return file->next_id++;
