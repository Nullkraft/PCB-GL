Bottom: 42cb27b42f85c6d435b1e19c1e4d1e53406edfb3
Top:    64991df188c548b04c25e66b60a2661ba5502e24
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 15:56:06 +0000

Add STEPcode based assembly export function


---

diff --git a/configure.ac b/configure.ac
index f557c37..058fa40 100644
--- a/configure.ac
+++ b/configure.ac
@@ -456,6 +456,23 @@ which exporters you want and do not list png there.])
 	esac
 fi
 
+# Location of STEPcode sources to build against
+AC_ARG_WITH(stepcodedir, [  --with-stepcodedir=path  Change where the STEPcode source tree is located [[]]], [stepcodedir=$withval])
+
+if test x$stepcodedir = x ; then
+	case " ${HIDLIST} " in
+		*\ step\ *)
+			AC_MSG_ERROR([you have requested the STEP export HID but not specified the location
+of the STEPcode sources to build against])
+			;;
+
+		*)
+			;;
+	esac
+fi
+STEPCODEDIR=$stepcodedir
+AC_SUBST(STEPCODEDIR)
+
 for hid in $HIDLIST; do
     F=$srcdir/src/hid/$hid/hid.conf
     if test -f $F ; then
diff --git a/src/Makefile.am b/src/Makefile.am
index d1eb83e..d85b062 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -175,6 +175,7 @@ PCB_SRCS = \
 	hid/hidint.h 
 
 EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS} toporouter.c toporouter.h
+nodist_EXTRA_pcb_SOURCES = dummy.cpp
 DBUS_SRCS= \
 	dbus-pcbmain.c \
 	dbus-pcbmain.h \
@@ -466,14 +467,38 @@ hid/ps/ps_lists.h : ${LIBPS_SRCS} Makefile
 	(for f in ${LIBPS_SRCS} ; do cat $(srcdir)/$$f ; done) | grep "^REGISTER" > $@.tmp
 	mv $@.tmp $@
 
-libstep_a_CPPFLAGS = -I./hid/step
+libstep_a_CPPFLAGS = \
+	-I./hid/step \
+	-I${STEPCODEDIR}/include \
+	-I${STEPCODEDIR}/src/base \
+	-I${STEPCODEDIR}/src/clutils \
+	-I${STEPCODEDIR}/src/cldai \
+	-I${STEPCODEDIR}/src/clstepcore \
+	-I${STEPCODEDIR}/src/cleditor \
+	-I${STEPCODEDIR}/schemas/sdai_ap214e3
+
 LIBSTEP_SRCS = \
 	dolists.h \
 	hid/hidint.h \
 	hid/step/step.c \
-	hid/step/step.h
+	hid/step/step.h \
+	hid/step/assembly.cpp \
+	hid/step/assembly.h \
+	hid/step/utils.cpp \
+	hid/step/utils.h
 libstep_a_SOURCES = ${LIBSTEP_SRCS} hid/step/step_lists.h
 
+pcb_LDFLAGS = \
+	-Wl,-rpath,${STEPCODEDIR}/lib # HACK FOR EASIER DEBUG
+
+pcb_LDADD += \
+	-L${STEPCODEDIR}/lib \
+	-lstepcore \
+	-lstepeditor \
+	-lstepdai \
+	-lsteputils \
+	-lsdai_ap214e3
+
 hid/step/step_lists.h : ${LIBPS_SRCS} Makefile
 	$(MKDIR_P) hid/step
 	true > $@
diff --git a/src/hid/step/assembly.cpp b/src/hid/step/assembly.cpp
new file mode 100644
index 0000000..1cc4a3f
--- /dev/null
+++ b/src/hid/step/assembly.cpp
@@ -0,0 +1,946 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+//*****************************************************************************
+// Portions based upon the STEPcode example: AP203 Minimum
+//
+// AP203 Minimum
+//
+//  This program is intended to serve as a tutorial example for programmers
+// interested in learning about ISO 10303 (STEP), the STEPcode project, and
+// the AP203 portion of STEP.
+//
+//  This program creates and connects the minimum set of entities required
+// to form a valid AP203 STEP file.  Inspiration for this program came from
+// Appendix B of 'Recommended Practices for AP 203' released to the public
+// domain in 1998 by PDES Inc.  The recommended practices document is
+// available online at:
+//
+// http://www.steptools.com/support/stdev_docs/express/ap203/recprac203v8.pdf
+//
+//  The recommended practices document states:
+//
+//     "This document has been developed by the PDES, Inc. Industry
+//     consortium to aid in accelerating the implementation of the
+//     STEP standard.  It has not been copyrighted to allow for the
+//     free exchange of the information.  PDES, Inc. Requests that
+//     anyone using this information provide acknowledgment that
+//     PDES, Inc. was the original author."
+//
+//  In the same spirit, this program is released to the public domain.  Any
+// part of this program may be freely copied in part or in full for any
+// purpose.  No acknowledgment is required for the use of this code.
+//
+//  This program was written by Rob McDonald in October 2013.  Since that
+// time, it has been maintained by the STEPcode project.
+//
+//****************************************************************************/
+
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+extern "C" {
+#include "assembly.h"
+}
+
+enum LenEnum { MM, CM, M, IN, FT, YD };
+enum AngEnum { RAD, DEG };
+
+STEPcomplex * Geometric_Context( Registry * registry, InstMgr * instance_list, const LenEnum & len, const AngEnum & angle, const char * tolstr ) {
+    int instance_cnt = 0;
+    STEPattribute * attr;
+    STEPcomplex * stepcomplex;
+
+    SdaiDimensional_exponents * dimensional_exp = new SdaiDimensional_exponents();
+    dimensional_exp->length_exponent_( 0.0 );
+    dimensional_exp->mass_exponent_( 0.0 );
+    dimensional_exp->time_exponent_( 0.0 );
+    dimensional_exp->electric_current_exponent_( 0.0 );
+    dimensional_exp->thermodynamic_temperature_exponent_( 0.0 );
+    dimensional_exp->amount_of_substance_exponent_( 0.0 );
+    dimensional_exp->luminous_intensity_exponent_( 0.0 );
+    instance_list->Append( ( SDAI_Application_instance * ) dimensional_exp, completeSE );
+    instance_cnt++;
+
+    STEPcomplex * ua_length;
+    // First set up metric units if appropriate.  Default to mm.
+    // If imperial units, set up mm to be used as base to define imperial units.
+    Si_prefix pfx;
+    switch( len ) {
+        case CM:
+            pfx = Si_prefix__centi;
+            break;
+        case M:
+            pfx = Si_prefix_unset;
+            break;
+        case MM: /* fall through */
+        default:
+            pfx = Si_prefix__milli;
+    }
+
+    const char * ua_length_types[4] = { "length_unit", "named_unit", "si_unit", "*" };
+    ua_length = new STEPcomplex( registry, ( const char ** ) ua_length_types, instance_cnt );
+    stepcomplex = ua_length->head;
+    while( stepcomplex ) {
+        if (stepcomplex->EntityName() == NULL)
+          {
+            std::cout << "ERROR: Creating geometric context failed" << std::endl;
+            return NULL;
+          }
+        if( !strcmp( stepcomplex->EntityName(), "Si_Unit" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "prefix" ) ) {
+                    attr->Enum( new SdaiSi_prefix_var( pfx ) );
+                }
+                if( !strcmp( attr->Name(), "name" ) ) {
+                    attr->Enum( new SdaiSi_unit_name_var( Si_unit_name__metre ) );
+                }
+            }
+        }
+        stepcomplex = stepcomplex->sc;
+    }
+    instance_list->Append( ( SDAI_Application_instance * ) ua_length, completeSE );
+    instance_cnt++;
+
+    // If imperial, create conversion based unit.
+    if( len >= IN ) {
+        STEPcomplex * len_mm = ua_length;
+
+        char lenname[10];
+        double lenconv;
+
+        switch( len ) {
+            case IN:
+                strcat( lenname, "'INCH'\0" );
+                lenconv = 25.4;
+                break;
+            case FT:
+                strcat( lenname, "'FOOT'\0" );
+                lenconv = 25.4 * 12.0;
+                break;
+            case YD:
+                strcat( lenname, "'YARD'\0" );
+                lenconv = 25.4 * 36.0;
+                break;
+            case  M: /* not possible due to test above */
+            case CM: /* not possible due to test above */
+            case MM: /* not possible due to test above */
+                break;
+        }
+
+        SdaiUnit * len_unit = new SdaiUnit( ( SdaiNamed_unit * ) len_mm );
+
+        SdaiMeasure_value * len_measure_value = new SdaiMeasure_value( lenconv, automotive_design::t_measure_value );
+        len_measure_value->SetUnderlyingType( automotive_design::t_length_measure );
+
+        SdaiLength_measure_with_unit * len_measure_with_unit = new SdaiLength_measure_with_unit();
+        len_measure_with_unit->value_component_( len_measure_value );
+        len_measure_with_unit->unit_component_( len_unit );
+        instance_list->Append( ( SDAI_Application_instance * ) len_measure_with_unit, completeSE );
+        instance_cnt++;
+
+        SdaiDimensional_exponents * dimensional_exp_len = new SdaiDimensional_exponents();
+        dimensional_exp_len->length_exponent_( 1.0 );
+        dimensional_exp_len->mass_exponent_( 0.0 );
+        dimensional_exp_len->time_exponent_( 0.0 );
+        dimensional_exp_len->electric_current_exponent_( 0.0 );
+        dimensional_exp_len->thermodynamic_temperature_exponent_( 0.0 );
+        dimensional_exp_len->amount_of_substance_exponent_( 0.0 );
+        dimensional_exp_len->luminous_intensity_exponent_( 0.0 );
+        instance_list->Append( ( SDAI_Application_instance * ) dimensional_exp_len, completeSE );
+        instance_cnt++;
+
+        const char * ua_conv_len_types[4] = { "conversion_based_unit", "named_unit", "length_unit", "*" };
+        ua_length = new STEPcomplex( registry, ( const char ** ) ua_conv_len_types, instance_cnt );
+        stepcomplex = ua_length->head;
+        while( stepcomplex ) {
+            if (stepcomplex->EntityName() == NULL)
+              {
+                std::cout << "ERROR: Creating geometric context failed" << std::endl;
+                return NULL;
+              }
+            if( !strcmp( stepcomplex->EntityName(), "Conversion_Based_Unit" ) ) {
+                stepcomplex->ResetAttributes();
+                while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                    if( !strcmp( attr->Name(), "name" ) ) {
+                        attr->StrToVal( lenname );
+                    }
+                    if( !strcmp( attr->Name(), "conversion_factor" ) ) {
+                        attr->Entity( ( STEPentity * )( len_measure_with_unit ) );
+                    }
+                }
+            }
+            if( !strcmp( stepcomplex->EntityName(), "Named_Unit" ) ) {
+                stepcomplex->ResetAttributes();
+                while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                    if( !strcmp( attr->Name(), "dimensions" ) ) {
+                        attr->Entity( ( STEPentity * )( dimensional_exp_len ) );
+                    }
+                }
+            }
+            stepcomplex = stepcomplex->sc;
+        }
+
+        instance_list->Append( ( SDAI_Application_instance * ) ua_length, completeSE );
+        instance_cnt++;
+    }
+
+    SdaiUncertainty_measure_with_unit * uncertainty = ( SdaiUncertainty_measure_with_unit * )registry->ObjCreate( "UNCERTAINTY_MEASURE_WITH_UNIT" );
+    uncertainty->name_( "'DISTANCE_ACCURACY_VALUE'" );
+    uncertainty->description_( "'Threshold below which geometry imperfections (such as overlaps) are not considered errors.'" );
+    SdaiUnit * tol_unit = new SdaiUnit( ( SdaiNamed_unit * ) ua_length );
+    uncertainty->ResetAttributes();
+    {
+        while( ( attr = uncertainty->NextAttribute() ) != NULL ) {
+            if( !strcmp( attr->Name(), "unit_component" ) ) {
+                attr->Select( tol_unit );
+            }
+            if( !strcmp( attr->Name(), "value_component" ) ) {
+                attr->StrToVal( tolstr );
+            }
+        }
+    }
+    instance_list->Append( ( SDAI_Application_instance * ) uncertainty, completeSE );
+    instance_cnt++;
+
+    // First set up radians as base angle unit.
+    const char * ua_plane_angle_types[4] = { "named_unit", "plane_angle_unit", "si_unit", "*" };
+    STEPcomplex * ua_plane_angle = new STEPcomplex( registry, ( const char ** ) ua_plane_angle_types, instance_cnt );
+    stepcomplex = ua_plane_angle->head;
+    while( stepcomplex ) {
+        if (stepcomplex->EntityName() == NULL)
+          {
+            std::cout << "ERROR: Creating geometric context failed" << std::endl;
+            return NULL;
+          }
+        if( !strcmp( stepcomplex->EntityName(), "Si_Unit" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "name" ) ) {
+                    attr->Enum( new SdaiSi_unit_name_var( Si_unit_name__radian ) );
+                }
+            }
+        }
+        stepcomplex = stepcomplex->sc;
+    }
+    instance_list->Append( ( SDAI_Application_instance * ) ua_plane_angle, completeSE );
+    instance_cnt++;
+
+#if 0
+    // If degrees, create conversion based unit.
+    if( angle == DEG ) {
+        STEPcomplex * ang_rad = ua_plane_angle;
+
+        const double angconv = ( 3.14159265358979323846264338327950 / 180.0 );
+
+        SdaiUnit * p_ang_unit = new SdaiUnit( ( SdaiNamed_unit * ) ang_rad );
+
+        SdaiMeasure_value * p_ang_measure_value = new SdaiMeasure_value( angconv, automotive_design::t_measure_value );
+        p_ang_measure_value->SetUnderlyingType( automotive_design::t_plane_angle_measure );
+
+        SdaiPlane_angle_measure_with_unit * p_ang_measure_with_unit = new SdaiPlane_angle_measure_with_unit();
+        p_ang_measure_with_unit->value_component_( p_ang_measure_value );
+        p_ang_measure_with_unit->unit_component_( p_ang_unit );
+        instance_list->Append( ( SDAI_Application_instance * ) p_ang_measure_with_unit, completeSE );
+        instance_cnt++;
+
+        const char * ua_conv_angle_types[4] = { "conversion_based_unit", "named_unit", "plane_angle_unit", "*" };
+        ua_plane_angle = new STEPcomplex( registry, ( const char ** ) ua_conv_angle_types, instance_cnt );
+        stepcomplex = ua_plane_angle->head;
+        while( stepcomplex ) {
+            if( !strcmp( stepcomplex->EntityName(), "Conversion_Based_Unit" ) ) {
+                stepcomplex->ResetAttributes();
+                while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                    if( !strcmp( attr->Name(), "name" ) ) {
+                        attr->StrToVal( "'DEGREES'" );
+                    }
+                    if( !strcmp( attr->Name(), "conversion_factor" ) ) {
+                        attr->Entity( ( STEPentity * )( p_ang_measure_with_unit ) );
+                    }
+                }
+            }
+            if( !strcmp( stepcomplex->EntityName(), "Named_Unit" ) ) {
+                stepcomplex->ResetAttributes();
+                while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                    if( !strcmp( attr->Name(), "dimensions" ) ) {
+                        //attr->Entity( ( STEPentity * )( dimensional_exp ) );
+                        //attr->set_null();
+                        attr->Entity( dimensional_exp );
+                    }
+                }
+            }
+            stepcomplex = stepcomplex->sc;
+        }
+        instance_list->Append( ( SDAI_Application_instance * ) ua_plane_angle, completeSE );
+        instance_cnt++;
+    }
+#endif
+
+    const char * ua_solid_angle_types[4] = { "named_unit", "si_unit", "solid_angle_unit", "*" };
+    STEPcomplex * ua_solid_angle = new STEPcomplex( registry, ( const char ** ) ua_solid_angle_types, instance_cnt );
+    stepcomplex = ua_solid_angle->head;
+    while( stepcomplex ) {
+        if (stepcomplex->EntityName() == NULL)
+          {
+            std::cout << "ERROR: Creating geometric context failed" << std::endl;
+            return NULL;
+          }
+        if( !strcmp( stepcomplex->EntityName(), "Si_Unit" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "name" ) ) {
+                    attr->Enum( new SdaiSi_unit_name_var( Si_unit_name__steradian ) );
+                }
+            }
+        }
+        stepcomplex = stepcomplex->sc;
+    }
+    instance_list->Append( ( SDAI_Application_instance * ) ua_solid_angle, completeSE );
+    instance_cnt++;
+
+    // All units set up, stored in: ua_length, ua_plane_angle, ua_solid_angle
+    const char * entNmArr[5] = { "geometric_representation_context", "global_uncertainty_assigned_context", "global_unit_assigned_context", "representation_context", "*" };
+    STEPcomplex * complex_entity = new STEPcomplex( registry, ( const char ** ) entNmArr, instance_cnt );
+    stepcomplex = complex_entity->head;
+
+    while( stepcomplex ) {
+        if (stepcomplex->EntityName() == NULL)
+          {
+            std::cout << "ERROR: Creating geometric context failed" << std::endl;
+            return NULL;
+          }
+
+        if( !strcmp( stepcomplex->EntityName(), "Geometric_Representation_Context" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "coordinate_space_dimension" ) ) {
+                    attr->StrToVal( "3" );
+                }
+            }
+        }
+
+        if( !strcmp( stepcomplex->EntityName(), "Global_Uncertainty_Assigned_Context" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "uncertainty" ) ) {
+                    EntityAggregate * unc_agg = new EntityAggregate();
+                    unc_agg->AddNode( new EntityNode( ( SDAI_Application_instance * ) uncertainty ) );
+                    attr->Aggregate( unc_agg );
+                }
+            }
+
+        }
+
+        if( !strcmp( stepcomplex->EntityName(), "Global_Unit_Assigned_Context" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                std::string attrval;
+                if( !strcmp( attr->Name(), "units" ) ) {
+                    EntityAggregate * unit_assigned_agg = new EntityAggregate();
+                    unit_assigned_agg->AddNode( new EntityNode( ( SDAI_Application_instance * ) ua_length ) );
+                    unit_assigned_agg->AddNode( new EntityNode( ( SDAI_Application_instance * ) ua_plane_angle ) );
+                    unit_assigned_agg->AddNode( new EntityNode( ( SDAI_Application_instance * ) ua_solid_angle ) );
+                    attr->Aggregate( unit_assigned_agg );
+                }
+            }
+        }
+
+        if( !strcmp( stepcomplex->EntityName(), "Representation_Context" ) ) {
+            stepcomplex->ResetAttributes();
+            while( ( attr = stepcomplex->NextAttribute() ) != NULL ) {
+                if( !strcmp( attr->Name(), "context_identifier" ) ) {
+                    attr->StrToVal( "'STANDARD'" );
+                }
+                if( !strcmp( attr->Name(), "context_type" ) ) {
+                    attr->StrToVal( "'3D'" );
+                }
+            }
+        }
+        stepcomplex = stepcomplex->sc;
+    }
+    instance_list->Append( ( SDAI_Application_instance * ) complex_entity, completeSE );
+    instance_cnt++;
+
+    return complex_entity;
+}
+
+
+SdaiCartesian_point *
+MakePoint (Registry *registry, InstMgr *instance_list,
+           const double &x, const double &y, const double &z)
+{
+  SdaiCartesian_point * pnt = (SdaiCartesian_point *) registry->ObjCreate ("CARTESIAN_POINT");
+  pnt->name_ ("''");
+
+  RealAggregate * coords = pnt->coordinates_ ();
+
+  RealNode * xnode = new RealNode ();
+  xnode->value = x;
+  coords->AddNode (xnode);
+
+  RealNode * ynode = new RealNode ();
+  ynode->value = y;
+  coords->AddNode (ynode);
+
+  RealNode * znode = new RealNode ();
+  znode->value = z;
+  coords->AddNode (znode);
+
+  instance_list->Append ((SDAI_Application_instance *)pnt, completeSE);
+
+  return pnt;
+}
+
+
+SdaiDirection *
+MakeDirection (Registry *registry, InstMgr *instance_list,
+               const double &x, const double &y, const double &z)
+{
+  SdaiDirection * dir = (SdaiDirection *) registry->ObjCreate ("DIRECTION");
+  dir->name_ ("''");
+
+  RealAggregate * components = dir->direction_ratios_ ();
+
+  RealNode * xnode = new RealNode ();
+  xnode->value = x;
+  components->AddNode (xnode);
+
+  RealNode * ynode = new RealNode ();
+  ynode->value = y;
+  components->AddNode (ynode);
+
+  RealNode * znode = new RealNode ();
+  znode->value = z;
+  components->AddNode (znode);
+
+  instance_list->Append ((SDAI_Application_instance *) dir, completeSE);
+
+  return dir;
+}
+
+
+SdaiAxis2_placement_3d *
+MakeAxis (Registry *registry, InstMgr *instance_list,
+          const double &px, const double &py, const double & pz,
+          const double &ax, const double &ay, const double & az,
+          const double &rx, const double &ry, const double & rz)
+{
+  SdaiCartesian_point * pnt = MakePoint (registry, instance_list, px, py, pz);
+  SdaiDirection * axis = MakeDirection (registry, instance_list, ax, ay, az);
+  SdaiDirection * refd = MakeDirection (registry, instance_list, rx, ry, rz);
+
+  SdaiAxis2_placement_3d * placement = (SdaiAxis2_placement_3d *) registry->ObjCreate ("AXIS2_PLACEMENT_3D");
+  placement->name_ ("''");
+  placement->location_ (pnt);
+  placement->axis_ (axis);
+  placement->ref_direction_ (refd);
+
+  instance_list->Append ((SDAI_Application_instance *) placement, completeSE);
+
+  return placement;
+}
+
+
+SdaiAxis2_placement_3d *
+DefaultAxis (Registry *registry, InstMgr *instance_list)
+{
+  return MakeAxis (registry, instance_list, 0.0, 0.0, 0.0,
+                                            0.0, 0.0, 1.0,
+                                            1.0, 0.0, 0.0);
+}
+
+
+void
+write_ap214 (Registry *registry, InstMgr *instance_list, const char *filename)
+{
+  // STEPfile takes care of reading and writing Part 21 files
+  STEPfile sfile (*registry, *instance_list, "", false );
+
+  // Build file header
+  InstMgr *header_instances = sfile.HeaderInstances ();
+
+  int filename_length = strlen (filename);
+  char *step_fn = new char[filename_length + 3];
+  step_fn[0] = '\'';
+  strncpy (step_fn + 1, filename, filename_length);
+  step_fn[filename_length + 1] = '\'';
+  step_fn[filename_length + 2] = '\0';
+
+  SdaiFile_name *fn = (SdaiFile_name *)sfile.HeaderDefaultFileName ();
+  header_instances->Append ((SDAI_Application_instance *) fn, completeSE);
+  fn->name_ (step_fn);
+  fn->time_stamp_ ("''");
+  fn->author_ ()->AddNode (new StringNode( "''" ));
+  fn->organization_ ()->AddNode (new StringNode( "''" ));
+  fn->preprocessor_version_ ("''");
+  fn->originating_system_ ("''");
+  fn->authorization_ ("''");
+
+  SdaiFile_description *fd = (SdaiFile_description *)sfile.HeaderDefaultFileDescription ();
+  header_instances->Append ((SDAI_Application_instance *)fd, completeSE);
+  fd->description_()->AddNode (new StringNode ("''"));
+  fd->implementation_level_ ("'1'");
+
+  SdaiFile_schema *fs = (SdaiFile_schema *) sfile.HeaderDefaultFileSchema ();
+  header_instances->Append ((SDAI_Application_instance *)fs, completeSE);
+  fs->schema_identifiers_ ()->AddNode (new StringNode("'AUTOMOTIVE_DESIGN { 1 0 10303 214 3 1 1 }'")); /* XXX: NOT SURE IF THIS IS CORRECT! */
+
+  //sfile.WriteExchangeFile (filename);
+  sfile.WriteExchangeFile (filename, false); /* Turn off validation to try and force a save for bad data */
+  if (sfile.Error ().severity () < SEVERITY_USERMSG)
+    {
+      sfile.Error ().PrintContents (std::cout);
+    }
+
+  delete [] step_fn;
+}
+
+
+STEPcomplex *
+MakeRrwtSrr (Registry *registry,
+             InstMgr *inst_mgr,
+             const char *description,
+             const char *name,
+             SdaiRepresentation_item *rep_1,
+             SdaiRepresentation_item *rep_2,
+             SdaiTransformation *transformation_operator)
+{
+  STEPattribute *attr;
+  const char * rrwt_srr_types[4] = { "representation_relationship",
+                                     "representation_relationship_with_transformation",
+                                     "shape_representation_relationship",
+                                     "*" };
+
+  STEPcomplex *rrwt_srr = new STEPcomplex (registry, (const char **) rrwt_srr_types, 0 /* XXX: FileID ??? */);
+
+  STEPcomplex *stepcomplex = rrwt_srr->head;
+  while (stepcomplex)
+    {
+      if (!strcmp( stepcomplex->EntityName (), "Representation_Relationship"))
+        {
+          stepcomplex->ResetAttributes();
+          while ((attr = stepcomplex->NextAttribute ()) != NULL)
+            {
+              if (!strcmp( attr->Name(), "description"))
+                attr->String (new SDAI_String (description));
+              else if( !strcmp( attr->Name(), "name" ) )
+                attr->String (new SDAI_String (name));
+              else if( !strcmp( attr->Name(), "rep_1" ) )
+                attr->Entity (rep_1);
+              else if( !strcmp( attr->Name(), "rep_2" ) )
+                attr->Entity (rep_2);
+            }
+        }
+      else if (!strcmp( stepcomplex->EntityName (), "Representation_Relationship_With_Transformation"))
+        {
+          stepcomplex->ResetAttributes();
+          while ((attr = stepcomplex->NextAttribute ()) != NULL)
+            {
+              if (!strcmp( attr->Name(), "transformation_operator"))
+                attr->Select (transformation_operator);
+            }
+        }
+      stepcomplex = stepcomplex->sc;
+    }
+
+  return rrwt_srr;
+}
+
+
+SdaiProduct_definition *
+create_parent_assembly (Registry *registry,
+                        InstMgr *instance_list)
+{
+  // Build file data.  The entities have been created and added in order such that no entity
+  // references a later entity.  This is not required, but has been done to give a logical
+  // flow to the source and the resulting STEP file.
+
+  // Global units and tolerance.
+  STEPcomplex * context = Geometric_Context( registry, instance_list, MM, DEG, "LENGTH_MEASURE(0.0001)" );
+
+  if (context == NULL)
+    {
+      std::cout << "ERROR: Problem creating parent assembly" << std::endl;
+      return NULL;
+    }
+
+  // Primary coordinate system.
+  SdaiAxis2_placement_3d * orig_transform = DefaultAxis( registry, instance_list );
+
+  // Basic context through product and shape representation
+  SdaiApplication_context * app_context = ( SdaiApplication_context * ) registry->ObjCreate( "APPLICATION_CONTEXT" );
+  instance_list->Append( ( SDAI_Application_instance * ) app_context, completeSE );
+  app_context->application_( "'core data for automotive mechanical design processes'" );
+
+  SdaiProduct_context * prod_context = ( SdaiProduct_context * ) registry->ObjCreate( "PRODUCT_CONTEXT" );
+  instance_list->Append( ( SDAI_Application_instance * ) prod_context, completeSE );
+  prod_context->name_( "''" );
+  prod_context->discipline_type_( "'mechanical'" );
+  prod_context->frame_of_reference_( app_context );
+
+  SdaiApplication_protocol_definition * app_protocol = ( SdaiApplication_protocol_definition * ) registry->ObjCreate( "APPLICATION_PROTOCOL_DEFINITION" );
+  instance_list->Append( ( SDAI_Application_instance * ) app_protocol, completeSE );
+  app_protocol->status_( "'international standard'" );
+  app_protocol->application_protocol_year_( 2010 ); /* XXX: NOT SURE IF THIS IS CORRECT! */
+  app_protocol->application_interpreted_model_schema_name_( "'automotive_design'" );
+  app_protocol->application_( app_context );
+
+  SdaiProduct * prod = ( SdaiProduct * ) registry->ObjCreate( "PRODUCT" );
+  instance_list->Append( ( SDAI_Application_instance * ) prod, completeSE );
+  prod->id_( "''" );
+  prod->name_( "'prodname'" );
+  prod->description_( "''" );
+  prod->frame_of_reference_()->AddNode( new EntityNode( ( SDAI_Application_instance * ) prod_context ) );
+
+  SdaiProduct_related_product_category * prodcat = ( SdaiProduct_related_product_category * ) registry->ObjCreate( "PRODUCT_RELATED_PRODUCT_CATEGORY" );
+  instance_list->Append( ( SDAI_Application_instance * ) prodcat, completeSE );
+  prodcat->name_( "'assembly'" );
+  prodcat->description_( "''" );
+  prodcat->products_()->AddNode( new EntityNode( ( SDAI_Application_instance * ) prod ) );
+
+  SdaiProduct_definition_formation_with_specified_source * prod_def_form = ( SdaiProduct_definition_formation_with_specified_source * ) registry->ObjCreate( "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" );
+  instance_list->Append( ( SDAI_Application_instance * ) prod_def_form, completeSE );
+  prod_def_form->id_( "''" );
+  prod_def_form->description_( "''" );
+  prod_def_form->of_product_( prod );
+  prod_def_form->make_or_buy_( Source__made );
+
+  SdaiProduct_definition_context * prod_def_context = ( SdaiProduct_definition_context * ) registry->ObjCreate( "PRODUCT_DEFINITION_CONTEXT" );
+  instance_list->Append( ( SDAI_Application_instance * ) prod_def_context, completeSE );
+  prod_def_context->name_( "''" );
+  prod_def_context->life_cycle_stage_( "'design'" );
+  prod_def_context->frame_of_reference_( app_context );
+
+  SdaiProduct_definition * prod_def = ( SdaiProduct_definition * ) registry->ObjCreate( "PRODUCT_DEFINITION" );
+  instance_list->Append( ( SDAI_Application_instance * ) prod_def, completeSE );
+  prod_def->id_( "''" );
+  prod_def->description_( "''" );
+  prod_def->frame_of_reference_( prod_def_context );
+  prod_def->formation_( prod_def_form );
+
+  SdaiProduct_definition_shape * pshape = ( SdaiProduct_definition_shape * ) registry->ObjCreate( "PRODUCT_DEFINITION_SHAPE" );
+  instance_list->Append( ( SDAI_Application_instance * ) pshape, completeSE );
+  pshape->name_( "''" );
+  pshape->description_( "'ProductShapeDescription'" );
+  pshape->definition_( new SdaiCharacterized_definition( new SdaiCharacterized_product_definition( prod_def ) ) );
+
+  SdaiShape_representation * shape_rep = ( SdaiShape_representation * ) registry->ObjCreate( "SHAPE_REPRESENTATION" );
+  instance_list->Append( ( SDAI_Application_instance * ) shape_rep, completeSE );
+  shape_rep->name_( "''" ); // Document?
+  shape_rep->items_()->AddNode( new EntityNode( ( SDAI_Application_instance * ) orig_transform ) );
+  shape_rep->context_of_items_( ( SdaiRepresentation_context * ) context );
+
+  SdaiShape_definition_representation * shape_def_rep = ( SdaiShape_definition_representation * ) registry->ObjCreate( "SHAPE_DEFINITION_REPRESENTATION" );
+  instance_list->Append( ( SDAI_Application_instance * ) shape_def_rep, completeSE );
+  shape_def_rep->definition_( new SdaiRepresented_definition ( pshape ) );
+  shape_def_rep->used_representation_( shape_rep );
+
+  return prod_def;
+}
+
+
+typedef std::list<SDAI_Application_instance *> ai_list;
+
+
+SdaiProduct_definition *
+append_model_from_file (Registry *registry,
+                        InstMgr *instance_list,
+                        const char *filename)
+{
+  int max_existing_file_id = instance_list->MaxFileId ();
+
+  /* XXX: The following line is coppied from STEPfile.inline.cc, and we rely on it matching the algorithm there! */
+//  int file_increment = ( int )( ( ceil( ( max_existing_file_id + 99.0 ) / 1000.0 ) + 1.0 ) * 1000.0 ); /* XXX: RELYING ON SCL NOT CHANGING */
+//  std::cout << "INFO: Expecting a to add " << file_increment << " to entity names" << std::endl;
+
+  STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+
+  // XXX: This appears to throw exceptions from std::ios_base if the file doesn't exist
+  try
+    {
+      sfile.AppendExchangeFile (filename);
+    }
+  catch (...)
+    {
+      std::cout << "ERROR: Caught exception when attempting to read from file '" << filename << "' (does the file exist?)" << std::endl;
+      return NULL;
+    }
+
+  Severity severity = sfile.Error().severity();
+  if (severity != SEVERITY_NULL)
+    {
+      sfile.Error().PrintContents (std::cout);
+      std::cout << "WARNING: Error reading from file '" << filename << "'" << std::endl;
+//      return NULL;
+#warning HANDLE OTHER ERRORS BETTER?
+    }
+
+  pd_list all_pd_list;
+  pd_list pd_list;
+
+  // Find all PRODUCT_DEFINITION entities with a SHAPE_DEFINITION_REPRESETNATION
+  find_all_pd_with_sdr (instance_list, &all_pd_list);
+
+  // Find and copy over any PRODUCT_DEFINITION in our list which have entity numbers from the append
+  for (pd_list::iterator iter = all_pd_list.begin(); iter != all_pd_list.end(); iter++)
+    if ((*iter)->StepFileId () > max_existing_file_id)
+      pd_list.push_back (*iter);
+
+  /*  Try to determine the root product */
+  find_and_remove_child_pd (instance_list, &pd_list, "Next_assembly_usage_occurrence"); // Remove any PD which are children of another via NAUO
+  find_and_remove_child_pd (instance_list, &pd_list, "Assembly_component_usage");       // Remove any PD which are children of another via ACU
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+  std::cout << "Hopefully left with the root product definition" << std::endl;
+  for (pd_list::iterator iter = pd_list.begin(); iter != pd_list.end(); iter++)
+    std::cout << "Product definition list item #" << (*iter)->StepFileId () << std::endl;
+  std::cout << std::endl;
+#endif
+
+  // If we didn't find a suitable PD, give up now
+  if (pd_list.size() == 0)
+    {
+      std::cout << "ERROR: Did not find a PRODUCT_DEFINITION (with associated SHAPE_DEFINITION_REPRESENTATION)" << std::endl;
+      return NULL;
+    }
+
+  if (pd_list.size() > 1)
+    std::cout << "WARNING: Found more than one PRODUCT_DEFINITION that might be the root" << std::endl;
+
+  // Use the first PD meeting the criterion. Hopefully there should just be one, but if not, we pick the first.
+  return *pd_list.begin();
+}
+
+
+void
+convert_model_to_assy_capable (Registry *registry,
+                               InstMgr *instance_list,
+                               SdaiProduct_definition *pd)
+{
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, pd);
+  SdaiShape_representation *sr = (SdaiShape_representation *)sdr->used_representation_ ();
+
+  // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), return - we are already in the correct form
+  if (strcmp (sr->EntityName (), "Shape_Representation") == 0)
+    return;
+
+  // sr must be a subclass of Shape Representation, not an exact match for "Shape_Representation
+  // we need to adjust the shape representation structure to insert a SHAPE_REPRESENTATION, then
+  // relate this to the original shape representation.
+
+#ifdef DEBUG_PRODUCT_DEFINITION
+  std::cout << "Going to shoe-horn this into an assembly compatible structure" << std::endl;
+#endif
+
+  SdaiAxis2_placement_3d *child_origin = find_axis2_placement_3d_in_sr (sr);
+  if (child_origin == NULL)
+    {
+      std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION - ABORTING CONVERSION TO ASSEMBLY CAPABLE" << std::endl;
+      return;
+    }
+
+  SdaiShape_representation *new_sr = (SdaiShape_representation *) registry->ObjCreate ("SHAPE_REPRESENTATION");
+  instance_list->Append ((SDAI_Application_instance * ) new_sr, completeSE);
+  new_sr->name_ ( "''" ); // Document?
+  new_sr->items_ ()->AddNode (new EntityNode ((SDAI_Application_instance *) child_origin));
+  new_sr->context_of_items_ ((SdaiRepresentation_context *) sr->context_of_items_());
+
+  // Replace the shape representation from the model by our new entity
+  sdr->used_representation_ (new_sr);
+
+  // NEED SHAPE_REPRESENTATION_RELATIONSHIP linking new_sr and sr
+  SdaiShape_representation_relationship *new_srr = (SdaiShape_representation_relationship *) registry->ObjCreate ("SHAPE_REPRESENTATION_RELATIONSHIP");
+  instance_list->Append ((SDAI_Application_instance * ) new_srr, completeSE);
+  new_srr->name_ ( "'NONE'" );
+  new_srr->description_ ( "'NONE'" );
+  new_srr->rep_1_ (new_sr);
+  new_srr->rep_2_ (sr);
+}
+
+
+void
+assemble_instance_of_model (Registry *registry,
+                            InstMgr *instance_list,
+                            SdaiProduct_definition *parent_pd,
+                            SdaiProduct_definition *child_pd,
+                            SdaiAxis2_placement_3d *location_in_parent,
+                            const char *instance_name)
+{
+  SdaiShape_representation *parent_sr = find_sr_for_pd (instance_list, parent_pd);
+  SdaiShape_representation *child_sr = find_sr_for_pd (instance_list, child_pd);
+  SdaiAxis2_placement_3d *child_origin = find_axis2_placement_3d_in_sr (child_sr);
+
+  parent_sr->items_ ()->AddNode (new EntityNode (location_in_parent));
+
+  // NAUO
+  char *nauo_id = g_strdup_printf ("'%s'", instance_name); // XXX: SHOULD BE UNIQUE!
+
+  SdaiNext_assembly_usage_occurrence *nauo = (SdaiNext_assembly_usage_occurrence *) registry->ObjCreate ("NEXT_ASSEMBLY_USAGE_OCCURRENCE");
+  instance_list->Append ((SDAI_Application_instance *)nauo, completeSE);
+  nauo->description_ ("''");
+  nauo->id_ (nauo_id);
+  nauo->name_ ("''");
+  nauo->relating_product_definition_ (parent_pd);
+  nauo->related_product_definition_ (child_pd);
+  g_free (nauo_id);
+
+  // PDS
+  SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *) registry->ObjCreate ("PRODUCT_DEFINITION_SHAPE");
+  instance_list->Append ((SDAI_Application_instance *) pds, completeSE);
+  pds->name_ ("''");
+  pds->description_ ("'ProductShapeDescription'");
+  pds->definition_ (new SdaiCharacterized_definition (new SdaiCharacterized_product_definition (nauo)));
+
+  // IDT
+  SdaiItem_defined_transformation *idt = (SdaiItem_defined_transformation *) registry->ObjCreate ("ITEM_DEFINED_TRANSFORMATION");
+  instance_list->Append ((SDAI_Application_instance *) idt, completeSE);
+  idt->description_ ("''");
+  idt->name_ ("''");
+  idt->transform_item_1_ (location_in_parent); // Axis in the parent shape where the child origin should place
+  idt->transform_item_2_ (child_origin);       // Child origin in the child shape
+
+  // RRWT_SRR COMPLEX
+  STEPcomplex *rrwt_srr = MakeRrwtSrr (registry, instance_list,
+                                       "'NONE'",                             // RR   description
+                                       "'NONE'",                             // RR   name
+                                       (SdaiRepresentation_item *)parent_sr, // RR   rep_1,
+                                       (SdaiRepresentation_item *)child_sr,  // RR   rep_2,
+                                       new SdaiTransformation (idt));        // RRWT transformation_operator
+  instance_list->Append ((SDAI_Application_instance *) rrwt_srr, completeSE);
+
+  // CDSR
+  SdaiContext_dependent_shape_representation *cdsr = (SdaiContext_dependent_shape_representation *) registry->ObjCreate ("CONTEXT_DEPENDENT_SHAPE_REPRESENTATION");
+  instance_list->Append ((SDAI_Application_instance *) cdsr, completeSE);
+  cdsr->representation_relation_ ((SdaiShape_representation_relationship *)rrwt_srr);
+  cdsr->represented_product_relation_ (pds);
+}
+
+
+void
+print_pd_debug (InstMgr *instance_list, SdaiProduct_definition *pd)
+{
+#ifdef DEBUG_PRODUCT_DEFINITION
+  std::cout << "The product we are going to embed is called " << pd->formation_ ()->of_product_ ()->id_ ().c_str () << std::endl;
+
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, pd);
+
+  SdaiShape_representation *sr = find_sr_for_pd (instance_list, pd);
+  if (sr == NULL)
+    {
+      std::cout << "Could not find shape representation for the part!" << std::endl;
+      return;
+    }
+  std::cout << "The shape representation (#" << sr->StepFileId () << ") for the product has type " << sr->EntityName ();
+  std::cout << std::endl;
+#endif
+}
+
+
+extern "C" void
+export_step_assembly (const char *filename, GList *models)
+{
+  Registry * registry = new Registry (SchemaInit);
+  InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
+
+  // Increment FileId so entities start at #1 instead of #0.
+  instance_list->NextFileId();
+
+  SdaiProduct_definition *assembly_pd = create_parent_assembly (registry, instance_list);
+  if (assembly_pd == NULL)
+    {
+      printf ("ERROR creating parent assembly");
+      return;
+    }
+
+  GList *model_iter;
+  for (model_iter = models;
+       model_iter != NULL;
+       model_iter = g_list_next (model_iter))
+    {
+      struct assembly_model *model = (struct assembly_model *)model_iter->data;
+
+      SdaiProduct_definition *model_pd;
+      model_pd = append_model_from_file (registry, instance_list, model->filename);
+      if (model_pd == NULL)
+        {
+          printf ("ERROR Loading STEP model from file '%s'\n", model->filename);
+          continue;
+        }
+
+      GList *inst_iter;
+      for (inst_iter = model->instances;
+           inst_iter != NULL;
+           inst_iter = g_list_next (inst_iter))
+        {
+          struct assembly_model_instance *instance = (struct assembly_model_instance *)inst_iter->data;
+
+          SdaiAxis2_placement_3d *child_location;
+          child_location = MakeAxis (registry, instance_list,
+                                     instance->ox, instance->oy, instance->oz,  // POINT
+                                     instance->ax, instance->ay, instance->az,  // AXIS
+                                     instance->rx, instance->ry, instance->rz); // REF DIRECTION
+
+          assemble_instance_of_model (registry, instance_list, assembly_pd, model_pd, child_location, instance->name);
+        }
+    }
+
+  write_ap214 (registry, instance_list, filename);
+
+  delete instance_list;
+  delete registry;
+}
diff --git a/src/hid/step/assembly.h b/src/hid/step/assembly.h
new file mode 100644
index 0000000..7a8b5df
--- /dev/null
+++ b/src/hid/step/assembly.h
@@ -0,0 +1,24 @@
+
+struct assembly_model_instance {
+  const char *name;
+//  double ox;
+//  double oy;
+//  double rotation;
+  double ox;
+  double oy;
+  double oz;
+  double ax;
+  double ay;
+  double az;
+  double rx;
+  double ry;
+  double rz;
+};
+
+
+struct assembly_model {
+  const char *filename;
+  GList *instances;
+};
+
+void export_step_assembly (const char *filename, GList *assembly_models);
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 9b775ac..c109dc5 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -24,11 +24,14 @@
 #include "step.h"
 #include "hid/common/hidinit.h"
 #include "polygon.h"
+#include "misc.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#include "assembly.h"
+
 #define CRASH fprintf(stderr, "HID error: pcb called unimplemented STEP function %s.\n", __FUNCTION__); abort()
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
@@ -184,7 +187,7 @@ step_start_file (FILE *f, const char *filename)
               "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
 
   /* BREP STUFF FROM #21 onwards say? */
-  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( /* Manifold_solid_brep */ #21, #13 ), #18 ) ;\n"
+  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( #21, #13 ), #18 ) ;\n" /* #21 is the Manifold_solid_brep */
               "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
               "test_pcb_absr_name");
 
@@ -756,12 +759,60 @@ step_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   PCB->Flags = save_thindraw;
 }
 
+/* NB: Result is in mm */
+static void
+parse_cartesian_point_3d_string (const char *str, double *x, double *y, double *z)
+{
+  *x = 0.0, *y = 0.0, *z = 0.0;
+}
+
+/* NB: Result is in mm */
+static void
+parse_direction_3d_string (const char *str, double *x, double *y, double *z)
+{
+  *x = 0.0, *y = 0.0, *z = 0.0;
+}
+
+/* NB: Result is in degrees */
+static void
+parse_rotation_string (const char *str, double *rotation)
+{
+  *rotation = 0.0;
+}
+
+static void
+parse_position_attribute (ElementType *element, char *attr_name, double *res)
+{
+  const char *attr_value = AttributeGet (element, attr_name);
+  bool absolute;
+
+  *res = 0.0;
+  if (attr_value == NULL)
+    return;
+
+  *res = COORD_TO_MM (GetValueEx (attr_value, NULL, &absolute, NULL, "cmil"));
+}
+
+static void
+parse_numeric_attribute (ElementType *element, char *attr_name, double *res)
+{
+  const char *attr_value = AttributeGet (element, attr_name);
+  bool absolute;
+
+  *res = 0.0;
+  if (attr_value == NULL)
+    return;
+
+  *res = COORD_TO_MM (GetValueEx (attr_value, NULL, &absolute, NULL, "mm")); /* KLUDGE */
+}
+
 static void
 step_do_export (HID_Attr_Val * options)
 {
   FILE *fh;
   int save_ons[MAX_LAYER + 2];
   int i;
+  const char *temp_pcb_filename = "_pcb.step";
 
   if (!options)
     {
@@ -775,10 +826,10 @@ step_do_export (HID_Attr_Val * options)
   if (!global.filename)
     global.filename = "pcb-out.step";
 
-  fh = fopen (global.filename, "w");
+  fh = fopen (temp_pcb_filename, "w");
   if (fh == NULL)
     {
-      perror (global.filename);
+      perror (temp_pcb_filename);
       return;
     }
 
@@ -788,6 +839,206 @@ step_do_export (HID_Attr_Val * options)
 
   step_end_file (fh);
   fclose (fh);
+
+  {
+    GList *models = NULL;
+    struct assembly_model *model;
+    struct assembly_model_instance *instance;
+    const char *attribute;
+
+    model = g_new0 (struct assembly_model, 1);
+    model->filename = temp_pcb_filename;
+    models = g_list_append (models, model);
+
+    instance = g_new0 (struct assembly_model_instance, 1);
+    instance->name = "PCB";
+    instance->ox = 0.0,  instance->oy = 0.0,  instance->oz = 0.0;
+    instance->ax = 0.0,  instance->ay = 0.0,  instance->az = 1.0;
+    instance->rx = 1.0,  instance->ry = 0.0,  instance->rz = 0.0;
+    model->instances = g_list_append (model->instances, instance);
+
+
+    ELEMENT_LOOP (PCB->Data);
+      {
+        bool on_solder = TEST_FLAG (ONSOLDERFLAG, element);
+        double on_solder_negate = on_solder ? -1.0 : 1.0;
+        const char *model_filename;
+        double ox, oy, oz;
+        double ax, ay, az;
+        double rx, ry, rz;
+        double rotation;
+        double cos_rot;
+        double sin_rot;
+        GList *model_iter;
+
+        /* Skip if the component doesn't have a STEP-AP214 3d_model */
+        attribute = AttributeGet (element, "PCB::3d_model::type");
+        if (attribute == NULL || strcmp (attribute, "STEP-AP214") != 0)
+          continue;
+
+        attribute = AttributeGet (element, "PCB::3d_model::filename");
+        if (attribute == NULL)
+          continue;
+        model_filename = attribute;
+
+#if 0   /* Rather than write a parser for three floats in a string, separate X, Y, Z explicitly for quicker testing */
+
+        attribute = AttributeGet (element, "PCB::3d_model::origin");
+        if (attribute == NULL)
+          continue;
+        parse_cartesian_point_3d_string (attribute, &ox, &oy, &oz);
+
+        attribute = AttributeGet (element, "PCB::3d_model::axis");
+        if (attribute == NULL)
+          continue;
+        parse_direction_3d_string (attribute, &ax, &ay, &az);
+        ax = 0.0, ay = 0.0, az = 1.0;
+
+        attribute = AttributeGet (element, "PCB::3d_model::ref_dir");
+        if (attribute == NULL)
+          continue;
+        parse_direction_3d_string (attribute, &rx, &ry, &rz);
+        rx = 1.0, ry = 0.0, rz = 0.0;
+#endif
+
+        /* XXX: Should parse a unit suffix, e.g. "degrees" */
+        attribute = AttributeGet (element, "PCB::rotation");
+        if (attribute == NULL)
+          continue;
+        parse_rotation_string (attribute, &rotation);
+
+        /* XXX: QUICKER TO CODE INDIVIDULAL VALUES NOT SPACE SEPARATED */
+        parse_position_attribute (element, "PCB::3d_model::origin::X", &ox);
+        parse_position_attribute (element, "PCB::3d_model::origin::Y", &oy);
+        parse_position_attribute (element, "PCB::3d_model::origin::Z", &oz);
+        parse_numeric_attribute (element, "PCB::3d_model::axis::X", &ax);
+        parse_numeric_attribute (element, "PCB::3d_model::axis::Y", &ay);
+        parse_numeric_attribute (element, "PCB::3d_model::axis::Z", &az);
+        parse_numeric_attribute (element, "PCB::3d_model::ref_dir::X", &rx);
+        parse_numeric_attribute (element, "PCB::3d_model::ref_dir::Y", &ry);
+        parse_numeric_attribute (element, "PCB::3d_model::ref_dir::Z", &rz);
+        parse_numeric_attribute (element, "PCB::rotation", &rotation);
+
+#if 1  /* Write the intended final syntax attributes */
+        if (1)
+          {
+            GString *value = g_string_new (NULL);
+
+            attribute = AttributeGet (element, "PCB::3d_model::origin::X");
+            g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0mm");
+            attribute = AttributeGet (element, "PCB::3d_model::origin::Y");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0mm");
+            attribute = AttributeGet (element, "PCB::3d_model::origin::Z");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0mm");
+            AttributePutToList (&element->Attributes, "PCB::3d_model::origin", value->str, true);
+
+            attribute = AttributeGet (element, "PCB::3d_model::axis::X");
+            g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0");
+            attribute = AttributeGet (element, "PCB::3d_model::axis::Y");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+            attribute = AttributeGet (element, "PCB::3d_model::axis::Z");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+            AttributePutToList (&element->Attributes, "PCB::3d_model::axis", value->str, true);
+
+            attribute = AttributeGet (element, "PCB::3d_model::ref_dir::X");
+            g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0");
+            attribute = AttributeGet (element, "PCB::3d_model::ref_dir::Y");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+            attribute = AttributeGet (element, "PCB::3d_model::ref_dir::Z");
+            g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+            AttributePutToList (&element->Attributes, "PCB::3d_model::ref_dir", value->str, true);
+
+            g_string_free (value, true);
+          }
+#endif
+
+        printf ("Transform (%f, %f, %f), (%f, %f, %f), (%f, %f, %f). Rotation of part is %f\n", ox, oy, oz, ax, ay, az, rx, ry, rz, rotation);
+
+        model = NULL;
+
+        /* Look for prior usage of this model */
+        for (model_iter = models;
+             model_iter != NULL;
+             model_iter = g_list_next (model_iter))
+          {
+            struct assembly_model *possible_model;
+            possible_model = model_iter->data;
+            if (strcmp (possible_model->filename, model_filename) == 0)
+              {
+                model = possible_model;
+                break;
+              }
+          }
+
+        /* If we didn't find this model used already, add it to the list */
+        if (model == NULL)
+          {
+            model = g_new0 (struct assembly_model, 1);
+            model->filename = model_filename;
+            models = g_list_append (models, model);
+          }
+
+        cos_rot = cos (rotation * M_PI / 180.);
+        sin_rot = sin (rotation * M_PI / 180.);
+
+        // Rotation of part on board
+        // (NB: Y flipped from normal right handed convention)
+        //[cos -sin   0] [x] = [xcos - ysin]
+        //[sin  cos   0] [y]   [xsin + ycos]
+        //[  0    0   1] [z]   [z          ]
+
+        // Flip of part to backside of board
+        // [  1   0   0] [x] = [ x]
+        // [  0  -1   0] [y] = [-y]
+        // [  0   0  -1] [z] = [-z]
+
+        instance = g_new0 (struct assembly_model_instance, 1);
+        instance->name = NAMEONPCB_NAME (element);
+        instance->ox = COORD_TO_MM (element->MarkX) +                    ( ox * cos_rot + oy * sin_rot),
+        instance->oy = COORD_TO_MM (element->MarkY) + on_solder_negate * (-ox * sin_rot + oy * cos_rot),
+        instance->oz = on_solder_negate * -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0 + on_solder_negate * oz;
+        instance->ax =                    ( ax * cos_rot + ay * sin_rot),
+        instance->ay = on_solder_negate * (-ax * sin_rot + ay * cos_rot),
+        instance->az = on_solder_negate * az;
+        instance->rx =                    ( rx * cos_rot + ry * sin_rot), /* XXX: SHOULD THIS FACTOR IN on_solder_negate? */
+        instance->ry = on_solder_negate * (-rx * sin_rot + ry * cos_rot), /* XXX: SHOULD THIS FACTOR IN ol_solder_negaet? */
+        instance->rz = on_solder_negate * rz;
+        model->instances = g_list_append (model->instances, instance);
+
+      }
+    END_LOOP;
+
+#if 0
+    model = g_new0 (struct assembly_model, 1);
+    model->filename = "SOP65P780X200-22N_JEDEC_MO-150AF.step";
+    models = g_list_append (models, model);
+
+    instance = g_new0 (struct assembly_model_instance, 1);
+    instance->name = "DUMMY COMPONENT - 1";
+    instance->ox = 33.0,  instance->oy = 99.0,  instance->oz = -0.8; /* Locate origin (Z corresponds to bottom of board) */
+    instance->ax =  0.0,  instance->ay =  0.0,  instance->az = -1.0; /* Flip component Z-axis to orient on bottom of board */
+    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
+    model->instances = g_list_append (model->instances, instance);
+
+    instance = g_new0 (struct assembly_model_instance, 1);
+    instance->name = "DUMMY COMPONENT - 2";
+    instance->ox = 46.0,  instance->oy = 99.0,  instance->oz = -0.8; /* Locate origin (Z corresponds to bottom of board) */
+    instance->ax =  0.0,  instance->ay =  0.0,  instance->az = -1.0; /* Flip component Z-axis to orient on back of board */
+    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
+    model->instances = g_list_append (model->instances, instance);
+
+    instance = g_new0 (struct assembly_model_instance, 1);
+    instance->name = "DUMMY COMPONENT - 3";
+    instance->ox = 75.0,  instance->oy = 21.0,  instance->oz =  0.8; /* Locate origin (Z corresponds to top of board) */
+    instance->ax =  0.0,  instance->ay =  0.0,  instance->az =  1.0; /* Flip component Z-axis to orient on top of board */
+    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
+    model->instances = g_list_append (model->instances, instance);
+#endif
+
+    export_step_assembly (global.filename, models);
+
+    /* XXX: LEAK ALL THE MODEL DATA.. BEING LAZY RIGHT NOW */
+  }
 }
 
 static void
diff --git a/src/hid/step/utils.cpp b/src/hid/step/utils.cpp
new file mode 100644
index 0000000..ea90a52
--- /dev/null
+++ b/src/hid/step/utils.cpp
@@ -0,0 +1,193 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+
+void
+find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list)
+{
+  int search_index = 0;
+
+  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
+  SdaiShape_definition_representation *sdr;
+  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
+                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
+    {
+      SdaiRepresented_definition *sdr_definition = sdr->definition_ ();
+      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr_definition);
+      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
+
+      pd_list->push_back (pd);
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+      STEPentity *sdr_used_representation = sdr->used_representation_ ();
+      SdaiProduct_definition_formation *pdf = pd->formation_ ();
+      SdaiProduct *p = pdf->of_product_ ();
+
+      std::cout << "Got a SDR, #" << sdr->StepFileId ();
+      std::cout << " used_representation (sr or descendant) = #" << sdr_used_representation->StepFileId ();
+      std::cout << " definition (pds) = #" << pds->StepFileId ();
+      std::cout << " pds->definition (pd) = #" << pd->StepFileId ();
+      std::cout << " pd->formation (pdf) = #" << pdf->StepFileId ();
+      std::cout << " pdf->product (p) = #" << p->StepFileId ();
+      std::cout << std::endl;
+      std::cout << "Product id = " << p->id_ ().c_str () << " name = " << p->name_ ().c_str ();
+      std::cout << std::endl;
+#endif
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+      SdaiShape_representation *sr = (SdaiShape_representation *)sdr_used_representation;
+
+      std::cout << "SR is actually of type " << ((STEPentity *)sr)->EntityName () << std::endl;
+      std::cout << std::endl;
+#endif
+
+      int id = sdr->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+}
+
+/* entityName should be the name of entity Assembly_component_usage or one of its subtypes
+ * typically this will be "Assembly_component_usage" or "Next_assembly_usage_occurance"
+ */
+void
+find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, const char *entityName)
+{
+  int search_index = 0;
+
+  SdaiAssembly_component_usage *acu;
+  while (ENTITY_NULL != (acu = (SdaiAssembly_component_usage *)
+                               instance_list->GetApplication_instance (entityName, search_index)))
+    {
+      SdaiProduct_definition *related_pd = acu->related_product_definition_ ();
+
+#ifdef DEBUG_CHILD_REMOVAL
+      SdaiProduct_definition *relating_pd = acu->relating_product_definition_ ();
+
+      std::cout << "Product " << related_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
+      std::cout << " is a child of " << relating_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
+      std::cout << ".. removing it from list of possible root products";
+      std::cout << std::endl;
+#endif
+
+      /* Remove related_pd from the list of viable product definitions */
+      pd_list->remove (related_pd);
+
+      int id = acu->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+#ifdef DEBUG_CHILD_REMOVAL
+  std::cout << std::endl;
+#endif
+}
+
+
+SdaiShape_definition_representation *
+find_sdr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
+{
+  int search_index = 0;
+
+  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
+  SdaiShape_definition_representation *sdr;
+  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
+                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
+    {
+      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr->definition_ ());
+      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
+
+      /* Return the SHAPE_REPRESETATION (or subclass) associated with the first SHAPE_DEFINITION_REPRESENTATION for the required PRODUCT_DEFINITION */
+      if (pd == target_pd)
+        return sdr;
+//        return (SdaiShape_representation *)sdr->used_representation_ ();
+
+      int id = sdr->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+
+  return NULL;
+}
+
+
+SdaiShape_representation *
+find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
+{
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, target_pd);
+  return (SdaiShape_representation *)sdr->used_representation_ ();
+}
+
+
+SdaiAxis2_placement_3d *
+find_axis2_placement_3d_in_sr (SdaiShape_representation *sr)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Axis2_Placement_3d") == 0)
+        return (SdaiAxis2_placement_3d *)node;
+
+      iter = iter->NextNode ();
+    }
+
+  return NULL;
+}
diff --git a/src/hid/step/utils.h b/src/hid/step/utils.h
new file mode 100644
index 0000000..b5dd55a
--- /dev/null
+++ b/src/hid/step/utils.h
@@ -0,0 +1,43 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+typedef std::list<SdaiProduct_definition *> pd_list;
+
+
+void find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list);
+
+/* entityName should be the name of entity Assembly_component_usage or one of its subtypes
+ * typically this will be "Assembly_component_usage" or "Next_assembly_usage_occurance"
+ */
+void find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, const char *entityName);
+
+SdaiShape_definition_representation *find_sdr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd);
+
+SdaiShape_representation *find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd);
+
+SdaiAxis2_placement_3d *find_axis2_placement_3d_in_sr (SdaiShape_representation *sr);
