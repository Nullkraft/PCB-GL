Bottom: d6f8c49bcdc78d2e873d176b5240cad20f622e2f
Top:    418df059850da83d9de453fabcceb7b20b894b56
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-09 17:30:22 +0000

hidgl: Fixup to use HID_DRAW * rather than hidgl_instance *


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..b8409e3 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -130,9 +130,9 @@ static bool in_context = false;
 
 /* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
-hidgl_reset_triangle_array (hidgl_instance *hidgl)
+hidgl_reset_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     /* Hint to the driver that we're done with the previous buffer contents */
@@ -158,9 +158,9 @@ hidgl_reset_triangle_array (hidgl_instance *hidgl)
 }
 
 static void
-hidgl_init_triangle_array (hidgl_instance *hidgl)
+hidgl_init_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -189,13 +189,13 @@ hidgl_init_triangle_array (hidgl_instance *hidgl)
   priv->buffer.use_map = false;
 
   priv->buffer.triangle_array = NULL;
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 static void
-hidgl_finish_triangle_array (hidgl_instance *hidgl)
+hidgl_finish_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
@@ -212,9 +212,9 @@ hidgl_finish_triangle_array (hidgl_instance *hidgl)
 }
 
 void
-hidgl_flush_triangles (hidgl_instance *hidgl)
+hidgl_flush_triangles (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   GLfloat *data_pointer = NULL;
 
   CHECK_IS_IN_CONTEXT ();
@@ -253,15 +253,14 @@ hidgl_flush_triangles (hidgl_instance *hidgl)
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 void
 hidgl_ensure_vertex_space (hidGC gc, int count)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -273,7 +272,7 @@ hidgl_ensure_vertex_space (hidGC gc, int count)
       exit (1);
     }
   if (count > 3 * TRIANGLE_ARRAY_SIZE - priv->buffer.vertex_count)
-    hidgl_flush_triangles (hidgl);
+    hidgl_flush_triangles (hid_draw);
 }
 
 void
@@ -297,6 +296,7 @@ void
 hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   static GLfloat *points = 0;
   static int npoints = 0;
@@ -306,10 +306,10 @@ hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth,  drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, hid_draw->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, hid_draw->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  hid_draw->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, hid_draw->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -753,6 +753,7 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 
   myFreeCombined ();
   free (vertices);
+  tesselator_gc = NULL;
 }
 
 static inline void
@@ -774,8 +775,8 @@ fill_contour (hidGC gc, PLINE *contour)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 #if MEMCPY_VERTEX_DATA
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 #endif
   int i;
   int vertex_comp;
@@ -915,9 +916,8 @@ polygon_contains_user_holes (PolygonType *polygon)
 static void
 fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
@@ -933,7 +933,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
    */
   if (use_new_stencil)
     {
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);
       if (!stencil_bit)
         {
           printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
@@ -943,7 +943,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
     }
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
@@ -971,29 +971,28 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
   /* Drawing operations now set our reference bit in the stencil buffer */
 
   r_search (pa->contour_tree, clip_box, NULL, do_hole, gc);
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
+  glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                       /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
-
-  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);        /* This allows us to toggle the bit on the subcompositing bitplane */
+                                                    /* If the stencil test has passed, we know that bit is 0, so we're */
+                                                    /* effectively just setting it to 1. */
+  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);/* Pass stencil test if all assigned bits clear, */
+                                                    /* reference is all assigned bits so we set */
+                                                    /* any bits permitted by the stencil writemask */
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
   /* Draw the polygon outer */
   fill_contour (gc, pa->contours);
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   /* Unassign our stencil buffer bit */
   if (use_new_stencil)
-    hidgl_return_stencil_bit (hidgl, stencil_bit);
+    hidgl_return_stencil_bit (hid_draw, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
@@ -1136,15 +1135,19 @@ hidgl_init (void)
   called = true;
 }
 
-hidgl_instance *
-hidgl_new_instance (void)
+void
+hidgl_class_init (HID_DRAW_CLASS *klass)
+{
+  /* XXX: For now, our sub-classes have all the v-func methods, and they call us as required */
+}
+
+void
+hidgl_instance_init (HID_DRAW *hid_draw)
 {
-  hidgl_instance *hidgl;
   hidgl_priv *priv;
 
-  hidgl = calloc (1, sizeof (hidgl_instance));
   priv = calloc (1, sizeof (hidgl_priv));
-  hidgl->priv = priv;
+  hid_draw->priv = priv;
 
 #if 0
   glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
@@ -1162,28 +1165,25 @@ hidgl_new_instance (void)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_reset_stencil_usage (hidgl);
+  hidgl_reset_stencil_usage (hid_draw);
 #endif
-//  hidgl_init_triangle_array (hidgl);
-
-  return hidgl;
+//  hidgl_init_triangle_array (hid_draw);
 }
 
 void
-hidgl_free_instance (hidgl_instance *hidgl)
+hidgl_free_instance (HID_DRAW *hid_draw)
 {
-  free (hidgl->priv);
-  free (hidgl);
+  free (hid_draw->priv);
+  free (hid_draw);
 }
 
 void
-hidgl_init_gc (hidgl_instance *hidgl, hidGC gc)
+hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_gc->hidgl = hidgl;
   hidgl_gc->depth = 0.0;
 }
 
@@ -1193,9 +1193,9 @@ hidgl_finish_gc (hidGC gc)
 }
 
 void
-hidgl_start_render (hidgl_instance *hidgl)
+hidgl_start_render (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   static bool called = false;
 
   if (in_context)
@@ -1230,33 +1230,33 @@ hidgl_start_render (hidgl_instance *hidgl)
     }
 #endif
 
-  hidgl_init_triangle_array (hidgl);
+  hidgl_init_triangle_array (hid_draw);
   hidgl_shader_activate (/*priv->*/circular_program);
 }
 
 void
-hidgl_finish_render (hidgl_instance *hidgl)
+hidgl_finish_render (HID_DRAW *hid_draw)
 {
   if (!in_context)
     fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
 
-  hidgl_finish_triangle_array (hidgl);
+  hidgl_finish_triangle_array (hid_draw);
   hidgl_shader_activate (NULL);
   in_context = false;
 }
 
 int
-hidgl_stencil_bits (hidgl_instance *hidgl)
+hidgl_stencil_bits (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   return priv->stencil_bits;
 }
 
 static void
-hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
+hidgl_clean_unassigned_stencil (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -1268,9 +1268,9 @@ hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
 }
 
 int
-hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
+hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   int stencil_bitmask = (1 << priv->stencil_bits) - 1;
   int test;
@@ -1299,7 +1299,7 @@ hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
     }
 
   /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
-  hidgl_clean_unassigned_stencil (hidgl);
+  hidgl_clean_unassigned_stencil (hid_draw);
   priv->assigned_bits |= first_dirty;
   priv->dirty_bits = priv->assigned_bits;
 
@@ -1307,17 +1307,17 @@ hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
 }
 
 void
-hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit)
+hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits &= ~bit;
 }
 
 void
-hidgl_reset_stencil_usage (hidgl_instance *hidgl)
+hidgl_reset_stencil_usage (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits = 0;
   priv->dirty_bits = 0;
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index e2d7f67..a4fe876 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -52,18 +52,11 @@ typedef struct {
 
 } hidgl_priv;
 
-/* NB: hidgl_instance is a public type, intended to be used as an opaque pointer */
-typedef struct {
-  hidgl_priv *priv;
-
-} hidgl_instance;
 
 /* NB: hidglGC is a semi-private type, only defined here to enable inlining of geometry creation, and for derived GUIs to extend */
 typedef struct hidgl_gc_struct {
   struct hid_gc_struct gc; /* Parent */
 
-  hidgl_instance *hidgl;
-
   float depth;
 
 } *hidglGC;
@@ -71,7 +64,7 @@ typedef struct hidgl_gc_struct {
 extern hidgl_shader *circular_program;
 extern hidgl_shader *resistor_program;
 
-void hidgl_flush_triangles (hidgl_instance *hidgl);
+void hidgl_flush_triangles (HID_DRAW *hid_draw);
 void hidgl_ensure_vertex_space (hidGC gc, int count);
 void hidgl_ensure_triangle_space (hidGC gc, int count);
 
@@ -81,9 +74,8 @@ hidgl_add_vertex_3D_tex (hidGC gc,
                          GLfloat x, GLfloat y, GLfloat z,
                          GLfloat s, GLfloat t)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x;
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y;
@@ -166,16 +158,18 @@ void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_bo
 void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
-hidgl_instance *hidgl_new_instance (void);
-void hidgl_free_instance (hidgl_instance *hidgl);
-void hidgl_init_gc (hidgl_instance *hidgl, hidGC gc);
+HID_DRAW *hidgl_new_instance (void);
+void hidgl_class_init (HID_DRAW_CLASS *klass);
+void hidgl_instance_init (HID_DRAW *hid_draw);
+void hidgl_free_instance (HID_DRAW *hid_draw);
+void hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc);
 void hidgl_finish_gc (hidGC gc);
-void hidgl_start_render (hidgl_instance *hidgl);
-void hidgl_finish_render (hidgl_instance *hidgl);
-int hidgl_stencil_bits (hidgl_instance *hidgl);
-int hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl);
-void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
-void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
+void hidgl_start_render (HID_DRAW *hid_draw);
+void hidgl_finish_render (HID_DRAW *hid_draw);
+int hidgl_stencil_bits (HID_DRAW *hid_draw);
+int hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw);
+void hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit);
+void hidgl_reset_stencil_usage (HID_DRAW *hid_draw);
 
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 887850b..7b4006a 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -42,6 +42,7 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #include <gtk/gtkgl.h>
 #include "hid/common/hidgl.h"
 
+#include "hid/common/hidnogui.h"
 #include "hid/common/draw_helpers.h"
 #include "hid/common/trackball.h"
 
@@ -52,7 +53,7 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 //#define VIEW_ORTHO
 
 extern HID ghid_hid;
-extern HID_DRAW ghid_graphics;
+static HID_DRAW ghid_graphics;
 extern HID_DRAW_CLASS ghid_graphics_class;
 
 static hidGC current_gc = NULL;
@@ -95,7 +96,7 @@ typedef struct render_priv {
   Coord lead_user_x;
   Coord lead_user_y;
 
-  hidgl_instance *hidgl;
+  HID_DRAW *hid_draw;
   GList *active_gc_list;
   double edit_depth;
 
@@ -238,18 +239,18 @@ compute_depth (int group)
 }
 
 static void
-start_subcomposite (hidgl_instance *hidgl)
+start_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
   int stencil_bit;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
 
-  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);       /* Get a new (clean) bitplane to stencil with */
+  stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);    /* Get a new (clean) bitplane to stencil with */
   glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
   glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
 
@@ -257,14 +258,14 @@ start_subcomposite (hidgl_instance *hidgl)
 }
 
 static void
-end_subcomposite (hidgl_instance *hidgl)
+end_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
-  hidgl_return_stencil_bit (hidgl, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (hid_draw, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
 
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
@@ -307,7 +308,6 @@ int
 ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   bool group_visible = false;
   bool subcomposite = true;
 
@@ -352,10 +352,10 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 	}
     }
 
-  end_subcomposite (hidgl);
+  end_subcomposite (hid_draw);
 
   if (group_visible && subcomposite)
-    start_subcomposite (hidgl);
+    start_subcomposite (hid_draw);
 
   /* Drawing is already flushed by {start,end}_subcomposite */
   set_depth_on_all_active_gc (priv, compute_depth (group));
@@ -364,12 +364,9 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 }
 
 static void
-ghid_end_layer ()
+ghid_end_layer (HID_DRAW *graphics)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
-
-  end_subcomposite (hidgl);
+  end_subcomposite (graphics);
 }
 
 void
@@ -391,9 +388,9 @@ ghid_make_gc (HID_DRAW *hid_draw)
   gtkGC gtk_gc = (gtkGC)gc;
 
   gc->hid = &ghid_hid;
-  gc->hid_draw = &ghid_graphics;
+  gc->hid_draw = hid_draw;
 
-  hidgl_init_gc (priv->hidgl, gc);
+  hidgl_init_gc (hid_draw, gc);
 
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
@@ -543,15 +540,13 @@ ghid_draw_bg_image (void)
 void
 ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   static int stencil_bit = 0;
 
   if (mode == cur_mask)
     return;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   switch (mode)
     {
@@ -564,7 +559,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
       glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); /* Get a new (clean) bitplane to stencil with */
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw); /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
       glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value (with 1) */
@@ -580,7 +575,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 
     case HID_MASK_OFF:
       /* Disable stenciling */
-      hidgl_return_stencil_bit (hidgl, stencil_bit);        /* Relinquish any bitplane we previously used */
+      hidgl_return_stencil_bit (hid_draw, stencil_bit);     /* Relinquish any bitplane we previously used */
       glDisable (GL_STENCIL_TEST);                          /* Disable Stencil test */
       break;
     }
@@ -736,7 +731,7 @@ set_gl_color_for_gc (hidGC gc)
   g = g * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
   b = b * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gtk_gc->hidgl_gc.gc.hid_draw);
   glColor4d (r, g, b, a);
 }
 
@@ -1106,12 +1101,24 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
     }
 
   hidgl_init ();
-  priv->hidgl = hidgl_new_instance ();
 
   /* Setup HID function pointers specific to the GL renderer*/
+  hidgl_class_init (&ghid_graphics_class);
+
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class._fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class._thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+  /* Init ghid_graphics HID_DRAW instance */
+  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
+
+  ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
+  common_nogui_graphics_init (&ghid_graphics);
+  common_draw_helpers_init (&ghid_graphics);
+  hidgl_instance_init (&ghid_graphics);
+
+  priv->hid_draw = &ghid_graphics;
 }
 
 void
@@ -1119,7 +1126,7 @@ ghid_shutdown_renderer (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
 
-  hidgl_free_instance (priv->hidgl);
+  hidgl_free_instance (priv->hid_draw);
 
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
@@ -1164,7 +1171,7 @@ ghid_start_drawing (GHidPort *port, GtkWidget *widget)
 
   port->render_priv->in_context = true;
 
-  hidgl_start_render (port->render_priv->hidgl);
+  hidgl_start_render (port->render_priv->hid_draw);
 
   return TRUE;
 }
@@ -1174,7 +1181,7 @@ ghid_end_drawing (GHidPort *port, GtkWidget *widget)
 {
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_finish_render (port->render_priv->hidgl);
+  hidgl_finish_render (port->render_priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -1712,7 +1719,7 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 
 //  poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static void
@@ -1799,7 +1806,7 @@ GhidDrawMask (int side, BoxType * screen)
   fill_board_outline (out->fgGC, screen);
 
   ghid_set_alpha_mult (out->fgGC, 1.0);
-//  hidgl_flush_triangles (priv->hidgl);
+//  hidgl_flush_triangles (priv->hid_draw);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1883,7 +1890,7 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 
   poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static int
@@ -1922,7 +1929,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
 
       if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
         /* Mask out drilled holes on this layer */
-        hidgl_flush_triangles (priv->hidgl);
+        hidgl_flush_triangles (priv->hid_draw);
         glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
@@ -1930,7 +1937,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
         fill_board_outline_holes (Output.bgGC, screen);
-        hidgl_flush_triangles (priv->hidgl);
+        hidgl_flush_triangles (priv->hid_draw);
         glPopAttrib ();
       }
 
@@ -1947,7 +1954,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         hid_draw_set_layer (&ghid_graphics, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
-          hidgl_flush_triangles (priv->hidgl);
+          hidgl_flush_triangles (priv->hid_draw);
           glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
@@ -1955,7 +1962,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
           fill_board_outline_holes (Output.bgGC, screen);
-          hidgl_flush_triangles (priv->hidgl);
+          hidgl_flush_triangles (priv->hid_draw);
           glPopAttrib ();
         }
       }
@@ -2258,18 +2265,18 @@ ghid_draw_everything (BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    start_subcomposite (priv->hidgl);
+    start_subcomposite (priv->hid_draw);
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
-      hidgl_flush_triangles (priv->hidgl);
+      hidgl_flush_triangles (priv->hid_draw);
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
       fill_board_outline_holes (Output.bgGC, drawn_area);
-      hidgl_flush_triangles (priv->hidgl);
+      hidgl_flush_triangles (priv->hid_draw);
       glPopAttrib ();
     }
 
@@ -2277,7 +2284,7 @@ ghid_draw_everything (BoxType *drawn_area)
     if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
     if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
 
-    end_subcomposite (priv->hidgl);
+    end_subcomposite (priv->hid_draw);
   }
 
   /* Draw the solder mask if turned on */
@@ -2344,7 +2351,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits (priv->hidgl) == 0)
+  if (hidgl_stencil_bits (priv->hid_draw) == 0)
     ghid_graphics_class._fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
@@ -2430,7 +2437,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2573,10 +2580,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  common_set_clip_box (&ghid_graphics, &region);
-  /* hid_expose_callback (&ghid_graphics, &region, 0); */
+  common_set_clip_box (priv->hid_draw, &region);
+  /* hid_expose_callback (priv->hid_draw, &region, 0); */
   ghid_draw_everything (&region);
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glTexCoord2f (0., 0.);
   glColor3f (1., 1., 1.);
@@ -2628,7 +2635,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   DrawAttached (Output.fgGC);
   DrawMark (Output.fgGC);
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glEnable (GL_LIGHTING);
 
@@ -2691,7 +2698,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   draw_crosshair (Output.fgGC, priv);
   object3d_draw_debug ();
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   draw_lead_user (Output.fgGC, priv);
 
@@ -2739,6 +2746,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2822,7 +2830,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2840,8 +2848,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
-  hidgl_flush_triangles (priv->hidgl);
+  hid_expose_callback (hid_draw, NULL, pinout->element);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, widget);
@@ -2869,6 +2877,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2909,7 +2918,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
-  hidgl_start_render (priv->hidgl);
+  hidgl_start_render (priv->hid_draw);
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2934,7 +2943,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2962,14 +2971,14 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  common_set_clip_box (&ghid_graphics, &region);
-  hid_expose_callback (&ghid_graphics, &region, NULL);
-  hidgl_flush_triangles (priv->hidgl);
+  common_set_clip_box (priv->hid_draw, &region);
+  hid_expose_callback (priv->hid_draw, &region, NULL);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   glFlush ();
 
-  hidgl_finish_render (priv->hidgl);
+  hidgl_finish_render (priv->hid_draw);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -3031,7 +3040,7 @@ ghid_flush_debug_draw (HID_DRAW *hid_draw)
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -3042,9 +3051,7 @@ ghid_flush_debug_draw (HID_DRAW *hid_draw)
 void
 ghid_finish_debug_draw (HID_DRAW *hid_draw)
 {
-  render_priv *priv = gport->render_priv;
-
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, gport->drawing_area);
@@ -3406,7 +3413,6 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
 static void
 draw_lead_user (hidGC gc, render_priv *priv)
 {
-  gtkGC gtk_gc = (gtkGC)gc;
   int i;
   double radius = priv->lead_user_radius;
   double width = MM_TO_COORD (LEAD_USER_WIDTH);
@@ -3433,7 +3439,7 @@ draw_lead_user (hidGC gc, render_priv *priv)
                       radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gc->hid_draw);
   glPopAttrib ();
 }
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 846c997..4d623c6 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2100,8 +2100,7 @@ REGISTER_FLAGS (ghid_main_flag_list)
 #endif
 
 HID ghid_hid;
-HID_DRAW ghid_graphics;
-struct hid_draw_class_st ghid_graphics_class;
+HID_DRAW_CLASS ghid_graphics_class;
 
 void
 hid_gtk_init ()
@@ -2141,7 +2140,6 @@ hid_gtk_init ()
 #endif
 
   memset (&ghid_hid, 0, sizeof (HID));
-  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
   memset (&ghid_graphics_class, 0, sizeof (HID_DRAW_CLASS));
 
   common_nogui_init (&ghid_hid);
@@ -2219,14 +2217,8 @@ hid_gtk_init ()
   ghid_graphics_class.draw_pcb_pad     = common_gui_draw_pcb_pad;
   ghid_graphics_class.draw_pcb_pv      = common_gui_draw_pcb_pv;
 
-
   ghid_graphics_class.gui = true;
 
-  ghid_graphics.klass = &ghid_graphics_class;
-  ghid_graphics.poly_after = true;
-  common_nogui_graphics_init (&ghid_graphics);
-  common_draw_helpers_init (&ghid_graphics);
-
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
 }
diff --git a/src/hid_draw.h b/src/hid_draw.h
index 46e4140..a4178bd 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -103,6 +103,8 @@ struct hid_draw_st
   bool poly_after;  /* If set, the redraw code will draw polygons after  erasing the clearances. */
 
   BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
+
+  void *priv; /* XXX: TEMPORARY */
 };
 
 /* Base hidGC elements visible to any module */
