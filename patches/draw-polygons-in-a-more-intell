Bottom: 047dfbd6ed55506e9aca8fe422f0f2c4a8283b9d
Top:    23aa60ca73cbb4e1a2cd57d9108d5e5b766d92ed
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2015-01-01 17:11:05 +0000

Draw polygons in a more intelligent order

A sub-compositing stencil bit "S" is used to avoid overlapping polygons.

PASS 1a. Draw all non holed "SOLID" polygons which don't clear other
         geometry.

PASS 1b. Draw all "SOLID" polygons with holes.
         --
         In addition to "S", A second stencil bit, "H" is required for
         each of these polygons. Both are masked against. After each
         polygon drawn, a new "S" stencil bit is required.

PASS 2.  Mask out all clearance holes from other geometry.
         --
         As this is a polygon ONLY layer being subcomposited, this masking
         can be done directly on the "S" bit-plane.

PASS 3a. Draw all polygons which only feature clearance holes
PASS 3b. Draw all polygons which have user-defined holes.
         --
         In addition to "S", a second stencil bit, "H" is required for
         each of these polygons. Both are masked against. After each
         polygon drawn, a new "S" stencil bit is required.

NB: In this version. PASS 2 and 3 are carried out concurrently, although
    for boards with heavily overlapping polygons, it may be faster to
    mask out clearance for everything at once.


V2: We have to force a new stencil bit for each piece of a "fullpoly" polygon
as a hole in the first POLYAREA should not prevent a second POLYAREA of the
same polygon being drawn inside that hole. In this regard, we need to treat
"fullpoly" polygons as if they contained user holes.


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 56a3d3a..115b353 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -124,7 +124,7 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
   CHECK_IS_IN_CONTEXT ();
 
   buffer->use_vbo = true;
-  // buffer->use_vbo = false;
+  /* buffer->use_vbo = false; */
 
   if (buffer->use_vbo) {
     glGenBuffers (1, &buffer->vbo_id);
@@ -824,12 +824,19 @@ do_hole (const BoxType *b, void *cl)
   return 1;
 }
 
+static bool
+polygon_contains_user_holes (PolygonType *polygon)
+{
+  return (polygon->HoleIndexN > 0);
+}
+
+
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
 static void
-fill_polyarea (POLYAREA *pa, const BoxType *clip_box)
+fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
 {
   int stencil_bit;
 
@@ -841,14 +848,18 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box)
     return;
   }
 
-  /* Polygon has holes */
-
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
-  if (!stencil_bit)
+  /* Polygon has holes.. does it have any user-drawn holes? (caller tells us)
+   * If so, it must be masked with a _new_ stencil bit.
+   */
+  if (use_new_stencil)
     {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
-      return;
+      stencil_bit = hidgl_assign_clear_stencil_bit ();
+      if (!stencil_bit)
+        {
+          printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+          /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
+          return;
+        }
     }
 
   /* Flush out any existing geoemtry to be rendered */
@@ -856,12 +867,15 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box)
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
-  glStencilMask (stencil_bit);                          /* Only write to our stencil bit */
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, ref value is our bit */
   glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
   glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value */
+  if (use_new_stencil)
+    {
+      glStencilMask (stencil_bit);                            /* Only write to our stencil bit */
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    /* Always pass stencil test, ref value is our bit */
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);             /* Stencil pass => replace stencil value */
+    }
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
@@ -886,7 +900,8 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box)
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+  if (use_new_stencil)
+    hidgl_return_stencil_bit (stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
@@ -894,17 +909,22 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box)
 void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
+  bool use_new_stencil;
+
   if (poly->Clipped == NULL)
     return;
 
-  fill_polyarea (poly->Clipped, clip_box);
+  use_new_stencil = polygon_contains_user_holes (poly) ||
+                    TEST_FLAG (FULLPOLYFLAG, poly);
+
+  fill_polyarea (poly->Clipped, clip_box, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (pa, clip_box);
+        fill_polyarea (pa, clip_box, use_new_stencil);
     }
 }
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 9509692..8727de2 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1317,7 +1317,35 @@ static int
 poly_callback (const BoxType * b, void *cl)
 {
   struct poly_info *i = (struct poly_info *) cl;
-  PolygonType *polygon = (PolygonType *)b;
+  PolygonType *polygon = (PolygonType *) b;
+
+  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
+  gui->graphics->draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_no_clear (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
+  gui->graphics->draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_clearing (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
 
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
   gui->graphics->draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
@@ -1471,7 +1499,8 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (Layer->PolygonN) {
         info.layer = Layer;
         info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
