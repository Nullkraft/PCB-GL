Bottom: e961cc52a2163df9a7d6e3a3913bf1441af70f14
Top:    c7e6d370f34ed0d581671fdc068a70bd2f440768
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-21 12:38:39 +0000

Draw polygons in a more intelligent order

A sub-compositing stencil bit "S" is used to avoid overlapping polygons.

PASS 1a. Draw all non holed "SOLID" polygons which don't clear other
         geometry.

PASS 1b. Draw all "SOLID" polygons with holes.
         --
         In addition to "S", A second stencil bit, "H" is required for
         each of these polygons. Both are masked against. After each
         polygon drawn, a new "S" stencil bit is required.

PASS 2.  Mask out all clearance holes from other geometry.
         --
         As this is a polygon ONLY layer being subcomposited, this masking
         can be done directly on the "S" bit-plane.

PASS 3a. Draw all polygons which only feature clearance holes
PASS 3b. Draw all polygons which have user-defined holes.
         --
         In addition to "S", a second stencil bit, "H" is required for
         each of these polygons. Both are masked against. After each
         polygon drawn, a new "S" stencil bit is required.

NB: In this version. PASS 2 and 3 are carried out concurrently, although
    for boards with heavily overlapping polygons, it may be faster to
    mask out clearance for everything at once.


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index a4a9aa9..ad816d3 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -850,14 +850,23 @@ do_hole (const BoxType *b, void *cl)
   return 1;
 }
 
+static bool
+polygon_contains_user_holes (PolygonType *polygon)
+{
+  return (polygon->HoleIndexN > 0);
+}
+
+
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool force_new_stencil */)
 {
+  bool force_new_stencil = false;
+  bool use_new_stencil;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
@@ -868,59 +877,70 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
       return;
     }
 
-  if (poly->Clipped->contour_tree->size > 1) {
-    /* Polygon has holes */
+  if (poly->Clipped->contour_tree->size == 1)
+    {
+      /* Polygon does not have holes */
+      fill_contour (poly->Clipped->contours);
+      return;
+    }
 
-    stencil_bit = hidgl_assign_clear_stencil_bit ();
-    if (!stencil_bit)
-      {
-        printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-        /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
-        return;
-      }
+  /* Polygon has holes.. does it have any user-drawn holes?
+   * If so, it must be masked with a _new_ stencil bit.
+   */
+  use_new_stencil = force_new_stencil | polygon_contains_user_holes (poly);
 
-    /* Flush out any existing geoemtry to be rendered */
-    hidgl_flush_triangles (&buffer);
+  if (use_new_stencil)
+    {
+      stencil_bit = hidgl_assign_clear_stencil_bit ();
+      if (!stencil_bit)
+        {
+          printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+          /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
+          return;
+        }
+    }
 
-    glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
-                  GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
-    glStencilMask (stencil_bit);                            // Only write to our stencil bit
-    glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
-    glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
 
-    /* It will already be setup like this (so avoid prodding the state-machine):
-     * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
-     */
-    /* Drawing operations now set our reference bit in the stencil buffer */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT |           // Resave the stencil write-mask etc.., and
+                GL_COLOR_BUFFER_BIT);             // the colour buffer write mask etc.. for part way restore
+  glColorMask (0, 0, 0, 0);                       // Disable writting in color buffer
 
-    r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
-    hidgl_flush_triangles (&buffer);
+  if (use_new_stencil)
+    {
+      glStencilMask (stencil_bit);                            // Only write to our stencil bit
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
+    }
 
-    /* Drawing operations as masked to areas where the stencil buffer is '0' */
+  /* It will already be setup like this (so avoid prodding the state-machine):
+   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
+   */
+  /* Drawing operations now set our reference bit in the stencil buffer */
 
-    glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
-    glPushAttrib (GL_STENCIL_BUFFER_BIT);                       // Save the stencil op and function
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
+  hidgl_flush_triangles (&buffer);
 
-    glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
-                                               // If the stencil test has passed, we know that bit is 0, so we're
-                                               // effectively just setting it to 1.
-    glStencilFunc (GL_GEQUAL, 0, assigned_bits);
-  //  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
-                                                                // reference is all assigned bits so we set
-                                                                // any bits permitted by the stencil writemask
-    /* Draw the polygon outer */
-    fill_contour (poly->Clipped->contours);
-    hidgl_flush_triangles (&buffer);
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
-    /* Unassign our stencil buffer bit */
-    hidgl_return_stencil_bit (stencil_bit);
+  glPopAttrib ();                                 // Restore the colour and stencil buffer write-mask etc..
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);           // Save the stencil op and function
 
-    glPopAttrib ();                                             // Restore the stencil buffer op and function
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);      // This allows us to toggle the bit on the subcompositing bitplane
+                                                  // If the stencil test has passed, we know that bit is 0, so we're
+                                                  // effectively just setting it to 1.
+  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
+//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
+                                                  // reference is all assigned bits so we set
+                                                  // any bits permitted by the stencil writemask
+  /* Draw the polygon outer */
+  fill_contour (poly->Clipped->contours);
+  hidgl_flush_triangles (&buffer);
 
-  } else {
-    /* Polygon does not have holes */
-    fill_contour (poly->Clipped->contours);
-  }
+  if (use_new_stencil)
+    hidgl_return_stencil_bit (stencil_bit);       // Unassign our stencil buffer bit
+
+  glPopAttrib ();                                 // Restore the stencil buffer op and function
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 24f4241..840c36d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1280,11 +1280,28 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, const BoxType *dra
 }
 
 static int
-poly_callback (const BoxType * b, void *cl)
+poly_callback_no_clear (const BoxType * b, void *cl)
 {
   struct pin_info *i = (struct pin_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
 
-  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->drawn_area);
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  DrawPlainPolygon (i->Layer, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_clearing (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  DrawPlainPolygon (i->Layer, polygon, i->drawn_area);
   return 1;
 }
 
@@ -1488,7 +1505,8 @@ DrawLayerGroup (int group, const BoxType * screen)
       if (Layer->PolygonN) {
         info.Layer = Layer;
         info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
