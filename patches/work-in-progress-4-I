Bottom: 7ba8eb5aca5ad82043b5e4a33b71a7871a5f9c58
Top:    674c06bccac3ce52f2318addad61f94884cc70d7
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-01-07 01:46:14 +0000

Work in progress


---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 76921b2..a092db1 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -1096,6 +1096,7 @@ _cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t *sweep_line,
             return cmp;
         }
 
+#if 0
 //        printf ("Sweep-line compare edges test\n");
         count = _cairo_bo_edge_intersect ((cairo_bo_edge_t *)a,
                                           (cairo_bo_edge_t *)b,
@@ -1107,6 +1108,7 @@ _cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t *sweep_line,
 //          printf ("HMM, seems they DONT intersect?\n");
           return CAIRO_STATUS_SUCCESS;
         }
+#endif
 
         /* The two edges intersect exactly at y, so fall back on slope
          * comparison. We know that this compare_edges function will be
@@ -1466,6 +1468,17 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
     intersection2.x = -1; /* Shut the compiler up */
     intersection2.y = -1; /* Shut the compiler up */
 
+    if (left->done_insert_node || right->done_insert_node)
+      return CAIRO_STATUS_SUCCESS;
+
+#if 0
+    /* Don't intersect the same contour */
+    if (left->p == right->p)
+      return CAIRO_STATUS_SUCCESS;
+#endif
+
+    /* FIXME: Might need to insist on another iteration */
+
 //    if (_line_equal (&left->edge.line, &right->edge.line))
 //        return CAIRO_STATUS_SUCCESS;
 
@@ -2518,6 +2531,7 @@ cntrbox_adjust (PLINE * c, cairo_point_t p)
 static int
 adjust_tree (PLINE *p, VNODE *v)
 {
+  return 0;
   struct seg *s = lookup_seg (p, v);
   struct seg *q;
 
diff --git a/src/polygon1.c b/src/polygon1.c
index c5cab7d..4372156 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -674,7 +674,7 @@ make_edge_tree (PLINE * pb)
 	}
       s->v = bv;
       s->p = pb;
-      r_insert_entry (ans, (const BoxType *) s, 1);
+//      r_insert_entry (ans, (const BoxType *) s, 1);
     }
   while ((bv = bv->next) != &pb->head);
   return (void *) ans;
@@ -917,8 +917,8 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
 	{
 	  num_new_nodes = bo_intersect (e, a, b, first_pass);
 	  if (!first_pass && num_new_nodes != 0)
-	    printf ("Got %i new nodes with another pass\n", num_new_nodes);
-	  first_pass = 0;
+//          printf ("Got %i new nodes with another pass\n", num_new_nodes);
+	    first_pass = 0;
 	}
       while (num_new_nodes != 0);
