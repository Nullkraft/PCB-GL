Bottom: 9bc8f3beab6508ae50e94aaf6e40bb739cb35771
Top:    602c3da0a7a99da6ab4c0aa3a8b7d8ae2fc58810
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-04-30 16:39:09 +0100

Add basic support for tracking rotation of elements

This allows us to orient the 3D model correctly.

TODO: Wrap-around past 360 degrees...
TODO: Consider storing the footprint internals un-rotated!


---

diff --git a/src/buffer.c b/src/buffer.c
index 5de6542..c03c5d5 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -1238,11 +1238,27 @@ free_rotate (Coord *x, Coord *y, Coord cx, Coord cy, double cosa, double sina)
   *y = ny + cy;
 }
 
+static void
+parse_numeric_attribute (ElementType *element, char *attr_name, double *res)
+{
+  const char *attr_value = AttributeGet (element, attr_name);
+  bool absolute;
+
+  *res = 0.0;
+  if (attr_value == NULL)
+    return;
+
+  *res = COORD_TO_MM (GetValueEx (attr_value, NULL, &absolute, NULL, "mm")); /* KLUDGE */
+}
+
 void
 FreeRotateElementLowLevel (DataType *Data, ElementType *Element,
 			   Coord X, Coord Y,
 			   double cosa, double sina, Angle angle)
 {
+  double rotation;
+  char *value;
+
   /* solder side objects need a different orientation */
 
   /* the text subroutine decides by itself if the direction
@@ -1295,6 +1311,13 @@ FreeRotateElementLowLevel (DataType *Data, ElementType *Element,
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
   ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+
+  /* XXX: Should parse a unit suffix, e.g. "degrees" */
+  parse_numeric_attribute (Element, "PCB::rotation", &rotation);
+  rotation += angle;
+  value = g_strdup_printf ("%f degrees", rotation);
+  AttributePutToList (&Element->Attributes, "PCB::rotation", value, true);
+  g_free (value);
 }
 
 void
diff --git a/src/rotate.c b/src/rotate.c
index fb23ba1..d477d79 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -201,6 +201,19 @@ RotateArcLowLevel (ArcType *Arc, Coord X, Coord Y, unsigned Number)
   ROTATE (Arc->Point2.X, Arc->Point2.Y, X, Y, Number);
 }
 
+static void
+parse_numeric_attribute (ElementType *element, char *attr_name, double *res)
+{
+  const char *attr_value = AttributeGet (element, attr_name);
+  bool absolute;
+
+  *res = 0.0;
+  if (attr_value == NULL)
+    return;
+
+  *res = COORD_TO_MM (GetValueEx (attr_value, NULL, &absolute, NULL, "mm")); /* KLUDGE */
+}
+
 /* ---------------------------------------------------------------------------
  * rotate an element in 90 degree steps
  */
@@ -208,6 +221,9 @@ void
 RotateElementLowLevel (DataType *Data, ElementType *Element,
 		       Coord X, Coord Y, unsigned Number)
 {
+  double rotation;
+  char *value;
+
   /* solder side objects need a different orientation */
 
   /* the text subroutine decides by itself if the direction
@@ -252,6 +268,14 @@ RotateElementLowLevel (DataType *Data, ElementType *Element,
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
   ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+
+
+  /* XXX: Should parse a unit suffix, e.g. "degrees" */
+  parse_numeric_attribute (Element, "PCB::rotation", &rotation);
+  rotation += Number * 90.;
+  value = g_strdup_printf ("%f degrees", rotation);
+  AttributePutToList (&Element->Attributes, "PCB::rotation", value, true);
+  g_free (value);
 }
 
 /* ---------------------------------------------------------------------------
