Bottom: 56a72f6a5b4505ea2b40c4f89ecb49677029ee53
Top:    8b7e9077287084f85de7fa7f77514f5eb1afdd8c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-25 19:10:41 +0000

Add colour to STEP model rendering


---

diff --git a/src/hid/common/appearance.c b/src/hid/common/appearance.c
index e557b43..6efec3b 100644
--- a/src/hid/common/appearance.c
+++ b/src/hid/common/appearance.c
@@ -2,11 +2,31 @@
 
 #include "appearance.h"
 
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+
+
 appearance
 *make_appearance (void)
 {
   appearance *appear = g_new0 (appearance, 1);
 
+  appear->a = 1.0f;
+
   return appear;
 }
 
@@ -25,7 +45,20 @@ appearance_set_color (appearance *appear, float r, float g, float b)
 }
 
 void
+appearance_set_alpha (appearance *appear, float a)
+{
+  appear->a = a;
+}
+
+void
 appearance_set_appearance (appearance *appear, const appearance *from)
 {
   *appear = *from;
 }
+
+void
+appearance_apply_gl (appearance *appear)
+{
+//  glColor3f (appear->r, appear->g, appear->b);
+  glColor4f (appear->r, appear->g, appear->b, appear->a);
+}
diff --git a/src/hid/common/appearance.h b/src/hid/common/appearance.h
index d2bf7b3..ac1cac5 100644
--- a/src/hid/common/appearance.h
+++ b/src/hid/common/appearance.h
@@ -1,8 +1,11 @@
 typedef struct {
   float r, g, b;
+  float a;
 } appearance;
 
 appearance *make_appearance (void);
 void destroy_appearance (appearance *appear);
 void appearance_set_color (appearance *appear, float r, float g, float b);
+void appearance_set_alpha (appearance *appear, float a);
 void appearance_set_appearance (appearance *appear, const appearance *from);
+void appearance_apply_gl (appearance *appear);
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index d0e6721..bcb8d6d 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -1151,6 +1151,7 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
       return;
     }
 
+#if 0
   if (face->is_debug)
     glColor4f (1.0f, 0.0f, 0.0f, 0.5f);
   else if (selected)
@@ -1160,6 +1161,7 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
   else
     glColor4f (0.8f, 0.8f, 0.8f, 1.0f);
 //    glColor4f (0.8f, 0.8f, 0.8f, 0.3f);
+#endif
 
   emit_tristrip (face);
 }
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
index 644f338..97cd278 100644
--- a/src/hid/common/object3d_gl.c
+++ b/src/hid/common/object3d_gl.c
@@ -89,10 +89,42 @@
 
 static GList *object3d_test_objects = NULL;
 
+static appearance *object_default_face_appearance;
+static appearance *object_debug_face_appearance;
+static appearance *object_selected_face_appearance;
+static appearance *object_default_edge_appearance;
+static appearance *object_debug_edge_appearance;
+static appearance *object_selected_edge_appearance;
+
 void
 object3d_test_init (void)
 {
   object3d_test_objects = object3d_from_board_outline ();
+
+  object_default_face_appearance = make_appearance();
+  appearance_set_color (object_default_face_appearance, 0.8f, 0.8f, 0.8f); /* 1.0f */
+  appearance_set_alpha (object_default_face_appearance, 1.0f);
+
+  object_debug_face_appearance = make_appearance();
+  appearance_set_color (object_debug_face_appearance, 1.0f, 0.0f, 0.0f); /* 0.5f */
+  appearance_set_alpha (object_debug_face_appearance, 0.5f);
+
+  object_selected_face_appearance = make_appearance();
+  appearance_set_color (object_selected_face_appearance, 0.0f, 1.0f, 1.0f); /* 0.5f */
+  appearance_set_alpha (object_selected_face_appearance, 0.5f);
+
+  object_default_edge_appearance = make_appearance();
+  appearance_set_color (object_default_edge_appearance, 0.0f, 0.0f, 0.0f); /* 1.0f */
+  appearance_set_alpha (object_default_edge_appearance, 1.0f);
+
+  object_debug_edge_appearance = make_appearance();
+  appearance_set_color (object_debug_edge_appearance, 1.0f, 0.0f, 0.0f); /* 1.0f */
+  appearance_set_alpha (object_debug_edge_appearance, 1.0f);
+
+  object_selected_edge_appearance = make_appearance();
+  appearance_set_color (object_selected_edge_appearance, 0.0f, 1.0f, 1.0f); /* 1.0f */
+  appearance_set_alpha (object_selected_edge_appearance, 1.0f);
+
 }
 
 float colors[12][3] = {{1., 0., 0.},
@@ -114,6 +146,7 @@ float colors[12][3] = {{1., 0., 0.},
 
 struct draw_info {
   hidGC gc;
+  object3d *object;
   bool selected;
   bool debug_face;
 };
@@ -152,15 +185,14 @@ draw_quad_edge (edge_ref e, void *data)
 {
   edge_info *info = UNDIR_DATA(e);
   struct draw_info *d_info = data;
-  double x1, y1, z1;
-  double x2, y2, z2;
+#if 0
   int i;
 
-#if 0
   int id = ID(e) % 12;
 
   glColor3f (colors[id][0], colors[id][1], colors[id][2]);
-#else
+#endif
+#if 0
   if (d_info->selected)
     glColor4f (0.0, 1.0, 1., 1.0);
 //    glColor4f (0.0, 1.0, 1., 0.5);
@@ -169,14 +201,6 @@ draw_quad_edge (edge_ref e, void *data)
 //    glColor4f (1., 1., 1., 0.3);
 #endif
 
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
   if (info == NULL)
     return;
 
@@ -184,7 +208,7 @@ draw_quad_edge (edge_ref e, void *data)
       (info->is_placeholder ||
       d_info->debug_face))
     {
-      glColor4f (1.0, 0.0, 0.0, 1.0);
+//      glColor4f (1.0, 0.0, 0.0, 1.0);
       glDepthMask (TRUE);
       glDisable(GL_DEPTH_TEST);
     }
@@ -208,7 +232,6 @@ draw_contour (contour3d *contour, void *data)
 
   do
     {
-      edge_info *info = UNDIR_DATA(e);
       draw_quad_edge (e, data);
 
       /* LNEXT should take us counter-clockwise around the face */
@@ -225,6 +248,18 @@ draw_face_edges (face3d *face, void *data)
 
   info->debug_face = (face_no == debug_integer);
 //  info->debug_face = face->is_debug;
+
+  if (face->is_debug)
+    appearance_apply_gl (object_debug_edge_appearance);
+  else if (info->selected)
+    appearance_apply_gl (object_selected_edge_appearance);
+//  else if (face->appearance)
+//    appearance_apply_gl (face->apper);
+//  else if (info->object)
+//    appearance_apply_gl (info->object->apper);
+  else
+    appearance_apply_gl (object_default_edge_appearance);
+
   g_list_foreach (face->contours, (GFunc)draw_contour, info);
 
   face_no++;
@@ -236,6 +271,20 @@ draw_face (face3d *face, void *data)
   struct draw_info *info = data;
 
   face->is_debug = (face_no == debug_integer);
+
+  if (face->is_debug)
+    appearance_apply_gl (object_debug_face_appearance);
+  else if (info->selected)
+    appearance_apply_gl (object_selected_face_appearance);
+  else if (face->appear)
+    appearance_apply_gl (face->appear);
+  else if (info->object->appear)
+    appearance_apply_gl (info->object->appear);
+  else
+    appearance_apply_gl (object_default_face_appearance);
+
+  /* Object inherited appearances? */
+
   face3d_fill (info->gc, face, info->selected);
 //  face3d_fill (info->gc, face, (face_no == debug_integer));
 
@@ -263,6 +312,7 @@ object3d_draw (hidGC gc, object3d *object, bool selected)
   g_return_if_fail (object->edges != NULL);
 
   info.gc = gc;
+  info.object = object;
   info.selected = selected;
 
 //  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index eb22cbe..f01cedb 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -64,7 +64,7 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #define STEP_TO_COORD_Y(pcb, y) ((pcb->MaxHeight) - MM_TO_COORD((y)))
 #define STEP_TO_COORD_Z(pcb, z) ( MM_TO_COORD((z)))
 
-//#define VIEW_ORTHO
+#define VIEW_ORTHO
 
 extern HID ghid_hid;
 extern HID_DRAW ghid_graphics;
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index f6258c8..9d3763a 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -189,6 +189,233 @@ find_mapped_item (SdaiShape_representation *sr,
     }
 }
 
+/* XXX: This doesn't really follow the correct STEP approach here,
+ *      but we just start by looking whether we can find a styled_item
+ *      or overriding_styled_item pointing towards the item in question,
+ *      then retrieve its styling.
+ */
+
+static GHashTable *
+build_hash_of_styled_items (InstMgr *instance_list)
+{
+  /* NB: NULLs give g_direct_hash and g_direct_equal */
+  GHashTable *table = g_hash_table_new (NULL, NULL);
+
+  MgrNode * mnode = NULL;
+  int search_index;
+  SDAI_Application_instance *entity;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
+
+  while (ENTITY_NULL != (entity = instance_list->GetApplication_instance ("Styled_Item", search_index)))
+    {
+      SdaiStyled_item *si = static_cast<SdaiStyled_item *>(entity);
+
+      g_hash_table_insert (table, si->item_ (), (void *)si);
+
+      int id = entity->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+
+  mnode = NULL;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
+
+  while (ENTITY_NULL != (entity = instance_list->GetApplication_instance ("Over_Riding_Styled_Item", search_index)))
+    {
+      SdaiStyled_item *si = static_cast<SdaiStyled_item *>(entity);
+
+      g_hash_table_insert (table, si->item_ (), (void *)si);
+
+      int id = entity->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+
+  return table;
+}
+
+static EntityAggregate *
+find_styles_for_item (GHashTable *table, SDAI_Application_instance *item)
+{
+  /* When reading a STYLED_ITEM with item pointing to an ABSR entity (as Solidworks
+   * likes to emit, for product-wide colouring, STEPcode reads the item entity
+   * pointer as NULL_ENTITY, since ABSR doesn't match the type expected by
+   * the item property.
+   *
+   * We take a guess, and assume this is the only one - so if we look up NULL_ENTITY
+   * in the hash table, we find the correct corresponding STYLED_ITEM.
+   *
+   * XXX: This might not be the case unfortunately, e.g. an assembly with multiple
+   *      ABSR with errant STYLED_ITEM pointers associated. (Need to teach STEPcode
+   *      to store the incorrect pointer for us, or to be more lenient with this case.
+   */
+  if (!strcmp (item->EntityName (), "Advanced_Brep_Shape_Representation"))
+    {
+      item = NULL_ENTITY;
+    }
+
+  auto si = static_cast<SdaiStyled_item *>(g_hash_table_lookup (table, item));
+
+  if (si == NULL)
+    return NULL;
+
+  return si->styles_ ();
+}
+
+/* XXX: Does not pay paticularly much attention to specifics of how the STEP style
+ *      is defined to apply. Surface side, edge/face, etc... all we are really
+ *      interested in is extracting the required colour in the majority of cases.
+ */
+static appearance *
+make_appearance_for_styles (EntityAggregate *styles)
+{
+  /* Try to find path through from styles:
+   *
+   * SdaiPresentation_style_assignment *psa = styles[i];
+   * SdaiPresentation_style_select *pss = psa->styles[j];
+   * (One of:
+   *    pre_defined_presentation_style
+   *    point_style
+   *    curve_style
+   *    surface_style_usage          <--- Likely to find this one first
+   *    symbol_style
+   *    fill_area_style              <--- Eventually looking for this one?
+   *    text_style,
+   *    approximation_tolerance
+   *    externally_defined_style
+   *    null_style
+   * )
+   *
+   * SdaiSurface_style_usage *ssu = *pss;
+   * Ignore side specification given by ssu->side;
+   * SdaiSurface_side_style_select *ssss = ssu->style;
+   * SdaiSurface_side_style *sss = *ssss;
+   * SdaiSurface_style_element_select *sses = sss->styles[k]; 1-7 parts
+   * (One of:
+   *    surface_style_fill_area          <--- Looking for this one
+   *    surface_style_boundary
+   *    surface_style_silhouette
+   *    surface_style_segmentation_curve
+   *    surface_style_control_grid
+   *    surface_style_parameter_line
+   *    surface_style_rendering
+   * )
+   * SdaiSurface_style_fill_area *ssfa = *sses;
+   * SdaiFill_area_style *fas = ssfa->fill_area;   <--- WOOT.. NEARLY THERE!!
+   * SdaiFill_style_select *fss = fas->fill_styles[l];
+   * (One of:
+   *    fill_area_style_colour               <--- Looking for this one
+   *    externally_defined_tile_style
+   *    fill_area_style_tiles
+   *    externally_defined_hatch_style
+   *    fill_area_style_hatching
+   * )
+   * SdaiFill_area_style_colour *fasc = *fss;
+   * SdaiColour *fc = fasc->fill_colour;
+   * SdaiColour_Rgb *scr = dynamic_cast<SdaiColour_Rgb *>(fc);
+   * r = scr->red;
+   * g = scr->green;
+   * b = scr->blue;
+   */
+
+  for (EntityNode * psa_iter = static_cast<EntityNode *>(styles->GetHead ());
+       psa_iter != NULL;
+       psa_iter = static_cast<EntityNode *>(psa_iter->NextNode ()))
+    {
+      auto *psa = dynamic_cast<SdaiPresentation_style_assignment *>(psa_iter->node);
+
+      if (psa == NULL)
+        {
+          printf ("psa == NULL\n");
+          continue;
+        }
+
+      for (SelectNode * pss_iter = static_cast<SelectNode *>(psa->styles_ ()->GetHead ());
+           pss_iter != NULL;
+           pss_iter = static_cast<SelectNode *>(pss_iter->NextNode ()))
+        {
+          auto *pss = static_cast<SdaiPresentation_style_select *>(pss_iter->node);
+
+          if (pss == NULL)
+            {
+              printf ("pss == NULL\n");
+              continue;
+            }
+
+          if (pss->IsFill_area_style ())
+            {
+              printf ("Found a FILL_AREA_STYLE example... investigate!\n");
+            }
+          else if (!pss->IsSurface_style_usage ())
+            {
+              continue;
+            }
+
+          SdaiSurface_style_usage *ssu = *pss;
+
+//          printf ("Found a SSU.. (Side = %i)\n", (int)ssu->side_ ());
+
+          SdaiSurface_side_style_select *ssss = ssu->style_ ();
+          SdaiSurface_side_style *sss = *ssss;
+
+          for (SelectNode * sses_iter = static_cast<SelectNode *>(sss->styles_ ()->GetHead ());
+               sses_iter != NULL;
+               sses_iter = static_cast<SelectNode *>(sses_iter->NextNode ()))
+            {
+              auto *sses = static_cast<SdaiSurface_style_element_select *>(sses_iter->node);
+
+              if (!sses->IsSurface_style_fill_area ())
+                {
+                  continue;
+                }
+
+              SdaiSurface_style_fill_area *ssfa = *sses;
+              SdaiFill_area_style *fas = ssfa->fill_area_ ();
+
+              for (SelectNode * fss_iter = static_cast<SelectNode *>(fas->fill_styles_ ()->GetHead ());
+                   fss_iter != NULL;
+                   fss_iter = static_cast<SelectNode *>(fss_iter->NextNode ()))
+                {
+                  auto *fss = static_cast<SdaiFill_style_select *>(fss_iter->node);
+
+                  if (!fss->IsFill_area_style_colour ())
+                    {
+                      continue;
+                    }
+
+                  SdaiFill_area_style_colour *fasc = *fss;
+                  SdaiColour *fc = fasc->fill_colour_ ();
+                  SdaiColour_rgb *scr = dynamic_cast<SdaiColour_rgb *>(fc);
+
+                  if (scr == NULL)
+                    {
+                      printf ("Colour appears not to be COLOUR_RGB\n");
+                      continue;
+                    }
+
+                  float r = scr->red_ ();
+                  float g = scr->green_ ();
+                  float b = scr->blue_ ();
+
+                  appearance *appear = make_appearance ();
+                  appearance_set_color (appear, r, g, b);
+                  return appear;
+                }
+            }
+        }
+    }
+
+  return NULL;
+}
+
 static void
 unpack_axis_geom (SdaiAxis2_placement_3d *axis,
                   double *ox, double *oy, double *oz,
@@ -212,6 +439,7 @@ typedef struct process_step_info {
   face3d *current_face;
   contour3d *current_contour;
   double current_transform[4][4];
+  GHashTable *styled_items;
 
 } process_step_info;
 
@@ -753,7 +981,6 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
 static void
 process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, process_step_info *info)
 {
-  GHashTableIter iter;
   vertex3d *vertex;
   double x1, y1, z1;
   double x2, y2, z2;
@@ -1199,6 +1426,19 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
       return NULL;
     }
 
+  /* XXX: Solidworks seems to attach a STYLED_ITEM entity to the ABSR, however this is NOT legal AP214,
+   *      so STEPcode may not correctly read the STYLED_ITEM instance. (It does type checking of the item
+   *      pointed to in the STYLED_ITEM.
+   */
+  EntityAggregate *illegal_absr_styles = find_styles_for_item (info->styled_items, sr);
+  appearance *illegal_absr_appear = NULL;
+  if (illegal_absr_styles != NULL)
+    {
+      printf ("Found style list for ABSR (illegal, but Solidworks does this))\n");
+//      destroy_appearance (info->object->appear);
+      illegal_absr_appear = make_appearance_for_styles (illegal_absr_styles);
+    }
+
 //  object = make_object3d ((char *)"Test");
 
   step_model = g_new0(struct step_model, 1);
@@ -1229,6 +1469,25 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 
   for (msb_list::iterator iter = msb_list.begin (); iter != msb_list.end (); iter++)
     {
+
+      /* XXX: Default to the illegal ABSR appearance (Thanks Solidworks!) */
+      info->object->appear = illegal_absr_appear;
+
+      EntityAggregate *solid_styles = find_styles_for_item (info->styled_items, (*iter));
+      if (solid_styles != NULL)
+        {
+//          printf ("Found style list for solid\n");
+//          destroy_appearance (info->object->appear);
+          info->object->appear = make_appearance_for_styles (solid_styles);
+#if 0
+          printf ("Colour %f, %f, %f\n",
+                  (double)info->object->appear->r,
+                  (double)info->object->appear->g,
+                  (double)info->object->appear->b);
+#endif
+        }
+
+
 //      std::cout << "Found MANIFOLD_SOLID_BREP; processing" << std::endl;
       SdaiClosed_shell *cs = (*iter)->outer_ ();
 
@@ -1236,6 +1495,21 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 
 //      std::cout << "Closed shell is " << cs << std::endl;
 
+      EntityAggregate *shell_styles = find_styles_for_item (info->styled_items, cs);
+      if (shell_styles != NULL)
+        {
+//          printf ("Found style list for shell\n");
+//          destroy_appearance (info->object->appear);
+          info->object->appear = make_appearance_for_styles (shell_styles);
+#if 0
+          printf ("Colour %f, %f, %f\n",
+                  (double)info->object->appear->r,
+                  (double)info->object->appear->g,
+                  (double)info->object->appear->b);
+#endif
+        }
+
+
       /* NB: NULLs give g_direct_hash and g_direct_equal */
       edges_hash_set = g_hash_table_new (NULL, NULL);
 
@@ -1244,6 +1518,7 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
            iter = iter->NextNode ())
         {
           SdaiFace *face = (SdaiFace *)((EntityNode *)iter)->node;
+          EntityAggregate *face_styles = find_styles_for_item (info->styled_items, face);
 
           /* XXX: Do we look for specific types of face at this point? (Expect ADVANCED_FACE usually?) */
           if (strcmp (face->EntityName (), "Advanced_Face") != 0)
@@ -1266,6 +1541,36 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           info->current_face->face_identifier = fs->StepFileId ();
           object3d_add_face (info->object, info->current_face);
 
+          if (face_styles != NULL)
+            {
+//              printf ("Found style list for face\n");
+//              destroy_appearance (info->current_face->appear);
+              info->current_face->appear = make_appearance_for_styles (face_styles);
+#if 0
+              printf ("Colour %f, %f, %f\n",
+                      (double)info->current_face->appear->r,
+                      (double)info->current_face->appear->g,
+                      (double)info->current_face->appear->b);
+#endif
+               }
+
+          /* XXX: KLUDGE TO FIX THE FACT WE DON'T SUPPORT MULTIPLE BODIES, HENCE KEEP
+           *      OVER-WRITING THE VARIOUS PARENT STYLES IN THE object3d EACH TIME WE
+           *      ENCOUNTER A NEW SOLID BODY, OR SUB-ASSEMBLY PART
+           */
+          if (info->current_face->appear == NULL)
+            {
+//              printf ("Defauting face to solid appearance\n");
+              info->current_face->appear = info->object->appear;
+#if 0
+              printf ("Colour %f, %f, %f\n",
+                      (double)info->current_face->appear->r,
+                      (double)info->current_face->appear->g,
+                      (double)info->current_face->appear->b);
+#endif
+            }
+
+
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1679,6 +1984,8 @@ step_model_to_shape_master (const char *filename)
   info.object = make_object3d ((char *)"Test");
   identity_4x4 (info.current_transform);
 
+  info.styled_items = build_hash_of_styled_items (instance_list);
+
   step_model = process_sr_or_subtype (instance_list, sr, &info);
 
   if (step_model != NULL)
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 800f713..1e9d359 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -107,7 +107,7 @@ make_3d_metric_step_geometric_representation_context (step_file *file)
   fprintf (file->f, "#%i=(GEOMETRIC_REPRESENTATION_CONTEXT(3)"
                           "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT((#%i))"
                           "GLOBAL_UNIT_ASSIGNED_CONTEXT((#%i,#%i,#%i))"
-                          "REPRESENTATION_CONTEXT('NONE','WORKASPACE'));\n",
+                          "REPRESENTATION_CONTEXT('NONE','WORKSPACE'));\n",
                     file->next_id + 4, file->next_id + 3, file->next_id, file->next_id + 1, file->next_id + 2);
   file->next_id += 4;
