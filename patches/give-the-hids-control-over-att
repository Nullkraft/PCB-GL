Bottom: bc63ea7fd6a39e18f813e5cc86541a362e44cffa
Top:    2fb00fe37b6b90ceedd35dbc93a350e5efb254bf
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-21 16:19:13 +0100

Give the HIDs control over attached object (crosshair, mark) drawing

This is required if a renderer doesn't want to follow the current
drawing model where it is assumed the core can call the HID's
drawing APIs at any arbitrary point in time.

Expose some API from crosshair.c to perform the actual drawing on
demand, and add hooks to the HID structure to notify the GUI when it
would previously have called the crosshair or mark drawing routines.

This allows renderers with defined setup and tear-down requirements
around drawing to execute them before the objects are drawn.

CrosshairOn() and CrosshairOff() now simply set the Crosshair.On flag
and call the appropriate notification hooks.

This commit replaces all HideCrosshair() and RestoreCrosshair() calls
with the new hooks notify_{crosshair|mark}_changed(), with an argument
specifying whether a change is about to happen (false argument), or has
been completed (true argument).


---

diff --git a/src/action.c b/src/action.c
index e5a463f..a0577e4 100644
--- a/src/action.c
+++ b/src/action.c
@@ -607,7 +607,7 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
@@ -650,7 +650,7 @@ click_cb (hidval hv)
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }
 
@@ -945,7 +945,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair ();
+  notify_crosshair_change (false);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -960,7 +960,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 
@@ -2122,11 +2122,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2152,10 +2152,9 @@ EventMoveCrosshair (int ev_x, int ev_y)
     {
       if (MoveCrosshairAbsolute (ev_x, ev_y))
 	{
-
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	}
     }
   else
@@ -2731,7 +2730,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_CycleClip:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  if TEST_FLAG
 	    (ALLDIRECTIONFLAG, PCB)
 	    {
@@ -2741,27 +2740,27 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  else
 	    PCB->Clipping = (PCB->Clipping + 1) % 3;
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_CycleCrosshair:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  Crosshair.shape = CrosshairShapeIncrement(Crosshair.shape);
 	  if (Crosshair_Shapes_Number == Crosshair.shape)
 	    Crosshair.shape = Basic_Crosshair_Shape;
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleRubberBandMode:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (RUBBERBANDFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleStartDirection:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleUniqueNames:
@@ -2769,9 +2768,9 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleSnapPin:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SNAPPINFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleLocalRef:
@@ -2812,7 +2811,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleAutoDRC:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
@@ -2826,7 +2825,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleCheckPlanes:
@@ -2864,7 +2863,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (Crosshair.X, Crosshair.Y))
-	      RestoreCrosshair ();	/* was hidden by MoveCrosshairAbs */
+	      notify_crosshair_change (true);	/* first notify was in MoveCrosshairAbs */
 	    SetGrid (oldGrid, true);
 	  }
 	  break;
@@ -3068,7 +3067,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3264,7 +3263,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
 
@@ -4039,24 +4038,27 @@ ActionMarkCrosshair (int argc, char **argv, int x, int y)
     {
       if (Marked.status)
 	{
-	  DrawMark ();
+	  notify_mark_change (false);
 	  Marked.status = false;
+	  notify_mark_change (true);
 	}
       else
 	{
+	  notify_mark_change (false);
+	  Marked.status = false;
 	  Marked.status = true;
 	  Marked.X = Crosshair.X;
 	  Marked.Y = Crosshair.Y;
-	  DrawMark ();
+	  notify_mark_change (true);
 	}
     }
   else if (GetFunctionID (function) == F_Center)
     {
-      DrawMark ();
+      notify_mark_change (false);
       Marked.status = true;
       Marked.X = Crosshair.X;
       Marked.Y = Crosshair.Y;
-      DrawMark ();
+      notify_mark_change (true);
     }
   return 0;
 }
@@ -5450,7 +5452,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, true))
@@ -5458,7 +5460,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5629,7 +5631,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, false))
@@ -5637,7 +5639,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5868,18 +5870,18 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "LayoutToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadLayoutToBuffer (PASTEBUFFER, name))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "Layout") == 0)
@@ -5936,7 +5938,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (!name)
         return 1;
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       /* do emergency saving
        * clear the old struct and allocate memory for the new one
        */
@@ -5958,7 +5960,7 @@ ActionNew (int argc, char **argv, int x, int y)
       ClearAndRedrawOutput ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
   return 1;
@@ -6045,7 +6047,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair ();
+  notify_crosshair_change (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -6152,7 +6154,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair ();
+		notify_crosshair_change (false);
 		AFAIL (pastebuffer);
 	      }
 
@@ -6175,7 +6177,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6216,13 +6218,13 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if ((Settings.Mode == POLYGON_MODE ||
            Settings.Mode == POLYGONHOLE_MODE) &&
           Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6234,7 +6236,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
 	      SetLocalRef (0, 0, false);
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6262,7 +6264,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair ();
+		  notify_crosshair_change (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6309,7 +6311,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	}
@@ -6318,7 +6320,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6353,7 +6355,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6386,7 +6388,7 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (Redo (true))
     {
       SetChangedFlag (true);
@@ -6401,7 +6403,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6435,7 +6437,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6448,7 +6450,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   return 0;
 }
@@ -6612,24 +6614,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6638,13 +6640,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
diff --git a/src/buffer.c b/src/buffer.c
index 43d5c2b..75ab94a 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -521,12 +521,9 @@ void
 AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
 		     bool LeaveSelected)
 {
-  /* switch crosshair off because adding objects to the pastebuffer
-   * may change the 'valid' area for the cursor
-   */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Source = PCB->Data;
   Dest = Buffer->Data;
   SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
@@ -542,7 +539,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ExtraFlag = 0;
 }
 
@@ -1457,9 +1454,9 @@ ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
   else
     angle_s = argv[0];
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   FreeRotateBuffer(PASTEBUFFER, strtod(angle_s, 0));
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 054610b..b0ef6f8 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -66,15 +66,6 @@ typedef struct
 } point;
 
 /* ---------------------------------------------------------------------------
- * some local identifiers
- */
-
-/* This is a stack for HideCrosshair() and RestoreCrosshair() calls. They
- * must always be matched. */
-static bool CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
-static int CrosshairStackLocation = 0;
-
-/* ---------------------------------------------------------------------------
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
@@ -706,17 +697,68 @@ DrawMark (void)
 
 
 /* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the crosshair is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the crosshair attached objects - which may
+ * (if necessary) mean repainting the whole screen if the GUI hasn't tracked the
+ * location of existing attached drawing.
+ */
+void
+notify_crosshair_change (bool changes_complete)
+{
+  if (gui->notify_crosshair_change)
+    gui->notify_crosshair_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the mark is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the mark - which may (if necessary) mean
+ * repainting the whole screen if the GUI hasn't tracked the mark's location.
+ */
+void
+notify_mark_change (bool changes_complete)
+{
+  if (gui->notify_mark_change)
+    gui->notify_mark_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
  * switches crosshair on
  */
 void
 CrosshairOn (void)
 {
-  if (!Crosshair.On)
-    {
-      Crosshair.On = true;
-      DrawAttached ();
-      DrawMark ();
-    }
+  if (Crosshair.On)
+    return;
+
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
+
+  Crosshair.On = true;
+
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -725,54 +767,63 @@ CrosshairOn (void)
 void
 CrosshairOff (void)
 {
-  if (Crosshair.On)
-    {
-      DrawAttached ();
-      DrawMark ();
-      Crosshair.On = false;
-    }
+  if (!Crosshair.On)
+    return;
+
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
+
+  Crosshair.On = false;
+
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 /* ---------------------------------------------------------------------------
- * saves crosshair state (on/off) and hides him
+ * Convenience for plugins using the old {Hide,Restore}Crosshair API.
+ * This links up to notify the GUI of the expected changes using the new APIs.
+ *
+ * Use of this old API is deprecated, as the names don't necessarily reflect
+ * what all GUIs may do in response to the notifications. Keeping these APIs
+ * is aimed at easing transition to the newer API, they will emit a harmless
+ * warning at the time of their first use.
+ *
  */
 void
-HideCrosshair ()
+HideCrosshair (void)
 {
-  /* fprintf(stderr, "HideCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation overflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API HideCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStack[CrosshairStackLocation] = Crosshair.On;
-  CrosshairStackLocation++;
-
-  CrosshairOff ();
+  notify_crosshair_change (false);
+  notify_mark_change (false);
 }
 
-/* ---------------------------------------------------------------------------
- * restores last crosshair state
- */
 void
 RestoreCrosshair (void)
 {
-  /* fprintf(stderr, "RestoreCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation <= 0)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation underflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API RestoreCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStackLocation--;
-
-  if (CrosshairStack[CrosshairStackLocation])
-    CrosshairOn ();
-  else
-    CrosshairOff ();
+  notify_crosshair_change (true);
+  notify_mark_change (true);
 }
 
+/* ---------------------------------------------------------------------------
+ * Returns the square of the given number
+ */
 static double
 square (double x)
 {
@@ -1064,8 +1115,8 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 }
 
 /* ---------------------------------------------------------------------------
- * move crosshair absolute switched off if it moved
- * return true if it switched off
+ * move crosshair absolute
+ * return true if the crosshair was moved from its existing position
  */
 bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
@@ -1076,13 +1127,14 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
   FitCrosshairIntoGrid (X, Y);
   if (Crosshair.X != x || Crosshair.Y != y)
     {
-      /* back up to old position and erase crosshair */
+      /* back up to old position to notify the GUI
+       * (which might want to erase the old crosshair) */
       z = Crosshair.X;
       Crosshair.X = x;
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair ();
+      notify_crosshair_change (false); /* Our caller notifies when it has done */
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
@@ -1109,8 +1161,7 @@ SetCrosshairRange (LocationType MinX, LocationType MinY, LocationType MaxX,
 
 /* ---------------------------------------------------------------------------
  * initializes crosshair stuff
- * clears the struct, allocates to graphical contexts and
- * initializes the stack
+ * clears the struct, allocates to graphical contexts
  */
 void
 InitCrosshair (void)
@@ -1122,9 +1173,6 @@ InitCrosshair (void)
   gui->set_line_cap (Crosshair.GC, Trace_Cap);
   gui->set_line_width (Crosshair.GC, 1);
 
-  /* fake a crosshair off entry on stack */
-  CrosshairStackLocation = 0;
-  CrosshairStack[CrosshairStackLocation++] = true;
   Crosshair.On = true;
 
   /* set initial shape */
diff --git a/src/crosshair.h b/src/crosshair.h
index ff16b1e..efa6679 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -46,6 +46,8 @@
 #define	STATE_SECOND	1
 #define	STATE_THIRD		2
 
+void notify_crosshair_change (bool changes_complete);
+void notify_mark_change (bool changes_complete);
 void CrosshairOn (void);
 void CrosshairOff (void);
 void HideCrosshair (void);
diff --git a/src/draw.c b/src/draw.c
index 8b9b86a..e02fef7 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -180,15 +180,11 @@ UpdateAll (void)
 void
 Draw (void)
 {
-  HideCrosshair ();
-
   /* clear and create event if not drawing to a pixmap
    */
   if (Block.X1 <= Block.X2 && Block.Y1 <= Block.Y2)
     gui->invalidate_lr (Block.X1, Block.X2, Block.Y1, Block.Y2);
 
-  RestoreCrosshair ();
-
   /* shrink the update block */
   Block.X1 = Block.Y1 =  MAXINT;
   Block.X2 = Block.Y2 = -MAXINT;
diff --git a/src/hid.h b/src/hid.h
index 0a81ddd..36aca75 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -298,6 +298,8 @@ typedef enum
     /* This may be called to ask the GUI to force a redraw of a given area */
     void (*invalidate_lr) (int left_, int right_, int top_, int bottom_);
     void (*invalidate_all) (void);
+    void (*notify_crosshair_change) (bool changes_complete);
+    void (*notify_mark_change) (bool changes_complete);
 
     /* During redraw or print/export cycles, this is called once per
        layer (or layer group, for copper layers).  If it returns false
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 1568cd5..84ceda3 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -444,6 +444,8 @@ HID hid_nogui = {
   nogui_parse_arguments,
   nogui_invalidate_lr,
   nogui_invalidate_all,
+  0 /* nogui_notify_crosshair_change */ ,
+  0 /* nogui_notify_mark_change */ ,
   nogui_set_layer,
   nogui_make_gc,
   nogui_destroy_gc,
@@ -505,6 +507,8 @@ apply_default_hid (HID * d, HID * s)
   AD (parse_arguments);
   AD (invalidate_lr);
   AD (invalidate_all);
+  AD (notify_crosshair_change);
+  AD (notify_mark_change);
   AD (set_layer);
   AD (make_gc);
   AD (destroy_gc);
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index ba58d5d..3d90c27 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -34,6 +34,8 @@ typedef struct render_priv {
   GdkGC *mask_gc;
   GdkGC *u_gc;
   GdkGC *grid_gc;
+  int attached_invalidate_depth;
+  int mark_invalidate_depth;
 } render_priv;
 
 
@@ -709,6 +711,7 @@ ghid_invalidate_lr (int left, int right, int top, int bottom)
   ghid_invalidate_all ();
 }
 
+
 void
 ghid_invalidate_all ()
 {
@@ -770,12 +773,70 @@ ghid_invalidate_all ()
 
   hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_grid ();
-  if (ghidgui->need_restore_crosshair)
-    RestoreCrosshair ();
-  ghidgui->need_restore_crosshair = FALSE;
+
+  if (priv->attachment_invalidate_depth == 0)
+    DrawAttached ();
+  if (priv->mark_invalidate_depth == 0)
+    DrawMark ();
+
   ghid_screen_update ();
 }
 
+
+void
+ghid_notify_crosshair_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (priv->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->attached_invalidate_depth --;
+
+  if (priv->attached_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_crosshair_change calls\n");
+      priv->attached_invalidate_depth = 0;
+    }
+
+  if (priv->attached_invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    priv->attached_invalidate_depth ++;
+  else if (priv->drawing_area != NULL)
+    ghid_draw_area_update (priv, NULL);
+}
+
+void
+ghid_notify_mark_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (priv->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->mark_invalidate_depth --;
+
+  if (priv->mark_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_mark_change calls\n");
+      priv->mark_invalidate_depth = 0;
+    }
+
+  if (priv->mark_invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    priv->mark_invalidate_depth ++;
+  else
+    ghid_draw_area_update (priv, NULL);
+}
+
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 5af6ed6..8397978 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1838,11 +1838,11 @@ ScrollAction (int argc, char **argv, int x, int y)
   else
     AFAIL (scroll);
 
-  HideCrosshair ();
   ghid_port_ranges_pan (dx, dy, TRUE);
+  notify_crosshair_change (false);
   MoveCrosshairRelative (dx, dy);
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   return 0;
 }
@@ -2102,60 +2102,62 @@ hid_gtk_init ()
 
   common_draw_helpers_init (&ghid_hid);
 
-  ghid_hid.struct_size          = sizeof (HID);
-  ghid_hid.name                 = "gtk";
-  ghid_hid.description          = "Gtk - The Gimp Toolkit";
-  ghid_hid.gui                  = 1;
-  ghid_hid.poly_after           = 1;
-
-  ghid_hid.get_export_options   = ghid_get_export_options;
-  ghid_hid.do_export            = ghid_do_export;
-  ghid_hid.parse_arguments      = ghid_parse_arguments;
-  ghid_hid.invalidate_lr        = ghid_invalidate_lr;
-  ghid_hid.invalidate_all       = ghid_invalidate_all;
-  ghid_hid.set_layer            = ghid_set_layer;
-  ghid_hid.make_gc              = ghid_make_gc;
-  ghid_hid.destroy_gc           = ghid_destroy_gc;
-  ghid_hid.use_mask             = ghid_use_mask;
-  ghid_hid.set_color            = ghid_set_color;
-  ghid_hid.set_line_cap         = ghid_set_line_cap;
-  ghid_hid.set_line_width       = ghid_set_line_width;
-  ghid_hid.set_draw_xor         = ghid_set_draw_xor;
-  ghid_hid.set_draw_faded       = ghid_set_draw_faded;
-  ghid_hid.set_line_cap_angle   = ghid_set_line_cap_angle;
-  ghid_hid.draw_line            = ghid_draw_line;
-  ghid_hid.draw_arc             = ghid_draw_arc;
-  ghid_hid.draw_rect            = ghid_draw_rect;
-  ghid_hid.fill_circle          = ghid_fill_circle;
-  ghid_hid.fill_polygon         = ghid_fill_polygon;
-  ghid_hid.fill_rect            = ghid_fill_rect;
-
-  ghid_hid.calibrate            = ghid_calibrate;
-  ghid_hid.shift_is_pressed     = ghid_shift_is_pressed;
-  ghid_hid.control_is_pressed   = ghid_control_is_pressed;
-  ghid_hid.mod1_is_pressed      = ghid_mod1_is_pressed,
-  ghid_hid.get_coords           = ghid_get_coords;
-  ghid_hid.set_crosshair        = ghid_set_crosshair;
-  ghid_hid.add_timer            = ghid_add_timer;
-  ghid_hid.stop_timer           = ghid_stop_timer;
-  ghid_hid.watch_file           = ghid_watch_file;
-  ghid_hid.unwatch_file         = ghid_unwatch_file;
-  ghid_hid.add_block_hook       = ghid_add_block_hook;
-  ghid_hid.stop_block_hook      = ghid_stop_block_hook;
-
-  ghid_hid.log                  = ghid_log;
-  ghid_hid.logv                 = ghid_logv;
-  ghid_hid.confirm_dialog       = ghid_confirm_dialog;
-  ghid_hid.close_confirm_dialog = ghid_close_confirm_dialog;
-  ghid_hid.report_dialog        = ghid_report_dialog;
-  ghid_hid.prompt_for           = ghid_prompt_for;
-  ghid_hid.fileselect           = ghid_fileselect;
-  ghid_hid.attribute_dialog     = ghid_attribute_dialog;
-  ghid_hid.show_item            = ghid_show_item;
-  ghid_hid.beep                 = ghid_beep;
-  ghid_hid.progress             = ghid_progress;
-  ghid_hid.drc_gui              = &ghid_drc_gui,
-  ghid_hid.edit_attributes      = ghid_attributes;
+  ghid_hid.struct_size              = sizeof (HID);
+  ghid_hid.name                     = "gtk";
+  ghid_hid.description              = "Gtk - The Gimp Toolkit";
+  ghid_hid.gui                      = 1;
+  ghid_hid.poly_after               = 1;
+
+  ghid_hid.get_export_options       = ghid_get_export_options;
+  ghid_hid.do_export                = ghid_do_export;
+  ghid_hid.parse_arguments          = ghid_parse_arguments;
+  ghid_hid.invalidate_lr            = ghid_invalidate_lr;
+  ghid_hid.invalidate_all           = ghid_invalidate_all;
+  ghid_hid.notify_crosshair_change  = ghid_notify_crosshair_change;
+  ghid_hid.notify_mark_change       = ghid_notify_mark_change;
+  ghid_hid.set_layer                = ghid_set_layer;
+  ghid_hid.make_gc                  = ghid_make_gc;
+  ghid_hid.destroy_gc               = ghid_destroy_gc;
+  ghid_hid.use_mask                 = ghid_use_mask;
+  ghid_hid.set_color                = ghid_set_color;
+  ghid_hid.set_line_cap             = ghid_set_line_cap;
+  ghid_hid.set_line_width           = ghid_set_line_width;
+  ghid_hid.set_draw_xor             = ghid_set_draw_xor;
+  ghid_hid.set_draw_faded           = ghid_set_draw_faded;
+  ghid_hid.set_line_cap_angle       = ghid_set_line_cap_angle;
+  ghid_hid.draw_line                = ghid_draw_line;
+  ghid_hid.draw_arc                 = ghid_draw_arc;
+  ghid_hid.draw_rect                = ghid_draw_rect;
+  ghid_hid.fill_circle              = ghid_fill_circle;
+  ghid_hid.fill_polygon             = ghid_fill_polygon;
+  ghid_hid.fill_rect                = ghid_fill_rect;
+
+  ghid_hid.calibrate                = ghid_calibrate;
+  ghid_hid.shift_is_pressed         = ghid_shift_is_pressed;
+  ghid_hid.control_is_pressed       = ghid_control_is_pressed;
+  ghid_hid.mod1_is_pressed          = ghid_mod1_is_pressed,
+  ghid_hid.get_coords               = ghid_get_coords;
+  ghid_hid.set_crosshair            = ghid_set_crosshair;
+  ghid_hid.add_timer                = ghid_add_timer;
+  ghid_hid.stop_timer               = ghid_stop_timer;
+  ghid_hid.watch_file               = ghid_watch_file;
+  ghid_hid.unwatch_file             = ghid_unwatch_file;
+  ghid_hid.add_block_hook           = ghid_add_block_hook;
+  ghid_hid.stop_block_hook          = ghid_stop_block_hook;
+
+  ghid_hid.log                      = ghid_log;
+  ghid_hid.logv                     = ghid_logv;
+  ghid_hid.confirm_dialog           = ghid_confirm_dialog;
+  ghid_hid.close_confirm_dialog     = ghid_close_confirm_dialog;
+  ghid_hid.report_dialog            = ghid_report_dialog;
+  ghid_hid.prompt_for               = ghid_prompt_for;
+  ghid_hid.fileselect               = ghid_fileselect;
+  ghid_hid.attribute_dialog         = ghid_attribute_dialog;
+  ghid_hid.show_item                = ghid_show_item;
+  ghid_hid.beep                     = ghid_beep;
+  ghid_hid.progress                 = ghid_progress;
+  ghid_hid.drc_gui                  = &ghid_drc_gui,
+  ghid_hid.edit_attributes          = ghid_attributes;
 
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 8bda96d..75ba763 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -403,12 +403,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -439,11 +439,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 268988d..70342d4 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -58,9 +58,6 @@ ghid_port_ranges_changed (void)
 {
   GtkAdjustment *h_adj, *v_adj;
 
-  HideCrosshair ();
-  ghidgui->need_restore_crosshair = TRUE;
-
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view_x0 = h_adj->value;
@@ -235,7 +232,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   ghid_set_cursor_position_labels ();
   return moved;
@@ -305,11 +302,10 @@ ghid_port_key_release_cb (GtkWidget * drawing_area, GdkEventKey * kev,
   if (ghid_is_modifier_key_sym (ksym))
     ghid_note_event_location (NULL);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   AdjustAttachedObjects ();
+  notify_crosshair_change (true);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
-  ghid_screen_update ();
   g_idle_add (ghid_idle_cb, NULL);
   return FALSE;
 }
@@ -447,12 +443,10 @@ ghid_port_button_press_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
   ghid_show_crosshair (FALSE);
-  HideCrosshair ();
 
   do_mouse_action(ev->button, mk);
 
   ghid_invalidate_all ();
-  RestoreCrosshair ();
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
   ghid_show_crosshair (TRUE);
@@ -473,14 +467,12 @@ ghid_port_button_release_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
 
-  HideCrosshair ();
-
   do_mouse_action(ev->button, mk + M_Release);
 
+  notify_crosshair_change (false);
   AdjustAttachedObjects ();
+  notify_crosshair_change (true);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
-  ghid_screen_update ();
 
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
@@ -496,7 +488,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  HideCrosshair ();
   gport->width = ev->width;
   gport->height = ev->height;
 
@@ -530,7 +521,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
   return 0;
 }
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index f33678a..e21ef18 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -650,11 +650,10 @@ ghid_menu_cb (GtkAction * action, gpointer data)
    */
   if (ghidgui->toggle_holdoff == FALSE) 
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       AdjustAttachedObjects ();
+      notify_crosshair_change (true);
       ghid_invalidate_all ();
-      RestoreCrosshair ();
-      ghid_screen_update ();
       ghid_window_set_name_label (PCB->Name);
       ghid_set_status_line_label ();
 #ifdef FIXME
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index f419530..5a51358 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -132,7 +132,7 @@ typedef struct
     small_label_markup,
     compact_horizontal,
     compact_vertical,
-    ghid_title_window, use_command_window, need_restore_crosshair, creating;
+    ghid_title_window, use_command_window, creating;
 
   gint n_mode_button_columns,
     top_window_width,
@@ -494,6 +494,8 @@ void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();
+void ghid_notify_crosshair_change (bool changes_complete);
+void ghid_notify_mark_change (bool changes_complete);
 void ghid_show_crosshair (gboolean show);
 void ghid_init_renderer (int *, char ***, GHidPort *);
 void ghid_init_drawing_widget (GtkWidget *widget, GHidPort *);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c1b12d3..b4a49e3 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -1310,12 +1310,12 @@ mod_changed (XKeyEvent * e, int set)
       return;
     }
   in_move_event = 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (panning)
     Pan (2, e->x, e->y);
   EventMoveCrosshair (Px (e->x), Py (e->y));
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   in_move_event = 0;
 }
 
@@ -1351,7 +1351,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1361,7 +1361,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -1371,7 +1371,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1382,7 +1382,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -2878,6 +2878,42 @@ lesstif_invalidate_all (void)
   lesstif_invalidate_lr (0, PCB->MaxWidth, 0, PCB->MaxHeight);
 }
 
+static void
+lesstif_notify_crosshair_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    invalidate_depth = 0;
+
+  if (invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
+static void
+lesstif_notify_mark_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    invalidate_depth = 0;
+
+  if (invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
 static int
 lesstif_set_layer (const char *name, int group, int empty)
 {
@@ -3803,60 +3839,62 @@ hid_lesstif_init ()
   memset (&lesstif_hid, 0, sizeof (HID));
 
   common_draw_helpers_init (&lesstif_hid);
-
-  lesstif_hid.struct_size           = sizeof (HID);
-  lesstif_hid.name                  = "lesstif";
-  lesstif_hid.description           = "LessTif - a Motif clone for X/Unix";
-  lesstif_hid.gui                   = 1;
-  lesstif_hid.poly_before           = 1;
-
-  lesstif_hid.get_export_options    = lesstif_get_export_options;
-  lesstif_hid.do_export             = lesstif_do_export;
-  lesstif_hid.parse_arguments       = lesstif_parse_arguments;
-  lesstif_hid.invalidate_lr         = lesstif_invalidate_lr;
-  lesstif_hid.invalidate_all        = lesstif_invalidate_all;
-  lesstif_hid.set_layer             = lesstif_set_layer;
-  lesstif_hid.make_gc               = lesstif_make_gc;
-  lesstif_hid.destroy_gc            = lesstif_destroy_gc;
-  lesstif_hid.use_mask              = lesstif_use_mask;
-  lesstif_hid.set_color             = lesstif_set_color;
-  lesstif_hid.set_line_cap          = lesstif_set_line_cap;
-  lesstif_hid.set_line_width        = lesstif_set_line_width;
-  lesstif_hid.set_draw_xor          = lesstif_set_draw_xor;
-  lesstif_hid.set_draw_faded        = lesstif_set_draw_faded;
-  lesstif_hid.set_line_cap_angle    = lesstif_set_line_cap_angle;
-  lesstif_hid.draw_line             = lesstif_draw_line;
-  lesstif_hid.draw_arc              = lesstif_draw_arc;
-  lesstif_hid.draw_rect             = lesstif_draw_rect;
-  lesstif_hid.fill_circle           = lesstif_fill_circle;
-  lesstif_hid.fill_polygon          = lesstif_fill_polygon;
-  lesstif_hid.fill_rect             = lesstif_fill_rect;
-
-  lesstif_hid.calibrate             = lesstif_calibrate;
-  lesstif_hid.shift_is_pressed      = lesstif_shift_is_pressed;
-  lesstif_hid.control_is_pressed    = lesstif_control_is_pressed;
-  lesstif_hid.mod1_is_pressed       = lesstif_mod1_is_pressed;
-  lesstif_hid.get_coords            = lesstif_get_coords;
-  lesstif_hid.set_crosshair         = lesstif_set_crosshair;
-  lesstif_hid.add_timer             = lesstif_add_timer;
-  lesstif_hid.stop_timer            = lesstif_stop_timer;
-  lesstif_hid.watch_file            = lesstif_watch_file;
-  lesstif_hid.unwatch_file          = lesstif_unwatch_file;
-  lesstif_hid.add_block_hook        = lesstif_add_block_hook;
-  lesstif_hid.stop_block_hook       = lesstif_stop_block_hook;
-
-  lesstif_hid.log                   = lesstif_log;
-  lesstif_hid.logv                  = lesstif_logv;
-  lesstif_hid.confirm_dialog        = lesstif_confirm_dialog;
-  lesstif_hid.close_confirm_dialog  = lesstif_close_confirm_dialog;
-  lesstif_hid.report_dialog         = lesstif_report_dialog;
-  lesstif_hid.prompt_for            = lesstif_prompt_for;
-  lesstif_hid.fileselect            = lesstif_fileselect;
-  lesstif_hid.attribute_dialog      = lesstif_attribute_dialog;
-  lesstif_hid.show_item             = lesstif_show_item;
-  lesstif_hid.beep                  = lesstif_beep;
-  lesstif_hid.progress              = lesstif_progress;
-  lesstif_hid.edit_attributes       = lesstif_attributes_dialog;
+  lesstif_hid.struct_size             = sizeof (HID);
+
+  lesstif_hid.name                    = "lesstif";
+  lesstif_hid.description             = "LessTif - a Motif clone for X/Unix";
+  lesstif_hid.gui                     = 1;
+  lesstif_hid.poly_before             = 1;
+
+  lesstif_hid.get_export_options      = lesstif_get_export_options;
+  lesstif_hid.do_export               = lesstif_do_export;
+  lesstif_hid.parse_arguments         = lesstif_parse_arguments;
+  lesstif_hid.invalidate_lr           = lesstif_invalidate_lr;
+  lesstif_hid.invalidate_all          = lesstif_invalidate_all;
+  lesstif_hid.notify_crosshair_change = lesstif_notify_crosshair_change;
+  lesstif_hid.notify_mark_change      = lesstif_notify_mark_change;
+  lesstif_hid.set_layer               = lesstif_set_layer;
+  lesstif_hid.make_gc                 = lesstif_make_gc;
+  lesstif_hid.destroy_gc              = lesstif_destroy_gc;
+  lesstif_hid.use_mask                = lesstif_use_mask;
+  lesstif_hid.set_color               = lesstif_set_color;
+  lesstif_hid.set_line_cap            = lesstif_set_line_cap;
+  lesstif_hid.set_line_width          = lesstif_set_line_width;
+  lesstif_hid.set_draw_xor            = lesstif_set_draw_xor;
+  lesstif_hid.set_draw_faded          = lesstif_set_draw_faded;
+  lesstif_hid.set_line_cap_angle      = lesstif_set_line_cap_angle;
+  lesstif_hid.draw_line               = lesstif_draw_line;
+  lesstif_hid.draw_arc                = lesstif_draw_arc;
+  lesstif_hid.draw_rect               = lesstif_draw_rect;
+  lesstif_hid.fill_circle             = lesstif_fill_circle;
+  lesstif_hid.fill_polygon            = lesstif_fill_polygon;
+  lesstif_hid.fill_rect               = lesstif_fill_rect;
+
+  lesstif_hid.calibrate               = lesstif_calibrate;
+  lesstif_hid.shift_is_pressed        = lesstif_shift_is_pressed;
+  lesstif_hid.control_is_pressed      = lesstif_control_is_pressed;
+  lesstif_hid.mod1_is_pressed         = lesstif_mod1_is_pressed;
+  lesstif_hid.get_coords              = lesstif_get_coords;
+  lesstif_hid.set_crosshair           = lesstif_set_crosshair;
+  lesstif_hid.add_timer               = lesstif_add_timer;
+  lesstif_hid.stop_timer              = lesstif_stop_timer;
+  lesstif_hid.watch_file              = lesstif_watch_file;
+  lesstif_hid.unwatch_file            = lesstif_unwatch_file;
+  lesstif_hid.add_block_hook          = lesstif_add_block_hook;
+  lesstif_hid.stop_block_hook         = lesstif_stop_block_hook;
+
+  lesstif_hid.log                     = lesstif_log;
+  lesstif_hid.logv                    = lesstif_logv;
+  lesstif_hid.confirm_dialog          = lesstif_confirm_dialog;
+  lesstif_hid.close_confirm_dialog    = lesstif_close_confirm_dialog;
+  lesstif_hid.report_dialog           = lesstif_report_dialog;
+  lesstif_hid.prompt_for              = lesstif_prompt_for;
+  lesstif_hid.fileselect              = lesstif_fileselect;
+  lesstif_hid.attribute_dialog        = lesstif_attribute_dialog;
+  lesstif_hid.show_item               = lesstif_show_item;
+  lesstif_hid.beep                    = lesstif_beep;
+  lesstif_hid.progress                = lesstif_progress;
+  lesstif_hid.edit_attributes         = lesstif_attributes_dialog;
 
   hid_register_hid (&lesstif_hid);
 #include "lesstif_lists.h"
diff --git a/src/misc.c b/src/misc.c
index 649208c..705f8df 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -679,15 +679,11 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
   if (Delta)
-    {
-      MoveCrosshairRelative (X, Y);
-    }
+    MoveCrosshairRelative (X, Y);
   else
     {
       if (MoveCrosshairAbsolute (X, Y))
-        {
-          RestoreCrosshair ();
-        }
+        notify_crosshair_change (true);
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
   PCB->Grid = save_grid;
diff --git a/src/set.c b/src/set.c
index 17f7583..8fef65a 100644
--- a/src/set.c
+++ b/src/set.c
@@ -244,7 +244,7 @@ SetMode (int Mode)
   if (recursing)
     return;
   recursing = true;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -314,7 +314,7 @@ SetMode (int Mode)
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 void
@@ -342,20 +342,20 @@ SetLocalRef (LocationType X, LocationType Y, bool Showing)
 
   if (Showing)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
       Marked.status = true;
       count++;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
   else if (count > 0)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
 }
