Bottom: aea7d42cd22623bf012eb186e389cb43754cea36
Top:    3195892f226e2c2ea238ffe596c89c20474280a4
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-12-04 19:24:08 +0000

Attempt lesstif GL support

Still needs:

__ A LOT __ of refactoring of common code
__ A LOT __ of drawing model changes in lesstif


---

diff --git a/configure.ac b/configure.ac
index f557c37..6a1f341 100644
--- a/configure.ac
+++ b/configure.ac
@@ -390,7 +390,8 @@ AC_ARG_ENABLE([gl],
 [  --enable-gl           Enable GL drawing (with GTK HID)],
 [],[
 	case " $with_gui " in
-		*\ gtk\ *) enable_gl=yes;;
+		*\ gtk\ *)     enable_gl=yes;;
+		*\ lesstif\ *) enable_gl=yes;;
 		* ) enable_gl=no;;
 	esac
 ])
@@ -400,8 +401,9 @@ AM_CONDITIONAL(USE_GL, test x$enable_gl = xyes)
 if test "x$enable_gl" = "xyes"; then
 	case " $with_gui " in
 		*\ gtk\ *) ;;
-		* ) AC_MSG_ERROR([GL drawing enabled but only works with the GTK HID.
-Either do not use --enable-gl or enable the gtk HID.])
+		*\ lesstif\ *) ;;
+		* ) AC_MSG_ERROR([GL drawing enabled but only works with the GTK or lesstif HIDs.
+Either do not use --enable-gl or enable the gtk or lesstif HID.])
 	;;
 	esac
 
@@ -734,6 +736,25 @@ for e in $HIDLIST; do
 	    ;;
 	  * ) ;;
 	esac
+
+	if test "x$enable_gl" = "xyes"; then
+		# Check for libGL
+		AC_CHECK_LIB(GL, glBegin, , , $X_LIBS)
+		if test $ac_cv_lib_GL_glBegin = "no"; then
+			AC_MSG_ERROR([You don't seem to have libGL installed.])
+		fi
+		# Check for libGLw
+		AC_CHECK_LIB(GLw, GLwDrawingAreaMakeCurrent, , , $X_LIBS)
+		if test $ac_cv_lib_GLw_GLwDrawingAreaMakeCurrent = "no"; then
+			AC_MSG_ERROR([You don't seem to have libGLw installed.])
+		fi
+		# Check for libGLU
+		AC_CHECK_LIB(GLU, gluNewTess, , , $X_LIBS)
+		if test $ac_cv_lib_GLU_gluNewTess = "no"; then
+			AC_MSG_ERROR([You don't seem to have libGLU installed.])
+		fi
+	fi
+
         ;;
 
       gtk )
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index ae0b9fa..3eeecb9 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -28,10 +28,14 @@
 #include "hid_draw.h"
 #include "../hidint.h"
 #include "hid/common/hidnogui.h"
+#include "GL/gl.h"
+#include "hid/common/hidgl.h"
 #include "hid/common/draw_helpers.h"
 #include "hid/common/hid_resource.h"
 #include "lesstif.h"
 
+#include "GL/GLwDrawA.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -46,6 +50,19 @@
 #define MAX_ZOOM_SCALE	10
 #define UUNIT	Settings.grid_unit->allow
 
+#ifndef GLwCreateDrawingArea
+#define GLwCreateDrawingArea(parent, name, arglist, argcount) \
+  XtCreateWidget(name, glwDrawingAreaWidgetClass, parent, arglist, argcount)
+#endif
+
+static void draw_grid ();
+void ghid_invalidate_current_gc (void);
+hidGC current_gc;
+#define USE_GC(gc) use_gc (gc)
+static int cur_mask = -1;
+static int gui_is_up = 0;
+static int trans_lines = 0;
+
 typedef struct lesstif_gc_struct
 {
   struct hid_gc_struct hid_gc /* Parent */;
@@ -94,8 +111,7 @@ static int pixmap_w = 0, pixmap_h = 0;
 Screen *screen_s;
 int screen;
 static Colormap colormap;
-static GC my_gc = 0, bg_gc, clip_gc = 0, bset_gc = 0, bclear_gc = 0, mask_gc =
-  0;
+static GC my_gc = 0, bg_gc, clip_gc = 0, bset_gc = 0, bclear_gc = 0;
 static Pixel bgcolor, offlimit_color, grid_color;
 static int bgred, bggreen, bgblue;
 
@@ -1598,18 +1614,152 @@ lesstif_show_crosshair (int show)
   showing = show;
 }
 
+GLXContext glx_context;
+Display * global_display;
+Window global_window;
+
 static void
 work_area_expose (Widget work_area, void *me,
-		  XmDrawingAreaCallbackStruct * cbs)
+		  XtPointer data)
 {
+  GLwDrawingAreaCallbackStruct *cbs = (GLwDrawingAreaCallbackStruct *)data;
   XExposeEvent *e;
+  BoxType region;
+  int eleft, eright, etop, ebottom;
+  int min_x, min_y;
+  int max_x, max_y;
+  Dimension width, height;
+
+  n = 0;
+  stdarg (XtNwidth, &width);
+  stdarg (XtNheight, &height);
+  XtGetValues (work_area, args, n);
 
-  show_crosshair (0);
   e = &(cbs->event->xexpose);
+#if 0
+  show_crosshair (0);
   XSetFunction (display, my_gc, GXcopy);
   XCopyArea (display, main_pixmap, window, my_gc,
 	     e->x, e->y, e->width, e->height, e->x, e->y);
   show_crosshair (1);
+#endif
+
+  /* make GL-context "current" */
+  GLwDrawingAreaMakeCurrent(work_area, glx_context);
+
+  hidgl_init ();
+
+  /* If we don't have any stencil bits available,
+     we can't use the hidgl polygon drawing routine */
+  /* TODO: We could use the GLU tessellator though */
+  if (hidgl_stencil_bits (hidgl) == 0)
+    {
+      lesstif_gui.fill_pcb_polygon = common_fill_pcb_polygon;
+      lesstif_gui.poly_dicer = 1;
+    }
+
+  show_crosshair (0);
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  glViewport (0, 0, width, height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (e->x,
+             height - e->height - e->y,
+             e->width, e->height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, width, height, 0, -100000, 100000);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glEnable (GL_STENCIL_TEST);
+#if 0
+  glClearColor (offlimits_color.red / 65535.,
+                offlimits_color.green / 65535.,
+                offlimits_color.blue / 65535.,
+                1.);
+#else
+  glClearColor (1.0, 0.5, 0.5, 1.0);
+#endif
+
+  glStencilMask (~0);
+  glClearStencil (0);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  hidgl_reset_stencil_usage (hidgl);
+
+  /* Disable the stencil test until we need it - otherwise it gets dirty */
+  glDisable (GL_STENCIL_TEST);
+  glStencilFunc (GL_ALWAYS, 0, 0);
+
+  min_x = e->x;
+  max_x = e->x + e->width;
+  min_y = e->y;
+  max_y = e->y + e->height;
+
+  region.X1 = MIN (Px (min_x), Px (max_x + 1));
+  region.X2 = MAX (Px (min_x), Px (max_x + 1));
+  region.Y1 = MIN (Py (min_y), Py (max_y + 1));
+  region.Y2 = MAX (Py (min_y), Py (max_y + 1));
+
+  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
+  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+
+  glColor3f (bgred / 65535.,
+             bggreen / 65535.,
+             bgblue / 65535.);
+
+  /* TODO: Background image */
+
+  ghid_invalidate_current_gc ();
+
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+//  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
+
+  glPushMatrix ();
+  glScalef ((flip_x ? -1. : 1.) / view_zoom,
+            (flip_y ? -1. : 1.) / view_zoom,
+            (flip_x == flip_y) ? 1. : -1.);
+  glTranslatef (flip_x ? view_left_x - PCB->MaxWidth  : -view_left_x,
+                flip_y ? view_top_y  - PCB->MaxHeight : -view_top_y,  0);
+
+  glBegin (GL_QUADS);
+  glVertex3i (0,             0,              0);
+  glVertex3i (PCB->MaxWidth, 0,              0);
+  glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
+  glVertex3i (0,             PCB->MaxHeight, 0);
+  glEnd ();
+
+  hid_expose_callback (&lesstif_gui, &region, 0);
+
+  hidgl_flush_triangles (hidgl);
+  glPopMatrix ();
+
+  draw_grid ();
+
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((flip_x ? -1. : 1.) / view_zoom,
+            (flip_y ? -1. : 1.) / view_zoom, 1);
+  glTranslatef (flip_x ? view_left_x - PCB->MaxWidth  : -view_left_x,
+                flip_y ? view_top_y  - PCB->MaxHeight : -view_top_y,  0);
+  //DrawAttached (TRUE);
+  //DrawMark (TRUE);
+  hidgl_flush_triangles (hidgl);
+  glPopMatrix ();
+
+  show_crosshair (1);
+
+  hidgl_flush_triangles (hidgl);
+
+  /* end drawing to current GL-context */
+  glXSwapBuffers(global_display, global_window);
 }
 
 static void
@@ -1803,6 +1953,23 @@ make_message (char *name, Widget left, int resizeable)
 }
 
 static void
+work_area_init (Widget w, XtPointer client_data, XtPointer call_data)
+{
+  Arg args[1];
+  XVisualInfo *vi;
+
+  XtSetArg (args[0], GLwNvisualInfo, &vi);
+  XtGetValues (w, args, 1);
+
+  global_display = XtDisplay(w);
+  global_window = XtWindow(w);
+  glx_context = glXCreateContext (global_display, vi, 0, GL_FALSE);
+
+  gui_is_up = 1;
+}
+
+
+static void
 lesstif_do_export (HID_Attr_Val * options)
 {
   Dimension width, height;
@@ -1848,12 +2015,20 @@ lesstif_do_export (HID_Attr_Val * options)
 
   n = 0;
   do_color (Settings.BackgroundColor, XmNbackground);
-  work_area = XmCreateDrawingArea (work_area_frame, "work_area", args, n);
+//  work_area = XmCreateDrawingArea (work_area_frame, "work_area", args, n);
+  work_area = GLwCreateDrawingArea (work_area_frame, "work_area", args, n);
   XtManageChild (work_area);
-  XtAddCallback (work_area, XmNexposeCallback,
-		 (XtCallbackProc) work_area_first_expose, 0);
-  XtAddCallback (work_area, XmNresizeCallback,
-		 (XtCallbackProc) work_area_resize, 0);
+  XtAddCallback(work_area, GLwNginitCallback, work_area_init,
+                (XtPointer) NULL);
+  XtAddCallback (work_area, GLwNexposeCallback,
+                 (XtCallbackProc) work_area_first_expose, (XtPointer) NULL);
+  XtAddCallback (work_area, GLwNresizeCallback,
+                 (XtCallbackProc) work_area_resize, (XtPointer) NULL);
+
+//  XtAddCallback (work_area, XmNexposeCallback,
+//		 (XtCallbackProc) work_area_first_expose, 0);
+//  XtAddCallback (work_area, XmNresizeCallback,
+//		 (XtCallbackProc) work_area_resize, 0);
   /* A regular callback won't work here, because lesstif swallows any
      Ctrl<Button>1 event.  */
   XtAddEventHandler (work_area,
@@ -2043,6 +2218,17 @@ lesstif_parse_arguments (int *argc, char ***argv)
   XtResource *new_resources;
   val_union *new_values;
   int render_event, render_error;
+  static String fallback_resources[] = {
+    "*work_area*rgba: TRUE",
+    "*work_area*doublebuffer: TRUE",
+    "*work_area*stencilSize: 8", /* FIXME: CHECK WHAT GL CAN DO FIRST! */
+    "*work_area*redSize: 8", /* FIXME: CHECK WHAT GL CAN DO FIRST! */
+    "*work_area*greenSize: 8", /* FIXME: CHECK WHAT GL CAN DO FIRST! */
+    "*work_area*blueSize: 8", /* FIXME: CHECK WHAT GL CAN DO FIRST! */
+    "*work_area*alphaSize: 8", /* FIXME: CHECK WHAT GL CAN DO FIRST! */
+    "*work_area*allocateBackground: TRUE", NULL
+  };
+
 
   XtSetTypeConverter (XtRString,
 		      XtRDouble,
@@ -2197,7 +2383,7 @@ lesstif_parse_arguments (int *argc, char ***argv)
 
   appwidget = XtAppInitialize (&app_context,
 			       "Pcb",
-			       new_options, amax, argc, *argv, 0, args, n);
+			       new_options, amax, argc, *argv, fallback_resources, args, n);
 
   display = XtDisplay (appwidget);
   screen_s = XtScreen (appwidget);
@@ -2499,7 +2685,8 @@ static int need_redraw = 0;
 static Boolean
 idle_proc (XtPointer dummy)
 {
-  if (need_redraw)
+//  if (need_redraw)
+  if (0)
     {
       int mx, my;
       BoxType region;
@@ -2904,7 +3091,7 @@ idle_proc (XtPointer dummy)
 
   lesstif_update_widget_flags ();
 
-  show_crosshair (1);
+//  show_crosshair (1);
   idle_proc_set = 0;
   return True;
 }
@@ -2921,11 +3108,22 @@ lesstif_need_idle_proc ()
 static void
 lesstif_invalidate_lr (int l, int r, int t, int b)
 {
+  GLwDrawingAreaCallbackStruct cbs;
+  XExposeEvent xexpose;
+
   if (!window)
     return;
 
   need_redraw = 1;
   need_idle_proc ();
+
+  /* GROSS HACK, WHERE IS THE INVALIDATE ROUTINE? */
+  cbs.event = &xexpose;
+  xexpose.x = 0;
+  xexpose.y = 0;
+  xexpose.width = PCB->MaxWidth;
+  xexpose.height = PCB->MaxHeight;
+  work_area_expose (work_area, NULL, (XtPointer) &cbs);
 }
 
 void
@@ -3190,6 +3388,7 @@ lesstif_set_color (hidGC gc, const char *name)
     }
 }
 
+#if 0
 static void
 set_gc (hidGC gc)
 {
@@ -3254,257 +3453,456 @@ set_gc (hidGC gc)
 			  join);
     }
 }
+#endif
 
-static void
-lesstif_set_line_cap (hidGC gc, EndCapStyle style)
+int compute_depth (int group)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
+  static int last_depth_computed = 0;
+
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
+  int max_depth;
+  int depth = last_depth_computed;
+  int newgroup;
+  int idx = (group >= 0
+             && group <
+             max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
+
+  max_depth = (1 + max_phys_group - min_phys_group) * 10;
+
+  if (group >= 0 && group < max_layer) {
+    newgroup = group;
+
+    depth = (max_depth - (newgroup - min_phys_group) * 10) * 200 / view_zoom;
+  } else if (SL_TYPE (idx) == SL_MASK) {
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 3) * 200 / view_zoom;
+    } else {
+      depth = (10 - 3) * 200 / view_zoom;
+    }
+  } else if (SL_TYPE (idx) == SL_SILK) {
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 5) * 200 / view_zoom;
+    } else {
+      depth = (10 - 5) * 200 / view_zoom;
+    }
+  } else if (SL_TYPE (idx) == SL_INVISIBLE) {
+    if (Settings.ShowSolderSide) {
+      depth = (max_depth + 5) * 200 / view_zoom;
+    } else {
+      depth = (10 - 5) * 200 / view_zoom;
+    }
+  }
 
-  lesstif_gc->cap = style;
+  last_depth_computed = depth;
+  return depth;
 }
 
-static void
-lesstif_set_line_width (hidGC gc, Coord width)
+int
+ghid_set_layer (const char *name, int group, int empty)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
+  static int stencil_bit = 0;
+  int idx = (group >= 0 && group < max_layer) ?
+              PCB->LayerGroups.Entries[group][0] : group;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (hidgl);
+
+  hidgl_set_depth (gc, compute_depth (group));
+
+  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
+  hidgl_return_stencil_bit (hidgl, stencil_bit);       // Relinquish any bitplane we previously used
+  if (SL_TYPE (idx) != SL_FINISHED) {
+    stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); // Get a new (clean) bitplane to stencil with
+    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
+  } else {
+    stencil_bit = 0;
+    glStencilMask (0);
+    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
+  }
+
+  if (idx >= 0 && idx < max_layer + 2) {
+    trans_lines = TRUE;
+    return PCB->Data->Layer[idx].On;
+  }
 
-  lesstif_gc->width = width;
+  if (idx < 0) {
+    switch (SL_TYPE (idx)) {
+      case SL_INVISIBLE:
+        return PCB->InvisibleObjectsOn;
+      case SL_MASK:
+        if (SL_MYSIDE (idx))
+          return TEST_FLAG (SHOWMASKFLAG, PCB);
+        return 0;
+      case SL_SILK:
+        trans_lines = TRUE;
+        if (SL_MYSIDE (idx))
+          return PCB->ElementOn;
+        return 0;
+      case SL_ASSY:
+        return 0;
+      case SL_RATS:
+        trans_lines = TRUE;
+        return 1;
+      case SL_PDRILL:
+      case SL_UDRILL:
+        return 1;
+    }
+  }
+  return 0;
 }
 
-static void
-lesstif_set_draw_xor (hidGC gc, int xor_set)
+void
+ghid_use_mask (enum mask_mode mode)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
+  static int stencil_bit = 0;
+
+  /* THE FOLLOWING IS COMPLETE ABUSE OF THIS MASK RENDERING API... NOT IMPLEMENTED */
+  if (mode == HID_LIVE_DRAWING ||
+      mode == HID_LIVE_DRAWING_OFF ||
+      mode == HID_FLUSH_DRAW_Q) {
+    return;
+  }
+
+  if (mode == cur_mask)
+    return;
 
-  lesstif_gc->xor_set = xor_set;
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (hidgl);
+
+  switch (mode)
+    {
+    case HID_MASK_BEFORE:
+      /* Write '1' to the stencil buffer where the solder-mask is drawn. */
+      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
+      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test, write stencil_bit
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+      break;
+
+    case HID_MASK_CLEAR:
+      /* Drawing operations clear the stencil buffer to '0' */
+      glStencilFunc (GL_ALWAYS, 0, stencil_bit);  // Always pass stencil test, write 0
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
+      break;
+
+    case HID_MASK_AFTER:
+      /* Drawing operations as masked to areas where the stencil buffer is '1' */
+      glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+      glStencilFunc (GL_LEQUAL, stencil_bit, stencil_bit);   // Draw only where our bit of the stencil buffer is set
+      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+      break;
+
+    case HID_MASK_OFF:
+      /* Disable stenciling */
+      hidgl_return_stencil_bit (hidgl, stencil_bit);  // Relinquish any bitplane we previously used
+      glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+      break;
+    }
+  cur_mask = mode;
 }
 
-#define ISORT(a,b) if (a>b) { a^=b; b^=a; a^=b; }
+typedef struct
+{
+  int color_set;
+  XColor color;
+  int xor_set;
+  XColor xor_color;
+  double red;
+  double green;
+  double blue;
+} ColorCache;
+
 
+  /* Config helper functions for when the user changes color preferences.
+     |  set_special colors used in the gtkhid.
+   */
 static void
-lesstif_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+set_special_grid_color (void)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
-  double dx1, dy1, dx2, dy2;
-  int vw = Vz (lesstif_gc->width);
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && lesstif_gc->erase)
-    return;
-#if 0
-  pcb_printf ("draw_line %#mD-%#mD @%#mS", x1, y1, x2, y2, lesstif_gc->width);
-#endif
-  dx1 = Vx (x1);
-  dy1 = Vy (y1);
-  dx2 = Vx (x2);
-  dy2 = Vy (y2);
-#if 0
-  pcb_printf (" = %#mD-%#mD %s\n", x1, y1, x2, y2, lesstif_gc->colorname);
-#endif
+  //if (!gport->colormap)
+  //  return;
+  //gport->grid_color.red ^= gport->bg_color.red;
+  //gport->grid_color.green ^= gport->bg_color.green;
+  //gport->grid_color.blue ^= gport->bg_color.blue;
+//  gdk_color_alloc (gport->colormap, &gport->grid_color);
+}
 
-#if 1
-  if (! ClipLine (0, 0, view_width, view_height,
-		  &dx1, &dy1, &dx2, &dy2, vw))
+void
+ghid_set_special_colors (HID_Attribute * ha)
+{
+#if 0
+  if (!ha->name || !ha->value)
     return;
+  if (!strcmp (ha->name, "background-color"))
+    {
+      ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
+      set_special_grid_color ();
+    }
+  else if (!strcmp (ha->name, "off-limit-color"))
+  {
+      ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
+    }
+  else if (!strcmp (ha->name, "grid-color"))
+    {
+      ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
+      set_special_grid_color ();
+    }
 #endif
+}
+
+/* static */ char *current_color = NULL;
+/* static */ double global_alpha_mult = 1.0;
+/* static */ int alpha_changed = 0;
 
-  x1 = dx1;
-  y1 = dy1;
-  x2 = dx2;
-  y2 = dy2;
+void
+ghid_set_color (hidGC gc, const char *name)
+{
+  static void *cache = NULL;
+  hidval cval;
+  ColorCache *cc;
+  double alpha_mult = 1.0;
+  double r, g, b, a;
+  static XColor color, exact_color;
+  a = 1.0;
 
-  set_gc (gc);
-  if (lesstif_gc->cap == Square_Cap && x1 == x2 && y1 == y2)
+  if (!alpha_changed && current_color != NULL)
     {
-      XFillRectangle (display, pixmap, my_gc, x1 - vw / 2, y1 - vw / 2, vw,
-		      vw);
-      if (use_mask)
-	XFillRectangle (display, mask_bitmap, mask_gc, x1 - vw / 2,
-			y1 - vw / 2, vw, vw);
+      if (strcmp (name, current_color) == 0)
+        return;
+      free (current_color);
     }
-  else
+
+  alpha_changed = 0;
+
+  current_color = strdup (name);
+
+  if (name == NULL)
     {
-      XDrawLine (display, pixmap, my_gc, x1, y1, x2, y2);
-      if (use_mask)
-	XDrawLine (display, mask_bitmap, mask_gc, x1, y1, x2, y2);
+      fprintf (stderr, "%s():  name = NULL, setting to magenta\n",
+               __FUNCTION__);
+      name = "magenta";
     }
-}
 
-static void
-lesstif_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
-		  Angle start_angle, Angle delta_angle)
-{
-  lesstifGC lesstif_gc = (lesstifGC)gc;
+  gc->colorname = (char *) name;
 
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
-    return;
-#if 0
-  pcb_printf ("draw_arc %#mD %#mSx%#mS s %d d %d", cx, cy, width, height, start_angle, delta_angle);
-#endif
-  width = Vz (width);
-  height = Vz (height);
-  cx = Vx (cx) - width;
-  cy = Vy (cy) - height;
-  if (flip_x)
+//  if (gport->colormap == 0)
+//    gport->colormap = gtk_widget_get_colormap (gport->top_window);
+  if (strcmp (name, "erase") == 0)
     {
-      start_angle = 180 - start_angle;
-      delta_angle = - delta_angle;
+      gc->erase = 1;
+      r = bgred   / 65535.;
+      g = bggreen / 65535.;
+      b = bgblue  / 65535.;
     }
-  if (flip_y)
+  else if (strcmp (name, "drill") == 0)
     {
-      start_angle = - start_angle;
-      delta_angle = - delta_angle;					
+      gc->erase = 0;
+      alpha_mult = 0.85;
+      r = 0.5;
+      g = 0.5;
+      b = 0.5;
+//      r = offlimit_color.red   / 65535.;
+//      g = offlimit_color.green / 65535.;
+//      b = offlimit_color.blue  / 65535.;
     }
-  start_angle = NormalizeAngle (start_angle);
-  if (start_angle >= 180)
-    start_angle -= 360;
-#if 0
-  pcb_printf (" = %#mD %#mSx%#mS %d %s\n", cx, cy, width, height, lesstif_gc->width,
-	  lesstif_gc->colorname);
-#endif
-  set_gc (gc);
-  XDrawArc (display, pixmap, my_gc, cx, cy,
-	    width * 2, height * 2, (start_angle + 180) * 64,
-	    delta_angle * 64);
-  if (use_mask && !TEST_FLAG (THINDRAWFLAG, PCB))
-    XDrawArc (display, mask_bitmap, mask_gc, cx, cy,
-	      width * 2, height * 2, (start_angle + 180) * 64,
-	      delta_angle * 64);
-#if 0
-  /* Enable this if you want to see the center and radii of drawn
-     arcs, for debugging.  */
-  if (TEST_FLAG (THINDRAWFLAG, PCB)
-      && delta_angle != 360)
+  else
     {
-      cx += width;
-      cy += height;
-      XDrawLine (display, pixmap, arc1_gc, cx, cy,
-		 cx - width*cos(start_angle*M_PI/180),
-		 cy + width*sin(start_angle*M_PI/180));
-      XDrawLine (display, pixmap, arc2_gc, cx, cy,
-		 cx - width*cos((start_angle+delta_angle)*M_PI/180),
-		 cy + width*sin((start_angle+delta_angle)*M_PI/180));
+      alpha_mult = 0.7;
+      if (hid_cache_color (0, name, &cval, &cache))
+        cc = (ColorCache *) cval.ptr;
+      else
+        {
+          cc = (ColorCache *) malloc (sizeof (ColorCache));
+          memset (cc, 0, sizeof (*cc));
+          cval.ptr = cc;
+          hid_cache_color (1, name, &cval, &cache);
+        }
+
+      if (!cc->color_set)
+        {
+      if (!XAllocNamedColor (display, colormap, name, &color, &cc->color))
+	color.pixel = WhitePixel (display, screen);
+//          if (gdk_color_parse (name, &cc->color))
+//            gdk_color_alloc (gport->colormap, &cc->color);
+//          else
+//            gdk_color_white (gport->colormap, &cc->color);
+          cc->red   = cc->color.red   / 65535.;
+          cc->green = cc->color.green / 65535.;
+          cc->blue  = cc->color.blue  / 65535.;
+          cc->color_set = 1;
+        }
+      if (gc->xor)
+        {
+          if (!cc->xor_set)
+            {
+              cc->xor_color.red =   cc->color.red   ^ bgred;
+              cc->xor_color.green = cc->color.green ^ bggreen;
+              cc->xor_color.blue =  cc->color.blue  ^ bgblue;
+//              gdk_color_alloc (gport->colormap, &cc->xor_color);
+              cc->red   = cc->color.red   / 65535.;
+              cc->green = cc->color.green / 65535.;
+              cc->blue  = cc->color.blue  / 65535.;
+              cc->xor_set = 1;
+            }
+        }
+      r = cc->red;
+      g = cc->green;
+      b = cc->blue;
+
+      gc->erase = 0;
     }
+  if (1) {
+    double maxi, mult;
+    alpha_mult *= global_alpha_mult;
+    if (trans_lines)
+      a = a * alpha_mult;
+    maxi = r;
+    if (g > maxi) maxi = g;
+    if (b > maxi) maxi = b;
+    mult = MIN (1 / alpha_mult, 1 / maxi);
+#if 1
+    r = r * mult;
+    g = g * mult;
+    b = b * mult;
 #endif
+  }
+
+  if( ! gui_is_up )
+    return;
+
+  hidgl_flush_triangles (hidgl);
+  glColor4d (r, g, b, a);
 }
 
-static void
-lesstif_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+void
+ghid_global_alpha_mult (hidGC gc, double alpha_mult)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
-  int vw = Vz (lesstif_gc->width);
-
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
-    return;
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
-  if (x1 < -vw && x2 < -vw)
-    return;
-  if (y1 < -vw && y2 < -vw)
-    return;
-  if (x1 > view_width + vw && x2 > view_width + vw)
-    return;
-  if (y1 > view_height + vw && y2 > view_height + vw)
-    return;
-  if (x1 > x2) { int xt = x1; x1 = x2; x2 = xt; }
-  if (y1 > y2) { int yt = y1; y1 = y2; y2 = yt; }
-  set_gc (gc);
-  XDrawRectangle (display, pixmap, my_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
-  if (use_mask)
-    XDrawRectangle (display, mask_bitmap, mask_gc, x1, y1, x2 - x1 + 1,
-		    y2 - y1 + 1);
+  if (alpha_mult != global_alpha_mult) {
+    global_alpha_mult = alpha_mult;
+    alpha_changed = 1;
+    ghid_set_color (gc, current_color);
+  }
 }
 
-static void
-lesstif_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
+void
+ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
+  gc->cap = style;
+}
 
-  if (pinout && use_mask && lesstif_gc->erase)
-    return;
-  if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB)) && lesstif_gc->erase)
-    return;
-#if 0
-  pcb_printf ("fill_circle %#mD %#mS", cx, cy, radius);
-#endif
-  radius = Vz (radius);
-  cx = Vx (cx) - radius;
-  cy = Vy (cy) - radius;
-  if (cx < -2 * radius || cx > view_width)
-    return;
-  if (cy < -2 * radius || cy > view_height)
-    return;
-#if 0
-  pcb_printf (" = %#mD %#mS %lx %s\n", cx, cy, radius, lesstif_gc->color, lesstif_gc->colorname);
-#endif
-  set_gc (gc);
-  XFillArc (display, pixmap, my_gc, cx, cy,
-	    radius * 2, radius * 2, 0, 360 * 64);
-  if (use_mask)
-    XFillArc (display, mask_bitmap, mask_gc, cx, cy,
-	      radius * 2, radius * 2, 0, 360 * 64);
+void
+ghid_set_line_width (hidGC gc, Coord width)
+{
+  gc->width = width;
 }
 
-static void
-lesstif_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
+void
+ghid_set_draw_xor (hidGC gc, int xor)
 {
-  static XPoint *p = 0;
-  static int maxp = 0;
-  int i;
+  // printf ("ghid_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
+  /* NOT IMPLEMENTED */
 
-  if (maxp < n_coords)
-    {
-      maxp = n_coords + 10;
-      if (p)
-	p = (XPoint *) realloc (p, maxp * sizeof (XPoint));
-      else
-	p = (XPoint *) malloc (maxp * sizeof (XPoint));
-    }
+  /* Only presently called when setting up a crosshair GC.
+   * We manage our own drawing model for that anyway. */
+}
 
-  for (i = 0; i < n_coords; i++)
-    {
-      p[i].x = Vx (x[i]);
-      p[i].y = Vy (y[i]);
-    }
-#if 0
-  printf ("fill_polygon %d pts\n", n_coords);
-#endif
-  set_gc (gc);
-  XFillPolygon (display, pixmap, my_gc, p, n_coords, Complex,
-		CoordModeOrigin);
-  if (use_mask)
-    XFillPolygon (display, mask_bitmap, mask_gc, p, n_coords, Complex,
-		  CoordModeOrigin);
+void
+ghid_invalidate_current_gc (void)
+{
+  current_gc = NULL;
 }
 
 static void
 lesstif_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  lesstifGC lesstif_gc = (lesstifGC)gc;
-  int vw = Vz (lesstif_gc->width);
-
-  if ((pinout || TEST_FLAG (THINDRAWFLAG, PCB)) && lesstif_gc->erase)
-    return;
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
-  if (x1 < -vw && x2 < -vw)
-    return;
-  if (y1 < -vw && y2 < -vw)
-    return;
-  if (x1 > view_width + vw && x2 > view_width + vw)
-    return;
-  if (y1 > view_height + vw && y2 > view_height + vw)
+  if (current_gc == gc)
     return;
-  if (x1 > x2) { int xt = x1; x1 = x2; x2 = xt; }
-  if (y1 > y2) { int yt = y1; y1 = y2; y2 = yt; }
-  set_gc (gc);
-  XFillRectangle (display, pixmap, my_gc, x1, y1, x2 - x1 + 1,
-		  y2 - y1 + 1);
-  if (use_mask)
-    XFillRectangle (display, mask_bitmap, mask_gc, x1, y1, x2 - x1 + 1,
-		    y2 - y1 + 1);
+
+  current_gc = gc;
+
+  ghid_set_color (gc, gc->colorname);
+}
+
+void
+ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  USE_GC (gc);
+
+  hidgl_draw_line (gc, gc->cap, gc->width, x1, y1, x2, y2, view_zoom);
+}
+
+void
+ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
+                         Angle start_angle, Angle delta_angle)
+{
+  USE_GC (gc);
+
+  hidgl_draw_arc (gc, gc->width, cx, cy, xradius, yradius,
+                  start_angle, delta_angle, view_zoom);
+}
+
+void
+ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  USE_GC (gc);
+
+  hidgl_draw_rect (gc, x1, y1, x2, y2);
+}
+
+
+void
+ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
+{
+  USE_GC (gc);
+
+  hidgl_fill_circle (gc, cx, cy, radius, view_zoom);
+}
+
+
+void
+ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
+{
+  USE_GC (gc);
+
+  hidgl_fill_polygon (gc, n_coords, x, y);
+}
+
+void
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  USE_GC (gc);
+
+  hidgl_fill_pcb_polygon (gc, poly, clip_box, view_zoom);
+}
+
+void
+ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  common_thindraw_pcb_polygon (gc, poly, clip_box);
+  ghid_global_alpha_mult (gc, 0.25);
+  ghid_fill_pcb_polygon (gc, poly, clip_box);
+  ghid_global_alpha_mult (gc, 1.0);
+}
+
+void
+ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  USE_GC (gc);
+
+  hidgl_fill_rect (gc, x1, y1, x2, y2);
 }
 
 static void
@@ -4118,20 +4516,22 @@ hid_lesstif_init ()
   common_nogui_graphics_class_init (&lesstif_graphics_class);
   common_draw_helpers_class_init (&lesstif_graphics_class);
 
-  lesstif_graphics_class.set_layer      = lesstif_set_layer;
-  lesstif_graphics_class.make_gc        = lesstif_make_gc;
-  lesstif_graphics_class.destroy_gc     = lesstif_destroy_gc;
-  lesstif_graphics_class.use_mask       = lesstif_use_mask;
-  lesstif_graphics_class.set_color      = lesstif_set_color;
-  lesstif_graphics_class.set_line_cap   = lesstif_set_line_cap;
-  lesstif_graphics_class.set_line_width = lesstif_set_line_width;
-  lesstif_graphics_class.set_draw_xor   = lesstif_set_draw_xor;
-  lesstif_graphics_class.draw_line      = lesstif_draw_line;
-  lesstif_graphics_class.draw_arc       = lesstif_draw_arc;
-  lesstif_graphics_class.draw_rect      = lesstif_draw_rect;
-  lesstif_graphics_class.fill_circle    = lesstif_fill_circle;
-  lesstif_graphics_class.fill_polygon   = lesstif_fill_polygon;
-  lesstif_graphics_class.fill_rect      = lesstif_fill_rect;
+  lesstif_graphics_class.set_layer            = lesstif_set_layer;
+  lesstif_graphics_class.make_gc              = lesstif_make_gc;
+  lesstif_graphics_class.destroy_gc           = lesstif_destroy_gc;
+  lesstif_graphics_class.use_mask             = ghid_use_mask;
+  lesstif_graphics_class.set_color            = ghid_set_color;
+  lesstif_graphics_class.set_line_cap         = ghid_set_line_cap;
+  lesstif_graphics_class.set_line_width       = ghid_set_line_width;
+  lesstif_graphics_class.set_draw_xor         = ghid_set_draw_xor;
+  lesstif_graphics_class.draw_line            = ghid_draw_line;
+  lesstif_graphics_class.draw_arc             = ghid_draw_arc;
+  lesstif_graphics_class.draw_rect            = ghid_draw_rect;
+  lesstif_graphics_class.fill_circle          = ghid_fill_circle;
+  lesstif_graphics_class.fill_polygon         = ghid_fill_polygon;
+  lesstif_graphics_class.fill_pcb_polygon     = ghid_fill_pcb_polygon;
+  lesstif_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+  lesstif_graphics_class.fill_rect            = ghid_fill_rect;
 
   lesstif_graphics_class.draw_pcb_polygon = common_gui_draw_pcb_polygon;
