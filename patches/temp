Bottom: b5d2f35f713138728caeecf4124a3b022f8fb0fd
Top:    2d4495adf19b60c1ef528a65c2809c55cfa27f5b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-06 11:24:39 +0000

temp


---

diff --git a/src/polygon1.c b/src/polygon1.c
index eb1c105..6e741e0 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -228,9 +228,14 @@ new_descriptor (VNODE * a, char poly, char side)
   CVCList *l = (CVCList *) malloc (sizeof (CVCList));
   Vector v;
   register double ang, dx, dy;
+  bool debug = false;
 
   if (!l)
     return NULL;
+
+  if (a->point[0] == 217500000 && a->point[1] == 8004135)
+    debug = true;
+
   l->head = NULL;
   l->parent = a;
   l->poly = poly;
@@ -276,8 +281,10 @@ new_descriptor (VNODE * a, char poly, char side)
     ang = 4.0 - ang;		/* 4th quadrant */
   l->angle = ang;
   assert (ang >= 0.0 && ang <= 4.0);
+  if (debug)
+    fprintf (stderr, "HELLO, THIS IS THE PROBLEMATIC COORDINATE\n");
 #ifdef DEBUG_ANGLE
-  DEBUGP ("node on %c at %#mD assigned angle %g on side %c\n", poly,
+  DEBUGP ("node on %c at (%$mm, %$mm) assigned angle %g on side %c\n", poly,
 	  a->point[0], a->point[1], ang, side);
 #endif
   return l;
@@ -287,7 +294,7 @@ new_descriptor (VNODE * a, char poly, char side)
 insert_descriptor
   (C) 2006 harry eaton
 
-   argument a is a cross-vertex node.
+   argument a is a cross-vertex node (and treated as a vertex).
    argument poly is the polygon it comes from ('A' or 'B')
    argument side is the side this descriptor goes on ('P' for previous
    'N' for next.
@@ -409,18 +416,18 @@ edge_label (VNODE * pn)
   int region = UNKNWN;
 
   assert (pn);
-  assert (pn->cvc_next);
-  this_poly = pn->cvc_next->poly;
+  assert (EDGE_BACKWARD_VERTEX (pn)->cvc_next);
+  this_poly = EDGE_BACKWARD_VERTEX (pn)->cvc_next->poly;
   /* search counter-clockwise in the cross vertex connectivity (CVC) list
    *
    * check for shared edges (that could be prev or next in the list since the angles are equal)
    * and check if this edge (pn -> pn->next) is found between the other poly's entry and exit
    */
 
-  if (pn->cvc_next->angle == pn->cvc_next->prev->angle)
-    l = pn->cvc_next->prev;
+  if (EDGE_BACKWARD_VERTEX (pn)->cvc_next->angle == EDGE_BACKWARD_VERTEX (pn)->cvc_next->prev->angle)
+    l = EDGE_BACKWARD_VERTEX (pn)->cvc_next->prev;
   else
-    l = pn->cvc_next;
+    l = EDGE_BACKWARD_VERTEX (pn)->cvc_next;
 
   first_l = l;
   while ((l->poly == this_poly) && (l != first_l->prev))
@@ -453,11 +460,12 @@ edge_label (VNODE * pn)
 	}
       else
 	{
-	  if (l->angle == pn->cvc_next->angle)
+	  if (l->angle == EDGE_BACKWARD_VERTEX (pn)->cvc_next->angle)
 	    {
 	      if (!(EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (l->parent))->point[0] == EDGE_FORWARD_VERTEX (pn)->point[0] &&
 	            EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (l->parent))->point[1] == EDGE_FORWARD_VERTEX (pn)->point[1]))
                 {
+                  pcb_fprintf (stderr, "%lu, %lu\n", EDGE_BACKWARD_VERTEX (pn)->point[0], EDGE_BACKWARD_VERTEX (pn)->point[1]);
                   pcb_fprintf (stderr, "edge_label called on edge (%mm, %mm)-(%mm, %mm)\n",
                                EDGE_BACKWARD_VERTEX (pn)->point[0],
                                EDGE_BACKWARD_VERTEX (pn)->point[1],
@@ -475,7 +483,7 @@ edge_label (VNODE * pn)
                                  EDGE_BACKWARD_VERTEX (pn)->point[0],
                                  EDGE_BACKWARD_VERTEX (pn)->point[1]);
                     do {
-                      pcb_fprintf (stderr, "angle = %f, poly = %c, side = %c, (%mm, %mm)-(%mm, %mm)\n",
+                      pcb_fprintf (stderr, "angle = %f, poly = %c, side = %c, (%$mn, %$mn)-(%$mn, %$mn)\n",
                                    iter->angle,
                                    iter->poly,
                                    iter->side,
@@ -483,7 +491,7 @@ edge_label (VNODE * pn)
                                    ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1],
                                    ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
                                    ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1]);
-                    } while ((iter = iter->next) != pn->cvc_next);
+                    } while ((iter = iter->next) != EDGE_BACKWARD_VERTEX (pn)->cvc_next);
                   }
                 }
               /* Assertion fails here for the broken STEP export test case */
@@ -498,7 +506,7 @@ edge_label (VNODE * pn)
     }
   if (region == UNKNWN)
     {
-      for (l = l->next; l != pn->cvc_next; l = l->next)
+      for (l = l->next; l != EDGE_BACKWARD_VERTEX (pn)->cvc_next; l = l->next)
 	{
 	  if (l->poly != this_poly)
 	    {
@@ -664,6 +672,11 @@ prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
   return task;
 }
 
+void foo (void)
+{
+  fprintf (stderr, "foo()\n");
+}
+
 /*
  * seg_in_seg()
  * (C) 2006 harry eaton
@@ -693,6 +706,8 @@ seg_in_seg (const BoxType * b, void *cl)
 
   cnt = vect_inters2 (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point,
 		      EDGE_BACKWARD_VERTEX (i->v)->point, EDGE_FORWARD_VERTEX (i->v)->point, s1, s2);
+  if (cnt == 2)
+    foo ();
   if (!cnt)
     return 0;
   if (i->touch)			/* if checking touches one find and we're done */
@@ -3481,6 +3496,16 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
   double s, t, deel;
   double rpx, rpy, rqx, rqy;
 
+  if ((p1[0] == 217500000 && p1[1] == 8004135) ||
+      (p2[0] == 217500000 && p2[1] == 8004135) ||
+      (q1[0] == 217500000 && q1[1] == 8004135) ||
+      (q2[0] == 217500000 && q2[1] == 8004135))
+    {
+      fprintf (stderr, "************** vect_inters2() called with one of the points as our suspect vertex thingy ***********\n");
+      pcb_fprintf (stderr, "(%$mn, %$mn)-(%$mn, %$mn) tested against (%$mn, %$mn)-(%$mn, %$mn)\n",
+                   p1[0], p1[1], p2[0], p2[1], q1[0], q1[1], q2[0], q2[1]);
+    }
+
   if (max (p1[0], p2[0]) < min (q1[0], q2[0]) ||
       max (q1[0], q2[0]) < min (p1[0], p2[0]) ||
       max (p1[1], p2[1]) < min (q1[1], q2[1]) ||
@@ -3503,6 +3528,8 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
       double dc1, dc2, d1, d2, h;	/* Check to see whether p1-p2 and q1-q2 are on the same line */
       Vector hp1, hq1, hp2, hq2, q1p1, q1q2;
 
+      fprintf (stderr, "vect_inters2(): Parallel line case\n");
+
       Vsub2 (q1p1, q1, p1);
       Vsub2 (q1q2, q1, q2);
