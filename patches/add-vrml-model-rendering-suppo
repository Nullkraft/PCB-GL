Bottom: bb543769bcc081e75e62da5e3d8d22498c38d03b
Top:    9da001bc8263467a31d9d9861144e59a9c1d32c3
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-11-13 00:19:21 +0000

Add VRML model rendering support

XXX: Why did we change various double typed parameters to float in this patch??


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 4590ef8..269f134 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -181,7 +181,16 @@ GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
 	hid/common/glext.h \
+	hid/common/hidgl_geometry.c \
+	hid/common/hidgl_geometry.h \
+	hid/common/hidgl_material.c \
+	hid/common/hidgl_material.h \
+	hid/common/hidgl_matrix.c \
+	hid/common/hidgl_matrix.h \
 	hid/common/hidgl_package_acy_resistor.c \
+	hid/common/hidgl_package_vrml.c \
+	hid/common/hidgl_package_vrml_y.y \
+	hid/common/hidgl_package_vrml_l.l \
 	hid/common/hidgl_shaders.c \
 	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..823fd5e 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -1133,6 +1133,8 @@ hidgl_init (void)
     printf ("Failed to initialise shader support\n");
 #endif
 
+  hidgl_init_acy_resistor ();
+
   called = true;
 }
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index e2d7f67..ac57601 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,6 +23,7 @@
 #ifndef PCB_HID_COMMON_HIDGL_H
 #define PCB_HID_COMMON_HIDGL_H
 
+#include "hidgl_matrix.h"
 #include "hidgl_shaders.h"
 
 /* NB: triangle_buffer is a private type, only defined here to enable inlining of geometry creation */
@@ -178,6 +179,7 @@ void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
 void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
 
 /* hidgl_pacakge_acy_resistor.c */
+void hidgl_init_acy_resistor ();
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
 void hidgl_draw_800mil_resistor (ElementType *element, float surface_depth, float board_thickness);
 void hidgl_draw_2300mil_resistor (ElementType *element, float surface_depth, float board_thickness);
@@ -185,4 +187,7 @@ void hidgl_draw_700mil_diode_smd (ElementType *element, float surface_depth, flo
 void hidgl_draw_1650mil_cap (ElementType *element, float surface_depth, float board_thickness);
 void hidgl_draw_350x800mil_cap (ElementType *element, float surface_depth, float board_thickness);
 
+/* hidgl_pacakge_vrml.c */
+void hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file);
+
 #endif /* PCB_HID_COMMON_HIDGL_H  */
diff --git a/src/hid/common/hidgl_geometry.c b/src/hid/common/hidgl_geometry.c
new file mode 100644
index 0000000..9fdcf1f
--- /dev/null
+++ b/src/hid/common/hidgl_geometry.c
@@ -0,0 +1,88 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "hidgl_geometry.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* Opaque data-structure keeping a geometry object */
+struct _hidgl_geometry {
+  char *name;
+
+  hidgl_geometry_class *klass;
+};
+
+
+hidgl_geometry *
+hidgl_geometry_new (char *name)
+{
+  hidgl_geometry *geometry;
+
+  geometry = malloc (sizeof (hidgl_geometry));
+
+  if (geometry == NULL)
+    return NULL;
+
+  geometry->name = strdup (name);
+  geometry->klass = NULL; /* To be filled in by the subclass */
+
+  return geometry;
+}
+
+
+/* Delete the passed geometry. */
+void
+hidgl_geometry_free (hidgl_geometry *geometry)
+{
+  if (geometry->klass != NULL)
+    geometry->klass->free (geometry);
+
+  free (geometry->name);
+  free (geometry);
+}
+
+
+/* Draw the given geometry */
+void
+hidgl_geometry_draw (hidgl_geometry *geometry)
+{
+  if (geometry->klass != NULL)
+    geometry->klass->draw (geometry);
+}
diff --git a/src/hid/common/hidgl_geometry.h b/src/hid/common/hidgl_geometry.h
new file mode 100644
index 0000000..3c603b3
--- /dev/null
+++ b/src/hid/common/hidgl_geometry.h
@@ -0,0 +1,69 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_GEOMETRY_INCLUDED__
+#define __HIDGL_GEOMETRY_INCLUDED__
+
+typedef struct _hidgl_geometry        hidgl_geometry;
+typedef struct _hidgl_geometry_class  hidgl_geometry_class;
+
+struct _hidgl_geometry_class {
+  void (*draw) (hidgl_geometry *geometry);   /* What assumptions are made about the GL state prior to calling this? */
+  void (*free) (hidgl_geometry *geometry);   /* Clean up any internal state and delete */
+};
+
+/* Subclasses required / planned / thought of :
+ *
+ * hidgl_tristrip_geometry
+ * hidgl_triangle_geometry
+ * hidgl_mesh_geometry (EXAMPLE)
+ * hidgl_brep_geometry (EXAMPLE)
+ */
+
+#if 0
+tristrip_geometry and traiangle geometry probably share some common data-storage stuff?
+Should we do like VRML and keep data-definition separate from the defining geometry?
+Should we create a data-storage class for reading the meshes / vertex data into?
+
+Need something which looks a little like the following:
+
+Group / transform node
+  (Transform properties)
+  (Children)-+------------> Shape -+-> Appearance / material
+             |                     `-> Geometry
+             |------------> Shape -+-> Appearance / material
+             |                     `-> Geometry
+             |------------> Shape -+-> Appearance / material
+             |                     `-> Geometry
+             `---------> Transform
+                            (Children)-+---> Shape -+-> Appearance / material
+                                       |            `-> Geometry
+                                       `---> Shape -+-> Appearance / material
+                                                    `-> Geometry
+#endif
+
+
+hidgl_geometry *hidgl_geometry_new (char *name);
+void hidgl_geometry_free (hidgl_geometry *geometry);
+void hidgl_geometry_draw (hidgl_geometry *geometry);
+
+#endif /* __HIDGL_GEOMETRY_INCLUDED__  */
diff --git a/src/hid/common/hidgl_material.c b/src/hid/common/hidgl_material.c
new file mode 100644
index 0000000..7709a44
--- /dev/null
+++ b/src/hid/common/hidgl_material.c
@@ -0,0 +1,252 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "hidgl_material.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+typedef struct {
+  GLfloat value[4];
+} _color;
+
+/* Opaque data-structure keeping a material object */
+struct _hidgl_material {
+  char *name;
+
+  _color ambient_color;
+  _color diffuse_color;
+  _color emission_color;
+  _color specular_color;
+  float shininess;
+
+  /* Potentially unused by the renderer */
+  _color transparent_color; /* NB: From collada, not used */
+  float transparency;       /* NB: From collada, not used */
+  _color reflective_color;  /* NB: From collada, not used */
+  float reflectivity;       /* NB: From collada, not used */
+
+  hidgl_shader *shader_program;
+};
+
+
+hidgl_material *
+hidgl_material_new (char *name)
+{
+  hidgl_material *material;
+  _color black;
+  _color white;
+
+  material = malloc (sizeof (hidgl_material));
+
+  if (material == NULL)
+    return NULL;
+
+  black.value[0] = 0.;
+  black.value[1] = 0.;
+  black.value[2] = 0.;
+  black.value[3] = 0.;
+
+  white.value[0] = 1.;
+  white.value[1] = 1.;
+  white.value[2] = 1.;
+  white.value[3] = 1.;
+
+  material->name = strdup (name);
+  material->ambient_color = white;
+  material->diffuse_color = white;
+  material->emission_color = black;
+  material->specular_color = white;
+  material->shininess = 0.;
+  material->transparent_color = white;
+  material->transparency = 0.;
+  material->reflective_color = white;
+  material->reflectivity = 0.;
+  material->shader_program = NULL;
+
+  return material;
+}
+
+
+/* Delete the passed material. */
+void
+hidgl_material_free (hidgl_material *material)
+{
+  free (material->name);
+  free (material);
+}
+
+
+/* Set the given material properties */
+void
+hidgl_material_activate (hidgl_material *material)
+{
+  glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT,   material->ambient_color.value);
+  glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE,   material->diffuse_color.value);
+  glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION,  material->emission_color.value);
+  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR,  material->specular_color.value);
+  glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &material->shininess);
+
+  /* XXX: Unused parameter: material->transparent_color */
+  /* XXX: Unused parameter: material->reflection_color  */
+  /* XXX: Unused parameter: material->transparency      */
+  /* XXX: Unused parameter: material->reflectivity      */
+
+  hidgl_shader_activate (material->shader_program);
+}
+
+void
+hidgl_material_set_ambient_color (hidgl_material *material, GLfloat color[4])
+{
+  material->ambient_color = *(_color *)color;
+}
+
+void hidgl_material_set_diffuse_color (hidgl_material *material, GLfloat color[4])
+{
+  material->diffuse_color = *(_color *)color;
+}
+
+void
+hidgl_material_set_emission_color (hidgl_material *material, GLfloat color[4])
+{
+  material->emission_color = *(_color *)color;
+}
+
+void
+hidgl_material_set_specular_color (hidgl_material *material, GLfloat color[4])
+{
+  material->specular_color = *(_color *)color;
+}
+
+void
+hidgl_material_set_shininess (hidgl_material *material, float shininess)
+{
+  material->shininess = shininess;
+}
+
+void
+hidgl_material_set_transparent_color (hidgl_material *material, GLfloat color[4])
+{
+  material->transparent_color = *(_color *)color;
+}
+
+void
+hidgl_material_set_transparency (hidgl_material *material, float transparency)
+{
+  material->transparency = transparency;
+}
+
+void
+hidgl_material_set_reflective_color (hidgl_material *material, GLfloat color[4])
+{
+  material->reflective_color = *(_color *)color;
+}
+
+void
+hidgl_material_set_reflectivity (hidgl_material *material, float reflectivity)
+{
+  material->reflectivity = reflectivity;
+}
+
+void
+hidgl_material_set_shader (hidgl_material *material, hidgl_shader *program)
+{
+  material->shader_program = program;
+}
+
+
+void
+hidgl_material_get_ambient_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->ambient_color;
+}
+
+void
+hidgl_material_get_diffuse_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->diffuse_color;
+}
+
+void
+hidgl_material_get_emission_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->emission_color;
+}
+
+void
+hidgl_material_get_specular_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->specular_color;
+}
+
+float
+hidgl_material_get_shininess (hidgl_material *material)
+{
+  return material->shininess;
+}
+
+void
+hidgl_material_get_transparent_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->transparent_color;
+}
+
+float
+hidgl_material_get_transparency (hidgl_material *material)
+{
+  return material->transparency;
+}
+
+void
+hidgl_material_get_reflective_color (hidgl_material *material, GLfloat *color)
+{
+  *(_color *)color = material->reflective_color;
+}
+
+float
+hidgl_material_get_reflectivity (hidgl_material *material)
+{
+  return material->reflectivity;
+}
+
+hidgl_shader *
+hidgl_material_get_shader (hidgl_material *material)
+{
+  return material->shader_program;
+}
diff --git a/src/hid/common/hidgl_material.h b/src/hid/common/hidgl_material.h
new file mode 100644
index 0000000..79638f4
--- /dev/null
+++ b/src/hid/common/hidgl_material.h
@@ -0,0 +1,58 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_MATERIAL_INCLUDED__
+#define __HIDGL_MATERIAL_INCLUDED__
+
+#include "hidgl_shaders.h"
+
+typedef struct _hidgl_material hidgl_material;
+
+hidgl_material *hidgl_material_new (char *name);
+void hidgl_material_free (hidgl_material *material);
+void hidgl_material_activate (hidgl_material *material);
+
+void hidgl_material_set_ambient_color     (hidgl_material *material, GLfloat color[4]);
+void hidgl_material_set_diffuse_color     (hidgl_material *material, GLfloat color[4]);
+void hidgl_material_set_emission_color    (hidgl_material *material, GLfloat color[4]);
+void hidgl_material_set_specular_color    (hidgl_material *material, GLfloat color[4]);
+void hidgl_material_set_shininess         (hidgl_material *material, float shininess);
+void hidgl_material_set_transparent_color (hidgl_material *material, GLfloat color[4]);   /* Not used? */
+void hidgl_material_set_transparency      (hidgl_material *material, float transparency); /* Not used? */
+void hidgl_material_set_reflective_color  (hidgl_material *material, GLfloat color[4]);   /* Not used? */
+void hidgl_material_set_reflectivity      (hidgl_material *material, float reflectivity); /* Not used? */
+void hidgl_material_set_shader            (hidgl_material *material, hidgl_shader *program);
+/* XXX: Textures? */
+
+void hidgl_material_get_ambient_color     (hidgl_material *material, GLfloat *color);
+void hidgl_material_get_diffuse_color     (hidgl_material *material, GLfloat *color);
+void hidgl_material_get_emission_color    (hidgl_material *material, GLfloat *color);
+void hidgl_material_get_specular_color    (hidgl_material *material, GLfloat *color);
+float hidgl_material_get_shininess        (hidgl_material *material);
+void hidgl_material_get_transparent_color (hidgl_material *material, GLfloat *color); /* Not used? */
+float hidgl_material_get_transparency     (hidgl_material *material);                 /* Not used? */
+void hidgl_material_get_reflective_color  (hidgl_material *material, GLfloat *color); /* Not used? */
+float hidgl_material_get_reflectivity     (hidgl_material *material);                 /* Not used? */
+hidgl_shader * hidgl_material_get_shader  (hidgl_material *material);
+
+
+#endif /* __HIDGL_MATERIAL_INCLUDED__  */
diff --git a/src/hid/common/hidgl_matrix.c b/src/hid/common/hidgl_matrix.c
new file mode 100644
index 0000000..5a9afdd
--- /dev/null
+++ b/src/hid/common/hidgl_matrix.c
@@ -0,0 +1,96 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+float
+determinant_2x2 (float m[2][2])
+{
+  float det;
+  det = m[0][0] * m[1][1] -
+        m[0][1] * m[1][0];
+  return det;
+}
+
+void
+invert_2x2 (float m[2][2], float out[2][2])
+{
+  float scale = 1 / determinant_2x2 (m);
+  out[0][0] =  m[1][1] * scale;
+  out[0][1] = -m[0][1] * scale;
+  out[1][0] = -m[1][0] * scale;
+  out[1][1] =  m[0][0] * scale;
+}
+
+float
+determinant_4x4 (float m[4][4])
+{
+  float det;
+  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
+        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
+        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
+        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
+        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
+        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
+        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
+        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
+        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
+        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
+        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
+        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
+   return det;
+}
+
+void
+invert_4x4 (float m[4][4], float out[4][4])
+{
+  float scale = 1 / determinant_4x4 (m);
+
+  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
+               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
+               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
+  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
+               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
+               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
+  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
+               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
+               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
+  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
+               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
+               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
+  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
+               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
+               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
+  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
+               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
+               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
+  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
+               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
+               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
+  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
+               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
+               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
+  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
+               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
+               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
+  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
+               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
+               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
+  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
+               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
+               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
+  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
+               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
+               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
+  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
+               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
+               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
+  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
+               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
+               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
+  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
+               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
+               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
+  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
+               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
+               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
+}
diff --git a/src/hid/common/hidgl_matrix.h b/src/hid/common/hidgl_matrix.h
new file mode 100644
index 0000000..5a8bc27
--- /dev/null
+++ b/src/hid/common/hidgl_matrix.h
@@ -0,0 +1,36 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_MATRIX_INCLUDED__
+#define __HIDGL_MATRIX_INCLUDED__
+
+/* Some convenience routines for simple matrix operations. For anything
+ * more complicated, we should probably pull in a linear algebra library.
+ */
+
+float determinant_2x2 (float m[2][2]);
+void invert_2x2 (float m[2][2], float out[2][2]);
+
+float determinant_4x4 (float m[4][4]);
+void invert_4x4 (float m[4][4], float out[4][4]);
+
+#endif /* __HIDGL_MATRIX_INCLUDED__  */
diff --git a/src/hid/common/hidgl_package_acy_resistor.c b/src/hid/common/hidgl_package_acy_resistor.c
index 97434e4..14a9439 100644
--- a/src/hid/common/hidgl_package_acy_resistor.c
+++ b/src/hid/common/hidgl_package_acy_resistor.c
@@ -30,6 +30,8 @@
 
 #include "hid_draw.h"
 #include "hidgl.h"
+#include "hidgl_material.h"
+#include "hidgl_geometry.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -49,6 +51,38 @@ extern PFNGLACTIVETEXTUREARBPROC   glActiveTextureARB;
 
 #endif
 
+typedef struct _hidgl_shape hidgl_shape;
+typedef struct _hidgl_transform hidgl_transform;
+
+hidgl_shape *hidgl_shape_new (hidgl_geometry *geometry, hidgl_material *material);
+hidgl_geometry *hidgl_tristrip_geometry_new ();
+hidgl_transform *hidgl_transform_new ();
+void hidgl_transform_rotate (hidgl_transform *transform, float angle, float x, float y, float z);
+void hidgl_transform_add_child (hidgl_transform *transform, hidgl_shape *shape);
+
+/* Static data we initialise for the model */
+typedef struct {
+  hidgl_transform *root;
+  hidgl_material *resistor_body_mat;
+  hidgl_material *resistor_pins_mat;
+  hidgl_material *selected_pins_mat;
+  hidgl_geometry *resistor_body_geom;
+  hidgl_geometry *resistor_pins_geom;
+  GLuint resistor_body_bump_texture;
+  GLuint zero_ohm_body_bump_texture;
+} model_data;
+
+static model_data model = {
+    .root = NULL,
+    .resistor_body_mat = NULL,
+    .resistor_pins_mat = NULL,
+    .selected_pins_mat = NULL,
+    .resistor_body_geom = NULL,
+    .resistor_pins_geom = NULL,
+    .resistor_body_bump_texture = 0,
+    .zero_ohm_body_bump_texture = 0
+};
+
 static int
 compute_offset (int x, int y, int width, int height)
 {
@@ -435,8 +469,6 @@ setup_hvdiode_texture (ElementType *element, GLfloat *body_color)
 }
 
 
-static void invert_4x4 (float m[4][4], float out[4][4]);
-
 static GLfloat *debug_lines = NULL;
 static int no_debug_lines = 0;
 static int max_debug_lines = 0;
@@ -716,41 +748,19 @@ emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
                  tex0_s, ang_edge2 / 2. / M_PI, tex0_s, mvm);
 }
 
-
 #define NUM_RESISTOR_STRIPS 100
 #define NUM_PIN_RINGS 15
 
 /* XXX: HARDCODED MAGIC */
 #define BOARD_THICKNESS MM_TO_COORD (1.6)
 
-void
-hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness)
+static hidgl_geometry *
+body_geometry (float resistor_pin_spacing)
 {
-
-  float center_x, center_y;
-  float angle;
-  GLfloat resistor_body_color[] =         {0.31, 0.47, 0.64};
-  GLfloat resistor_pin_color[] =          {0.82, 0.82, 0.82};
-  GLfloat resistor_warn_pin_color[] =     {0.82, 0.20, 0.20};
-  GLfloat resistor_found_pin_color[] =    {0.20, 0.82, 0.20};
-  GLfloat resistor_selected_pin_color[] = {0.00, 0.70, 0.82};
-  GLfloat *pin_color;
-
-  GLfloat mvm[16];
-
+  GLfloat mvm[16]; /* DOES NOT BELONG HERE */
+  hidgl_geometry *geometry = hidgl_tristrip_geometry_new ();
   int strip;
   int no_strips = NUM_RESISTOR_STRIPS;
-  int ring;
-  int no_rings = NUM_PIN_RINGS;
-  int end;
-  bool zero_ohm;
-
-  static bool first_run = true;
-  static GLuint texture1;
-  static GLuint texture2_resistor;
-  static GLuint texture2_zero_ohm;
-
-  GLuint restore_sp;
 
   /* XXX: Hard-coded magic */
   float resistor_pin_radius = MIL_TO_COORD (12.);
@@ -763,101 +773,14 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
   float resistor_taper2_offset = MIL_TO_COORD (33.);
   float resistor_bulge_offset = MIL_TO_COORD (45.);
   float resistor_bulge_width = MIL_TO_COORD (50.);
-  float resistor_pin_spacing = MIL_TO_COORD (400.);
-
-  float pin_penetration_depth = MIL_TO_COORD (30.) + board_thickness;
 
   float resistor_pin_bend_radius = resistor_bulge_radius;
   float resistor_width = resistor_pin_spacing - 2. * resistor_pin_bend_radius;
 
-  PinType *first_pin = element->Pin->data;
-  PinType *second_pin = g_list_next (element->Pin)->data;
-  PinType *pin;
-
-  Coord pin_delta_x = second_pin->X - first_pin->X;
-  Coord pin_delta_y = second_pin->Y - first_pin->Y;
-
-  center_x = first_pin->X + pin_delta_x / 2.;
-  center_y = first_pin->Y + pin_delta_y / 2.;
-  angle = atan2f (pin_delta_y, pin_delta_x);
-
-  /* TRANSFORM MATRIX */
-  glPushMatrix ();
-  glTranslatef (center_x, center_y, surface_depth + resistor_pin_bend_radius);
-  glRotatef (angle * 180. / M_PI + 90, 0., 0., 1.);
-  glRotatef (90, 1., 0., 0.);
-
-  /* Retrieve the resulting modelview matrix for the lighting calculations */
+  /* Retrieve the resulting modelview matrix for the lighting calculations  - DOES NOT BELONG HERE, GEOMETRY SHOULD BE STATIC */
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
 
-  /* TEXTURE SETUP */
-  glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
-  hidgl_shader_activate (resistor_program);
-
-  {
-    GLuint program = hidgl_shader_get_program (resistor_program);
-    int tex0_location = glGetUniformLocation (program, "detail_tex");
-    int tex1_location = glGetUniformLocation (program, "bump_tex");
-    glUniform1i (tex0_location, 0);
-    glUniform1i (tex1_location, 1);
-  }
-
-  glActiveTextureARB (GL_TEXTURE0_ARB);
-//  if (first_run) {
-    glGenTextures (1, &texture1);
-    glBindTexture (GL_TEXTURE_1D, texture1);
-    zero_ohm = setup_resistor_texture (element, resistor_body_color, 3);
-//  } else {
-//    glBindTexture (GL_TEXTURE_1D, texture1);
-//  }
-  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-  glEnable (GL_TEXTURE_1D);
-
-  glActiveTextureARB (GL_TEXTURE1_ARB);
-  if (first_run) {
-    glGenTextures (1, &texture2_resistor);
-    glBindTexture (GL_TEXTURE_2D, texture2_resistor);
-    load_texture_from_png ("resistor_bump.png", true);
-
-    glGenTextures (1, &texture2_zero_ohm);
-    glBindTexture (GL_TEXTURE_2D, texture2_zero_ohm);
-    load_texture_from_png ("zero_ohm_bump.png", true);
-  }
-  if (zero_ohm)
-    glBindTexture (GL_TEXTURE_2D, texture2_zero_ohm);
-  else
-    glBindTexture (GL_TEXTURE_2D, texture2_resistor);
-
-  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-  glEnable (GL_TEXTURE_2D);
-  glActiveTextureARB (GL_TEXTURE0_ARB);
-
-  /* COLOR / MATERIAL SETUP */
-//  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-//  glEnable (GL_COLOR_MATERIAL);
-
-  glPushAttrib (GL_CURRENT_BIT);
-//  glColor4f (1., 1., 1., 1.);
-  glColor4f (0., 0., 1., 0.);
-
-  glDisable (GL_LIGHTING);
-
-  if (1) {
-    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
-    GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
-    GLfloat shininess = 20.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
-  }
 
-#if 1
   glBegin (GL_TRIANGLE_STRIP);
 
   for (strip = 0; strip < no_strips; strip++) {
@@ -912,38 +835,34 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
                  strip_data[ring    ].tex0_s, resistor_width, pos, mvm);
     }
   }
-#endif
-
   glEnd ();
 
-  glActiveTextureARB (GL_TEXTURE1_ARB);
-  glDisable (GL_TEXTURE_2D);
-  glBindTexture (GL_TEXTURE_2D, 0);
-
-  glActiveTextureARB (GL_TEXTURE0_ARB);
-  glDisable (GL_TEXTURE_1D);
-  glBindTexture (GL_TEXTURE_1D, 0);
-  glDeleteTextures (1, &texture1);
-
-  glEnable (GL_LIGHTING);
+  return geometry;
+}
 
-  glUseProgram (0);
+static hidgl_geometry *
+pins_geometry (float resistor_pin_spacing, float board_thickness)
+{
+  hidgl_geometry *geometry = hidgl_tristrip_geometry_new ();
+  int strip;
+  int no_strips = NUM_RESISTOR_STRIPS;
+  int ring;
+  int no_rings = NUM_PIN_RINGS;
+  int end;
 
-  /* COLOR / MATERIAL SETUP */
-  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-  glEnable (GL_COLOR_MATERIAL);
+  /* XXX: Hard-coded magic */
+  float resistor_pin_radius = MIL_TO_COORD (12.);
+  float pin_penetration_depth = MIL_TO_COORD (30.) + board_thickness;
 
-  if (1) {
-//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
-    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
-    GLfloat shininess = 120.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
-  }
+  float resistor_bulge_radius = MIL_TO_COORD (43.);
+  float resistor_pin_bend_radius = resistor_bulge_radius;
+  float resistor_width = resistor_pin_spacing - 2. * resistor_pin_bend_radius;
 
+  float r = resistor_pin_bend_radius;
   for (end = 0; end < 2; end++) {
     float end_sign = (end == 0) ? 1. : -1.;
 
+#if 0
     pin = (end == 1) ? first_pin : second_pin;
 
     if (TEST_FLAG (WARNFLAG, pin))
@@ -958,6 +877,7 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
     glColor3f (pin_color[0] / 1.5,
                pin_color[1] / 1.5,
                pin_color[2] / 1.5);
+#endif
 
     for (ring = 0; ring < no_rings; ring++) {
 
@@ -993,74 +913,219 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
       glEnd ();
     }
 
-    if (1) {
-      float r = resistor_pin_bend_radius;
-      glBegin (GL_TRIANGLE_STRIP);
+    glBegin (GL_TRIANGLE_STRIP);
 
-      /* NB: We wrap back around to complete the last segment, so in effect
-       *     we draw no_strips + 1 strips.
-       */
-      for (strip = 0; strip < no_strips + 1; strip++) {
-        float strip_angle = strip * 2. * M_PI / no_strips;
+    /* NB: We wrap back around to complete the last segment, so in effect
+     *     we draw no_strips + 1 strips.
+     */
+    for (strip = 0; strip < no_strips + 1; strip++) {
+      float strip_angle = strip * 2. * M_PI / no_strips;
 
-        float x1 = resistor_pin_radius * cos (strip_angle);
-        float y1 = -r;
-        float z1 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+      float x1 = resistor_pin_radius * cos (strip_angle);
+      float y1 = -r;
+      float z1 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
 
-        float x2 = resistor_pin_radius * cos (strip_angle);
-        float y2 = -r - pin_penetration_depth;
-        float z2 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+      float x2 = resistor_pin_radius * cos (strip_angle);
+      float y2 = -r - pin_penetration_depth;
+      float z2 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
 
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x1, y1, z1);
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x2, y2, z2);
-      }
-      glEnd ();
+      glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+      glVertex3f (x1, y1, z1);
+      glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+      glVertex3f (x2, y2, z2);
     }
+    glEnd ();
 
-    if (1) {
-      float r = resistor_pin_bend_radius;
-      glBegin (GL_TRIANGLE_FAN);
+    glBegin (GL_TRIANGLE_FAN);
 
-      glNormal3f (0, 0., -1.);
-      glVertex3f (0, -r - pin_penetration_depth - resistor_pin_radius / 2., (r + resistor_width / 2.) * end_sign);
+    glNormal3f (0, 0., -1.);
+    glVertex3f (0, -r - pin_penetration_depth - resistor_pin_radius / 2., (r + resistor_width / 2.) * end_sign);
 
-      /* NB: We wrap back around to complete the last segment, so in effect
-       *     we draw no_strips + 1 strips.
-       */
-      for (strip = no_strips + 1; strip > 0; strip--) {
-        float strip_angle = strip * 2. * M_PI / no_strips;
+    /* NB: We wrap back around to complete the last segment, so in effect
+     *     we draw no_strips + 1 strips.
+     */
+    for (strip = no_strips + 1; strip > 0; strip--) {
+      float strip_angle = strip * 2. * M_PI / no_strips;
 
-        float x = resistor_pin_radius * cos (strip_angle);
-        float y = -r - pin_penetration_depth;
-        float z = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+      float x = resistor_pin_radius * cos (strip_angle);
+      float y = -r - pin_penetration_depth;
+      float z = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
 
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x, y, z);
-      }
-      glEnd ();
+      glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+      glVertex3f (x, y, z);
     }
+    glEnd ();
+  }
+
+  return geometry;
+}
+
+void
+hidgl_init_acy_resistor (void)
+{
+  hidgl_geometry *body_geom;
+  hidgl_geometry *pins_geom;
+  hidgl_shape *body_shape;
+  hidgl_shape *pins_shape;
+
+  GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
+  GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
+  GLfloat metal_pin_color[] =    {0.55f, 0.55f, 0.55f, 1.0f};
+  GLfloat warn_pin_color[] =     {0.82f, 0.20f, 0.20f, 1.0f};
+  GLfloat found_pin_color[] =    {0.20f, 0.82f, 0.20f, 1.0f};
+  GLfloat selected_pin_color[] = {0.00f, 0.70f, 0.82f, 1.0f};
+  GLfloat *pin_color = metal_pin_color;
+
+  /* Define the resistor body material */
+  model.resistor_body_mat = hidgl_material_new ("resistor_body");
+  hidgl_material_set_emission_color (model.resistor_body_mat, emission);
+  hidgl_material_set_specular_color (model.resistor_body_mat, specular);
+  hidgl_material_set_shininess (model.resistor_body_mat, 20.0f);
+  hidgl_material_set_shader (model.resistor_body_mat, resistor_program);
+
+  /* Define the resistor pins material */
+  model.resistor_pins_mat = hidgl_material_new ("resistor_pins");
+  hidgl_material_set_ambient_color (model.resistor_pins_mat, pin_color);
+  hidgl_material_set_diffuse_color (model.resistor_pins_mat, pin_color);
+  hidgl_material_set_emission_color (model.resistor_pins_mat, emission);
+  hidgl_material_set_specular_color (model.resistor_pins_mat, specular);
+  hidgl_material_set_shininess (model.resistor_pins_mat, 120.0f);
+
+  /* Define the resistor selected pin material */
+  model.selected_pins_mat = hidgl_material_new ("selected_pins");
+  hidgl_material_set_ambient_color (model.selected_pins_mat, selected_pin_color);
+  hidgl_material_set_diffuse_color (model.selected_pins_mat, selected_pin_color);
+  hidgl_material_set_emission_color (model.selected_pins_mat, emission);
+  hidgl_material_set_specular_color (model.selected_pins_mat, specular);
+  hidgl_material_set_shininess (model.selected_pins_mat, 120.0f);
+
+  /* Load bump mapping textures */
+  glGenTextures (1, &model.resistor_body_bump_texture);
+  glBindTexture (GL_TEXTURE_2D, model.resistor_body_bump_texture);
+  load_texture_from_png ("resistor_bump.png", true);
+
+  glGenTextures (1, &model.zero_ohm_body_bump_texture);
+  glBindTexture (GL_TEXTURE_2D, model.zero_ohm_body_bump_texture);
+  load_texture_from_png ("zero_ohm_bump.png", true);
+
+  /* Setup geometry and transforms */
+  model.root = hidgl_transform_new ();
+  hidgl_transform_rotate (model.root, 90., 1., 0., 0.);
+
+  body_geom = body_geometry (MIL_TO_COORD (400.));
+  pins_geom = pins_geometry (MIL_TO_COORD (400.), BOARD_THICKNESS);
+
+  body_shape = hidgl_shape_new (body_geom, model.resistor_body_mat);
+  pins_shape = hidgl_shape_new (pins_geom, model.resistor_pins_mat);
+
+  hidgl_transform_add_child (model.root, body_shape);
+  hidgl_transform_add_child (model.root, pins_shape);
+}
+
+void
+hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness)
+{
+  float center_x, center_y;
+  float angle;
+  GLfloat resistor_body_color[] = {0.31, 0.47, 0.64, 1.0};
+  GLfloat mvm[16];
+  bool zero_ohm;
+  static GLuint texture1;
+  GLuint restore_sp;
+
+  /* XXX: Hard-coded magic */
+  float resistor_bulge_radius = MIL_TO_COORD (43.);
+  float resistor_pin_bend_radius = resistor_bulge_radius;
+
+  PinType *first_pin = element->Pin->data;
+  PinType *second_pin = g_list_next (element->Pin)->data;
+
+  Coord pin_delta_x = second_pin->X - first_pin->X;
+  Coord pin_delta_y = second_pin->Y - first_pin->Y;
+
+  center_x = first_pin->X + pin_delta_x / 2.;
+  center_y = first_pin->Y + pin_delta_y / 2.;
+  angle = atan2f (pin_delta_y, pin_delta_x);
+
+  /* TRANSFORM MATRIX */
+  glPushMatrix ();
+  glTranslatef (center_x, center_y, surface_depth + resistor_pin_bend_radius);
+  glRotatef (angle * 180. / M_PI + 90, 0., 0., 1.);
+  glRotatef (90, 1., 0., 0.);
+
+  /* Retrieve the resulting modelview matrix for the lighting calculations */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  /* TEXTURE SETUP */
+  glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
+  hidgl_shader_activate (resistor_program);
+
+  {
+    GLuint program = hidgl_shader_get_program (resistor_program);
+    int tex0_location = glGetUniformLocation (program, "detail_tex");
+    int tex1_location = glGetUniformLocation (program, "bump_tex");
+    glUniform1i (tex0_location, 0);
+    glUniform1i (tex1_location, 1);
   }
 
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+  glGenTextures (1, &texture1);
+  glBindTexture (GL_TEXTURE_1D, texture1);
+  zero_ohm = setup_resistor_texture (element, resistor_body_color, 3);
+
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glEnable (GL_TEXTURE_1D);
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  if (zero_ohm)
+    glBindTexture (GL_TEXTURE_2D, model.zero_ohm_body_bump_texture);
+  else
+    glBindTexture (GL_TEXTURE_2D, model.resistor_body_bump_texture);
+
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glEnable (GL_TEXTURE_2D);
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+
+  glPushAttrib (GL_CURRENT_BIT);
+
+  glDisable (GL_LIGHTING);
+
+  hidgl_material_activate (model.resistor_body_mat);
+
+  /* Draw body */
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  glDisable (GL_TEXTURE_2D);
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+  glDisable (GL_TEXTURE_1D);
+  glBindTexture (GL_TEXTURE_1D, 0);
+  glDeleteTextures (1, &texture1);
+
+  glEnable (GL_LIGHTING);
+
+  hidgl_material_activate (model.resistor_pins_mat);
+
+  /* Draw pins */
+
   glDisable (GL_COLOR_MATERIAL);
   glPopAttrib ();
 
   glDisable (GL_LIGHTING);
-//  glDisable (GL_DEPTH_TEST);
-
-  glPushMatrix ();
-  glLoadIdentity ();
-  debug_basis_display ();
-  glPopMatrix ();
-//  glEnable (GL_DEPTH_TEST);
 
   glPopMatrix ();
   glUseProgram (restore_sp);
-
-  first_run = false;
 }
 
+
+
 void
 hidgl_draw_800mil_resistor (ElementType *element, float surface_depth, float board_thickness)
 {
@@ -2625,77 +2690,3 @@ hidgl_draw_350x800mil_cap (ElementType *element, float surface_depth, float boar
 
   first_run = false;
 }
-
-static float
-determinant_4x4 (float m[4][4])
-{
-  float det;
-  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
-        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
-        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
-        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
-        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
-        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
-        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
-        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
-        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
-        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
-        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
-        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
-   return det;
-}
-
-static void
-invert_4x4 (float m[4][4], float out[4][4])
-{
-  float scale = 1 / determinant_4x4 (m);
-
-  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
-               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
-               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
-  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
-               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
-               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
-  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
-               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
-               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
-  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
-               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
-               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
-  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
-               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
-               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
-  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
-               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
-               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
-  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
-               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
-               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
-  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
-               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
-               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
-  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
-               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
-               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
-  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
-               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
-               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
-  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
-               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
-               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
-  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
-               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
-               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
-  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
-               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
-               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
-  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
-               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
-               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
-  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
-               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
-               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
-  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
-               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
-               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
-}
diff --git a/src/hid/common/hidgl_package_vrml.c b/src/hid/common/hidgl_package_vrml.c
new file mode 100644
index 0000000..aa30bfd
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml.c
@@ -0,0 +1,366 @@
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <stdbool.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include "data.h"
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+
+#include "hidgl_matrix.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+static void
+load_texture_from_png (char *filename)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  int has_alpha;
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
+
+  g_object_unref (pixbuf);
+}
+
+
+static GLfloat *debug_lines = NULL;
+static int no_debug_lines = 0;
+static int max_debug_lines = 0;
+
+//#define LENG 1000
+#define LENG 0.6
+#define STRIDE_FLOATS 6
+static void
+debug_basis_vector (float x,   float y,   float z,
+                    float b1x, float b1y, float b1z,
+                    float b2x, float b2y, float b2z,
+                    float b3x, float b3y, float b3z)
+{
+  int comp_count;
+  float lenb1, lenb2, lenb3;
+
+  if (no_debug_lines + 3 > max_debug_lines) {
+    max_debug_lines += 10;
+    debug_lines = realloc (debug_lines, max_debug_lines * sizeof (GLfloat) * 2 * STRIDE_FLOATS);
+  }
+
+  lenb1 = sqrt (b1x * b1x + b1y * b1y + b1z * b1z);
+  lenb2 = sqrt (b2x * b2x + b2y * b2y + b2z * b2z);
+  lenb3 = sqrt (b3x * b3x + b3y * b3y + b3z * b3z);
+  b1x /= lenb1;  b1y /= lenb1;  b1z /= lenb1;
+  b2x /= lenb2;  b2y /= lenb2;  b2z /= lenb2;
+  b3x /= lenb3;  b3y /= lenb3;  b3z /= lenb3;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b1x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b1y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b1z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b2x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b2y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b2z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b3x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b3y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b3z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  no_debug_lines++;
+}
+
+static void
+debug_basis_display ()
+{
+  if (no_debug_lines == 0)
+    return;
+
+#if 1
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glVertexPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[0]);
+  glColorPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[3]);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glDrawArrays (GL_LINES, 0, no_debug_lines * 2);
+  glDisableClientState (GL_COLOR_ARRAY);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glPopAttrib ();
+#endif
+
+  free (debug_lines);
+  debug_lines = NULL;
+  no_debug_lines = 0;
+  max_debug_lines = 0;
+}
+
+/* b1{x,y,z} is the basis vector along "s" texture space */
+/* b2{x,y,z} is the basis vector along "t" texture space */
+static void
+compute_light_vector (float b1x, float b1y, float b1z,
+                      float b2x, float b2y, float b2z,
+                      float *lx, float *ly, float *lz,
+                      float *hx, float *hy, float *hz,
+                      float x,   float y,   float z)
+{
+  float b3x, b3y, b3z;
+  float tb1x, tb1y, tb1z;
+  float tb2x, tb2y, tb2z;
+  float tb3x, tb3y, tb3z;
+  float mvm[16]; /* NB: TRANSPOSED IN MEMORY */
+  /* NB: light_direction is a vector _TOWARDS_ the light source position */
+//  float light_direction[] = {-0.5, 1., -1.}; /* XXX: HARDCODEED! */
+  float light_direction[] = {0.0, 0.0, 1.0}; /* XXX: HARDCODEED! */
+  float half_direction[3];
+  float texspace_to_eye[4][4];
+  float eye_to_texspace[4][4];
+  float lenb1, lenb2, lenb3;
+  float len_half;
+  float len_light;
+
+  /* Normalise the light vector */
+  len_light = sqrt (light_direction[0] * light_direction[0] +
+                    light_direction[1] * light_direction[1] +
+                    light_direction[2] * light_direction[2]);
+  light_direction[0] /= len_light;
+  light_direction[1] /= len_light;
+  light_direction[2] /= len_light;
+
+  /* Sum with the unit vector towards the viewer */
+  half_direction[0] = light_direction[0] + 0.;
+  half_direction[1] = light_direction[1] + 0.;
+  half_direction[2] = light_direction[2] + 1.;
+
+  /* XXX: Should cache this ourselves */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                        0., 0., 1.,
+                        light_direction[0], light_direction[1], light_direction[2],
+                        half_direction[0], half_direction[1], half_direction[2]);
+
+  /* Third basis vector is the cross product of tb1 and tb2 */
+  b3x = (b2y * b1z - b2z * b1y);
+  b3y = (b2z * b1x - b2x * b1z);
+  b3z = (b2x * b1y - b2y * b1x);
+
+  /* Transform the S, T texture space bases into eye coordinates */
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;
+
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;
+
+  tb3x = mvm[0] * b3x + mvm[4] * b3y + mvm[ 8] * b3z;
+  tb3y = mvm[1] * b3x + mvm[5] * b3y + mvm[ 9] * b3z;
+  tb3z = mvm[2] * b3x + mvm[6] * b3y + mvm[10] * b3z;
+
+#if 1
+  /* Normalise tb1, tb2 and tb3 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  lenb3 = sqrt (tb3x * tb3x + tb3y * tb3y + tb3z * tb3z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+  tb3x /= lenb3;  tb3y /= lenb3;  tb3z /= lenb3;
+#endif
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                         tb1x, tb1y, tb1z, tb2x, tb2y, tb2z, tb3x, tb3y, tb3z);
+
+  texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
+  texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
+  texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
+  texspace_to_eye[3][0] = 0.0;  texspace_to_eye[3][1] = 0.0;  texspace_to_eye[3][2] = 0.0;   texspace_to_eye[3][3] = 1.0;
+
+  invert_4x4 (texspace_to_eye, eye_to_texspace);
+
+  /* light_direction is in eye space, we need to transform this into texture space */
+  *lx = eye_to_texspace[0][0] * light_direction[0] +
+        eye_to_texspace[0][1] * light_direction[1] +
+        eye_to_texspace[0][2] * light_direction[2];
+  *ly = eye_to_texspace[1][0] * light_direction[0] +
+        eye_to_texspace[1][1] * light_direction[1] +
+        eye_to_texspace[1][2] * light_direction[2];
+  *lz = eye_to_texspace[2][0] * light_direction[0] +
+        eye_to_texspace[2][1] * light_direction[1] +
+        eye_to_texspace[2][2] * light_direction[2];
+
+  /* half_direction is in eye space, we need to transform this into texture space */
+  *hx = eye_to_texspace[0][0] * half_direction[0] +
+        eye_to_texspace[0][1] * half_direction[1] +
+        eye_to_texspace[0][2] * half_direction[2];
+  *hy = eye_to_texspace[1][0] * half_direction[0] +
+        eye_to_texspace[1][1] * half_direction[1] +
+        eye_to_texspace[1][2] * half_direction[2];
+  *hz = eye_to_texspace[2][0] * half_direction[0] +
+        eye_to_texspace[2][1] * half_direction[1] +
+        eye_to_texspace[2][2] * half_direction[2];
+
+  {
+    len_light = sqrt (*lx * *lx + *ly * *ly + *lz * *lz);
+    *lx /= len_light;
+    *ly /= len_light;
+    *lz /= len_light;
+
+    *lx = *lx / 2. + 0.5;
+    *ly = *ly / 2. + 0.5;
+    *lz = *lz / 2. + 0.5;
+
+    len_half = sqrt (*hx * *hx + *hy * *hy + *hz * *hz);
+    *hx /= len_half;
+    *hy /= len_half;
+    *hz /= len_half;
+
+    *hx = *hx / 2. + 0.5;
+    *hy = *hy / 2. + 0.5;
+    *hz = *hz / 2. + 0.5;
+  }
+}
+
+static void
+emit_vertex (float x,   float y,   float z,
+             float b1x, float b1y, float b1z,
+             float b2x, float b2y, float b2z,
+             float tex0_s, float tex1_s, float tex1_t)
+{
+  GLfloat lx, ly, lz;
+  GLfloat hx, hy, hz;
+  compute_light_vector (b1x, b1y, b1z, b2x, b2y, b2z, &lx, &ly, &lz, &hx, &hy, &hz, x, y, z);
+  glColor3f (lx, ly, lz);
+  glMultiTexCoord1f (GL_TEXTURE0, tex0_s);
+  glMultiTexCoord2f (GL_TEXTURE1, tex1_s, tex1_t);
+  glMultiTexCoord3f (GL_TEXTURE2, hx, hy, hz);
+  glVertex3f (x, y, z);
+}
+
+enum geom_pos {
+  FIRST,
+  MIDDLE,
+  LAST
+};
+
+static void
+emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
+           float ang_edge2, float cos_edge2, float sin_edge2,
+           float prev_r, float prev_z,
+           float      r, float      z,
+           float next_r, float next_z,
+           float tex0_s, float resistor_width,
+           enum geom_pos pos)
+{
+  int repeat;
+
+  tex0_s = z / resistor_width + 0.5;
+
+  for (repeat = 0; repeat < ((pos == FIRST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge1, r * sin_edge1, z,
+                 sin_edge1, -cos_edge1, 0,
+                 cos_edge1 * (next_r - prev_r) / 2., sin_edge1 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge1 / 2. / M_PI, tex0_s);
+
+  for (repeat = 0; repeat < ((pos == LAST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge2, r * sin_edge2, z,
+                 sin_edge2, -cos_edge2, 0,
+                 cos_edge2 * (next_r - prev_r) / 2., sin_edge2 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge2 / 2. / M_PI, tex0_s);
+}
+
+
+#define NUM_RESISTOR_STRIPS 100
+#define NUM_PIN_RINGS 15
+#define MIL_TO_INTERNAL 100.
+
+extern int hidgl_parse_vrml (char *filename);
+
+void
+hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file)
+{
+  static bool one_shot = true;
+
+  if (!one_shot)
+    return;
+
+  printf ("hidgl_draw_vrml\n");
+  hidgl_parse_vrml ("test.wrl");
+  one_shot = false;
+}
diff --git a/src/hid/common/hidgl_package_vrml_l.l b/src/hid/common/hidgl_package_vrml_l.l
new file mode 100644
index 0000000..d8f86af
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_l.l
@@ -0,0 +1,276 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if defined(_POSIX_SOURCE) || defined(_HPUX_SOURCE)
+#include <unistd.h>
+#endif
+
+#include "global.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+
+#include "global.h"
+#include "crosshair.h"
+#include "data.h"
+#include "error.h"
+#include "file.h"
+#include "mymem.h"
+#include "misc.h"
+#include "strflags.h"
+#include "hidgl_package_vrml_y.h"
+
+/* ---------------------------------------------------------------------------
+ * some shared parser identifiers
+ */
+#ifdef FLEX_SCANNER
+int vrml_yylineno;  /* linenumber */
+#define yyunput ATTRIBUTE_UNUSED yyunput
+#endif
+
+char *vrml_yyfilename; /* in this file */
+
+/* ---------------------------------------------------------------------------
+ * an external prototype
+ */
+extern int	vrml_yyparse(void);
+
+/*STRING			".*" ... double-quotes must be \", backslashes must be \\... */
+/*IDFIRSTCHAR		[^0-9 "#'+,-.\[\\\]{}] */
+/*IDRESTCHARS		[^ "#',.\[\\\]{}] */
+
+/*STRINGCHAR              ([^"\n\r\\]|\\.) */
+/* \"{STRINGCHAR}*\"	{printf ("DEAD RULE?\n");} */
+/* {STRINGCHAR}+		{ */
+
+%}
+
+INT32			([+\-]?(([0-9]+)|(0[xX][0-9a-fA-F]+)))
+FLOATING		([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
+
+DECIMAL                 -?[1-9][0-9]*|0
+
+STRINGCHAR              ([^, "\n\r\\{}\[\]]|\\.)
+
+%option prefix="vrml_yy"
+%option outfile="lex.yy.c"
+%option yylineno
+
+%%
+
+DEF		{ return T_DEF; }
+EXTERNPROTO	{ return T_EXTERNPROTO; }
+FALSE		{ return T_FALSE; }
+IS		{ return T_IS; }
+NULL		{ return T_NULL; }
+PROTO		{ return T_PROTO; }
+ROUTE		{ return T_ROUTE; }
+TO		{ return T_TO; }
+TRUE		{ return T_TRUE; }
+USE		{ return T_USE; }
+eventIn		{ return T_EVENTIN; }
+eventOut	{ return T_EVENTOUT; }
+exposedField	{ return T_EXPOSEDFIELD; }
+field		{ return T_FIELD; }
+
+Script		{ return T_SCRIPT; }
+
+"#VRML V2.0 utf8"	{ return T_VRMLHEADER; }
+
+%{ /* Fields for any grouping node */ %}
+children		{ return T_children; }
+
+%{ /* Transform node and its fields */ %}
+Transform		{ return T_TRANSFORM; }
+center			{ return T_center; }
+rotation		{ return T_rotation; }
+scale			{ return T_scale; }
+scaleOrientation	{ return T_scale_orientation; }
+translation		{ return T_translation; }
+bboxCenter		{ return T_bbox_center; }
+bboxSize		{ return T_bbox_size; }
+
+%{ /* Shape node and its fields */ %}
+Shape			{ return T_SHAPE; }
+appearance		{ return T_appearance; }
+geometry		{ return T_geometry; }
+
+%{ /* Appearance node and its fields */ %}
+Appearance		{ return T_APPEARANCE; }
+material		{ return T_material; }
+texture			{ return T_texture; }
+textureTransform	{ return T_texture_transform; }
+
+%{ /* Material node and its fields */ %}
+Material		{ return T_MATERIAL; }
+ambientIntensity	{ return T_ambient_intensity; }
+diffuseColor		{ return T_diffuse_color; }
+emissiveColor		{ return T_emissive_color; }
+shininess		{ return T_shininess; }
+specularColor		{ return T_specular_color; }
+transparency		{ return T_transparency; }
+
+%{ /* IndexedFaceSet node and its fields */ %}
+IndexedFaceSet		{ return T_INDEXED_FACE_SET; }
+color			{ return T_color; }
+coord			{ return T_coord; }
+normal			{ return T_normal; }
+texCoord		{ return T_tex_coord; }
+ccw			{ return T_ccw; }
+colorIndex		{ return T_color_index; }
+colorPerVertex		{ return T_color_per_vertex; }
+convex			{ return T_convex; }
+coordIndex		{ return T_coord_index; }
+creaseAngle		{ return T_crease_angle; }
+normalIndex		{ return T_normal_index; }
+normalPerVertex		{ return T_normal_per_vertex; }
+solid			{ return T_solid; }
+texCoordIndex		{ return T_tex_coord_index; }
+
+%{ /* Coordinate node and its field */ %}
+Coordinate		{ return T_COORDINATE; }
+point			{ return T_point; }
+
+%{ /* Normal node and its field */ %}
+Normal			{ return T_NORMAL; }
+vector			{ return T_vector; }
+
+
+{INT32}		{
+					vrml_yylval.int32 = atoi(vrml_yytext);
+					return INT32;
+			}
+
+{FLOATING}		{
+					vrml_yylval.floating = strtod (vrml_yytext, NULL);
+					return FLOATING;
+			}
+
+#.*					{}
+
+{STRINGCHAR}*	{
+
+						char	*p1, *p2;
+
+							/* allocate memory and copy string;
+							 * stringlength is counted and copied without
+							 * leading and trailing '"'
+							 */
+						vrml_yylval.string = calloc (vrml_yyleng+1, sizeof(char));
+						p1 = (char *) (vrml_yytext);
+						p2 = vrml_yylval.string;
+						while(vrml_yyleng--)
+						{
+								/* check for special character */
+							if (*p1 == '\\')
+							{
+								vrml_yyleng--;
+								p1++;
+
+							}
+							*p2++ = *p1++;
+						}
+						*p2 = '\0';
+//						printf ("Returning a string token %s\n", vrml_yylval.string);
+						return(STRING);
+					}
+[ \t,]+				{}
+[\n]				{
+#ifndef FLEX_SCANNER
+						vrml_yylineno++;
+#endif
+					}
+[\r]				{}
+.					{ return(*vrml_yytext); }
+
+%%
+
+/* ---------------------------------------------------------------------------
+ * sets up the preprocessor command
+ */
+static int Parse(char *filename)
+{
+  int retval;
+  extern int vrml_yydebug;
+
+#ifdef FLEX_SCANNER
+  static	bool	firsttime = true;
+#endif
+
+  yyin = fopen (filename, "r");
+  if (!yyin)
+    return 1;
+
+#ifdef FLEX_SCANNER
+  /* reset parser if not called the first time */
+  if (!firsttime)
+    vrml_yyrestart(yyin);
+  firsttime = false;
+#endif
+
+  /* init linenumber and filename for vrml_yyerror() */
+  vrml_yylineno = 1;
+  vrml_yyfilename = filename;
+//  vrml_yydebug = 1;
+
+  /* We need to save the data temporarily because lex-yacc are able
+   * to break the application if the input file has an illegal format.
+   * It's not necessary if the system supports the call of functions
+   * on termination.
+   */
+
+#if !defined(HAS_ATEXIT) && !defined(HAS_ON_EXIT)
+  if (PCB)
+    SaveTMPData();
+  retval = vrml_yyparse();
+  RemoveTMPData();
+#else
+  retval = vrml_yyparse();
+#endif
+
+  /* clean up parse buffer */
+  vrml_yy_delete_buffer (YY_CURRENT_BUFFER);
+
+  return (fclose (vrml_yyin) ? 1 : retval);
+}
+
+/* ---------------------------------------------------------------------------
+ * initializes LEX and calls parser for a single element file
+ */
+int hidgl_parse_vrml (char *filename)
+{
+  return (Parse (filename));
+}
diff --git a/src/hid/common/hidgl_package_vrml_y.y b/src/hid/common/hidgl_package_vrml_y.y
new file mode 100644
index 0000000..0a59fbe
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_y.y
@@ -0,0 +1,631 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "global.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+#define YYDEBUG 1
+
+int vrml_yyerror(const char *s);
+extern int vrml_yylex();
+extern int vrml_yylineno;
+extern char *vrml_yyfilename;
+
+%}
+
+%name-prefix="vrml_yy"
+
+%union									/* define YYSTACK type */
+{
+	int		int32;
+	double		floating;
+	char		*string;
+}
+
+%token T_DEF
+%token T_EXTERNPROTO
+%token T_FALSE
+%token T_IS
+%token T_NULL
+%token T_PROTO
+%token T_ROUTE
+%token T_TO
+%token T_TRUE
+%token T_USE
+%token T_EVENTIN
+%token T_EVENTOUT
+%token T_EXPOSEDFIELD
+%token T_FIELD
+
+%token MFColor
+%token MFFloat
+%token MFInt32
+%token MFNode
+%token MFRotation
+%token MFString
+%token MFTime
+%token MFVec2f
+%token MFVec3f
+%token SFBool
+%token SFColor
+%token SFFloat
+%token SFImage
+%token SFInt32
+%token SFNode
+%token SFRotation
+%token SFString
+%token SFTime
+%token SFVec2f
+%token SFVec3f
+
+%token T_VRMLHEADER
+%token T_SCRIPT
+%token T_ID
+%token T_FIELDTYPE
+
+
+/* Fields for any grouping node */
+%token T_children
+
+/* Transform node and its fields */
+%token T_TRANSFORM
+%token T_center
+%token T_rotation
+%token T_scale
+%token T_scale_orientation
+%token T_translation
+%token T_bbox_center
+%token T_bbox_size
+
+/* Shape node and its fields */
+%token T_SHAPE
+%token T_appearance
+%token T_geometry
+
+/* Appearance node and its fields */
+%token T_APPEARANCE
+%token T_material
+%token T_texture
+%token T_texture_transform
+
+/* Material node and its fields */
+%token T_MATERIAL
+%token T_ambient_intensity
+%token T_diffuse_color
+%token T_emissive_color
+%token T_shininess
+%token T_specular_color
+%token T_transparency
+
+/* IndexedFaceSet node and its fields */
+%token T_INDEXED_FACE_SET
+%token T_color
+%token T_coord
+%token T_normal
+%token T_tex_coord
+%token T_ccw
+%token T_color_index
+%token T_color_per_vertex
+%token T_convex
+%token T_coord_index
+%token T_crease_angle
+%token T_normal_index
+%token T_normal_per_vertex
+%token T_solid
+%token T_tex_coord_index
+
+/* Coordinate node and its field */
+%token T_COORDINATE
+%token T_point
+
+/* Normal node and its field */
+%token T_NORMAL
+%token T_vector
+
+
+%token <floating>      FLOATING
+%token <number>        INT32
+
+%token <string>        STRING
+//%token <string>        IDFIRSTCHAR
+//%token <string>        IDRESTCHARS
+
+%%
+
+/* General VRML stuff */
+
+parse				: vrmlHeader
+				  vrmlScene
+				| error { YYABORT; }
+				;
+
+vrmlHeader			: T_VRMLHEADER { printf ("Got header\n"); }
+				  vrmlHeaderComment
+				;
+
+vrmlHeaderComment		: sfstringValues
+				| empty
+				;
+
+vrmlScene			: statements
+				;
+
+statements			: statement
+				| statement statements
+				| empty
+				;
+
+statement			: nodeStatement
+//				| protoStatement
+//				| routeStatement
+				;
+
+nodeStatement			: node
+				| T_DEF nodeNameId node
+				| T_USE nodeNameId
+				;
+
+/*
+rootNodeStatement		: node
+				| T_DEF nodeNameId node { printf ("Got a root Node Statement\n"); }
+				;
+
+protoStatement			: proto
+				| externproto
+				;
+
+protoStatements			: protoStatement
+				| protoStatement protoStatements
+				| empty
+				;
+
+proto				: T_PROTO nodeTypeId '[' interfaceDeclarations ']' '{' protoBody '}'
+				;
+
+protoBody			: protoStatements rootNodeStatement statements
+				;
+
+interfaceDeclarations		: interfaceDeclaration
+				| interfaceDeclaration interfaceDeclarations
+				| empty
+				;
+
+restrictedInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId fieldValue
+				;
+
+interfaceDeclaration		: restrictedInterfaceDeclaration
+				| T_EXPOSEDFIELD fieldType fieldId fieldValue
+				;
+
+externproto			: T_EXTERNPROTO nodeTypeId '[' externInterfaceDeclarations ']' URLList
+				;
+
+externInterfaceDeclarations	: externInterfaceDeclaration
+				| externInterfaceDeclaration externInterfaceDeclarations
+				| empty
+				;
+
+externInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId
+				| T_EXPOSEDFIELD fieldType fieldId
+				;
+
+routeStatement			: T_ROUTE nodeNameId '.' eventOutId T_TO nodeNameId '.' eventInId
+				;
+
+URLList				: mfstringValue
+				;
+*/
+
+empty				:
+				;
+
+
+/* NODES */
+
+/*
+node				: nodeTypeId '{' nodeBody '}'
+				| T_SCRIPT '{' scriptBody '}'
+				;
+*/
+
+node				: T_TRANSFORM        '{' Transform_nodeBody      '}' { printf ("Got a transform node\n");}
+				| T_SHAPE            '{' Shape_nodeBody          '}' { printf ("Got a shape node\n");}
+				| T_APPEARANCE       '{' Appearance_nodeBody     '}' { printf ("Got an appearance node\n");}
+				| T_MATERIAL         '{' Material_nodeBody       '}' { printf ("Got a material node\n");}
+				| T_INDEXED_FACE_SET '{' IndexedFaceSet_nodeBody '}' { printf ("Got an indexed face set node\n");}
+				| T_COORDINATE       '{' Coordinate_nodeBody     '}' { printf ("Got a coordinate node\n");}
+				| T_NORMAL           '{' Normal_nodeBody         '}' { printf ("Got a normal node\n");}
+				| T_SCRIPT           '{' scriptBody '}'
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Transform_nodeBody		: Transform_nodeBodyElements
+				| empty;
+
+Transform_nodeBodyElements	: Transform_nodeBodyElement
+				| Transform_nodeBodyElement Transform_nodeBodyElements;
+
+Transform_nodeBodyElement	: T_center sfvec3fValue
+				| T_children '[' statements ']'
+				| T_rotation sfvec3fValue
+				| T_scale sfvec3fValue
+				| T_scale_orientation sfrotationValue
+				| T_translation sfvec3fValue
+				| T_bbox_center sfvec3fValue
+				| T_bbox_size sfvec3fValue
+				;
+
+/* SHAPE NODE -------------------------------------------------------------- */
+Shape_nodeBody			: Shape_nodeBodyElements
+				| empty;
+
+Shape_nodeBodyElements		: Shape_nodeBodyElement
+				| Shape_nodeBodyElement Shape_nodeBodyElements;
+
+Shape_nodeBodyElement		: T_appearance statements
+				| T_geometry statements
+				;
+
+/* APPEARANCE NODE --------------------------------------------------------- */
+Appearance_nodeBody		: Appearance_nodeBodyElements
+				| empty;
+
+Appearance_nodeBodyElements	: Appearance_nodeBodyElement
+				| Appearance_nodeBodyElement Appearance_nodeBodyElements;
+
+Appearance_nodeBodyElement	: T_material statements
+				| T_texture statements
+				| T_texture_transform statements
+				;
+
+/* MATERIAL NODE ----------------------------------------------------------- */
+Material_nodeBody		: Material_nodeBodyElements
+				| empty;
+
+Material_nodeBodyElements	: Material_nodeBodyElement
+				| Material_nodeBodyElement Material_nodeBodyElements;
+
+Material_nodeBodyElement	: T_ambient_intensity sffloatValue
+				| T_diffuse_color sfcolorValue
+				| T_emissive_color sfcolorValue
+				| T_shininess sffloatValue
+				| T_specular_color sfcolorValue
+				| T_transparency sffloatValue
+				;
+
+/* INDEXED_FACE_SET NODE --------------------------------------------------- */
+IndexedFaceSet_nodeBody		: IndexedFaceSet_nodeBodyElements
+				| empty;
+
+IndexedFaceSet_nodeBodyElements	: IndexedFaceSet_nodeBodyElement
+				| IndexedFaceSet_nodeBodyElement IndexedFaceSet_nodeBodyElements;
+
+IndexedFaceSet_nodeBodyElement	: T_color statement
+				| T_coord statement
+				| T_normal statement
+				| T_tex_coord statement
+				| T_ccw sfboolValue
+				| T_color_index mfint32Value
+				| T_color_per_vertex sfboolValue
+				| T_convex sfboolValue
+				| T_coord_index mfint32Value
+				| T_crease_angle sffloatValue
+				| T_normal_index mfint32Value
+				| T_normal_per_vertex sfboolValue
+				| T_solid sfboolValue
+				| T_tex_coord_index mfint32Value
+				;
+
+/* COORDINATE NODE --------------------------------------------------------- */
+Coordinate_nodeBody		: Coordinate_nodeBodyElements
+				| empty;
+
+Coordinate_nodeBodyElements	: Coordinate_nodeBodyElement
+				| Coordinate_nodeBodyElement Coordinate_nodeBodyElements;
+
+Coordinate_nodeBodyElement	: T_point mfvec3fValue
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Normal_nodeBody			: Normal_nodeBodyElements
+				| empty;
+
+Normal_nodeBodyElements		: Normal_nodeBodyElement
+				| Normal_nodeBodyElement Normal_nodeBodyElements;
+
+Normal_nodeBodyElement		: T_vector mfvec3fValue
+				;
+
+/* GENERIC NODE ------------------------------------------------------------ */
+/*
+nodeBody			: nodeBodyElement
+				| nodeBodyElement nodeBody
+				| empty
+				;
+*/
+
+scriptBody			: // scriptBodyElement
+//				| scriptBodyElement scriptBody
+/*				| */ empty
+				;
+
+/*
+scriptBodyElement		: nodeBodyElement
+				| restrictedInterfaceDeclaration
+				| T_EVENTIN fieldType eventInId T_IS eventInId
+				| T_EVENTOUT fieldType eventOutId T_IS eventOutId
+				| T_FIELD fieldType fieldId T_IS fieldId
+				;
+
+nodeBodyElement			: //fieldId fieldValue
+//				| fieldId T_IS fieldId
+//				| eventInId T_IS eventInId
+//				| eventOutId T_IS eventOutId
+//				| routeStatement
+//				| protoStatement
+				;
+*/
+
+nodeNameId			: Id
+				;
+
+/*
+nodeTypeId			: Id
+				;
+
+fieldId				: Id
+				;
+
+eventInId			: Id
+				;
+
+eventOutId			: Id
+				;
+*/
+
+/*
+Id				: IDFIRSTCHAR
+				| IDFIRSTCHAR IDRESTCHARS
+				;
+*/
+
+Id				: STRING
+				;
+
+/* FIELDS */
+
+/*
+fieldType			: MFColor
+				| MFFloat
+				| MFInt32
+				| MFNode
+				| MFRotation
+				| MFString
+				| MFTime
+				| MFVec2f
+				| MFVec3f
+				| SFBool
+				| SFColor
+				| SFFloat
+				| SFImage
+				| SFInt32
+				| SFNode
+				| SFRotation
+				| SFString
+				| SFTime
+				| SFVec2f
+				| SFVec3f
+				;
+
+fieldValue			:
+				| sfboolValue
+				| sfcolorValue
+				| sffloatValue
+				| sfimageValue
+				| sfint32Value
+				| sfnodeValue
+				| sfrotationValue
+				| sfstringValue
+				| sftimeValue
+				| sfvec2fValue
+				| sfvec3fValue
+				| mfcolorValue
+				| mffloatValue
+				| mfint32Value
+				| mfnodeValue
+				| mfrotationValue
+				| mfstringValue
+				| mftimeValue
+				| mfvec2fValue
+				| mfvec3fValue
+				;
+*/
+
+sfboolValue			: T_TRUE
+				| T_FALSE
+				;
+
+sfcolorValue			: FLOATING FLOATING FLOATING
+				;
+
+sffloatValue			: FLOATING
+				;
+
+/*
+sfimageValue			: image_data
+				;
+
+image_data			: INT32
+				| image_data INT32
+				;
+*/
+
+sfint32Value			: INT32
+				;
+
+/*
+sfnodeValue			: nodeStatement
+				| T_NULL
+				;
+*/
+
+sfrotationValue			: FLOATING FLOATING FLOATING FLOATING
+				;
+
+sfstringValue			: STRING
+				;
+
+/*
+sftimeValue			: DOUBLE
+				;
+
+mftimeValue			: sftimeValue
+				| '[' ']'
+				| '[' sftimeValues ']'
+				;
+
+sftimeValues			: sftimeValue
+				| sftimeValue sftimeValues
+				;
+
+sfvec2fValue			: FLOATING FLOATING
+				;
+*/
+
+sfvec3fValue			: FLOATING FLOATING FLOATING
+				;
+
+/*
+mfcolorValue			: sfcolorValue
+				| '[' ']'
+				| '[' sfcolorValues ']'
+				;
+
+sfcolorValues			: sfcolorValue
+				| sfcolorValue sfcolorValues
+				;
+
+mffloatValue			: sffloatValue
+				| '[' ']'
+				| '[' sffloatValues ']'
+				;
+
+sffloatValues			: sffloatValue
+				| sffloatValue sffloatValues
+				;
+*/
+
+mfint32Value			: sfint32Value
+				| '[' ']'
+				| '[' sfint32Values ']'
+				;
+
+sfint32Values			: sfint32Value
+				| sfint32Value sfint32Values
+				;
+
+/*
+mfnodeValue			: nodeStatement
+				| '[' ']'
+				| '[' nodeStatements ']'
+				;
+
+nodeStatements			: nodeStatement
+				| nodeStatement nodeStatements
+				;
+
+mfrotationValue			: sfrotationValue
+				| '[' ']'
+				| '[' sfrotationValues ']'
+				;
+
+sfrotationValues		: sfrotationValue
+				| sfrotationValue sfrotationValues
+				;
+*/
+
+/*
+mfstringValue			: sfstringValue
+				| '[' ']'
+				| '[' sfstringValues ']'
+				;
+*/
+
+sfstringValues			: sfstringValue
+				| sfstringValue sfstringValues
+				;
+
+/*
+mfvec2fValue			: sfvec2fValue
+				| '[' ']'
+				| '[' sfvec2fValues ']'
+				;
+
+sfvec2fValues			: sfvec2fValue
+				| sfvec2fValue sfvec2fValues
+				;
+*/
+
+mfvec3fValue			: sfvec3fValue
+				| '[' ']'
+				| '[' sfvec3fValues ']'
+				;
+
+sfvec3fValues			: sfvec3fValue
+				| sfvec3fValue sfvec3fValues
+				;
+
+
+%%
+
+/* ---------------------------------------------------------------------------
+ * error routine called by parser library
+ */
+int vrml_yyerror(s)
+const char *s;
+{
+	printf("ERROR parsing file (%s)\n"
+		"    line number: %i\n"
+		"    description: '%s'\n",
+		vrml_yyfilename, vrml_yylineno, s);
+	return(0);
+}
+
+int vrml_yywrap()
+{
+  return 1;
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index da711d5..2f877a9 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1560,7 +1560,7 @@ GhidDrawMask (int side, BoxType * screen)
   } else {
     glBindTexture (GL_TEXTURE_2D, texture);
   }
-  glUseProgram (0);
+  hidgl_shader_activate (NULL);
 
   if (1) {
     GLfloat s_params[] = {0.0001, 0., 0., 0.};
@@ -1842,6 +1842,11 @@ frontE_package_callback (const BoxType * b, void *cl)
         int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
         hidgl_draw_350x800mil_cap (element, compute_depth (layer_group), BOARD_THICKNESS);
       }
+
+      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "VRML_TEST") == 0) {
+        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+        hidgl_draw_vrml (element, compute_depth (layer_group), BOARD_THICKNESS, "dummy_filename.wrl");
+      }
     }
   return 1;
 }
@@ -2755,125 +2760,27 @@ ghid_finish_debug_draw (void)
   ghid_end_drawing (gport, gport->drawing_area);
 }
 
-static double
-determinant_2x2 (double m[2][2])
-{
-  double det;
-  det = m[0][0] * m[1][1] -
-        m[0][1] * m[1][0];
-  return det;
-}
-
-#if 0
-static float
-determinant_4x4 (float m[4][4])
-{
-  float det;
-  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
-        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
-        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
-        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
-        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
-        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
-        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
-        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
-        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
-        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
-        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
-        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
-   return det;
-}
-#endif
-
-static void
-invert_2x2 (double m[2][2], double out[2][2])
-{
-  double scale = 1 / determinant_2x2 (m);
-  out[0][0] =  m[1][1] * scale;
-  out[0][1] = -m[0][1] * scale;
-  out[1][0] = -m[1][0] * scale;
-  out[1][1] =  m[0][0] * scale;
-}
-
-#if 0
-static void
-invert_4x4 (float m[4][4], float out[4][4])
-{
-  float scale = 1 / determinant_4x4 (m);
-
-  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
-               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
-               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
-  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
-               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
-               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
-  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
-               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
-               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
-  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
-               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
-               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
-  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
-               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
-               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
-  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
-               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
-               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
-  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
-               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
-               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
-  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
-               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
-               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
-  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
-               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
-               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
-  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
-               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
-               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
-  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
-               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
-               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
-  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
-               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
-               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
-  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
-               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
-               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
-  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
-               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
-               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
-  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
-               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
-               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
-  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
-               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
-               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
-}
-#endif
-
-
 static bool
 ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y)
 {
-  double mat[2][2];
-  double inv_mat[2][2];
-  double x, y;
-  double fvz;
-  double vpx, vpy;
-  double fvx, fvy;
+  float mat[2][2];
+  float inv_mat[2][2];
+  float x, y;
+  float fvz;
+  float vpx, vpy;
+  float fvx, fvy;
   GtkWidget *widget = gport->drawing_area;
 
   /* FIXME: Dirty kludge.. I know what our view parameters are here */
-  double aspect = (double)widget->allocation.width / (double)widget->allocation.height;
-  double width = 2. * aspect;
-  double height = 2.;
-  double near_plane = 1.;
-  /* double far_plane = 24.; */
+  float aspect = (float)widget->allocation.width / (float)widget->allocation.height;
+  float width = 2. * aspect;
+  float height = 2.;
+  float near_plane = 1.;
+  /* float far_plane = 24.; */
 
   /* This is nasty beyond words, but I'm lazy and translating directly
    * from some untested maths I derived which used this notation */
-  double A, B, C, D, E, F, G, H, I, J, K, L;
+  float A, B, C, D, E, F, G, H, I, J, K, L;
 
   /* NB: last_modelview_matrix is transposed in memory! */
   A = last_modelview_matrix[0][0];
