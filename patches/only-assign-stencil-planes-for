Bottom: 4af9ece9863cef035567d15810e65904e564d115
Top:    c148cf9fc0a7f9b06e44adc5d8c046152461bccb
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-07 18:01:28 +0100

Only assign stencil planes for visible layers

NB: Split out of the FBO patch


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index dfe34b2..d1cbc8c 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -153,6 +153,7 @@ ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   static int stencil_bit = 0;
+  bool group_visible = false;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -172,48 +173,53 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
-  glEnable (GL_STENCIL_TEST);                   /* Enable Stencil test */
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   /* Stencil pass => replace stencil value (with 1) */
-  hidgl_return_stencil_bit (stencil_bit);       /* Relinquish any bitplane we previously used */
-  if (SL_TYPE (idx) != SL_FINISHED) {
-    stencil_bit = hidgl_assign_clear_stencil_bit();       /* Get a new (clean) bitplane to stencil with */
-    glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
-    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); /* Pass stencil test if our assigned bit is clear */
-  } else {
-    stencil_bit = 0;
-    glStencilMask (0);
-    glStencilFunc (GL_ALWAYS, 0, 0);  /* Always pass stencil test */
-  }
-
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
-      return PCB->Data->Layer[idx].On;
+      group_visible = PCB->Data->Layer[idx].On;
     }
-
-  if (idx < 0)
+  else if (idx < 0)
     {
       switch (SL_TYPE (idx))
 	{
 	case SL_INVISIBLE:
-	  return PCB->InvisibleObjectsOn;
+	  group_visible = PCB->InvisibleObjectsOn;
+	  break;
 	case SL_MASK:
-	  return TEST_FLAG (SHOWMASKFLAG, PCB);
+	  group_visible = TEST_FLAG (SHOWMASKFLAG, PCB);
+	  break;
 	case SL_SILK:
 	  priv->trans_lines = true;
-	  return PCB->ElementOn;
+	  group_visible = PCB->ElementOn;
+	  break;
 	case SL_ASSY:
-	  return 0;
+	  break;
 	case SL_PDRILL:
 	case SL_UDRILL:
-	  return 1;
+	  group_visible = true;
+	  break;
 	case SL_RATS:
 	  if (PCB->RatOn)
 	    priv->trans_lines = true;
-	  return PCB->RatOn;
+	  group_visible = PCB->RatOn;
+	  break;
 	}
     }
-  return 0;
+
+  glEnable (GL_STENCIL_TEST);                   /* Enable Stencil test */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   /* Stencil pass => replace stencil value (with 1) */
+  hidgl_return_stencil_bit (stencil_bit);       /* Relinquish any bitplane we previously used */
+  if (group_visible) {
+    stencil_bit = hidgl_assign_clear_stencil_bit();       /* Get a new (clean) bitplane to stencil with */
+    glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
+    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); /* Pass stencil test if our assigned bit is clear */
+  } else {
+    stencil_bit = 0;
+    glStencilMask (0);
+    glStencilFunc (GL_ALWAYS, 0, 0);  /* Always pass stencil test */
+  }
+
+  return group_visible;
 }
 
 void
