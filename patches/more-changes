Bottom: 7129e1d401e4a4e8d24b107f810b821e9c2d5ae9
Top:    f5dc80b55c72a199cab3ec85a3eeff0800c7d994
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-13 21:24:07 +0000

More changes...


---

diff --git a/src/polygon.h b/src/polygon.h
index f5ae0b3..94e1a86 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,7 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 20 //8 //40
+#define POLY_CIRC_SEGS 40 //8 //40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index 87a622e..7561400 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1058,29 +1058,32 @@ vertex_in_seg_rounded (const BoxType * b, void *cl)
   struct seg *s = (struct seg *) b;
   VNODE *new_node;
 
-  if (!line_point_inters (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point, i->v->point))
-    return 0;
-
   /* When new nodes are added at the end of a pass due to an intersection
    * the segments may be altered. If either segment we're looking at has
    * already been intersected this pass, skip it until the next pass.
    */
   if (s->intersected)
+    {
+//      g_warning ("Should not reach this 1");
+      return 0;
+    }
+
+  if (!line_point_inters (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point, i->v->point))
     return 0;
 
   if (i->touch)			/* if checking touches one find and we're done */
     longjmp (*i->touch, TOUCHES);
 
 //  i->s->p->Flags.status = ISECTED; /* XXX */
-  s->p->Flags.status = ISECTED;
+//  s->p->Flags.status = ISECTED;
 
   new_node = node_add_single_point (s->v, i->v->point);
   if (new_node != NULL)
     {
-//#ifdef DEBUG_INTERSECT
+#ifdef DEBUG_INTERSECT
       DEBUGP ("found new rounded intersection on segment \"s\" at (%$mn, %$mn)\n",
               i->v->point[0], i->v->point[1]);
-//#endif
+#endif
       i->node_insert_list =
         prepend_insert_node_task (i->node_insert_list, i->rtree_over_poly, s, new_node);
       s->intersected = 1;
@@ -1101,10 +1104,9 @@ rounded_contour_bounds_touch (const BoxType * b, void *cl)
   VNODE *av; /* node iterators */ /* av is considered an edge */
   struct info info;
   BoxType box;
-  jmp_buf restart;
 
   /* Have vertex_in_seg_rounded return to our desired location if it touches */
-  info.env = &restart;
+  info.env = NULL;
   info.touch = c_info->getout;
   info.need_restart = 0;
   info.node_insert_list = c_info->node_insert_list;
@@ -1120,16 +1122,14 @@ rounded_contour_bounds_touch (const BoxType * b, void *cl)
       /* check this vertex for any insertions */
       info.v = av;
 
-      box.X2 = (box.X1 = av->point[0] - 1) + 3; /* NB: We expand the search box to ensure we catch edges which may round to this coordinate */
+      /* NB: We expand the search box to ensure we catch edges which may round to this coordinate */
+      box.X2 = (box.X1 = av->point[0] - 1) + 3;
       box.Y2 = (box.Y1 = av->point[1] - 1) + 3;
 
-      if (setjmp (restart))
-	continue;
-
       /* NB: If this actually hits anything, we are teleported back to the beginning */
-      if (rtree_over->tree)
-	if (UNLIKELY (r_search (rtree_over->tree, &box, NULL, vertex_in_seg_rounded, &info)))
-	  assert (0); /* XXX: Memory allocation failure */
+      if (rtree_over->tree &&
+          UNLIKELY (r_search (rtree_over->tree, &box, NULL, vertex_in_seg_rounded, &info)))
+        assert (0); /* XXX: Memory allocation failure */
     }
   while ((av = NEXT_VERTEX (av)) != &looping_over->head);
 
@@ -1380,12 +1380,54 @@ static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CVCList **list_out)
 {
   POLYAREA *a = afst, *b = bfst;
+  POLYAREA *a2, *b2;
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
   if (a == NULL || b == NULL)
     error (err_bad_parm);
 
+  if (0)//add)
+{
+#if 1
+  /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+  do
+    {
+      a2 = a->f;
+      for (a2 = a->f; a2 != a; a2 = a2->f)
+        {
+          if (a->contours->xmax >= a2->contours->xmin &&
+              a->contours->ymax >= a2->contours->ymin &&
+              a->contours->xmin <= a2->contours->xmax &&
+              a->contours->ymin <= a2->contours->ymax)
+            {
+              intersect_rounded (e, a, a2, true);
+            }
+        }
+    }
+  while ((a = a->f) != afst);
+
+#endif
+
+#if 1
+  /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+  do
+    {
+      b2 = b->f;
+      for (b2 = b->f; b2 != b; b2 = b2->f)
+        {
+          if (b->contours->xmax >= b2->contours->xmin &&
+              b->contours->ymax >= b2->contours->ymin &&
+              b->contours->xmin <= b2->contours->xmax &&
+              b->contours->ymin <= b2->contours->ymax)
+            {
+              intersect_rounded (e, b, b2, true);
+            }
+        }
+    }
+  while ((b = b->f) != bfst);
+#endif
+
 #if 1
   do
     {
@@ -1404,6 +1446,7 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CV
     }
   while (add && (b = b->f) != bfst);
 #endif
+}
 
   do
     {
@@ -1603,7 +1646,7 @@ label_contour (PLINE * a)
         }
       else
         {
-          g_warning ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
+          g_info ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
           /* Head was marked, so presumably the entire contour is either SHARED or SHARED2 */
         }
     }
@@ -2192,7 +2235,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir, char **
 
   if (*contour_name != NULL)
     {
-      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
+//      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
       (*result)->name = strdup (*contour_name);
     }
 
@@ -2480,8 +2523,8 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
 	  int is_first = contour_is_first (a, curc);
 	  int is_last = contour_is_last (curc);
 	  int isect_contour = (curc->Flags.status == ISECTED);
-          if (isect_contour && curc->name != NULL)
-            printf ("A contour with name %s was ISECTED\n", curc->name);
+//          if (isect_contour && curc->name != NULL)
+//            printf ("A contour with name %s was ISECTED\n", curc->name);
 
 	  next = curc->next;
 
@@ -3243,7 +3286,7 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-      M_POLYAREA_intersect (&e, a, b, false, NULL);
+//      M_POLYAREA_intersect (&e, a, b, false, NULL);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
@@ -3367,6 +3410,9 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
 
+      /* XXX */
+      M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
+
 #if 1
       M_POLYAREA_check_hairline_edges (the_list, a);
       M_POLYAREA_check_hairline_edges (the_list, b);
