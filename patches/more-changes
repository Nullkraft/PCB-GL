Bottom: c146c73b96284422ad79d077444251bea27af7c6
Top:    3751e37344b4c960e9bce0c1d96282c80a5a36f9
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-13 21:24:07 +0000

More changes...


---

diff --git a/src/polygon.h b/src/polygon.h
index f5ae0b3..80392a3 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,7 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 20 //8 //40
+#define POLY_CIRC_SEGS 8 //40 //8 //40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index 81d8574..9ed6a20 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1058,29 +1058,32 @@ vertex_in_seg_rounded (const BoxType * b, void *cl)
   struct seg *s = (struct seg *) b;
   VNODE *new_node;
 
-  if (!line_point_inters (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point, i->v->point))
-    return 0;
-
   /* When new nodes are added at the end of a pass due to an intersection
    * the segments may be altered. If either segment we're looking at has
    * already been intersected this pass, skip it until the next pass.
    */
   if (s->intersected)
+    {
+//      g_warning ("Should not reach this 1");
+      return 0;
+    }
+
+  if (!line_point_inters (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point, i->v->point))
     return 0;
 
   if (i->touch)			/* if checking touches one find and we're done */
     longjmp (*i->touch, TOUCHES);
 
 //  i->s->p->Flags.status = ISECTED; /* XXX */
-  s->p->Flags.status = ISECTED;
+//  s->p->Flags.status = ISECTED;
 
   new_node = node_add_single_point (s->v, i->v->point);
   if (new_node != NULL)
     {
-//#ifdef DEBUG_INTERSECT
+#ifdef DEBUG_INTERSECT
       DEBUGP ("found new rounded intersection on segment \"s\" at (%$mn, %$mn)\n",
               i->v->point[0], i->v->point[1]);
-//#endif
+#endif
       i->node_insert_list =
         prepend_insert_node_task (i->node_insert_list, i->rtree_over_poly, s, new_node);
       s->intersected = 1;
@@ -1101,10 +1104,9 @@ rounded_contour_bounds_touch (const BoxType * b, void *cl)
   VNODE *av; /* node iterators */ /* av is considered an edge */
   struct info info;
   BoxType box;
-  jmp_buf restart;
 
   /* Have vertex_in_seg_rounded return to our desired location if it touches */
-  info.env = &restart;
+  info.env = NULL;
   info.touch = c_info->getout;
   info.need_restart = 0;
   info.node_insert_list = c_info->node_insert_list;
@@ -1115,54 +1117,19 @@ rounded_contour_bounds_touch (const BoxType * b, void *cl)
   rtree_over = pb;
 
   av = &looping_over->head;
-  do				/* Loop over the edges in the smaller contour */
+  do  /* Loop over the edges in the a contour */
     {
       /* check this vertex for any insertions */
       info.v = av;
-#if 0
-      /* check this edge for any insertions */
-      double dx;
-      /* compute the slant for region trimming */
-      dx = EDGE_FORWARD_VERTEX (av)->point[0] - EDGE_BACKWARD_VERTEX (av)->point[0];
-      if (dx == 0)
-	info.m = 0;
-      else
-	{
-	  info.m = (EDGE_FORWARD_VERTEX (av)->point[1] - EDGE_BACKWARD_VERTEX (av)->point[1]) / dx;
-	  info.b = EDGE_BACKWARD_VERTEX (av)->point[1] - info.m * EDGE_BACKWARD_VERTEX (av)->point[0];
-	}
-      box.X2 = (box.X1 = EDGE_BACKWARD_VERTEX (av)->point[0]) + 1;
-      box.Y2 = (box.Y1 = EDGE_BACKWARD_VERTEX (av)->point[1]) + 1;
-#endif
 
-      box.X2 = (box.X1 = av->point[0] - 1) + 3; /* NB: We expand the search box to ensure we catch edges which may round to this coordinate */
+      /* NB: We expand the search box to ensure we catch edges which may round to this coordinate */
+      box.X2 = (box.X1 = av->point[0] - 1) + 3;
       box.Y2 = (box.Y1 = av->point[1] - 1) + 3;
 
-#if 0
-      /* fill in the segment in info corresponding to this node */
-      if (setjmp (info.sego) == 0)
-	{
-	  info.debug = false;
-	  r_search (looping_over->tree, &box, NULL, get_seg, &info);
-	  g_error ("Did not find segment in contour tree!");
-	}
-
-      /* If we're going to have another pass anyway, skip this */
-      if (info.s->intersected && info.node_insert_list != NULL)
-	continue;
-#endif
-
-      if (setjmp (restart))
-	continue;
-
       /* NB: If this actually hits anything, we are teleported back to the beginning */
-//      info.tree = rtree_over->tree;
-//      if (info.tree)
-//	if (UNLIKELY (r_search (info.tree, &box /*&info.s->box*/,
-      if (rtree_over->tree)
-	if (UNLIKELY (r_search (rtree_over->tree, &box /*&info.s->box*/,
-				NULL/*seg_in_region*/, vertex_in_seg_rounded, &info)))
-	  assert (0); /* XXX: Memory allocation failure */
+      if (rtree_over->tree &&
+          UNLIKELY (r_search (rtree_over->tree, &box, NULL, vertex_in_seg_rounded, &info)))
+        assert (0); /* XXX: Memory allocation failure */
     }
   while ((av = NEXT_VERTEX (av)) != &looping_over->head);
 
@@ -1409,16 +1376,71 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
   return 0;
 }
 
+#if 0
+static void
+intersect_rounded_pl_m_pl (jump_buf * e, POLYAREA *outer_contour, POLYAREA *m_contour)
+{
+  PLINE *pl;
+
+  for (pl = m_contour; pl != NULL; pl = pl->next)
+    {
+      intersect_rounded_no_trees (e, outer_contour, pl, true);
+    }
+}
+#endif
+
 static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CVCList **list_out)
 {
   POLYAREA *a = afst, *b = bfst;
+  POLYAREA *a2, *b2;
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
   if (a == NULL || b == NULL)
     error (err_bad_parm);
 
+  if (0)//add)
+{
+#if 1
+  /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+  do
+    {
+      a2 = a->f;
+      for (a2 = a->f; a2 != a; a2 = a2->f)
+        {
+          if (a->contours->xmax >= a2->contours->xmin &&
+              a->contours->ymax >= a2->contours->ymin &&
+              a->contours->xmin <= a2->contours->xmax &&
+              a->contours->ymin <= a2->contours->ymax)
+            {
+              intersect_rounded (e, a, a2, true);
+            }
+        }
+    }
+  while ((a = a->f) != afst);
+
+#endif
+
+#if 1
+  /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+  do
+    {
+      b2 = b->f;
+      for (b2 = b->f; b2 != b; b2 = b2->f)
+        {
+          if (b->contours->xmax >= b2->contours->xmin &&
+              b->contours->ymax >= b2->contours->ymin &&
+              b->contours->xmin <= b2->contours->xmax &&
+              b->contours->ymin <= b2->contours->ymax)
+            {
+              intersect_rounded (e, b, b2, true);
+            }
+        }
+    }
+  while ((b = b->f) != bfst);
+#endif
+
 #if 1
   do
     {
@@ -1437,6 +1459,7 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CV
     }
   while (add && (b = b->f) != bfst);
 #endif
+}
 
   do
     {
@@ -1636,7 +1659,7 @@ label_contour (PLINE * a)
         }
       else
         {
-          g_warning ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
+          g_info ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
           /* Head was marked, so presumably the entire contour is either SHARED or SHARED2 */
         }
     }
@@ -2225,7 +2248,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir, char **
 
   if (*contour_name != NULL)
     {
-      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
+//      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
       (*result)->name = strdup (*contour_name);
     }
 
@@ -2513,8 +2536,8 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
 	  int is_first = contour_is_first (a, curc);
 	  int is_last = contour_is_last (curc);
 	  int isect_contour = (curc->Flags.status == ISECTED);
-          if (isect_contour && curc->name != NULL)
-            printf ("A contour with name %s was ISECTED\n", curc->name);
+//          if (isect_contour && curc->name != NULL)
+//            printf ("A contour with name %s was ISECTED\n", curc->name);
 
 	  next = curc->next;
 
@@ -3333,7 +3356,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
   *res = NULL;
 
-#if 0
+#if 1
   /* Make copies for tracking polygon parentage (DEBUG) */
   if (!poly_M_Copy0 (&a_copy, a) || !poly_M_Copy0 (&b_copy, b))
       return err_no_memory;
@@ -3400,6 +3423,9 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
 
+      /* XXX */
+      M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
+
 #if 1
       M_POLYAREA_check_hairline_edges (the_list, a);
       M_POLYAREA_check_hairline_edges (the_list, b);
