Bottom: f5dfb8a41ac68b6a41507f7917a368131fed9ef0
Top:    341bdcb6b9e2be532a5894348db55556d256ed51
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 12:14:06 +0000

STEP changes from more-play-with-quad-edge-data


---

diff --git a/src/hid/common/contour3d.h b/src/hid/common/contour3d.h
index 7723f31..818bd8e 100644
--- a/src/hid/common/contour3d.h
+++ b/src/hid/common/contour3d.h
@@ -1,6 +1,8 @@
 typedef struct {
   edge_ref first_edge;
 
+  /* XXX: STEP specific - breaks encapsulation */
+  int face_bound_identifier;
 } contour3d;
 
 contour3d *make_contour3d (edge_ref first_edge);
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 060c7b2..f54468c 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -12,6 +12,10 @@ typedef struct
   double ny;
   double nz;
   double radius;
+
+  /* XXX: STEP specific - breaks encapsulation */
+  int infinite_line_identifier;
+  int edge_identifier;
 } edge_info;
 
 edge_info *make_edge_info (void);
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 95232a6..40ef822 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -10,6 +10,11 @@ typedef struct {
   double radius;
 
   appearance *appear;
+
+  /* XXX: STEP specific - breaks encapsulation */
+  int surface_identifier;
+  int face_identifier;
+  int face_bound_identifier;
 } face3d;
 
 face3d *make_face3d (void);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index b6219e4..9d2796b 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -63,6 +63,7 @@ object3d_test_init (void)
 {
   //object3d_test_object = object3d_create_test_cube ();
   object3d_test_object = object3d_from_board_outline ();
+  object3d_test_board_outline ();
 }
 
 object3d *
@@ -501,194 +502,6 @@ object3d_from_board_outline (void)
   return object;
 }
 
-object3d *
-object3d_from_tracking (void)
-{
-  object3d *object;
-  appearance *board_appearance;
-  appearance *top_bot_appearance;
-  POLYAREA *outline;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  face3d **faces;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  outline = board_outline_poly (true);
-  ncontours = 0;
-  npoints = 0;
-
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
-
-  ct = contour;
-  while (ct != NULL)
-    {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-  object = make_object3d (PCB->Name);
-  board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
-  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-  object3d_set_appearance (object, board_appearance);
-
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-  faces    = malloc (sizeof (face3d *) * (2 + npoints));
-
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      double x1, y1;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
-        {
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-        }
-
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-      object3d_add_vertex (object, vertices[i]);
-      object3d_add_vertex (object, vertices[npoints + i]);
-    }
-
-  /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++)
-    {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (object, edges[i]);
-    }
-
-  /* Define the faces */
-  for (i = 0; i < npoints; i++)
-    {
-      faces[i] = make_face3d ();
-
-      object3d_add_face (object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-    }
-
-  faces[npoints] = make_face3d (); /* bottom_face */
-  face3d_set_normal (faces[npoints], 0., 0., -1.);
-  face3d_set_appearance (faces[npoints], top_bot_appearance);
-  object3d_add_face (object, faces[npoints]);
-
-  faces[npoints + 1] = make_face3d (); /* top_face */
-  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-  object3d_add_face (object, faces[npoints + 1]);
-
-  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      int next_i_around_ct;
-      int prev_i_around_ct;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
-        {
-          start_of_ct = i;
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-
-          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-        }
-
-      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-      /* Define the (non-normalized) face normal to point to the outside of the contour */
-      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[              i]) = vertices[0 * npoints + i];
-      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-      if (ct->is_round)
-        {
-
-          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                            COORD_TO_MM (ct->radius));
-          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-          edge_info_set_round (UNDIR_DATA (edges[i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-        }
-
-    }
-
-  poly_Free (&outline);
-
-  return object;
-}
-
 void
 object3d_test_board_outline (void)
 {
diff --git a/src/hid/common/vertex3d.h b/src/hid/common/vertex3d.h
index e399b88..3625c5e 100644
--- a/src/hid/common/vertex3d.h
+++ b/src/hid/common/vertex3d.h
@@ -4,6 +4,9 @@ typedef struct
   double y;
   double z;
   int id;
+
+  /* XXX: STEP specific - breaks encapsulation */
+  int vertex_identifier;
 } vertex3d;
 
 vertex3d *make_vertex3d (double x, double y, double z);
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 449d44a..41c287d 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -9,7 +9,7 @@
 #include "hid/common/contour3d.h"
 #include "hid/common/appearance.h"
 #include "hid/common/face3d.h"
-//#include "hid/common/edge3d.h"
+#include "hid/common/edge3d.h"
 #include "hid/common/object3d.h"
 //#include "polygon.h"
 #include "data.h"
@@ -17,16 +17,6 @@
 #include "object3d_step.h"
 
 
-static void
-fprint_idlist (FILE *f, int *ids, int num_ids)
-{
-  int i;
-  fprintf (f, "(");
-  for (i = 0; i < num_ids - 1; i++)
-    fprintf (f, "#%i, ", ids[i]);
-  fprintf (f, "#%i) ) ;\n", ids[i]);
-}
-
 void
 object3d_export_to_step (object3d *object, const char *filename)
 {
@@ -34,8 +24,16 @@ object3d_export_to_step (object3d *object, const char *filename)
   time_t currenttime;
   struct tm utc;
   int next_step_identifier;
+  int geometric_representation_context_identifier;
   int brep_identifier;
   int pcb_shell_identifier;
+  int brep_style_identifier;
+  GList *styled_item_identifiers = NULL;
+  GList *styled_item_iter;
+  GList *face_iter;
+  GList *edge_iter;
+  GList *vertex_iter;
+  GList *contour_iter;
 
   f = fopen (filename, "w");
   if (f == NULL)
@@ -98,26 +96,42 @@ object3d_export_to_step (object3d *object, const char *filename)
               "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
               "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
 
-  /* BREP STUFF FROM #21 onwards say? */
   fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( /* Manifold_solid_brep */ #21, #13 ), #18 ) ;\n"
               "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
               "test_pcb_absr_name");
 
+  geometric_representation_context_identifier = 18;
+
+  /* Save a place for the brep identifier */
   next_step_identifier = 21;
+  brep_identifier = next_step_identifier++;
+
+  /* Body style */
+  fprintf (f, "#22 = COLOUR_RGB ( '', %f, %f, %f ) ;\n", object->appear->r, object->appear->g, object->appear->b);
+  fprintf (f, "#23 = FILL_AREA_STYLE_COLOUR ( '', #22 ) ;\n"
+              "#24 = FILL_AREA_STYLE ('', ( #23 ) ) ;\n"
+              "#25 = SURFACE_STYLE_FILL_AREA ( #24 ) ;\n"
+              "#26 = SURFACE_SIDE_STYLE ('', ( #25 ) ) ;\n"
+              "#27 = SURFACE_STYLE_USAGE ( .BOTH. , #26 ) ;\n"
+              "#28 = PRESENTATION_STYLE_ASSIGNMENT ( ( #27 ) ) ;\n");
+  fprintf (f, "#29 = STYLED_ITEM ( 'NONE', ( #28 ), #%i ) ;\n", brep_identifier);
+  brep_style_identifier = 29;
+  fprintf (f, "#30 = PRESENTATION_LAYER_ASSIGNMENT (  '1', 'Layer 1', ( #%i ) ) ;\n", brep_style_identifier);
+
+  next_step_identifier = 31;
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
-  /* TODO.. EXPORT FROM A QUAD DATA-STRUCTURE */
-#if 1
 #define FWD 1
 #define REV 2
-
-  /* Save a place for the brep identifier */
-  brep_identifier = next_step_identifier++;
+#define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
 
   /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
     {
-      if (ct->is_round)
+      face3d *face = face_iter->data;
+
+      if (face->is_cylindrical)
         {
           /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
            * BECAUSE OUR ROUND CONTOURS ARE (CURRENTLY) ALWAYS HOLES IN THE SOLID,
@@ -128,125 +142,232 @@ object3d_export_to_step (object3d *object, const char *filename)
                       "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
                       "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
                       "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
-                   next_step_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
-                   next_step_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
-                   next_step_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
+                   next_step_identifier,     /* A point on the axis of the cylinder */ face->cx, face->cy, face->cz,
+                   next_step_identifier + 1, /* Direction of the cylindrical axis */   face->ax, face->ay, face->az,
+                   next_step_identifier + 2, /* A normal to the axis direction */      face->nx, face->ny, face->nz,
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                   next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
+                   next_step_identifier + 4, next_step_identifier + 3, face->radius);
 
-          plane_identifiers[i] = next_step_identifier + 4;
+          face->surface_orientation_reversed = true;
+          face->surface_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
       else
         {
-          /* FOR CONSISTENCY WITH ABOVE, DEFINE PLANE NORMAL TO BE POINTING INSIDE THE SHAPE.
-           * THIS ALLOWS TO FLIP THE ORIENTATION OF THE UNDERLYING SURFACE WHEN DEFINING EVERY ADVANCED_FACE
+          contour3d *outer_contour = face->contours->data;
+          edge_ref first_edge = outer_contour->first_edge;
+
+          double ox, oy, oz;
+          double nx, ny, nz;
+          double rx, ry, rz;
+
+          /* Define 0,0 of the face coordinate system to arbitraily correspond to the
+             origin vertex of the edge this contour links to in the quad edge structure.
+           */
+          ox = ((vertex3d *)ODATA (first_edge))->x;
+          oy = ((vertex3d *)ODATA (first_edge))->y;
+          oz = ((vertex3d *)ODATA (first_edge))->z;
+
+          nx = face->nx;
+          ny = face->ny;
+          nz = face->nz;
+
+          /* Define the reference x-axis of the face coordinate system to be along the
+             edge this contour links to in the quad edge data structure.
            */
-          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier, x1, y1, 0.0);    // <-- A locating point on the plane. Forms 0,0 of its parameterised coords.
-          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 1,  -(y2 - y1), (x2 - x1), 0.0);  /* An axis direction pointing into the shape */ // <-- Or is this the z-axis of the coordinate placement -> plane normal?
-          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 2, 0.0, 0.0, 1.0);          // <-- Reference x-axis, should be orthogonal to the z-axis above.
-          fprintf (f, "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2);
-          fprintf (f, "#%i = PLANE ( 'NONE',  #%i ) ;\n",
+
+          rx = ((vertex3d *)DDATA (first_edge))->x - ox;
+          ry = ((vertex3d *)DDATA (first_edge))->y - oy;
+          rz = ((vertex3d *)DDATA (first_edge))->z - oz;
+
+          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
+                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
+                      "#%i = PLANE ( 'NONE',  #%i ) ;\n",
+                   next_step_identifier,     /* A point on the plane. Forms 0,0 of its parameterised coords. */ ox, oy, oz,
+                   next_step_identifier + 1, /* An axis direction normal to the the face - Gives z-axis */      nx, ny, nz,
+                   next_step_identifier + 2, /* Reference x-axis, orthogonal to z-axis above */                 rx, ry, rz,
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3);
-          plane_identifiers[i] = next_step_identifier + 4;
+
+          face->surface_orientation_reversed = false;
+          face->surface_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
     }
 
   /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
     {
+      edge_ref edge = (edge_ref)edge_iter->data;
+      edge_info *info = UNDIR_DATA (edge);
 
-      if (ct->is_round)
+      if (info->is_round)
         {
           fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
                       "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
                       "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
+                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ; "
                       "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                   next_step_identifier,     /* Center of the circle   */ edge_info->cx, edge_info->cy, edge_info->cz, // <--- Center of coordinate placement
+                   next_step_identifier,     /* Center of the circle   */ info->cx, info->cy, info->cz, // <--- Center of coordinate placement
                    next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                   next_step_identifier + 4, next_step_identifier + 3, edge_info->radius);
-          infinite_line_identifiers[i] = next_step_identifier + 4;
+                   next_step_identifier + 4, next_step_identifier + 3, info->radius);
+          info->infinite_line_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
       else
         {
+          double  x,  y,  z;
           double dx, dy, dz;
 
-          dx = end_v->x - start_v->x;
-          dy = end_v->y - start_v->y;
-          dz = end_v->z - start_v->z;
+          x = ((vertex3d *)ODATA (edge))->x;
+          y = ((vertex3d *)ODATA (edge))->y;
+          z = ((vertex3d *)ODATA (edge))->z;
+
+          dx = ((vertex3d *)DDATA (edge))->x - x;
+          dy = ((vertex3d *)DDATA (edge))->y - y;
+          dz = ((vertex3d *)DDATA (edge))->z - z;
 
           fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
                       "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
                       "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
                       "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                   next_step_identifier,     /* A point on the line         */ start_v->x, start_v->y, start_v->z,
+                   next_step_identifier,     /* A point on the line         */  x,  y,  z,
                    next_step_identifier + 1, /* A direction along the line  */ dx, dy, dz,
                    next_step_identifier + 2, next_step_identifier + 1,
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-          infinite_line_identifiers[i] = next_step_identifier + 3;
+          info->infinite_line_identifier = next_step_identifier + 3;
           next_step_identifier = next_step_identifier + 4;
         }
     }
 
   /* Define the vertices */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter))
     {
-      fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier,     /* Vertex coordinate  */ x, y, z);
+      vertex3d *vertex = vertex_iter->data;
+
+      fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier, vertex->x, vertex->y, vertex->z); /* Vertex coordinate  */ 
       fprintf (f, "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",             next_step_identifier + 1, next_step_identifier);
-      vertex_identifiers[i] = next_step_identifier + 1;
+      vertex->vertex_identifier = next_step_identifier + 1;
       next_step_identifier = next_step_identifier + 2;
     }
 
   /* Define the Edges */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
     {
-      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; ", next_step_identifier, start_vertex_identifiers[i], end_vertex_identifiers[i], infinite_line_identifier[i]);
-      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; ",    next_step_identifier + 1, next_step_identifier);
-      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",   next_step_identifier + 2, next_step_identifier);
-      edge_identifiers[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
+      edge_ref edge = (edge_ref)edge_iter->data;
+      edge_info *info = UNDIR_DATA (edge);
+
+      int sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
+      int ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
+
+      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i, .T. ) ; ", next_step_identifier, sv, ev, info->infinite_line_identifier);
+      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ; ",    next_step_identifier + 1, next_step_identifier);
+      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ;\n",   next_step_identifier + 2, next_step_identifier);
+      info->edge_identifier = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
       next_step_identifier = next_step_identifier + 3;
     }
 
   /* Define the faces */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE (ESPECIALLY FOR CORRECT ORDERING!)*/
-  for (;;)
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
     {
-      start_i = 0;
-      for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next)
-        {
+      face3d *face = face_iter->data;
+      bool outer_contour = true;
 
-          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */ 
-          fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_edge_identifiers[i], face_contour_npoints[i]); fprintf (f, " ) ; ");
-          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n", next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-          face_bound_identifiers[icont] = next_step_identifier + 1;
+      for (contour_iter = face->contours;
+           contour_iter != NULL;
+           contour_iter = g_list_next (contour_iter), outer_contour = false)
+        {
+          contour3d *contour = contour_iter->data;
+          edge_ref edge;
+
+          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */
+          fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier);
+
+          /* Emit the edges.. */
+          fprintf (f, "(");
+          for (edge = contour->first_edge;
+               edge != LPREV (contour->first_edge);
+               edge = LNEXT (edge))
+            {
+              fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
+            }
+          fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
+          fprintf (f, " ) ; ");
+
+          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", next_step_identifier + 1, outer_contour ? "OUTER_" : "", next_step_identifier);
+          contour->face_bound_identifier = next_step_identifier + 1;
           next_step_identifier = next_step_identifier + 2;
         }
 
-      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_bound_identifiers, ncontours);  fprintf (f, ", #%i, .F. ) ;\n", plane_identifiers[i]);
-      face_identifiers[i] = next_step_identifier;
+      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier);
+      fprintf (f, "(");
+      for (contour_iter = face->contours;
+           contour_iter != NULL && g_list_next (contour_iter) != NULL;
+           contour_iter = g_list_next (contour_iter))
+        {
+          fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
+        }
+      fprintf (f, "#%i)", ((contour3d *)contour_iter->data)->face_bound_identifier);
+      fprintf (f, ", #%i, %s ) ;\n", face->surface_identifier, face->surface_orientation_reversed ? ".F." : ".T.");
+      face->face_identifier = next_step_identifier;
       next_step_identifier = next_step_identifier + 1;
+
+      if (face->appear != NULL)
+        {
+          /* Face styles */
+          fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             next_step_identifier, face->appear->r, face->appear->g, face->appear->b);
+          fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        next_step_identifier + 1, next_step_identifier);
+          fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            next_step_identifier + 2, next_step_identifier + 1);
+          fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           next_step_identifier + 3, next_step_identifier + 2);
+          fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         next_step_identifier + 4, next_step_identifier + 3);
+          fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      next_step_identifier + 5, next_step_identifier + 4);
+          fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", next_step_identifier + 6, next_step_identifier + 5);
+          fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
+                   next_step_identifier + 7, next_step_identifier + 6, face->face_identifier, brep_style_identifier);
+          styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (next_step_identifier + 7));
+          next_step_identifier = next_step_identifier + 8;
+        }
     }
 
   /* Closed shell which bounds the brep solid */
   pcb_shell_identifier = next_step_identifier;
   next_step_identifier++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ", pcb_shell_identifier); fprint_idlist (f, face_identifiers, nfaces); fprintf (f, " ) ;\n");
+  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ", pcb_shell_identifier);
+  /* Emit the faces.. */
+  fprintf (f, "(");
+  for (face_iter = object->faces;
+       face_iter != NULL && g_list_next (face_iter) != NULL;
+       face_iter = g_list_next (face_iter))
+    {
+      fprintf (f, "#%i, ", ((face3d *)face_iter->data)->face_identifier);
+    }
+  fprintf (f, "#%i)", ((face3d *)face_iter->data)->face_identifier);
+  fprintf (f, " ) ;\n");
 
   /* Finally emit the brep solid definition */
   fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
 
+  /* Emit references to the styled and over_ridden styled items */
+  fprintf (f, "#%i = MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION (  '', ", next_step_identifier);
+  fprintf (f, "(");
+  for (styled_item_iter = styled_item_identifiers;
+       styled_item_iter != NULL && g_list_next (styled_item_iter) != NULL;
+       styled_item_iter = g_list_next (styled_item_iter))
+    {
+      fprintf (f, "#%i, ", GPOINTER_TO_INT (styled_item_iter->data));
+    }
+  fprintf (f, "#%i)", GPOINTER_TO_INT (styled_item_iter->data));
+  fprintf (f, ", #%i ) ;\n", geometric_representation_context_identifier);
+  next_step_identifier = next_step_identifier + 1;
+
+
 #undef FWD
 #undef REV
-#endif
+#undef ORIENTED_EDGE_IDENTIFIER
 
   fprintf (f, "ENDSEC;\n" );
   fprintf (f, "END-ISO-10303-21;\n" );
