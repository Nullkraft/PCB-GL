Bottom: b28805bcb1bdb5be17fee455b500053095e34709
Top:    d36fba12129f50ba1c8a81ccf06b14b8bff59b93
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-25 12:51:36 +0000

Extend object3d code to support arc-segments in POLYAREA contours


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index d188f21..960d6ef 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -23,6 +23,7 @@
 #include "misc.h"
 #include "hid/hidint.h"
 
+#define PERFECT_ROUND_CONTOURS
 
 //#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
 #undef REVERSED_PCB_CONTOURS
@@ -201,9 +202,14 @@ object3d_draw_debug (void)
 static int
 get_contour_npoints (PLINE *contour)
 {
+#ifdef PERFECT_ROUND_CONTOURS
   /* HACK FOR ROUND CONTOURS */
   if (contour->is_round)
+    {
+      fprintf (stderr, "get_contour_npoints returning 1 for round contour\n");
     return 1;
+    }
+#endif
 
   return contour->Count;
 }
@@ -213,6 +219,7 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
+#ifdef PERFECT_ROUND_CONTOURS
   if (contour->is_round)
     {
       /* HACK SPECIAL CASE FOR ROUND CONTOURS */
@@ -226,6 +233,7 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 
       return;
     }
+#endif
 
   while (n > 0) {
     vertex = vertex->next; /* The VNODE structure is circularly linked, so wrapping is OK */
@@ -236,6 +244,88 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
   *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
+static bool
+get_contour_edge_n_is_round (PLINE *contour, int n)
+{
+  VNODE *edge = &contour->head;
+
+#ifdef PERFECT_ROUND_CONTOURS
+  if (contour->is_round)
+    {
+      /* HACK SPECIAL CASE FOR ROUND CONTOURS */
+
+      fprintf (stderr, "***************************************************************************************************************************************************************************************\n");
+      return true;
+    }
+#endif
+
+  return false;
+
+  while (n > 0) {
+    edge = edge->next; /* The VNODE structure is circularly linked, so wrapping is OK */
+    n--;
+  }
+
+  return edge->is_round;
+}
+
+/* Copied from polygon1.c */
+#define Vsub2(r,a,b)	{(r)[0] = (a)[0] - (b)[0]; (r)[1] = (a)[1] - (b)[1];}
+#define EDGE_BACKWARD_VERTEX(e) ((e))
+#define EDGE_FORWARD_VERTEX(e) ((e)->next)
+
+static int compare_ccw_cw (Vector a, Vector b, Vector c)
+{
+  double cross;
+  Vector ab;
+  Vector ac;
+
+  Vsub2 (ab, b, a);
+  Vsub2 (ac, c, a);
+
+  cross = (double) ab[0] * ac[1] - (double) ac[0] * ab[1];
+  if (cross > 0.0)
+    return 1;
+  else if (cross < 0.0)
+    return -1;
+  else
+    return 0;
+}
+
+static void
+get_contour_edge_n_round_geometry_in_step_mm (PLINE *contour, int n, double *cx, double *cy, double *r, bool *cw)
+{
+  VNODE *edge = &contour->head;
+  Vector center;
+
+#ifdef PERFECT_ROUND_CONTOURS
+  if (contour->is_round)
+    {
+      /* HACK SPECIAL CASE FOR ROUND CONTOURS */
+      fprintf (stderr, ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n");
+
+      *cx = COORD_TO_STEP_X (PCB, contour->cx);
+      *cy = COORD_TO_STEP_Y (PCB, contour->cy);
+      *r = COORD_TO_MM (contour->radius);
+      *cw = (contour->Flags.orient != PLF_DIR);
+      return;
+    }
+#endif
+
+  while (n > 0) {
+    edge = edge->next; /* The VNODE structure is circularly linked, so wrapping is OK */
+    n--;
+  }
+
+  center[0] = edge->cx;
+  center[1] = edge->cy;
+
+  *cx = COORD_TO_STEP_X (PCB, edge->cx);
+  *cy = COORD_TO_STEP_Y (PCB, edge->cy);
+  *r = COORD_TO_MM (edge->radius);
+  *cw = (compare_ccw_cw (EDGE_BACKWARD_VERTEX (edge)->point, center, EDGE_FORWARD_VERTEX (edge)->point) > 0);
+}
+
 GList *
 object3d_from_contours (const POLYAREA *contours,
                         double zbot,
@@ -456,31 +546,41 @@ object3d_from_contours (const POLYAREA *contours,
       splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
 #endif
 
-      if (ct->is_round) {
+      if (get_contour_edge_n_is_round (ct, offset_in_ct)) {
+        double cx;
+        double cy;
+        double radius;
+        double normal_z;
+        bool cw;
+
+        get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
+
+        face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1., /* Direction of the cylindrical axis */
+                                          radius);
+
+        /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
+        if (ct->Flags.orient == PLF_INV)
+          face3d_set_surface_orientation_reversed (faces[i]);
 
-        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
-                                          COORD_TO_MM (ct->radius));
-        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
 #ifdef REVERSED_PCB_CONTOURS
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        normal_z = (/*(ct->Flags.orient == PLF_DIR) !=*/ cw) ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
+        normal_z = (/*(ct->Flags.orient == PLF_DIR) !=*/ cw) ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+
+
         edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+                             cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                             0., 0., normal_z, /* Normal */ radius);
         edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-#endif
-        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+                             cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                             0., 0., normal_z, /* Normal */ radius);
+        if (ct->is_round)
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
       }
 
     }
@@ -1405,6 +1505,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   int min_phys_group;
   int max_phys_group;
 
+  fprintf (stderr, "object3d_from_copper_layers_within_area\n");
 //  poly_Copy0 (&info.poly, area);
 
   copper_appearance = make_appearance ();
@@ -1437,19 +1538,21 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
       {
         fprintf (stderr, "Accumulating elements from layer %i\n", GetLayerNumber (PCB->Data, layer));
 
-//        r_search (layer->line_tree, &bounds, NULL, line_copper_callback, &info);
-//        r_search (layer->arc_tree,  &bounds, NULL, arc_copper_callback, &info);
-//        r_search (layer->text_tree, &bounds, NULL, text_copper_callback, &info);
+        r_search (layer->line_tree, &bounds, NULL, line_copper_callback, &info);
+        r_search (layer->arc_tree,  &bounds, NULL, arc_copper_callback, &info);
+        r_search (layer->text_tree, &bounds, NULL, text_copper_callback, &info);
         r_search (layer->polygon_tree, &bounds, NULL, polygon_copper_callback, &info);
       }
     END_LOOP;
-
-//    fprintf (stderr, "Accumulating pin + via pads\n");
-//    r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
-//    r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
 #endif
 
 #if 0
+    fprintf (stderr, "Accumulating pin + via pads\n");
+    r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
+    r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
+#endif
+
+#if 1
     if (group == top_group ||
         group == bottom_group)
       {
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 48ddf29..a4fe3c5 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -152,8 +152,11 @@ step_do_export (HID_Attr_Val * options)
   if (filename == NULL)
     filename = "pcb-out.step";
 
-//  board_outline_list = object3d_from_board_outline ();
+#if 0
+  board_outline_list = object3d_from_board_outline ();
+#else
   board_outline_list = NULL;
+#endif
 
   board_outline = board_outline_poly (true);
   piece = board_outline;
diff --git a/src/polygon.h b/src/polygon.h
index 1343d03..a2e7b56 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,7 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 8 //10 //40
+#define POLY_CIRC_SEGS 4 //10 //40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index ca4dd28..3c3f1a6 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -39,7 +39,7 @@
       are marked
 */
 
-#undef NDEBUG
+//#undef NDEBUG
 #include	<assert.h>
 #include	<stdlib.h>
 #include	<stdio.h>
@@ -110,13 +110,13 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 
 #define error(code)  longjmp(*(e), code)
 
-#define DEBUG_INTERSECT
-#define DEBUG_LABEL
-#define DEBUG_ALL_LABELS
-#define DEBUG_JUMP
-#define DEBUG_GATHER
-#define DEBUG_ANGLE
-#define DEBUG
+#undef DEBUG_INTERSECT
+#undef DEBUG_LABEL
+#undef DEBUG_ALL_LABELS
+#undef DEBUG_JUMP
+#undef DEBUG_GATHER
+#undef DEBUG_ANGLE
+#undef DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -2997,14 +2997,20 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
   *res = NULL;
 
+#if 0
   fprintf (stderr, "# A POLYGON\n");
   if (a == NULL) printf ("NULL\n"); else poly_dump (a);
   fprintf (stderr, "# B POLYGON\n");
   if (b == NULL) printf ("NULL\n"); else poly_dump (b);
+#endif
 
+#if 0
   /* Make copies for tracking polygon parentage (DEBUG) */
   if (!poly_M_Copy0 (&a_copy, a) || !poly_M_Copy0 (&b_copy, b))
       return err_no_memory;
+#endif
+  a_copy = NULL;
+  b_copy = NULL;
 
   /* Move the parentage information over onto the copy */
   if (a_copy != NULL)
