Bottom: 1d6466143e626a62746c5b56d66407df26000bee
Top:    647458551d67cd78e5ec727ac295e7a473bda2d1
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-13 19:38:31 +0000

Allocate VNODE with g_slice_new0, rather than calloc

g_slice should be optimised for lots of small allocations - lets try this..


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 9f71638..ba66d9d 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -202,10 +202,10 @@ poly_CreateNodeFull (Vector v, bool is_round, double cx, double cy, double radiu
   Coord *c;
 
   assert (v);
-  res = (VNODE *) calloc (1, sizeof (VNODE));
+  res = g_slice_new0 (VNODE);
   if (res == NULL)
     return NULL;
-  // bzero (res, sizeof (VNODE) - sizeof(Vector));
+
   c = res->point;
   *c++ = *v++;
   *c = *v;
@@ -367,6 +367,7 @@ new_descriptor (VNODE * a, char poly, char side)
                 PREV_VERTEX (a)->cvc_prev = PREV_VERTEX (a)->cvc_next = NULL;
               poly_ExclVertex (PREV_VERTEX (a));
               vect_sub (v, PREV_VERTEX (a)->point, a->point);
+#warning DOES THIS LEAK A VERTEX?
             }
           else
             {
@@ -374,6 +375,7 @@ new_descriptor (VNODE * a, char poly, char side)
                 NEXT_VERTEX (a)->cvc_prev = NEXT_VERTEX (a)->cvc_next = NULL;
               poly_ExclVertex (NEXT_VERTEX (a));
               vect_sub (v, NEXT_VERTEX (a)->point, a->point);
+#warning DOES THIS LEAK A VERTEX?
             }
         }
 
@@ -3513,7 +3515,7 @@ poly_NewContour (VNODE *node)
   res->head.radius = node->radius;
 #warning THIS WILL BE BOGUS IF WE GET A CIRCULAR CONTOUR STARTING AT THE HEAD.. NEED 2ND POINT TO DETMERMINE BOUNDS
   cntrbox_adjust (res, res->head.point);
-  free (node);
+  g_slice_free (VNODE, node);
 
   return res;
 }
@@ -3527,7 +3529,7 @@ poly_ClrContour (PLINE * c)
   while ((cur = NEXT_EDGE (&c->head)) != &c->head)
     {
       poly_ExclVertex (cur);
-      free (cur);
+      g_slice_free (VNODE, cur);
     }
   free (c->tristrip_vertices);
   c->tristrip_vertices = NULL;
@@ -3550,7 +3552,7 @@ poly_DelContour (PLINE ** c)
 	  free (cur->cvc_next);
 	  free (cur->cvc_prev);
 	}
-      free (cur);
+      g_slice_free (VNODE, cur);
     }
   if ((*c)->head.cvc_next != NULL)
     {
@@ -3594,7 +3596,7 @@ poly_PreContour (PLINE * C, BOOLp optimize)
           if (0)
 	    {
 	      poly_ExclVertex (c);
-	      free (c);
+	      g_slice_free (VNODE, c);
 	      c = p;
 	    }
 	}
@@ -3852,7 +3854,7 @@ poly_InclVertex (VNODE * after, VNODE * node)
       VNODE *t = PREV_VERTEX (node);
       NEXT_VERTEX (PREV_VERTEX (t)) = node;
       PREV_VERTEX (node) = PREV_VERTEX (t);
-      free (t);
+      g_slice_free (VNODE, t);
     }
 }
 
@@ -4647,10 +4649,10 @@ vect_inters2 (Vector p1, Vector p2, double s1, double s2,
       Vector q1_trimmed;
       Vector q2_trimmed;
 
-      double sq1;
-      double sq2;
-      double tp1;
-      double tp2;
+//      double sq1;
+//      double sq2;
+//      double tp1;
+//      double tp2;
 
       p1_trimmed[0] = p1[0] + ROUND (s1 * rpx);
       p1_trimmed[1] = p1[1] + ROUND (s1 * rpy);
@@ -4663,10 +4665,10 @@ vect_inters2 (Vector p1, Vector p2, double s1, double s2,
       q2_trimmed[1] = q1[1] + ROUND (t2 * rqy);
 
       /* Calculate the parameter values on each line (p1-p2 has s param, q1-q2 has t param), of the end-points of the other line */
-      sq1 = calculate_line_point_intersection (p1, p2, q1_trimmed);
-      sq2 = calculate_line_point_intersection (p1, p2, q2_trimmed);
-      tp1 = calculate_line_point_intersection (q1, q2, p1_trimmed);
-      tp2 = calculate_line_point_intersection (q1, q2, p2_trimmed);
+//      sq1 = calculate_line_point_intersection (p1, p2, q1_trimmed);
+//      sq2 = calculate_line_point_intersection (p1, p2, q2_trimmed);
+//      tp1 = calculate_line_point_intersection (q1, q2, p1_trimmed);
+//      tp2 = calculate_line_point_intersection (q1, q2, p2_trimmed);
 
       {
       double dc1, dc2, d1, d2, h;	/* Check to see whether p1-p2 and q1-q2 are on the same line */
