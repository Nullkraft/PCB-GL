Bottom: b760cdbc5238510efc54a18d33ed6a293d8afe73
Top:    a3a951532d48ac2b6d495cc9725a0b91b2124119
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:33:44 +0000

Extend board export

Include emission of soldermask etc..

V2: Apply the solder-mask on top of the board (core) thickness, don't shrink the core to account for it

---

diff --git a/src/hid/common/appearance.c b/src/hid/common/appearance.c
index 92790fcc..e557b43 100644
--- a/src/hid/common/appearance.c
+++ b/src/hid/common/appearance.c
@@ -23,3 +23,9 @@ appearance_set_color (appearance *appear, float r, float g, float b)
   appear->g = g;
   appear->b = b;
 }
+
+void
+appearance_set_appearance (appearance *appear, const appearance *from)
+{
+  *appear = *from;
+}
diff --git a/src/hid/common/appearance.h b/src/hid/common/appearance.h
index d4917d7..d2bf7b3 100644
--- a/src/hid/common/appearance.h
+++ b/src/hid/common/appearance.h
@@ -3,5 +3,6 @@ typedef struct {
 } appearance;
 
 appearance *make_appearance (void);
-void destroy_appearance (appearance *appearance);
-void appearance_set_color (appearance *appearance, float r, float g, float b);
+void destroy_appearance (appearance *appear);
+void appearance_set_color (appearance *appear, float r, float g, float b);
+void appearance_set_appearance (appearance *appear, const appearance *from);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index c34c17f..4ce4990 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -5,6 +5,7 @@
 
 #include <glib.h>
 
+#include "data.h"
 #include "step_id.h"
 #include "quad.h"
 #include "vertex3d.h"
@@ -14,7 +15,9 @@
 #include "edge3d.h"
 #include "object3d.h"
 #include "polygon.h"
-#include "data.h"
+
+#include "rtree.h"
+#include "rotate.h"
 
 #include "pcb-printf.h"
 
@@ -57,6 +60,7 @@
 
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
+#define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
 
 static GList *object3d_test_objects = NULL;
 
@@ -228,8 +232,637 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 }
 
 GList *
+object3d_from_contours (const POLYAREA *contours,
+                        double zbot,
+                        double ztop,
+                        const appearance *master_object_appearance,
+                        const appearance *master_top_bot_appearance)
+{
+  GList *objects = NULL;
+  object3d *object;
+  appearance *object_appearance = NULL;
+  appearance *top_bot_appearance = NULL;
+  const POLYAREA *pa;
+  PLINE *contour;
+  PLINE *ct;
+  int ncontours;
+  int npoints;
+  int i;
+  vertex3d **vertices;
+  edge_ref *edges;
+  face3d **faces;
+  int start_of_ct;
+  int offset_in_ct;
+  int ct_npoints;
+
+  if (contours == NULL)
+    return NULL;
+
+  /* Loop over all board outline pieces */
+  pa = contours;
+  do {
+
+    contour = pa->contours;
+    ncontours = 0;
+    npoints = 0;
+
+    ct = contour;
+    while (ct != NULL) {
+      ncontours ++;
+      npoints += get_contour_npoints (ct);
+      ct = ct->next;
+    }
+
+    object = make_object3d (PCB->Name);
+
+    if (master_object_appearance != NULL)
+      {
+        object_appearance = make_appearance ();
+        appearance_set_appearance (object_appearance, master_object_appearance);
+      }
+
+    if (master_top_bot_appearance != NULL)
+      {
+        top_bot_appearance = make_appearance ();
+        appearance_set_appearance (top_bot_appearance, master_top_bot_appearance);
+      }
+
+    object3d_set_appearance (object, object_appearance);
+
+    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
+    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
+    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
+
+    /* Define the vertices */
+    ct = contour;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      double x1, y1;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+      }
+
+      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+
+      vertices[i]           = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, zbot)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, ztop)); /* Top */
+
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
+    }
+
+    /* Define the edges */
+    for (i = 0; i < 3 * npoints; i++) {
+      edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
+      object3d_add_edge (object, edges[i]);
+    }
+
+    /* Define the faces */
+    for (i = 0; i < npoints; i++) {
+      faces[i] = make_face3d ();
+
+      object3d_add_face (object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
+    }
+
+    faces[npoints] = make_face3d (); /* bottom_face */
+    face3d_set_normal (faces[npoints], 0., 0., -1.);
+    face3d_set_appearance (faces[npoints], top_bot_appearance);
+    object3d_add_face (object, faces[npoints]);
+
+    faces[npoints + 1] = make_face3d (); /* top_face */
+    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints + 1]);
+
+    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
+    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
+
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
+      }
+
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+#if REVERSED_PCB_CONTOURS
+      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#else
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
+
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
+
+      if (ct->is_round) {
+
+        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
+                                          COORD_TO_MM (ct->radius));
+        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+#ifdef REVERSED_PCB_CONTOURS
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+      }
+
+    }
+
+    if (0) {
+      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+      edge_ref cylinder_edges[3];
+      vertex3d *cylinder_vertices[2];
+      face3d *cylinder_faces[2];
+
+      /* Edge on top of board */
+      cylinder_edges[0] = make_edge ();
+      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
+#else
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);         /* Radius */
+#endif
+      object3d_add_edge (object, cylinder_edges[0]);
+
+      /* Edge on top of cylinder */
+      cylinder_edges[1] = make_edge ();
+      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
+                            5.);          /* Radius */
+      object3d_add_edge (object, cylinder_edges[1]);
+
+      /* Edge stitching cylinder */
+      cylinder_edges[2] = make_edge ();
+      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+      object3d_add_edge (object, cylinder_edges[2]);
+
+      /* Vertex on board top surface */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+      object3d_add_vertex (object, cylinder_vertices[0]);
+
+      /* Vertex on cylinder top surface */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+      object3d_add_vertex (object, cylinder_vertices[1]);
+
+      /* Cylindrical face */
+      cylinder_faces[0] = make_face3d ();
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
+                                        5.);                   /* Radius of cylinder */
+      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+      object3d_add_face (object, cylinder_faces[0]);
+      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+      /* Top face of cylinder */
+      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+      object3d_add_face (object, cylinder_faces[1]);
+      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+      /* Splice onto board */
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+      LDATA (cylinder_edges[0]) = cylinder_faces[0];
+      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+      LDATA (cylinder_edges[1]) = cylinder_faces[1];
+      RDATA (cylinder_edges[1]) = cylinder_faces[0];
+      LDATA (cylinder_edges[2]) = cylinder_faces[0];
+      RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+      /* Splice things together.... */
+
+      /* Link edges orbiting the cylinder bottom vertex */
+      splice (cylinder_edges[0], cylinder_edges[2]);
+      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+      /* Link edges orbiting the cylinder top vertex */
+      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+    }
+
+    objects = g_list_append (objects, object);
+
+  } while (pa = pa->f, pa != contours);
+
+  return objects;
+}
+
+GList *
 object3d_from_board_outline (void)
 {
+  POLYAREA *board_outline = board_outline_poly (true);
+
+#if 0
+  return object3d_from_soldermask_within_area (board_outline, TOP_SIDE);
+#else
+
+  appearance *board_appearance;
+  appearance *top_bot_appearance;
+  GList *objects;
+
+  board_appearance = make_appearance ();
+  top_bot_appearance = NULL;
+//  top_bot_appearance = make_appearance ();
+  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+//  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+
+#ifdef REVERSED_PCB_CONTOURS
+  objects = object3d_from_contours (board_outline,
+                                    -HACK_BOARD_THICKNESS, /* Bottom */
+                                    0                    ,  /* Top */
+                                    board_appearance,
+                                    top_bot_appearance);
+#else
+  objects = object3d_from_contours (board_outline,
+                                     HACK_BOARD_THICKNESS / 2, /* Bottom */
+                                    -HACK_BOARD_THICKNESS / 2, /* Top */
+                                    board_appearance,
+                                    top_bot_appearance);
+#endif
+
+  destroy_appearance (board_appearance);
+  destroy_appearance (top_bot_appearance);
+
+  poly_Free (&board_outline);
+
+  return objects;
+#endif
+}
+
+struct mask_info {
+  POLYAREA *poly;
+  int side;
+};
+
+static POLYAREA *
+TextToPoly (TextType *Text, Coord min_line_width)
+{
+  POLYAREA *np, *res;
+  Coord x = 0;
+  unsigned char *string = (unsigned char *) Text->TextString;
+  Cardinal n;
+  FontType *font = &PCB->Font;
+
+  res = NULL;
+
+  while (string && *string)
+    {
+      /* draw lines if symbol is valid and data is present */
+      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
+        {
+          LineType *line = font->Symbol[*string].Line;
+          LineType newline;
+
+          for (n = font->Symbol[*string].LineN; n; n--, line++)
+            {
+              /* create one line, scale, move, rotate and swap it */
+              newline = *line;
+              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
+              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
+              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
+              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
+              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
+              if (newline.Thickness < min_line_width)
+                newline.Thickness = min_line_width;
+
+              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
+
+              /* the labels of SMD objects on the bottom
+               * side haven't been swapped yet, only their offset
+               */
+              if (TEST_FLAG (ONSOLDERFLAG, Text))
+                {
+                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
+                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
+                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
+                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
+                }
+              /* add offset and draw line */
+              newline.Point1.X += Text->X;
+              newline.Point1.Y += Text->Y;
+              newline.Point2.X += Text->X;
+              newline.Point2.Y += Text->Y;
+
+              np = LinePoly (&newline, newline.Thickness, NULL);
+              poly_Boolean_free (res, np, &res, PBO_UNITE);
+            }
+
+          /* move on to next cursor position */
+          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
+        }
+      else
+        {
+          /* the default symbol is a filled box */
+          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
+          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
+
+          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
+          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
+          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
+          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
+
+          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
+
+          /* add offset and draw box */
+          defaultsymbol.X1 += Text->X;
+          defaultsymbol.Y1 += Text->Y;
+          defaultsymbol.X2 += Text->X;
+          defaultsymbol.Y2 += Text->Y;
+
+          np = RectPoly (defaultsymbol.X1, defaultsymbol.X2,
+                         defaultsymbol.Y1, defaultsymbol.Y2);
+          poly_Boolean_free (res, np, &res, PBO_UNITE);
+
+          /* move on to next cursor position */
+          x += size;
+        }
+      string++;
+    }
+
+  return res;
+}
+
+static int
+line_mask_callback (const BoxType * b, void *cl)
+{
+  LineType *line = (LineType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = LinePoly (line, line->Thickness, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+arc_mask_callback (const BoxType * b, void *cl)
+{
+  ArcType *arc = (ArcType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = ArcPoly (arc, arc->Thickness, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+
+static int
+text_mask_callback (const BoxType * b, void *cl)
+{
+  TextType *text = (TextType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = TextToPoly (text, PCB->minWid))) /* XXX: Min mask cutout width should be separate */
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+polygon_mask_callback (const BoxType * b, void *cl)
+{
+  PolygonType *poly = (PolygonType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = PolygonToPoly (poly)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+pad_mask_callback (const BoxType * b, void *cl)
+{
+  PadType *pad = (PadType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (pad->Mask == 0)
+    return 0;
+
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), (info->side == BOTTOM_SIDE)))
+    return 0;
+
+  if (!(np = PadPoly (pad, pad->Mask)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+pv_mask_callback (const BoxType * b, void *cl)
+{
+  PinType *pv = (PinType *)b;
+  struct mask_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = CirclePoly (pv->X, pv->Y, pv->Mask / 2, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+
+GList *
+object3d_from_soldermask_within_area (POLYAREA *area, int side)
+{
+  appearance *mask_appearance;
+  GList *objects;
+  struct mask_info info;
+  BoxType bounds;
+  LayerType *layer;
+
+  poly_Copy0 (&info.poly, area);
+  info.side = side;
+
+  bounds.X1 = area->contours->xmin;
+  bounds.X2 = area->contours->xmax;
+  bounds.Y1 = area->contours->ymin;
+  bounds.Y2 = area->contours->ymax;
+
+  layer = LAYER_PTR ((side == TOP_SIDE) ? top_soldermask_layer : bottom_soldermask_layer);
+
+  r_search (layer->line_tree, &bounds, NULL, line_mask_callback, &info);
+  r_search (layer->arc_tree,  &bounds, NULL, arc_mask_callback, &info);
+  r_search (layer->text_tree, &bounds, NULL, text_mask_callback, &info);
+  r_search (layer->polygon_tree, &bounds, NULL, polygon_mask_callback, &info);
+  r_search (PCB->Data->pad_tree, &bounds, NULL, pad_mask_callback, &info);
+  r_search (PCB->Data->pin_tree, &bounds, NULL, pv_mask_callback, &info);
+  r_search (PCB->Data->via_tree, &bounds, NULL, pv_mask_callback, &info);
+
+  mask_appearance = make_appearance ();
+  appearance_set_color (mask_appearance, 0.2, 0.8, 0.2);
+
+#ifdef REVERSED_PCB_CONTOURS
+  objects = object3d_from_contours (info.poly,
+                                    (side == TOP_SIDE) ? 0                    : -HACK_BOARD_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
+                                    (side == TOP_SIDE) ? HACK_MASK_THICKNESS  : -HACK_BOARD_THICKNESS,                       /* Top */
+                                    mask_appearance,
+                                    NULL);
+#else
+  objects = object3d_from_contours (info.poly,
+                                    (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2                       : HACK_BOARD_THICKNESS / 2 + HACK_MASK_THICKNESS, /* Bottom */
+                                    (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2, /* Top */
+                                    mask_appearance,
+                                    NULL);
+#endif
+
+  destroy_appearance (mask_appearance);
+
+  poly_Free (&info.poly);
+
+  return objects;
+}
+
+GList *
+old_object3d_from_board_outline (void)
+{
   GList *board_objects = NULL;
   object3d *board_object;
   appearance *board_appearance;
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index e8c26e2..2ffdb54 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -15,4 +15,6 @@ void object3d_set_appearance (object3d *object, appearance *appear);
 void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
+GList *object3d_from_contours (const POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance);
 GList *object3d_from_board_outline (void);
+GList *object3d_from_soldermask_within_area (POLYAREA *area, int side);
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 8748f51..aa2ee46 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -5,6 +5,8 @@
 
 #include <glib.h>
 
+#include "data.h"
+
 #include "hid/common/step_id.h"
 #include "hid/common/quad.h"
 #include "hid/common/vertex3d.h"
@@ -98,26 +100,15 @@ finish_ap214_file (step_file *step)
 }
 
 static void
-object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, char *part_name, char *part_description, char *body_name,
-                           step_id *shape_definition_representation, step_id *placement_axis)
+step_product_fragment (step_file *step, char *part_id, char *part_name, char *part_description,
+                       step_id *geometric_representation_context,
+                       step_id *product_definition_shape)
 {
   step_id application_context_identifier;
   step_id product_identifier;
   step_id product_definition_identifier;
   step_id product_definition_shape_identifier;
   step_id geometric_representation_context_identifier;
-  step_id shape_representation_identifier;
-  step_id brep_identifier;
-  step_id anchor_axis_identifier;
-  step_id pcb_shell_identifier;
-  step_id brep_style_identifier;
-  step_id shape_definition_representation_identifier;
-  GList *styled_item_identifiers = NULL;
-  GList *shell_face_list = NULL;
-  GList *face_iter;
-  GList *edge_iter;
-  GList *vertex_iter;
-  GList *contour_iter;
 
   /* Setup the context of the "product" we are defining", and that it is a 'part' */
   application_context_identifier = step_application_context (step, "automotive_design");
@@ -134,6 +125,29 @@ object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, cha
 
   geometric_representation_context_identifier = make_3d_metric_step_geometric_representation_context (step);
 
+  if (geometric_representation_context != NULL)
+    *geometric_representation_context = geometric_representation_context_identifier;
+
+  if (product_definition_shape != NULL)
+    *product_definition_shape = product_definition_shape_identifier;
+}
+
+static void
+object3d_to_step_body_fragment (step_file *step,
+                                object3d *object,
+                                char *body_name,
+                                step_id *brep,
+                                step_id_list *styled_item_identifiers)
+{
+  step_id brep_identifier;
+  step_id pcb_shell_identifier;
+  step_id brep_style_identifier;
+  GList *shell_face_list = NULL;
+  GList *face_iter;
+  GList *edge_iter;
+  GList *vertex_iter;
+  GList *contour_iter;
+
 #define FWD 1
 #define REV 2
 #define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
@@ -292,7 +306,7 @@ object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, cha
   brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
   step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
+  *styled_item_identifiers = step_id_list_append (*styled_item_identifiers, brep_style_identifier);
 
   /* Face styles */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
@@ -302,14 +316,34 @@ object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, cha
       step_id orsi = step_over_riding_styled_item (step, "NONE",
                                                    presentation_style_assignments_from_appearance (step, face->appear),
                                                    face->face_identifier, brep_style_identifier);
-      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+      *styled_item_identifiers = step_id_list_append (*styled_item_identifiers, orsi);
     }
   }
-
-  /* Emit references to the styled and over_ridden styled items */
-  step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
 #endif
 
+  if (brep != NULL)
+    *brep = brep_identifier;
+
+#undef ORIENTED_EDGE_IDENTIFIER
+#undef FWD
+#undef REV
+}
+
+
+static void
+step_absr_fragment (step_file *step,
+                    step_id_list brep_list,
+                    step_id_list styled_item_list,
+                    step_id geometric_representation_context_identifier,
+                    step_id product_definition_shape_identifier,
+                    step_id *shape_representation,
+                    step_id *shape_definition_representation,
+                    step_id *placement_axis)
+{
+  step_id shape_representation_identifier;
+  step_id anchor_axis_identifier;
+  step_id shape_definition_representation_identifier;
+
   /* Need an anchor in 3D space to orient the shape */
   anchor_axis_identifier = step_axis2_placement_3d (step, "NONE",
                                                     step_cartesian_point (step, "NONE", 0.0, 0.0, 0.0),
@@ -318,20 +352,110 @@ object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, cha
 
   shape_representation_identifier =
     step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
-                                             make_step_id_list (2, brep_identifier, anchor_axis_identifier), geometric_representation_context_identifier);
+                                             step_id_list_append (brep_list, anchor_axis_identifier),
+                                             geometric_representation_context_identifier);
 
   shape_definition_representation_identifier =
   step_shape_definition_representation (step, product_definition_shape_identifier, shape_representation_identifier);
 
+  /* Emit references to the styled and over_ridden styled items */
+  step_mechanical_design_geometric_presentation_representation (step, "", styled_item_list, geometric_representation_context_identifier);
+
   if (shape_definition_representation != NULL)
     *shape_definition_representation = shape_definition_representation_identifier;
 
   if (placement_axis != NULL)
     *placement_axis = anchor_axis_identifier;
+}
 
-#undef ORIENTED_EDGE_IDENTIFIER
-#undef FWD
-#undef REV
+void
+object3d_list_export_to_step_part (GList *objects, const char *filename)
+{
+  step_file *step;
+  step_id geometric_representation_context;
+  step_id product_definition_shape;
+  step_id shape_representation;
+  step_id shape_definition_representation;
+  step_id placement_axis;
+  step_id comp_brep;
+  GList *object_iter;
+  int part;
+  bool multiple_bodies;
+  GString *part_id;
+  GString *part_name;
+  step_id_list breps;
+  step_id_list styled_items;
+
+  multiple_bodies = (g_list_next (objects) != NULL);
+
+  step = start_ap214_file (filename);
+
+  part_id   = g_string_new ("part id");
+  part_name = g_string_new ("part name");
+
+  step_product_fragment (step, part_id->str, part_name->str, "PCB model",
+                         &geometric_representation_context,
+                         &product_definition_shape);
+
+  g_string_free (part_id, true);
+  g_string_free (part_name, true);
+
+  breps = make_step_id_list (0);
+  styled_items = make_step_id_list (0);
+
+  for (object_iter = objects, part = 1;
+       object_iter != NULL;
+       object_iter = g_list_next (object_iter), part++) {
+
+    object3d *object = object_iter->data;
+    GString *body_name;
+
+    body_name = g_string_new ("part body");
+    if (multiple_bodies)
+      g_string_append_printf (body_name, " - %i", part);
+
+    object3d_to_step_body_fragment (step, object, body_name->str, &comp_brep, &styled_items);
+
+    g_string_free (body_name, true);
+
+    breps = step_id_list_append (breps, comp_brep);
+  }
+
+  step_absr_fragment (step,
+                      breps,
+                      styled_items,
+                      geometric_representation_context,
+                      product_definition_shape,
+                      &shape_representation,
+                      &shape_definition_representation,
+                      &placement_axis);
+
+  finish_ap214_file (step);
+}
+
+static void
+object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, char *part_name, char *part_description, char *body_name,
+                           step_id *shape_definition_representation, step_id *placement_axis)
+{
+  step_id product_definition_shape_identifier;
+  step_id geometric_representation_context_identifier;
+  step_id brep_identifier;
+  GList *styled_item_identifiers = NULL;
+
+  step_product_fragment (step, part_id, part_name, part_description,
+                         &geometric_representation_context_identifier,
+                         &product_definition_shape_identifier);
+
+  object3d_to_step_body_fragment (step, object, body_name, &brep_identifier, &styled_item_identifiers);
+
+  step_absr_fragment (step,
+                      make_step_id_list (1, brep_identifier),
+                      styled_item_identifiers,
+                      geometric_representation_context_identifier,
+                      product_definition_shape_identifier,
+                      NULL /* shape_representation */,
+                      shape_definition_representation,
+                      placement_axis);
 }
 
 void
diff --git a/src/hid/step/object3d_step.h b/src/hid/step/object3d_step.h
index 5dc6f4d..2860d9b 100644
--- a/src/hid/step/object3d_step.h
+++ b/src/hid/step/object3d_step.h
@@ -1,2 +1,3 @@
+void object3d_list_export_to_step_part (GList *objects, const char *filename);
 void object3d_list_export_to_step_assy (GList *objects, const char *filename);
 void object3d_export_to_step (object3d *object, const char *filename);
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 2e2e86d..d765c3c 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -6,7 +6,7 @@
 //#include <stdarg.h> /* not used */
 //#include <stdlib.h>
 //#include <string.h>
-//#include <assert.h> /* not used */
+#include <assert.h>
 #include <time.h>
 
 #include "global.h"
@@ -25,6 +25,7 @@
 #include "hid/common/hidinit.h"
 #include "polygon.h"
 #include "misc.h"
+#include "rtree.h"
 
 #include "hid/common/step_id.h"
 #include "hid/common/quad.h"
@@ -136,6 +137,8 @@ step_do_export (HID_Attr_Val * options)
   const char *filename;
   const char *temp_pcb_filename = "_pcb.step";
   GList *board_outline_list;
+  POLYAREA *board_outline;
+  POLYAREA *piece;
 
   if (!options)
     {
@@ -150,7 +153,61 @@ step_do_export (HID_Attr_Val * options)
     filename = "pcb-out.step";
 
   board_outline_list = object3d_from_board_outline ();
-  object3d_list_export_to_step_assy (board_outline_list, temp_pcb_filename);
+
+  board_outline = board_outline_poly (true);
+  piece = board_outline;
+  do {
+    GList *mask_objects;
+    PLINE *curc;
+    PLINE *next;
+    PLINE **prev_next;
+
+    // Remove any complete internal contours due to vias, so we may
+    // more realistically show tented vias without loosing the ability
+    // to split the soldermask body with a contour partly formed of vias.
+    //
+    // Should have the semantics that via holes in the mask are only due
+    // to the clearance size, not the drill size - IFF they are on the
+    // interior of a board body piece.
+    //
+    // If the via wall forms part of the board piece outside contour, the
+    // soldermask will be the maximum of the drilling hole, or the clearance;
+    // via drill-hole walls are not removed from the piece outside contour.
+
+    prev_next = &piece->contours;
+    for (curc = piece->contours; curc != NULL; curc = next)
+      {
+        next = curc->next;
+
+        /* XXX: Insufficient test for via contour.. really need to KNOW this was a pin/via,
+         *      as we may start using round tagged contours for circular cutouts etc...
+         */
+        if (!curc->is_round)
+          {
+            prev_next = &curc->next;
+            continue;
+          }
+
+        /* Remove contour... */
+        assert (*prev_next == curc);
+        *prev_next = curc->next;
+        curc->next = NULL;
+
+        r_delete_entry (piece->contour_tree, (BoxType *) curc);
+        poly_DelContour (&curc);
+      }
+
+    mask_objects = object3d_from_soldermask_within_area (piece, TOP_SIDE);
+    board_outline_list = g_list_concat (board_outline_list, mask_objects);
+
+    mask_objects = object3d_from_soldermask_within_area (piece, BOTTOM_SIDE);
+    board_outline_list = g_list_concat (board_outline_list, mask_objects);
+
+  } while ((piece = piece->f) != board_outline);
+  poly_Free (&board_outline);
+
+  object3d_list_export_to_step_part (board_outline_list, temp_pcb_filename);
+//  object3d_list_export_to_step_assy (board_outline_list, temp_pcb_filename);
   g_list_free_full (board_outline_list, (GDestroyNotify)destroy_object3d);
 
   {
diff --git a/src/polygon.c b/src/polygon.c
index ea7c4ec..15256b8 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -861,14 +861,72 @@ LinePoly (LineType * L, Coord thick, char *name)
   return np;
 }
 
-/* make a rounded-corner rectangle */
-POLYAREA *
+/* make a rectangle pad (clear is applied square, not rounded) */
+static POLYAREA *
 SquarePadPoly (PadType * pad, Coord clear)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
   double d;
+  double cx, cy;
+  PadType _c=*pad,*c=&_c;
+  int halfclear = (clear + 1) / 2;
+
+  d =
+    sqrt (SQUARE (pad->Point1.X - pad->Point2.X) +
+          SQUARE (pad->Point1.Y - pad->Point2.Y));
+  if (d != 0)
+    {
+      double a = halfclear / d;
+      cx = (c->Point1.Y - c->Point2.Y) * a;
+      cy = (c->Point2.X - c->Point1.X) * a;
+
+      c->Point1.X -= cy;
+      c->Point1.Y += cx;
+      c->Point2.X += cy;
+      c->Point2.Y -= cx;
+    }
+  else
+    {
+      cx = halfclear;
+      cy = 0;
+
+      c->Point1.Y += cx;
+      c->Point2.Y -= cx;
+    }
+
+  v[0] = c->Point1.X + cx;
+  v[1] = c->Point1.Y + cy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
+
+  v[0] = c->Point1.X - cx;
+  v[1] = c->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  v[0] = c->Point2.X - cx;
+  v[1] = c->Point2.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  v[0] = c->Point2.X + cx;
+  v[1] = c->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  /* now we have the line contour */
+  if (!(np = ContourToPoly (contour)))
+    return NULL;
+  return np;
+}
+
+/* make a rounded-corner rectangle */
+static POLYAREA *
+SquarePadClearPoly (PadType * pad, Coord clear)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Vector v;
+  double d;
   double tx, ty;
   double cx, cy;
   PadType _t=*pad,*t=&_t;
@@ -1025,6 +1083,24 @@ BoxPolyBloated (BoxType *box, Coord bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
+POLYAREA *
+PadPoly (PadType *pad, Coord size)
+{
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    return SquarePadPoly (pad, size);
+  else
+    return LinePoly ((LineType *) pad, size, NULL);
+}
+
+static POLYAREA *
+PadClearPoly (PadType *pad, Coord size)
+{
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    return SquarePadClearPoly (pad, size);
+  else
+    return LinePoly ((LineType *) pad, size, NULL);
+}
+
 /* remove the pin clearance from the polygon */
 static int
 SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
@@ -1095,18 +1171,8 @@ SubtractPad (PadType * pad, PolygonType * p)
 
   if (pad->Clearance == 0)
     return 0;
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance, NULL)))
-        return -1;
-    }
+  if (!(np = PadClearPoly (pad, pad->Thickness + pad->Clearance)))
+    return -1;
   return Subtract (np, p, true);
 }
 
diff --git a/src/polygon.h b/src/polygon.h
index 8d4bfc4..15df8cc 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -92,6 +92,7 @@ POLYAREA * LinePoly(LineType *l, Coord thick, char *name);
 POLYAREA * ArcPoly(ArcType *l, Coord thick, char *name);
 POLYAREA * PinPoly(PinType *l, Coord thick, Coord clear);
 POLYAREA * BoxPolyBloated (BoxType *box, Coord radius);
+POLYAREA * PadPoly (PadType *pad, Coord size);
 void frac_circle (PLINE *, Coord, Coord, Vector, int);
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
