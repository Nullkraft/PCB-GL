Bottom: 2536b308cd1bf73a0ce6337e55a7890e03369f0e
Top:    6e169803e3cb0fdbc78bca1935e4c545564a122b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-06 14:51:36 +0000

hidgl: Provide more explicit management of rendering instances

Provide an (hidgl_instance *) pointer which is used to refer to a hidgl
instance when caling hidgl_* APIs that are instance, but not hidGC specific.

Various hidgl APIs now take the hidgl_instance as a parameter, or in the case
of hidgl_new_instance(), return a new instance.

Graphics APIs which previously had a hidGC parameter remain the same, as the
hidglGC structure now contains a link to the hidgl instance which created it.

This change paves the way to potentially having multiple hidgl instances active
simultaneously, and removes various global variables (such as "buffer" and
"global_depth") which were previously accessible to allow the gtk-gl HID to
draw using the hidgl internals.

The gtk-gl HID_DRAW graphics API now subclasses the hidgl HID_DRAW API, so the
gtk-gl HID can access the (non-private) gtk_gc->hidgl_gc.* fields.


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index ac68ce0..37da288 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -59,6 +59,7 @@
 #include "clip.h"
 
 #include "hid.h"
+#include "hid_draw.h"
 #include "hidgl.h"
 #include "rtree.h"
 
@@ -67,34 +68,44 @@
 #endif
 
 
-triangle_buffer buffer;
-float global_depth = 0;
+static void
+hidgl_reset_triangle_array (hidgl_instance *hidgl)
+{
+  hidgl_priv *priv = hidgl->priv;
+
+  priv->buffer.triangle_count = 0;
+  priv->buffer.coord_comp_count = 0;
+}
 
 static void
-hidgl_init_triangle_array (triangle_buffer *buffer)
+hidgl_init_triangle_array (hidgl_instance *hidgl)
 {
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  hidgl_reset_triangle_array (hidgl);
 }
 
 void
-hidgl_flush_triangles (triangle_buffer *buffer)
+hidgl_flush_triangles (hidgl_instance *hidgl)
 {
-  if (buffer->triangle_count == 0)
+  hidgl_priv *priv = hidgl->priv;
+
+  if (priv->buffer.triangle_count == 0)
     return;
 
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
-  glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
+  glVertexPointer   (3, GL_FLOAT, 0, priv->buffer.triangle_array);
+  glDrawArrays (GL_TRIANGLES, 0, priv->buffer.triangle_count * 3);
   glDisableClientState (GL_VERTEX_ARRAY);
 
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  hidgl_reset_triangle_array (hidgl);
 }
 
 void
-hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+hidgl_ensure_triangle_space (hidGC gc, int count)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+  hidgl_priv *priv = hidgl->priv;
+
   if (count > TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
@@ -102,19 +113,23 @@ hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
                        count, TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
-    hidgl_flush_triangles (buffer);
+  if (count > TRIANGLE_ARRAY_SIZE - priv->buffer.triangle_count)
+    hidgl_flush_triangles (hidgl);
 }
 
 void
-hidgl_set_depth (float depth)
+hidgl_set_depth (hidGC gc, float depth)
 {
-  global_depth = depth;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->depth = depth;
 }
 
 void
-hidgl_draw_grid (BoxType *drawn_area)
+hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   static GLfloat *points = 0;
   static int npoints = 0;
   Coord x1, y1, x2, y2, n, i;
@@ -125,7 +140,7 @@ hidgl_draw_grid (BoxType *drawn_area)
 
   x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
   y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth, drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
+  x2 = GridFit (MIN (PCB->MaxWidth,  drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
   y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
@@ -156,7 +171,7 @@ hidgl_draw_grid (BoxType *drawn_area)
   for (x = x1; x <= x2; x += PCB->Grid)
     {
       points[3 * n + 0] = x;
-      points[3 * n + 2] = global_depth;
+      points[3 * n + 2] = hidgl_gc->depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
@@ -184,7 +199,7 @@ int calc_slices (float pix_radius, float sweep_angle)
 
 #define MIN_TRIANGLES_PER_CAP 3
 #define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (Coord width, Coord x, Coord y, Angle angle, double scale)
+static void draw_cap (hidGC gc, Coord width, Coord x, Coord y, Angle angle, double scale)
 {
   float last_capx, last_capy;
   float capx, capy;
@@ -198,21 +213,21 @@ static void draw_cap (Coord width, Coord x, Coord y, Angle angle, double scale)
   if (slices > MAX_TRIANGLES_PER_CAP)
     slices = MAX_TRIANGLES_PER_CAP;
 
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_triangle_space (gc, slices);
 
   last_capx =  radius * cosf (angle * M_PI / 180.) + x;
   last_capy = -radius * sinf (angle * M_PI / 180.) + y;
   for (i = 0; i < slices; i++) {
     capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
     capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
+    hidgl_add_triangle (gc, last_capx, last_capy, capx, capy, x, y);
     last_capx = capx;
     last_capy = capy;
   }
 }
 
 void
-hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale)
+hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale)
 {
   double angle;
   double deltax, deltay, length;
@@ -260,26 +275,26 @@ hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, d
       break;
   }
 
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
+  hidgl_ensure_triangle_space (gc, 2);
+  hidgl_add_triangle (gc, x1 - wdx, y1 - wdy,
+                          x2 - wdx, y2 - wdy,
+                          x2 + wdx, y2 + wdy);
+  hidgl_add_triangle (gc, x1 - wdx, y1 - wdy,
+                          x2 + wdx, y2 + wdy,
+                          x1 + wdx, y1 + wdy);
 
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (width, x1, y1, angle + 90., scale);
-      draw_cap (width, x2, y2, angle - 90., scale);
+      draw_cap (gc, width, x1, y1, angle + 90., scale);
+      draw_cap (gc, width, x2, y2, angle - 90., scale);
     }
 }
 
 #define MIN_SLICES_PER_ARC 6
 #define MAX_SLICES_PER_ARC 360
 void
-hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
+hidgl_draw_arc (hidGC gc, Coord width, Coord x, Coord y, Coord rx, Coord ry,
                 Angle start_angle, Angle delta_angle, double scale)
 {
   float last_inner_x, last_inner_y;
@@ -321,7 +336,7 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
   if (slices > MAX_SLICES_PER_ARC)
     slices = MAX_SLICES_PER_ARC;
 
-  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+  hidgl_ensure_triangle_space (gc, 2 * slices);
 
   angle_incr_rad = delta_angle_rad / (float)slices;
 
@@ -334,12 +349,12 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
     sin_ang = sinf (start_angle_rad + ((float)(i)) * angle_incr_rad);
     inner_x = -inner_r * cos_ang + x;  inner_y = inner_r * sin_ang + y;
     outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
-    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
-                                 last_outer_x, last_outer_y,
-                                 outer_x, outer_y);
-    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
-                                 inner_x, inner_y,
-                                 outer_x, outer_y);
+    hidgl_add_triangle (gc, last_inner_x, last_inner_y,
+                            last_outer_x, last_outer_y,
+                            outer_x, outer_y);
+    hidgl_add_triangle (gc, last_inner_x, last_inner_y,
+                            inner_x, inner_y,
+                            outer_x, outer_y);
     last_inner_x = inner_x;  last_inner_y = inner_y;
     last_outer_x = outer_x;  last_outer_y = outer_y;
   }
@@ -348,28 +363,30 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
   if (hairline)
     return;
 
-  draw_cap (width, x + rx * -cosf (start_angle_rad),
-                   y + rx *  sinf (start_angle_rad),
-                   start_angle, scale);
-  draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
-                   y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180., scale);
+  draw_cap (gc, width, x + rx * -cosf (start_angle_rad),
+                       y + rx *  sinf (start_angle_rad),
+                       start_angle, scale);
+  draw_cap (gc, width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
+                       y + rx *  sinf (start_angle_rad + delta_angle_rad),
+                       start_angle + delta_angle + 180., scale);
 }
 
 void
-hidgl_draw_rect (Coord x1, Coord y1, Coord x2, Coord y2)
+hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   glBegin (GL_LINE_LOOP);
-  glVertex3f (x1, y1, global_depth);
-  glVertex3f (x1, y2, global_depth);
-  glVertex3f (x2, y2, global_depth);
-  glVertex3f (x2, y1, global_depth);
+  glVertex3f (x1, y1, hidgl_gc->depth);
+  glVertex3f (x1, y2, hidgl_gc->depth);
+  glVertex3f (x2, y2, hidgl_gc->depth);
+  glVertex3f (x2, y1, hidgl_gc->depth);
   glEnd ();
 }
 
 
 void
-hidgl_fill_circle (Coord vx, Coord vy, Coord vr, double scale)
+hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr, double scale)
 {
 #define MIN_TRIANGLES_PER_CIRCLE 6
 #define MAX_TRIANGLES_PER_CIRCLE 360
@@ -386,7 +403,7 @@ hidgl_fill_circle (Coord vx, Coord vy, Coord vr, double scale)
   if (slices > MAX_TRIANGLES_PER_CIRCLE)
     slices = MAX_TRIANGLES_PER_CIRCLE;
 
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_triangle_space (gc, slices);
 
   last_x = vx + vr;
   last_y = vy;
@@ -395,7 +412,7 @@ hidgl_fill_circle (Coord vx, Coord vy, Coord vr, double scale)
     float x, y;
     x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
     y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
+    hidgl_add_triangle (gc, vx, vy, last_x, last_y, x, y);
     last_x = x;
     last_y = y;
   }
@@ -459,11 +476,13 @@ myBegin (GLenum type)
 }
 
 static double global_scale;
+static hidGC tesselator_gc = NULL;
 
 static void CALLBACK
 myVertex (GLdouble *vertex_data)
 {
   static GLfloat triangle_vertices [2 * 3];
+  hidGC gc = tesselator_gc;
 
   if (tessVertexType == GL_TRIANGLE_STRIP ||
       tessVertexType == GL_TRIANGLE_FAN)
@@ -476,8 +495,8 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
-          hidgl_ensure_triangle_space (&buffer, 1);
-          hidgl_add_triangle (&buffer,
+          hidgl_ensure_triangle_space (gc, 1);
+          hidgl_add_triangle (gc,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
@@ -500,8 +519,8 @@ myVertex (GLdouble *vertex_data)
       stashed_vertices ++;
       if (stashed_vertices == 3)
         {
-          hidgl_ensure_triangle_space (&buffer, 1);
-          hidgl_add_triangle (&buffer,
+          hidgl_ensure_triangle_space (gc, 1);
+          hidgl_add_triangle (gc,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               triangle_vertices [4], triangle_vertices [5]);
@@ -521,7 +540,7 @@ myFreeCombined ()
 }
 
 void
-hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
+hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
   int i;
   GLUtesselator *tobj;
@@ -531,6 +550,7 @@ hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
 
   vertices = malloc (sizeof(GLdouble) * n_coords * 3);
 
+  tesselator_gc = gc;
   tobj = gluNewTess ();
   gluTessCallback(tobj, GLU_TESS_BEGIN,   (_GLUfuncptr)myBegin);
   gluTessCallback(tobj, GLU_TESS_VERTEX,  (_GLUfuncptr)myVertex);
@@ -551,6 +571,7 @@ hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
   gluTessEndContour (tobj);
   gluTessEndPolygon (tobj);
   gluDeleteTess (tobj);
+  tesselator_gc = NULL;
 
   myFreeCombined ();
   free (vertices);
@@ -570,7 +591,7 @@ tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices,
   if (contour->is_round) {
     double slices = calc_slices (contour->radius / scale, 2 * M_PI);
     if (slices < contour->Count) {
-      hidgl_fill_circle (contour->cx, contour->cy, contour->radius, scale);
+      hidgl_fill_circle (tesselator_gc, contour->cx, contour->cy, contour->radius, scale);
       return;
     }
   }
@@ -609,13 +630,12 @@ do_hole (const BoxType *b, void *cl)
   return 1;
 }
 
-static GLint stencil_bits;
-static int dirty_bits = 0;
-static int assigned_bits = 0;
-
 static void
-fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
+fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+  hidgl_priv *priv = hidgl->priv;
   int vertex_count = 0;
   PLINE *contour;
   struct do_hole_info info;
@@ -624,7 +644,7 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
   info.scale = scale;
   global_scale = scale;
 
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
+  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
   if (!stencil_bit)
     {
       printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
@@ -632,13 +652,14 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
     }
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
   /* Walk the polygon structure, counting vertices */
   /* This gives an upper bound on the amount of storage required */
   for (contour = pa->contours; contour != NULL; contour = contour->next)
     vertex_count = MAX (vertex_count, contour->Count);
 
+  tesselator_gc = gc;
   info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
   info.tobj = gluNewTess ();
   gluTessCallback(info.tobj, GLU_TESS_BEGIN,   (_GLUfuncptr)myBegin);
@@ -659,7 +680,7 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
   /* Drawing operations now set our reference bit in the stencil buffer */
 
   r_search (pa->contour_tree, clip_box, NULL, do_hole, &info);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
   glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
 
@@ -667,7 +688,7 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
                                                 /* If the stencil test has passed, we know that bit is 0, so we're */
                                                 /* effectively just setting it to 1. */
 
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);  /* Pass stencil test if all assigned bits clear, */
+  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
                                                 /* reference is all assigned bits so we set */
                                                 /* any bits permitted by the stencil writemask */
 
@@ -676,136 +697,216 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, double scale)
   /* Draw the polygon outer */
   tesselate_contour (info.tobj, pa->contours, info.vertices, scale);
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
   /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+  hidgl_return_stencil_bit (hidgl, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer write-mask etc.. */
 
   gluDeleteTess (info.tobj);
+  tesselator_gc = NULL;
   myFreeCombined ();
   free (info.vertices);
 }
 
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box, double scale)
 {
   if (poly->Clipped == NULL)
     return;
 
-  fill_polyarea (poly->Clipped, clip_box, scale);
+  fill_polyarea (gc, poly->Clipped, clip_box, scale);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (pa, clip_box, scale);
+        fill_polyarea (gc, pa, clip_box, scale);
     }
 }
 
 void
-hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2)
+hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_ensure_triangle_space (gc, 2);
+  hidgl_add_triangle (gc, x1, y1, x1, y2, x2, y2);
+  hidgl_add_triangle (gc, x2, y1, x2, y2, x1, y1);
 }
 
 void
 hidgl_init (void)
 {
-  glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
+  static bool called = false;
+
+  if (called == true)
+    {
+      fprintf (stderr, "ERROR: hidgl_init() called multiple times\n");
+      return;
+    }
+
+  /* Any one-time (hopefully!) hidgl setup goes in here */
+
+  called = true;
+}
+
+hidgl_instance *
+hidgl_new_instance (void)
+{
+  hidgl_instance *hidgl;
+  hidgl_priv *priv;
+
+  hidgl = calloc (1, sizeof (hidgl_instance));
+  priv = calloc (1, sizeof (hidgl_priv));
+  hidgl->priv = priv;
+
+#if 0
+  glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
 
-  if (stencil_bits == 0)
+  if (priv->stencil_bits == 0)
     {
       printf ("No stencil bits available.\n"
               "Cannot mask polygon holes or subcomposite layers\n");
       /* TODO: Flag this to the HID so it can revert to the dicer? */
     }
-  else if (stencil_bits == 1)
+  else if (priv->stencil_bits == 1)
     {
       printf ("Only one stencil bitplane avilable\n"
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+
+  hidgl_reset_stencil_usage (hidgl);
+#endif
+  hidgl_init_triangle_array (hidgl);
+
+  return hidgl;
 }
 
 void
-hidgl_start_render (void)
+hidgl_free_instance (hidgl_instance *hidgl)
 {
-  hidgl_init ();
-  hidgl_init_triangle_array (&buffer);
+  free (hidgl->priv);
+  free (hidgl);
 }
 
 void
-hidgl_finish_render (void)
+hidgl_init_gc (hidgl_instance *hidgl, hidGC gc)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->hidgl = hidgl;
+  hidgl_gc->depth = 0.0;
+}
+
+void
+hidgl_finish_gc (hidGC gc)
+{
+}
+
+void
+hidgl_start_render (hidgl_instance *hidgl)
+{
+  hidgl_priv *priv = hidgl->priv;
+
+//  hidgl_init ();
+  glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
+
+  if (priv->stencil_bits == 0)
+    {
+      printf ("No stencil bits available.\n"
+              "Cannot mask polygon holes or subcomposite layers\n");
+      /* TODO: Flag this to the HID so it can revert to the dicer? */
+    }
+  else if (priv->stencil_bits == 1)
+    {
+      printf ("Only one stencil bitplane avilable\n"
+              "Cannot use stencil buffer to sub-composite layers.\n");
+      /* Do we need to disable that somewhere? */
+    }
+
+  hidgl_reset_stencil_usage (hidgl);
+  hidgl_init_triangle_array (hidgl);
+}
+
+void
+hidgl_finish_render (hidgl_instance *hidgl)
 {
 }
 
 int
-hidgl_stencil_bits (void)
+hidgl_stencil_bits (hidgl_instance *hidgl)
 {
-  return stencil_bits;
+  hidgl_priv *priv = hidgl->priv;
+
+  return priv->stencil_bits;
 }
 
 static void
-hidgl_clean_unassigned_stencil (void)
+hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
 {
+  hidgl_priv *priv = hidgl->priv;
+
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
-  glStencilMask (~assigned_bits);
+  glStencilMask (~priv->assigned_bits);
   glClearStencil (0);
   glClear (GL_STENCIL_BUFFER_BIT);
   glPopAttrib ();
 }
 
 int
-hidgl_assign_clear_stencil_bit (void)
+hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
 {
-  int stencil_bitmask = (1 << stencil_bits) - 1;
+  hidgl_priv *priv = hidgl->priv;
+
+  int stencil_bitmask = (1 << priv->stencil_bits) - 1;
   int test;
   int first_dirty = 0;
 
-  if (assigned_bits == stencil_bitmask)
+  if (priv->assigned_bits == stencil_bitmask)
     {
       printf ("No more stencil bits available, total of %i already assigned\n",
-              stencil_bits);
+              priv->stencil_bits);
       return 0;
     }
 
   /* Look for a bitplane we don't have to clear */
   for (test = 1; test & stencil_bitmask; test <<= 1)
     {
-      if (!(test & dirty_bits))
+      if (!(test & priv->dirty_bits))
         {
-          assigned_bits |= test;
-          dirty_bits |= test;
+          priv->assigned_bits |= test;
+          priv->dirty_bits    |= test;
           return test;
         }
-      else if (!first_dirty && !(test & assigned_bits))
+      else if (!first_dirty && !(test & priv->assigned_bits))
         {
           first_dirty = test;
         }
     }
 
   /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
-  hidgl_clean_unassigned_stencil ();
-  assigned_bits |= first_dirty;
-  dirty_bits = assigned_bits;
+  hidgl_clean_unassigned_stencil (hidgl);
+  priv->assigned_bits |= first_dirty;
+  priv->dirty_bits = priv->assigned_bits;
 
   return first_dirty;
 }
 
 void
-hidgl_return_stencil_bit (int bit)
+hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit)
 {
-  assigned_bits &= ~bit;
+  hidgl_priv *priv = hidgl->priv;
+
+  priv->assigned_bits &= ~bit;
 }
 
 void
-hidgl_reset_stencil_usage (void)
+hidgl_reset_stencil_usage (hidgl_instance *hidgl)
 {
-  assigned_bits = 0;
-  dirty_bits = 0;
+  hidgl_priv *priv = hidgl->priv;
+
+  priv->assigned_bits = 0;
+  priv->dirty_bits = 0;
 }
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 8d2c78c..4b80714 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,6 +23,7 @@
 #ifndef PCB_HID_COMMON_HIDGL_H
 #define PCB_HID_COMMON_HIDGL_H
 
+/* NB: triangle_buffer is a private type, only defined here to enable inlining of geometry creation */
 #define TRIANGLE_ARRAY_SIZE 5461
 typedef struct {
   GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
@@ -30,57 +31,93 @@ typedef struct {
   unsigned int coord_comp_count;
 } triangle_buffer;
 
-extern triangle_buffer buffer;
-extern float global_depth;
+/* NB: hidgl_priv is a private type, only defined here to enable inlining of geometry creation */
+typedef struct {
+  /* Triangle management */
+  triangle_buffer buffer;
+
+  /* Stencil management */
+  GLint stencil_bits;
+  int dirty_bits;
+  int assigned_bits;
+
+} hidgl_priv;
+
+/* NB: hidgl_instance is a public type, intended to be used as an opaque pointer */
+typedef struct {
+  hidgl_priv *priv;
+
+} hidgl_instance;
+
+/* NB: hidglGC is a semi-private type, only defined here to enable inlining of geometry creation, and for derived GUIs to extend */
+typedef struct hidgl_gc_struct {
+  struct hid_gc_struct gc; /* Parent */
+
+  hidgl_instance *hidgl;
+
+  float depth;
+
+} *hidglGC;
+
+void hidgl_flush_triangles (hidgl_instance *hidgl);
+void hidgl_ensure_triangle_space (hidGC gc, int count);
 
-void hidgl_flush_triangles (triangle_buffer *buffer);
-void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
 static inline void
-hidgl_add_triangle_3D (triangle_buffer *buffer,
+hidgl_add_triangle_3D (hidGC gc,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
-  buffer->triangle_count++;
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+  hidgl_priv *priv = hidgl->priv;
+
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x1;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y1;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z1;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x2;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y2;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z2;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x3;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y3;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z3;
+  priv->buffer.triangle_count++;
 }
 
 static inline void
-hidgl_add_triangle (triangle_buffer *buffer,
+hidgl_add_triangle (hidGC gc,
                     GLfloat x1, GLfloat y1,
                     GLfloat x2, GLfloat y2,
                     GLfloat x3, GLfloat y3)
 {
-  hidgl_add_triangle_3D (buffer, x1, y1, global_depth,
-                                 x2, y2, global_depth,
-                                 x3, y3, global_depth);
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_add_triangle_3D (gc, x1, y1, hidgl_gc->depth,
+                             x2, y2, hidgl_gc->depth,
+                             x3, y3, hidgl_gc->depth);
 }
 
-void hidgl_draw_grid (BoxType *drawn_area);
-void hidgl_set_depth (float depth);
-void hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
-void hidgl_draw_arc (Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
-void hidgl_draw_rect (Coord x1, Coord y1, Coord x2, Coord y2);
-void hidgl_fill_circle (Coord vx, Coord vy, Coord vr, double scale);
-void hidgl_fill_polygon (int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
-void hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2);
+void hidgl_draw_grid (hidGC gc, BoxType *drawn_area);
+void hidgl_set_depth (hidGC gc, float depth);
+void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
+void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
+void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
+void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr, double scale);
+void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
-void hidgl_start_render (void);
-void hidgl_finish_render (void);
-int hidgl_stencil_bits (void);
-int hidgl_assign_clear_stencil_bit (void);
-void hidgl_return_stencil_bit (int bit);
-void hidgl_reset_stencil_usage (void);
+hidgl_instance *hidgl_new_instance (void);
+void hidgl_free_instance (hidgl_instance *hidgl);
+void hidgl_init_gc (hidgl_instance *hidgl, hidGC gc);
+void hidgl_finish_gc (hidGC gc);
+void hidgl_start_render (hidgl_instance *hidgl);
+void hidgl_finish_render (hidgl_instance *hidgl);
+int hidgl_stencil_bits (hidgl_instance *hidgl);
+int hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl);
+void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
+void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
 
 #endif /* PCB_HID_COMMON_HIDGL_H  */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 4690dd5..c7197d4 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -72,11 +72,13 @@ typedef struct render_priv {
   Coord lead_user_y;
 
   hidGC crosshair_gc;
+  hidgl_instance *hidgl;
+
 } render_priv;
 
 typedef struct gtk_gc_struct
 {
-  struct hid_gc_struct hid_gc; /* Parent */
+  struct hidgl_gc_struct hidgl_gc; /* Parent */
 
   const char *colorname;
   double alpha_mult;
@@ -84,23 +86,23 @@ typedef struct gtk_gc_struct
   gint cap, join;
 } *gtkGC;
 
-static void draw_lead_user (render_priv *priv);
+static void draw_lead_user (hidGC gc, render_priv *priv);
 static void ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
 
 
 static void
-start_subcomposite (void)
+start_subcomposite (hidgl_instance *hidgl)
 {
   render_priv *priv = gport->render_priv;
   int stencil_bit;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
   glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
 
-  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);       /* Get a new (clean) bitplane to stencil with */
   glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
   glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
 
@@ -108,14 +110,14 @@ start_subcomposite (void)
 }
 
 static void
-end_subcomposite (void)
+end_subcomposite (hidgl_instance *hidgl)
 {
   render_priv *priv = gport->render_priv;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (hidgl, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
 
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
@@ -129,7 +131,9 @@ int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
+  hidgl_instance *hidgl = priv->hidgl;
   int idx = group;
+
   if (idx >= 0 && idx < max_group)
     {
       int n = PCB->LayerGroups.Number[group];
@@ -143,8 +147,8 @@ ghid_set_layer (const char *name, int group, int empty)
       idx = PCB->LayerGroups.Entries[group][idx];
   }
 
-  end_subcomposite ();
-  start_subcomposite ();
+  end_subcomposite (hidgl);
+  start_subcomposite (hidgl);
 
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
@@ -181,26 +185,33 @@ ghid_set_layer (const char *name, int group, int empty)
 }
 
 static void
-ghid_end_layer (void)
+ghid_end_layer ()
 {
-  end_subcomposite ();
+  render_priv *priv = gport->render_priv;
+  hidgl_instance *hidgl = priv->hidgl;
+
+  end_subcomposite (hidgl);
 }
 
 void
 ghid_destroy_gc (hidGC gc)
 {
+  hidgl_finish_gc (gc);
   g_free (gc);
 }
 
 hidGC
 ghid_make_gc (void)
 {
+  render_priv *priv = gport->render_priv;
   hidGC gc = (hidGC) g_new0 (struct gtk_gc_struct, 1);
   gtkGC gtk_gc = (gtkGC)gc;
 
   gc->hid = &ghid_hid;
   gc->hid_draw = &ghid_graphics;
 
+  hidgl_init_gc (priv->hidgl, gc);
+
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
 
@@ -208,7 +219,7 @@ ghid_make_gc (void)
 }
 
 static void
-ghid_draw_grid (BoxType *drawn_area)
+ghid_draw_grid (hidGC gc, BoxType *drawn_area)
 {
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
@@ -227,7 +238,7 @@ ghid_draw_grid (BoxType *drawn_area)
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  hidgl_draw_grid (drawn_area);
+  hidgl_draw_grid (gc, drawn_area);
 
   glDisable (GL_COLOR_LOGIC_OP);
 }
@@ -292,13 +303,15 @@ ghid_draw_bg_image (void)
 void
 ghid_use_mask (enum mask_mode mode)
 {
+  render_priv *priv = gport->render_priv;
+  hidgl_instance *hidgl = priv->hidgl;
   static int stencil_bit = 0;
 
   if (mode == cur_mask)
     return;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (hidgl);
 
   switch (mode)
     {
@@ -310,7 +323,7 @@ ghid_use_mask (enum mask_mode mode)
       /* Write '1' to the stencil buffer where the solder-mask should not be drawn. */
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
-      stencil_bit = hidgl_assign_clear_stencil_bit();       /* Get a new (clean) bitplane to stencil with */
+      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
       glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value (with 1) */
@@ -318,15 +331,15 @@ ghid_use_mask (enum mask_mode mode)
 
     case HID_MASK_AFTER:
       /* Drawing operations as masked to areas where the stencil buffer is '0' */
-      glColorMask (1, 1, 1, 1);                   /* Enable drawing of r, g, b & a */
-      glStencilFunc (GL_GEQUAL, 0, stencil_bit);  /* Draw only where our bit of the stencil buffer is clear */
-      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    /* Stencil buffer read only */
+      glColorMask (1, 1, 1, 1);                             /* Enable drawing of r, g, b & a */
+      glStencilFunc (GL_GEQUAL, 0, stencil_bit);            /* Draw only where our bit of the stencil buffer is clear */
+      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);              /* Stencil buffer read only */
       break;
 
     case HID_MASK_OFF:
       /* Disable stenciling */
-      hidgl_return_stencil_bit (stencil_bit);     /* Relinquish any bitplane we previously used */
-      glDisable (GL_STENCIL_TEST);                /* Disable Stencil test */
+      hidgl_return_stencil_bit (hidgl, stencil_bit);        /* Relinquish any bitplane we previously used */
+      glDisable (GL_STENCIL_TEST);                          /* Disable Stencil test */
       break;
     }
   cur_mask = mode;
@@ -458,7 +471,7 @@ set_gl_color_for_gc (hidGC gc)
   if(!priv->in_context)
     return;
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
   glColor4d (r, g, b, a);
 }
 
@@ -548,7 +561,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_line (gtk_gc->cap, gtk_gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc, gtk_gc->cap, gtk_gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
 }
 
 void
@@ -558,7 +571,7 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
   gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_arc (gtk_gc->width, cx, cy, xradius, yradius,
+  hidgl_draw_arc (gc, gtk_gc->width, cx, cy, xradius, yradius,
                   start_angle, delta_angle, gport->view.coord_per_px);
 }
 
@@ -567,7 +580,7 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   USE_GC (gc);
 
-  hidgl_draw_rect (x1, y1, x2, y2);
+  hidgl_draw_rect (gc, x1, y1, x2, y2);
 }
 
 
@@ -576,7 +589,7 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (gc, cx, cy, radius, gport->view.coord_per_px);
 }
 
 
@@ -585,7 +598,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
   USE_GC (gc);
 
-  hidgl_fill_polygon (n_coords, x, y);
+  hidgl_fill_polygon (gc, n_coords, x, y);
 }
 
 void
@@ -593,7 +606,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
+  hidgl_fill_pcb_polygon (gc, poly, clip_box, gport->view.coord_per_px);
 }
 
 void
@@ -610,7 +623,7 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   USE_GC (gc);
 
-  hidgl_fill_rect (x1, y1, x2, y2);
+  hidgl_fill_rect (gc, x1, y1, x2, y2);
 }
 
 void
@@ -786,7 +799,6 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   render_priv *priv;
 
   port->render_priv = priv = g_new0 (render_priv, 1);
-  port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
 
   priv->time_since_expose = g_timer_new ();
 
@@ -802,6 +814,10 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
       return; /* Should we abort? */
     }
 
+  hidgl_init ();
+  priv->hidgl = hidgl_new_instance ();
+  port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
+
   /* Setup HID function pointers specific to the GL renderer*/
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
@@ -814,6 +830,8 @@ ghid_shutdown_renderer (GHidPort *port)
   render_priv *priv = port->render_priv;
 
   hid_draw_destroy_gc (priv->crosshair_gc);
+  hidgl_free_instance (priv->hidgl);
+
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
   port->render_priv = NULL;
@@ -848,6 +866,8 @@ ghid_start_drawing (GHidPort *port, GtkWidget *widget)
 
   port->render_priv->in_context = true;
 
+  hidgl_start_render (port->render_priv->hidgl);
+
   return TRUE;
 }
 
@@ -856,6 +876,8 @@ ghid_end_drawing (GHidPort *port, GtkWidget *widget)
 {
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
+  hidgl_finish_render (port->render_priv->hidgl);
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
@@ -890,12 +912,11 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port, widget);
-  hidgl_start_render ();
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits() == 0)
+  if (hidgl_stencil_bits (priv->hidgl) == 0)
     ghid_graphics_class.fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
@@ -933,7 +954,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (priv->hidgl);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -1019,22 +1040,21 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_invalidate_current_gc ();
   hid_expose_callback (&ghid_hid, &region, 0);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
 
-  ghid_draw_grid (&region);
+  ghid_draw_grid (priv->crosshair_gc, &region);
 
   ghid_invalidate_current_gc ();
 
   DrawAttached (priv->crosshair_gc);
   DrawMark (priv->crosshair_gc);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
 
   draw_crosshair (priv);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
 
-  draw_lead_user (priv);
+  draw_lead_user (priv->crosshair_gc, priv);
 
-  hidgl_finish_render ();
   ghid_end_drawing (port, widget);
 
   g_timer_start (priv->time_since_expose);
@@ -1065,6 +1085,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
+  render_priv *priv = gport->render_priv;
   GtkAllocation allocation;
   view_data save_view;
   int save_width, save_height;
@@ -1098,7 +1119,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   PCB->MaxHeight = pinout->y_max;
 
   ghid_start_drawing (gport, widget);
-  hidgl_start_render ();
 
 #if 0  /* We disable alpha blending here, as hid_expose_callback() does not
         * call set_layer() as appropriate for us to sub-composite rendering
@@ -1155,7 +1175,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (priv->hidgl);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -1174,10 +1194,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                                     -gport->view.y0, 0);
 
   hid_expose_callback (&ghid_hid, NULL, pinout->element);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
-  hidgl_finish_render ();
   ghid_end_drawing (gport, widget);
 
   gport->view = save_view;
@@ -1193,6 +1212,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
@@ -1234,7 +1254,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
-  hidgl_start_render ();
+  hidgl_start_render (priv->hidgl);
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -1259,7 +1279,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (priv->hidgl);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -1288,12 +1308,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
   hid_expose_callback (&ghid_hid, &region, NULL);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
   glFlush ();
 
-  hidgl_finish_render ();
+  hidgl_finish_render (priv->hidgl);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -1321,7 +1341,6 @@ ghid_request_debug_draw (void)
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port, widget);
-  hidgl_start_render ();
 
   glViewport (0, 0, allocation.width, allocation.height);
 
@@ -1352,10 +1371,11 @@ ghid_request_debug_draw (void)
 void
 ghid_flush_debug_draw (void)
 {
+  render_priv *priv = gport->render_priv;
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (priv->hidgl);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -1366,10 +1386,11 @@ ghid_flush_debug_draw (void)
 void
 ghid_finish_debug_draw (void)
 {
-  hidgl_flush_triangles (&buffer);
+  render_priv *priv = gport->render_priv;
+
+  hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
-  hidgl_finish_render ();
   ghid_end_drawing (gport, gport->drawing_area);
 }
 
@@ -1607,8 +1628,9 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
 #define LEAD_USER_COLOR_B         0.
 
 static void
-draw_lead_user (render_priv *priv)
+draw_lead_user (hidGC gc, render_priv *priv)
 {
+  gtkGC gtk_gc = (gtkGC)gc;
   int i;
   double radius = priv->lead_user_radius;
   double width = MM_TO_COORD (LEAD_USER_WIDTH);
@@ -1631,11 +1653,11 @@ draw_lead_user (render_priv *priv)
         radius += MM_TO_COORD (LEAD_USER_INITIAL_RADIUS);
 
       /* Draw an arc at radius */
-      hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
+      hidgl_draw_arc (gc, width, priv->lead_user_x, priv->lead_user_y,
                       radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
   glPopAttrib ();
 }
