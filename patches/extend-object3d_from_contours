Bottom: 3f1ea28edad4e91d1d0f6c98e9a729644929d0dd
Top:    8ff6082bc01b8db1d074b3236d946000c61570fd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:31:27 +0000

Extend object3d_from_contours() to have an option to produce an inverted shell contour

This will be useful when extruding voids within objects during 3D export.


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 21427f7..e47aa05 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -327,7 +327,8 @@ object3d_from_contours (const POLYAREA *contours,
                         double zbot,
                         double ztop,
                         const appearance *master_object_appearance,
-                        const appearance *master_top_bot_appearance)
+                        const appearance *master_top_bot_appearance,
+                        bool extrude_inverted)
 {
   GList *objects = NULL;
   object3d *object;
@@ -350,9 +351,9 @@ object3d_from_contours (const POLYAREA *contours,
   double nx, ny;
 
 #ifdef REVERSED_PCB_CONTOURS
-  invert_face_normals = true;
+  invert_face_normals = extrude_inverted ? false : true;
 #else
-  invert_face_normals = false;
+  invert_face_normals = extrude_inverted ? true : false;
 #endif
 
   if (contours == NULL)
@@ -395,6 +396,7 @@ object3d_from_contours (const POLYAREA *contours,
       edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
       faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
 
+<<<<<<< current
       /* Define the vertices */
       ct = contour;
       offset_in_ct = 0;
@@ -410,7 +412,75 @@ object3d_from_contours (const POLYAREA *contours,
               offset_in_ct = 0;
               ct = ct->next;
               ct_npoints = get_contour_npoints (ct);
+
             }
+      object3d_add_face (object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+      if (!extrude_inverted)
+        face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+      else
+        face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+    }
+
+    faces[npoints    ] = make_face3d (); /* bottom_face */
+    faces[npoints + 1] = make_face3d (); /* top_face */
+    if (invert_face_normals)
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0., -1.); /* bottom_face */
+        face3d_set_normal (faces[npoints + 1], 0., 0.,  1.); /* top_face */
+      }
+    else
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0.,  1.); /* bottom_face */ /* PCB bottom is at positive Z in this scheme */
+        face3d_set_normal (faces[npoints + 1], 0., 0., -1.); /* top_face */    /* PCB top is at negative Z in this scheme */
+      }
+    face3d_set_appearance (faces[npoints    ], top_bot_appearance);
+    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints    ]);
+    object3d_add_face (object, faces[npoints + 1]);
+
+    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+    if (!extrude_inverted)
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+      }
+    else
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[0])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+      }
+
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+        /* XXX: Haven't properly thought through how (if) inverting works with multiple contours */
+      if (!extrude_inverted)
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+        }
+      else
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        }
+      }
+>>>>>>> patched
 
           get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
 
@@ -434,6 +504,7 @@ object3d_from_contours (const POLYAREA *contours,
         {
           faces[i] = make_face3d ();
 
+<<<<<<< current
           object3d_add_face (object, faces[i]);
           /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
           face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
@@ -464,6 +535,20 @@ object3d_from_contours (const POLYAREA *contours,
         start_of_ct = 0;
         offset_in_ct = 0;
         ct_npoints = get_contour_npoints (ct);
+=======
+          /* NOTE: Axis directon not depend on whether we invert the top/bot contour.. the edge loop is appropriate already */
+          face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
+                                            radius);
+
+          /* NOTE: Surface orientation is only fixed up during emission if we flag the need here..
+           *       cylindrical surface orientation is always pointing outward from its axis, so
+           *       orientation reversed is used for holes
+           */
+          /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! - THIS IS NOT EXACTLY CORRECT!.. NEEDS TO TAKE ACOUNT FOR cw / ccw WHEN DEALING WITH ARC CONTOUR SEGMENTS */
+          if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
+            face3d_set_surface_orientation_reversed (faces[i]);
+>>>>>>> patched
 
         for (i = 0; i < npoints; i++, offset_in_ct++)
           {
@@ -522,145 +607,174 @@ object3d_from_contours (const POLYAREA *contours,
 
                 get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
 
+                /* NOTE: Axis directon not depend on whether we invert the top/bot contour.. the edge loop is appropriate already */
                 face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
                                                   0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
                                                   radius);
 
-                /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
-                if (ct->Flags.orient == PLF_INV)
+               /* NOTE: Surface orientation is only fixed up during emission if we flag the need here..
+                *       cylindrical surface orientation is always pointing outward from its axis, so
+                *       orientation reversed is used for holes
+                */
+               /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! - THIS IS NOT EXACTLY CORRECT!.. NEEDS TO TAKE ACOUNT FOR cw / ccw WHEN DEALING WITH ARC CONTOUR SEGMENTS */
+               if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
                   face3d_set_surface_orientation_reversed (faces[i]);
 
                 face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                           /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
+        /* DOES NOT DEPEND ON WHETHER WE INVERT THE CONTOUR.. THE EDGE TRAVERSAL IS REVERSED DURING EMISSION.
+         * Only depends on the coordinate system transform, and what Z values it requires to create a
+         * clockwise / counterclockwise circular edge consistent with the the polygon data.
+         */
 #ifdef REVERSED_PCB_CONTOURS
                 normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
                 normal_z = cw ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #endif
 
-                edge_info_set_round (UNDIR_DATA (edges[i]),
-                                     cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
-                                     0., 0., normal_z, /* Normal */ radius);
-                edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                                     cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
-                                     0., 0., normal_z, /* Normal */ radius);
-                if (ct->is_round)
-                  edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-              }
+              edge_info_set_round (UNDIR_DATA (edges[i]),
+                                   cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                                   0., 0., normal_z, /* Normal */ radius);
+              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                   cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                                   0., 0., normal_z, /* Normal */ radius);
+              if (ct->is_round)
+                edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+            }
 
-            /* NB: Contours are counter clockwise in XY plane.
-             *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-             *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-             *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-             */
-
-            RDATA (edges[              i]) = faces[i];
-            LDATA (edges[              i]) = faces[npoints];
-            RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-            LDATA (edges[1 * npoints + i]) = faces[i];
-            RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-            LDATA (edges[2 * npoints + i]) = faces[i];
-
-            /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-            splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-            splice (edges[2 * npoints + i], edges[i]);
-            /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-            splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-            splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
-          }
+          /* NB: Contours are counter clockwise in XY plane.
+           *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+           *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+           *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+           */
 
-        if (0)
-          {
-            /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+          if (extrude_inverted)
+            {
+              LDATA (edges[              i]) = faces[i];
+              RDATA (edges[              i]) = faces[npoints];
+              LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+              RDATA (edges[1 * npoints + i]) = faces[i];
+              LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+              RDATA (edges[2 * npoints + i]) = faces[i];
+
+              /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+              splice (SYM(edges[prev_i_around_ct]), edges[i]);
+              splice (edges[i], edges[2 * npoints + i]);
+              /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+              splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+              splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+            }
+          else
+            {
+              RDATA (edges[              i]) = faces[i];
+              LDATA (edges[              i]) = faces[npoints];
+              RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+              LDATA (edges[1 * npoints + i]) = faces[i];
+              RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+              LDATA (edges[2 * npoints + i]) = faces[i];
+
+              /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+              splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+              splice (edges[2 * npoints + i], edges[i]);
+              /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+              splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+              splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+            }
+        }
+
+      if (0)
+        {
+          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
-            edge_ref cylinder_edges[3];
-            vertex3d *cylinder_vertices[2];
-            face3d *cylinder_faces[2];
+          edge_ref cylinder_edges[3];
+          vertex3d *cylinder_vertices[2];
+          face3d *cylinder_faces[2];
 
-            /* Edge on top of board */
-            cylinder_edges[0] = make_edge ();
-            UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+          /* Edge on top of board */
+          cylinder_edges[0] = make_edge ();
+          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 #ifdef REVERSED_PCB_CONTOURS
-            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                  0.,   0., 1., /* Normal */
-                                  5.);          /* Radius */
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);          /* Radius */
 #else
-            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                  0.,   0., 1., /* Normal */
-                                  5.);         /* Radius */
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);         /* Radius */
 #endif
-        object3d_add_edge (object, cylinder_edges[0]);
-
-        /* Edge on top of cylinder */
-        cylinder_edges[1] = make_edge ();
-        UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-        edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
-                              0.,   0., 1.,  /* Normal */
-                              5.);          /* Radius */
-        object3d_add_edge (object, cylinder_edges[1]);
-
-        /* Edge stitching cylinder */
-        cylinder_edges[2] = make_edge ();
-        UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-        edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-        object3d_add_edge (object, cylinder_edges[2]);
-
-        /* Vertex on board top surface */
-        cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-        object3d_add_vertex (object, cylinder_vertices[0]);
-
-        /* Vertex on cylinder top surface */
-        cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-        object3d_add_vertex (object, cylinder_vertices[1]);
-
-        /* Cylindrical face */
-        cylinder_faces[0] = make_face3d ();
-        face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,             /* Direction of the cylindrical axis */
-                                          5.);                   /* Radius of cylinder */
-        face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                     /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-        object3d_add_face (object, cylinder_faces[0]);
-        face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-        /* Top face of cylinder */
-        cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-        face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-        face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-        object3d_add_face (object, cylinder_faces[1]);
-        face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-        /* Splice onto board */
-        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-        /* Assign the appropriate vertex geometric data to each edge end */
-        ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-        DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-        ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-        DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-        ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-        DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-        LDATA (cylinder_edges[0]) = cylinder_faces[0];
-        RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-        LDATA (cylinder_edges[1]) = cylinder_faces[1];
-        RDATA (cylinder_edges[1]) = cylinder_faces[0];
-        LDATA (cylinder_edges[2]) = cylinder_faces[0];
-        RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-        /* Splice things together.... */
-
-        /* Link edges orbiting the cylinder bottom vertex */
-        splice (cylinder_edges[0], cylinder_edges[2]);
-        splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-        /* Link edges orbiting the cylinder top vertex */
-        splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-        splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-      }
+          object3d_add_edge (object, cylinder_edges[0]);
+
+          /* Edge on top of cylinder */
+          cylinder_edges[1] = make_edge ();
+          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                                0.,   0., 1.,  /* Normal */
+                                5.);          /* Radius */
+          object3d_add_edge (object, cylinder_edges[1]);
+
+          /* Edge stitching cylinder */
+          cylinder_edges[2] = make_edge ();
+          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+          object3d_add_edge (object, cylinder_edges[2]);
+
+          /* Vertex on board top surface */
+          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+          object3d_add_vertex (object, cylinder_vertices[0]);
+
+          /* Vertex on cylinder top surface */
+          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+          object3d_add_vertex (object, cylinder_vertices[1]);
+
+          /* Cylindrical face */
+          cylinder_faces[0] = make_face3d ();
+          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,             /* Direction of the cylindrical axis */
+                                            5.);                   /* Radius of cylinder */
+          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+          object3d_add_face (object, cylinder_faces[0]);
+          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+          /* Top face of cylinder */
+          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+          object3d_add_face (object, cylinder_faces[1]);
+          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+          /* Splice onto board */
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+          /* Assign the appropriate vertex geometric data to each edge end */
+          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+          LDATA (cylinder_edges[0]) = cylinder_faces[0];
+          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+          LDATA (cylinder_edges[1]) = cylinder_faces[1];
+          RDATA (cylinder_edges[1]) = cylinder_faces[0];
+          LDATA (cylinder_edges[2]) = cylinder_faces[0];
+          RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+          /* Splice things together.... */
+
+          /* Link edges orbiting the cylinder bottom vertex */
+          splice (cylinder_edges[0], cylinder_edges[2]);
+          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+          /* Link edges orbiting the cylinder top vertex */
+          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+        }
+
 #ifndef NDEBUG
       ct = contour;
       start_of_ct = 0;
@@ -684,23 +798,33 @@ object3d_from_contours (const POLYAREA *contours,
           next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
           prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-          g_assert (RDATA (edges[              i]) == faces[i]);
-          g_assert (LDATA (edges[              i]) == faces[npoints]);
-          g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
-          g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
-          g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
-          g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
-
-          g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
-          g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
-          g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
-          g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
-          g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
-          g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
-
-          g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
-          g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
-          g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+          if (!extrude_inverted)
+            {
+              g_assert (RDATA (edges[              i]) == faces[i]);
+              g_assert (LDATA (edges[              i]) == faces[npoints]);
+              g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+              g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+              g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+              g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+              g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+              g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+              g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+              g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+              g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+              g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+              g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+              g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+              g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+            }
+          else
+            {
+              /* XXX: No debug checks for this yet. LDATA and RDATA should be swapped from the
+               *      above case, and ONEXT order should be reversed. It works, so have not
+               *      written in the debug checks.
+               */
+            }
         }
 #endif
 
@@ -740,7 +864,8 @@ object3d_from_board_outline (void)
                                     -HACK_BOARD_THICKNESS / 2, /* Top */
 #endif
                                     board_appearance,
-                                    top_bot_appearance);
+                                    top_bot_appearance,
+                                    false); /* Don't invert */
 
   destroy_appearance (board_appearance);
   destroy_appearance (top_bot_appearance);
@@ -1004,7 +1129,8 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2 + HACK_COPPER_THICKNESS, /* Top */
 #endif
                                     mask_appearance,
-                                    NULL);
+                                    NULL,
+                                    false); /* Don't invert */
 
   destroy_appearance (mask_appearance);
 
@@ -1302,7 +1428,8 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
                               -depth - HACK_COPPER_THICKNESS, /* Top */
 #endif
                               copper_appearance,
-                              NULL));
+                              NULL,
+                              false)); /* Don't invert */
   }
 
 
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 0e679ab..13a42c9 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -15,7 +15,7 @@ void object3d_set_appearance (object3d *object, appearance *appear);
 void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
-GList *object3d_from_contours (const POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance);
+GList *object3d_from_contours (const POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance, bool extrude_inverted);
 GList *object3d_from_board_outline (void);
 GList *object3d_from_soldermask_within_area (POLYAREA *area, int side);
 GList *object3d_from_copper_layers_within_area (POLYAREA *area);
