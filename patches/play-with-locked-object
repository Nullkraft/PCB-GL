Bottom: 6085abc054df36284860fdacbb1ccbbf8dce2b2c
Top:    b14387610029fd5789650304209a94f5f904cb58
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 15:55:50 +0000

Play with locked object rendering

(HACK HACK HACK HACK HACK)

Did I mention this was a hacky pile of rubbish code.. the main point of
the exercise is to determine whether the usability is better or not.


---

diff --git a/src/action.c b/src/action.c
index cf34a76..7726be6 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1152,7 +1152,6 @@ NotifyMode (void)
 	    DrawElement (element);
 	    Draw ();
 	    SetChangedFlag (true);
-	    hid_actionl ("Report", "Object", NULL);
 	  }
 	else if (type != NO_TYPE)
 	  {
@@ -1167,7 +1166,6 @@ NotifyMode (void)
 		Draw ();
 	      }
 	    SetChangedFlag (true);
-	    hid_actionl ("Report", "Object", NULL);
 	  }
 	break;
       }
diff --git a/src/draw.c b/src/draw.c
index 73a83b0..2993fac 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -67,6 +67,7 @@
 #define	LARGE_TEXT_SIZE			3
 #define	N_TEXT_SIZES			4
 
+void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -160,6 +161,7 @@ draw_element_name (ElementType *element)
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
     hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
@@ -240,6 +242,7 @@ rat_callback (const BoxType * b, void *cl)
 static void
 draw_element_package (ElementType *element)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
     hid_draw_set_color (Output.fgGC, PCB->ElementColor);
@@ -474,6 +477,7 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
   hid_draw_set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
   hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
   hid_draw_set_line_width (Output.fgGC, 0);
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index bd3df87..5b13d95 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -7,6 +7,8 @@
 #include "draw.h"
 #include "hid_draw.h"
 
+void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
+
 static void
 _draw_pv (PinType *pv, bool draw_hole)
 {
@@ -166,6 +168,7 @@ line_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   LineType *line = (LineType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
   set_layer_object_color (layer, (AnyObjectType *) line);
   dapi->draw_line (line, NULL, NULL);
   return 1;
@@ -177,6 +180,7 @@ arc_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
   set_layer_object_color (layer, (AnyObjectType *) arc);
   dapi->draw_arc (arc, NULL, NULL);
   return 1;
@@ -193,6 +197,7 @@ poly_callback (const BoxType * b, void *cl)
   struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
   dapi->draw_poly (polygon, i->drawn_area, NULL);
   return 1;
@@ -205,6 +210,7 @@ text_callback (const BoxType * b, void *cl)
   TextType *text = (TextType *)b;
   int min_silk_line;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
     hid_draw_set_color (Output.fgGC, layer->SelectedColor);
   else
@@ -221,6 +227,7 @@ text_callback (const BoxType * b, void *cl)
 static void
 set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
   if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
                                                                                              : PCB->PinSelectedColor);
@@ -256,6 +263,7 @@ pad_inlayer_callback (const BoxType * b, void *cl)
 
   if (ON_SIDE (pad, side))
     {
+      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
       if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
       else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (Output.fgGC, PCB->PinSelectedColor);
       else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
@@ -276,6 +284,7 @@ pin_hole_callback (const BoxType * b, void *cl)
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
   set_object_color ((AnyObjectType *) pin, PCB->WarnColor,
                     PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
@@ -293,6 +302,7 @@ via_hole_callback (const BoxType * b, void *cl)
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
   set_object_color ((AnyObjectType *) via, PCB->WarnColor,
                     PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
@@ -303,6 +313,7 @@ via_hole_callback (const BoxType * b, void *cl)
 static int
 pin_callback (const BoxType * b, void *cl)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
   set_object_color ((AnyObjectType *)b,
                     PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
@@ -314,6 +325,7 @@ pin_callback (const BoxType * b, void *cl)
 static int
 via_callback (const BoxType * b, void *cl)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
   set_object_color ((AnyObjectType *)b,
                     PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
@@ -330,6 +342,7 @@ pad_callback (const BoxType * b, void *cl)
 
   if (ON_SIDE (pad, *side))
     {
+      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
       set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index 72c49e0..9d3adaf 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -384,3 +384,9 @@ hid_batch_init ()
   hid_register_hid (&batch_hid);
 #include "batch_lists.h"
 }
+
+/* XXX: DUMMY FUNCTION TO ENABLE BUILD */
+void
+ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
+{
+}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index b78331f..8335d17 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -1404,3 +1404,9 @@ ghid_cancel_lead_user (void)
   priv->lead_user_timer = NULL;
   priv->lead_user = false;
 }
+
+/* XXX: DUMMY FUNCTION TO ENABLE BUILD */
+void
+ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
+{
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5d2ca7a..1b90a04 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -80,6 +80,8 @@ typedef struct render_priv {
   int subcomposite_stencil_bit;
   char *current_colorname;
   double current_alpha_mult;
+  double current_brightness;
+  double current_saturation;
   GTimer *time_since_expose;
 
   /* Feature for leading the user to a particular location */
@@ -102,6 +104,8 @@ typedef struct gtk_gc_struct
 
   const char *colorname;
   double alpha_mult;
+  double brightness;
+  double saturation;
   Coord width;
   gint cap, join;
 } *gtkGC;
@@ -109,6 +113,8 @@ typedef struct gtk_gc_struct
 static void draw_lead_user (hidGC gc, render_priv *priv);
 static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
 
+void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
+
 
 #define BOARD_THICKNESS         MM_TO_COORD(1.60)
 #define MASK_COPPER_SPACING     MM_TO_COORD(0.05)
@@ -346,6 +352,8 @@ ghid_make_gc (void)
 
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
+  gtk_gc->brightness = 1.0;
+  gtk_gc->saturation = 1.0;
 
   priv->active_gc_list = g_list_prepend (priv->active_gc_list, gc);
 
@@ -587,10 +595,13 @@ set_gl_color_for_gc (hidGC gc)
   hidval cval;
   ColorCache *cc;
   double r, g, b, a;
+  double luminance;
 
   if (priv->current_colorname != NULL &&
       strcmp (priv->current_colorname, gtk_gc->colorname) == 0 &&
-      priv->current_alpha_mult == gtk_gc->alpha_mult)
+      priv->current_alpha_mult == gtk_gc->alpha_mult &&
+      priv->current_brightness == gtk_gc->brightness &&
+      priv->current_saturation == gtk_gc->saturation)
     return;
 
   free (priv->current_colorname);
@@ -605,6 +616,8 @@ set_gl_color_for_gc (hidGC gc)
 
   priv->current_colorname = strdup (gtk_gc->colorname);
   priv->current_alpha_mult = gtk_gc->alpha_mult;
+  priv->current_brightness = gtk_gc->brightness;
+  priv->current_saturation = gtk_gc->saturation;
 
   if (gport->colormap == NULL)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
@@ -666,6 +679,18 @@ set_gl_color_for_gc (hidGC gc)
 #endif
   }
 
+  r *= gtk_gc->brightness;
+  g *= gtk_gc->brightness;
+  b *= gtk_gc->brightness;
+
+  /* B/W Equivalent brightness */
+  luminance = (r + g + b) / 3.0;
+
+  /* Fade between B/W and colour */
+  r = r * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
+  g = g * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
+  b = b * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
+
   hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
   glColor4d (r, g, b, a);
 }
@@ -688,6 +713,24 @@ ghid_set_alpha_mult (hidGC gc, double alpha_mult)
   set_gl_color_for_gc (gc);
 }
 
+static void
+ghid_set_saturation (hidGC gc, double saturation)
+{
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->saturation = saturation;
+  set_gl_color_for_gc (gc);
+}
+
+static void
+ghid_set_brightness (hidGC gc, double brightness)
+{
+  gtkGC gtk_gc = (gtkGC)gc;
+
+  gtk_gc->brightness = brightness;
+  set_gl_color_for_gc (gc);
+}
+
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
@@ -1125,6 +1168,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
+  ghid_set_lock_effects (Output.fgGC, obj);
   hid_draw_set_color (Output.fgGC, color);
 }
 
@@ -1137,6 +1181,8 @@ set_layer_object_color (LayerType *layer, AnyObjectType *obj)
 static void
 set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+
   if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
                                                                                               : PCB->PinSelectedColor);
@@ -1181,6 +1227,7 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
   hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
@@ -1297,6 +1344,7 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
   hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
@@ -1325,6 +1373,7 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 static void
 draw_pad (PadType *pad)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
   set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
@@ -1375,6 +1424,7 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
+      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
       set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
@@ -1392,6 +1442,7 @@ line_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   LineType *line = (LineType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
   set_layer_object_color (layer, (AnyObjectType *) line);
   hid_draw_pcb_line (Output.fgGC, line);
   return 1;
@@ -1403,6 +1454,7 @@ arc_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
   set_layer_object_color (layer, (AnyObjectType *) arc);
   hid_draw_pcb_arc (Output.fgGC, arc);
   return 1;
@@ -1415,6 +1467,7 @@ text_callback (const BoxType * b, void *cl)
   TextType *text = (TextType *)b;
   int min_silk_line;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
     hid_draw_set_color (Output.fgGC, layer->SelectedColor);
   else
@@ -1454,6 +1507,7 @@ poly_callback_no_clear (const BoxType * b, void *cl)
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
   hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
   return 1;
@@ -1468,6 +1522,7 @@ poly_callback_clearing (const BoxType * b, void *cl)
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
   hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
   return 1;
@@ -1786,6 +1841,7 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
   hid_draw_set_color (Output.fgGC, color);
   DrawDrillChannel (Output.fgGC, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
@@ -3197,3 +3253,26 @@ ghid_cancel_lead_user (void)
   priv->lead_user_timer = NULL;
   priv->lead_user = false;
 }
+
+void
+ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
+{
+  // XXX: Workaround to crashing exporters
+  if (gc->hid != &ghid_hid)
+    return;
+
+  /* Only apply effects to locked objects when in "lock" mode */
+  if (Settings.Mode == LOCK_MODE &&
+      TEST_FLAG (LOCKFLAG, object))
+    {
+      ghid_set_alpha_mult (gc, 0.8);
+      ghid_set_saturation (gc, 0.3);
+      ghid_set_brightness (gc, 0.7);
+    }
+  else
+    {
+      ghid_set_alpha_mult (gc, 1.0);
+      ghid_set_saturation (gc, 1.0);
+      ghid_set_brightness (gc, 1.0);
+    }
+}
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index d7b5e34..c9eb567 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -4145,3 +4145,9 @@ hid_lesstif_init ()
   hid_register_hid (&lesstif_hid);
 #include "lesstif_lists.h"
 }
+
+/* XXX: DUMMY FUNCTION TO ENABLE BUILD */
+void
+ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
+{
+}
