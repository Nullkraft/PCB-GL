Bottom: a854ab5023694cd87d51f3652d0fa68a8cd56bff
Top:    6dfde8b638991c8b97d46afd74508a1442f597de
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 19:24:14 +0000

Attempt at re-writing drawing routines to pass state via hidGC

Note, this appears to break clearing out of pin and via holes at the moment
Note, 3D event projection and unprojection is broken
Note, autoroute.c debug drawing cleanup is probably broken (ordering)


---

diff --git a/src/draw.c b/src/draw.c
index fa9458b..c9fbe2b 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -76,18 +76,17 @@ static BoxType Block = {MAXINT, MAXINT, -MAXINT, -MAXINT};
 
 static int doing_pinout = 0;
 static bool doing_assy = false;
-static HID_DRAW *hid_draw = NULL;
 
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
+static void DrawEverything (hidGC gc);
 static void AddPart (void *);
-/* static */ void DrawEMark (ElementType *, Coord, Coord, bool);
-/* static */ void DrawRats (HID_DRAW *hid_draw);
+/* static */ void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+/* static */ void DrawRats (hidGC gc);
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -98,7 +97,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 /*---------------------------------------------------------------------------
@@ -138,39 +137,46 @@ Redraw (void)
   gui->invalidate_all ();
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_element_name (ElementType *element)
+draw_element_name (hidGC gc, ElementType *element)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  hid_draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
+  hid_draw_pcb_text (gc, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -178,42 +184,42 @@ name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  int *side = cl;
+  struct side_info *info = cl;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
     return 0;
 
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_name (info->gc, element);
   return 0;
 }
 
 static void
-draw_element_pins_and_pads (ElementType *element)
+draw_element_pins_and_pads (hidGC gc, ElementType *element)
 {
   PAD_LOOP (element);
   {
     if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
       {
-        set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+        set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                           PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                           FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-        dapi->draw_pad (pad, NULL, NULL);
+        dapi->draw_pad (gc, pad, NULL);
       }
   }
   END_LOOP;
   PIN_LOOP (element);
   {
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
                       PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-    dapi->draw_pin (pin, NULL, NULL);
+    dapi->draw_pin (gc, pin, NULL);
 
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor,
                       PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-    dapi->draw_pin_hole (pin, NULL, NULL);
+    dapi->draw_pin_hole (gc, pin, NULL);
   }
   END_LOOP;
 }
@@ -222,8 +228,9 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -231,39 +238,40 @@ static int
 rat_callback (const BoxType * b, void *cl)
 {
   RatType *rat = (RatType *)b;
+  hidGC gc = cl;
 
-  set_object_color ((AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
+  set_object_color (gc, (AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->RatColor);
 
-  dapi->draw_rat (rat, NULL, NULL);
+  dapi->draw_rat (gc, rat, NULL);
   return 1;
 }
 
 static void
-draw_element_package (ElementType *element)
+draw_element_package (hidGC gc, ElementType *element)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    //hid_draw_pcb_line (Output.fgGC, line);
-    dapi->draw_line (line, NULL, NULL);
+    //hid_draw_pcb_line (gc, line);
+    dapi->draw_line (gc, line, NULL);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    //hid_draw_pcb_arc (Output.fgGC, arc);
-    dapi->draw_arc (arc, NULL, NULL);
+    //hid_draw_pcb_arc (gc, arc);
+    dapi->draw_arc (gc, arc, NULL);
   }
   END_LOOP;
 }
@@ -272,10 +280,10 @@ static int
 element_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_package (info->gc, element);
   return 1;
 }
 
@@ -284,17 +292,17 @@ element_callback (const BoxType * b, void *cl)
  */
 
 void
-PrintAssembly (HID_DRAW *hid_draw, int side)
+PrintAssembly (hidGC gc, int side)
 {
   int side_group = GetLayerGroupNumberBySide (side);
 
   doing_assy = true;
-  hid_draw_set_draw_faded (Output.fgGC, 1);
-  DrawLayerGroup (hid_draw, side_group);
-  hid_draw_set_draw_faded (Output.fgGC, 0);
+  hid_draw_set_draw_faded (gc, 1);
+  DrawLayerGroup (gc, side_group);
+  hid_draw_set_draw_faded (gc, 0);
 
   /* draw package */
-  DrawSilk (hid_draw, side);
+  DrawSilk (gc, side);
   doing_assy = false;
 }
 
@@ -302,9 +310,9 @@ PrintAssembly (HID_DRAW *hid_draw, int side)
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
 static void
-DrawEverything (const BoxType *drawn_area)
+DrawEverything (hidGC gc)
 {
-  int i, ngroups, side;
+  int i, ngroups;
   int top_group, bottom_group;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_GROUP];
@@ -312,6 +320,10 @@ DrawEverything (const BoxType *drawn_area)
   int drawn_groups[MAX_GROUP];
   int plated, unplated;
   bool paste_empty;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
 
   PCB->Data->SILKLAYER.Color = PCB->ElementColor;
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
@@ -337,14 +349,14 @@ DrawEverything (const BoxType *drawn_area)
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
       && hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0))
     {
-      side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+      info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &side);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &side);
-	  dapi->draw_layer (&(PCB->Data->Layer[max_copper_layer + side]), hid_draw->clip_box, NULL);
+	  r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
+	  dapi->draw_layer (gc, &(PCB->Data->Layer[max_copper_layer + info.side]), NULL);
 	}
-      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -355,7 +367,7 @@ DrawEverything (const BoxType *drawn_area)
 
       if (hid_draw_set_layer (hid_draw, 0, group, 0))
         {
-          DrawLayerGroup (hid_draw, group);
+          DrawLayerGroup (gc, group);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -365,20 +377,20 @@ DrawEverything (const BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (SWAP_IDENT ? bottom_group : top_group, hid_draw->clip_box, NULL);
+    dapi->draw_ppv (gc, SWAP_IDENT ? bottom_group : top_group, NULL);
   else
     {
       CountHoles (&plated, &unplated, hid_draw->clip_box);
 
       if (plated && hid_draw_set_layer (hid_draw, "plated-drill", SL (PDRILL, 0), 0))
         {
-          dapi->draw_holes (1, hid_draw->clip_box, NULL);
+          dapi->draw_holes (gc, 1, NULL);
           hid_draw_end_layer (hid_draw);
         }
 
       if (unplated && hid_draw_set_layer (hid_draw, "unplated-drill", SL (UDRILL, 0), 0))
         {
-          dapi->draw_holes (0, hid_draw->clip_box, NULL);
+          dapi->draw_holes (gc, 0, NULL);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -386,25 +398,25 @@ DrawEverything (const BoxType *drawn_area)
   /* Draw the solder mask if turned on */
   if (hid_draw_set_layer (hid_draw, "componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (hid_draw, TOP_SIDE);
+      DrawMask (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (hid_draw, BOTTOM_SIDE);
+      DrawMask (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (hid_draw, TOP_SIDE);
+      DrawSilk (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (hid_draw, BOTTOM_SIDE);
+      DrawSilk (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -412,11 +424,11 @@ DrawEverything (const BoxType *drawn_area)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, NULL);
+	r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
       /* Draw rat lines on top */
       if (hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0))
         {
-          DrawRats (hid_draw);
+          DrawRats (gc);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -424,38 +436,38 @@ DrawEverything (const BoxType *drawn_area)
   paste_empty = IsPasteEmpty (TOP_SIDE);
   if (hid_draw_set_layer (hid_draw, "toppaste", SL (PASTE, TOP), paste_empty))
     {
-      DrawPaste (hid_draw, TOP_SIDE);
+      DrawPaste (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
   if (hid_draw_set_layer (hid_draw, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
-      DrawPaste (hid_draw, BOTTOM_SIDE);
+      DrawPaste (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topassembly", SL (ASSY, TOP), 0))
     {
-      PrintAssembly (hid_draw, TOP_SIDE);
+      PrintAssembly (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomassembly", SL (ASSY, BOTTOM), 0))
     {
-      PrintAssembly (hid_draw, BOTTOM_SIDE);
+      PrintAssembly (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "fab", SL (FAB, 0), 0))
     {
-      PrintFab (Output.fgGC);
+      PrintFab (gc);
       hid_draw_end_layer (hid_draw);
     }
 }
 
 /* static */ void
-DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
+DrawEMark (hidGC gc, ElementType *e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -476,14 +488,14 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
-  hid_draw_set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
-  hid_draw_set_line_width (Output.fgGC, 0);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  ghid_set_lock_effects (gc, (AnyObjectType *)e);
+  hid_draw_set_color (gc, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 0);
+  hid_draw_line (gc, X - mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X - mark_size, Y, X, Y + mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -492,22 +504,26 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      hid_draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      hid_draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      hid_draw_line (gc, X, Y, X + 2 * mark_size, Y);
+      hid_draw_line (gc, X, Y, X, Y - 4* mark_size);
     }
 }
 
 static int
 pin_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_pin_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_pin_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
 static int
 via_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_via_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_via_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
@@ -515,9 +531,10 @@ static int
 pad_mask_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side))
-    dapi->draw_pad_mask (pad, NULL, NULL);
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side))
+    dapi->draw_pad_mask (info->gc, pad, NULL);
   return 1;
 }
 
@@ -526,10 +543,13 @@ pad_mask_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (HID_DRAW *new_hid_draw, int side)
+DrawSilk (hidGC gc, int side)
 {
-  HID_DRAW *old_hid_draw = hid_draw;
-  hid_draw = new_hid_draw;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
+  info.side = side;
 
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
@@ -542,62 +562,57 @@ DrawSilk (HID_DRAW *new_hid_draw, int side)
     {
       hid_draw_use_mask (hid_draw, HID_MASK_BEFORE);
 #endif
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + side), hid_draw->clip_box, NULL);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + side), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
 #if 0
     }
 
   hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (hid_draw->poly_after)
     {
-      hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + layer), hid_draw->clip_box, NULL);
+      hid_draw_use_mask (gc, hid_draw, HID_MASK_AFTER);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + layer), NULL);
       /* draw package */
       r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
     }
   hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 #endif
-
-  hid_draw = old_hid_draw;
 }
 
 
 static void
-DrawMaskBoardArea (HID_DRAW *hid_draw, int mask_type)
+DrawMaskBoardArea (hidGC gc, int mask_type)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   /* Skip the mask drawing if the GUI doesn't want this type */
   if ((mask_type == HID_MASK_BEFORE && !hid_draw->poly_before) ||
       (mask_type == HID_MASK_AFTER  && !hid_draw->poly_after))
     return;
 
   hid_draw_use_mask (hid_draw, mask_type);
-  hid_draw_set_color (Output.fgGC, PCB->MaskColor);
+  hid_draw_set_color (gc, PCB->MaskColor);
   if (hid_draw->clip_box == NULL)
-    hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+    hid_draw_fill_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    hid_draw_fill_rect (Output.fgGC, hid_draw->clip_box->X1, hid_draw->clip_box->Y1,
-                                     hid_draw->clip_box->X2, hid_draw->clip_box->Y2);
+    hid_draw_fill_rect (gc, hid_draw->clip_box->X1, hid_draw->clip_box->Y1,
+                            hid_draw->clip_box->X2, hid_draw->clip_box->Y2);
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 mask_poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  hidGC gc = cl;
 
-  hid_draw_pcb_polygon (Output.pmGC, polygon, i->drawn_area);
+  hid_draw_pcb_polygon (Output.pmGC, polygon);
   return 1;
 }
 
@@ -605,6 +620,7 @@ static int
 mask_line_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_line (Output.pmGC, line);
   return 1;
@@ -614,6 +630,7 @@ static int
 mask_arc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_arc (Output.pmGC, arc);
   return 1;
@@ -622,16 +639,13 @@ mask_arc_callback (const BoxType * b, void *cl)
 static int
 mask_text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  hidGC gc = cl;
   int min_silk_line;
 
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
-    min_silk_line = PCB->minSlk;
-  else
-    min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  min_silk_line = PCB->minSlk;
+
+  hid_draw_pcb_text (gc, text, min_silk_line);
   return 1;
 }
 
@@ -639,34 +653,38 @@ mask_text_callback (const BoxType * b, void *cl)
  * draws solder mask layer - this will cover nearly everything
  */
 void
-DrawMask (HID_DRAW *hid_draw, int side)
+DrawMask (hidGC gc, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
+  info.side = side;
 
   if (thin)
     hid_draw_set_color (Output.pmGC, PCB->MaskColor);
   else
     {
-      DrawMaskBoardArea (hid_draw, HID_MASK_BEFORE);
+      DrawMaskBoardArea (gc, HID_MASK_BEFORE);
       hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
     }
 
-  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, mask_poly_callback, &info);
-  r_search (Layer->line_tree,    hid_draw->clip_box, NULL, mask_line_callback, Layer);
-  r_search (Layer->arc_tree,     hid_draw->clip_box, NULL, mask_arc_callback,  Layer);
-  r_search (Layer->text_tree,    hid_draw->clip_box, NULL, mask_text_callback, Layer);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, mask_poly_callback, gc);
+  r_search (Layer->line_tree,    hid_draw->clip_box, NULL, mask_line_callback, gc);
+  r_search (Layer->arc_tree,     hid_draw->clip_box, NULL, mask_arc_callback,  gc);
+  r_search (Layer->text_tree,    hid_draw->clip_box, NULL, mask_text_callback, gc);
 
-  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (thin)
     hid_draw_set_color (Output.pmGC, "erase");
   else
     {
-      DrawMaskBoardArea (hid_draw, HID_MASK_AFTER);
+      DrawMaskBoardArea (gc, HID_MASK_AFTER);
       hid_draw_use_mask (hid_draw, HID_MASK_OFF);
     }
 }
@@ -675,20 +693,22 @@ DrawMask (HID_DRAW *hid_draw, int side)
  * draws solder paste layer for a given side of the board
  */
 void
-DrawPaste (HID_DRAW *hid_draw, int side)
+DrawPaste (hidGC gc, int side)
 {
-  hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+  hid_draw_set_color (gc, PCB->ElementColor);
   ALLPAD_LOOP (PCB->Data);
   {
     if (ON_SIDE (pad, side))
-      dapi->draw_pad_paste (pad, NULL, NULL);
+      dapi->draw_pad_paste (gc, pad, NULL);
   }
   ENDALL_LOOP;
 }
 
 /* static */ void
-DrawRats (HID_DRAW *hid_draw)
+DrawRats (hidGC gc)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
    * XXX gtk only allows negative drawing.
@@ -697,7 +717,7 @@ DrawRats (HID_DRAW *hid_draw)
 
   if (hid_draw_can_draw_in_mask_clear (hid_draw))
     hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, hid_draw->clip_box, NULL, rat_callback, NULL);
+  r_search (PCB->Data->rat_tree, hid_draw->clip_box, NULL, rat_callback, gc);
   if (hid_draw_can_draw_in_mask_clear (hid_draw))
     hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 }
@@ -707,13 +727,14 @@ DrawRats (HID_DRAW *hid_draw)
  * also draws the pins / pads / vias in this layer group.
  */
 void
-DrawLayerGroup (HID_DRAW *hid_draw, int group)
+DrawLayerGroup (hidGC gc, int group)
 {
   int i, rv = 1;
   int layernum;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   for (i = n_entries - 1; i >= 0; i--)
     {
@@ -723,13 +744,13 @@ DrawLayerGroup (HID_DRAW *hid_draw, int group)
           strcmp (Layer->Name, "route") == 0)
         rv = 0;
       if (layernum < max_copper_layer && Layer->On)
-        dapi->draw_layer (Layer, hid_draw->clip_box, NULL);
+        dapi->draw_layer (gc, Layer, NULL);
     }
   if (n_entries > 1)
     rv = 1;
 
   if (rv && !hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (group, hid_draw->clip_box, NULL);
+    dapi->draw_ppv (gc, group, NULL);
 }
 
 static void
@@ -1236,11 +1257,11 @@ DrawObject (int type, void *ptr1, void *ptr2)
 }
 
 static void
-draw_element (ElementType *element)
+draw_element (hidGC gc, ElementType *element)
 {
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
+  draw_element_package (gc, element);
+  draw_element_name (gc, element);
+  draw_element_pins_and_pads (gc, element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1248,11 +1269,11 @@ draw_element (ElementType *element)
  */
 
 void
-hid_expose_callback (HID_DRAW *expose_hid_draw, void *item)
+hid_expose_callback (HID_DRAW *hid_draw, void *item)
 {
-  hid_draw = expose_hid_draw;
+  hidGC gc;
 
-  Output.fgGC = hid_draw_make_gc (hid_draw);
+  gc = hid_draw_make_gc (hid_draw);
   Output.bgGC = hid_draw_make_gc (hid_draw);
   Output.pmGC = hid_draw_make_gc (hid_draw);
 
@@ -1262,13 +1283,13 @@ hid_expose_callback (HID_DRAW *expose_hid_draw, void *item)
   if (item)
     {
       doing_pinout = true;
-      draw_element ((ElementType *)item);
+      draw_element (gc, (ElementType *)item);
       doing_pinout = false;
     }
   else
-    DrawEverything (hid_draw->clip_box);
+    DrawEverything (gc);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
   hid_draw = NULL;
diff --git a/src/draw.h b/src/draw.h
index 5c70583..6a65993 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -66,21 +66,21 @@ void EraseElementPinsAndPads (ElementType *);
 void EraseElementName (ElementType *);
 void EraseObject (int, void *, void *);
 
-void DrawLayerGroup (HID_DRAW *hid_draw, int side);
-void DrawPaste (HID_DRAW *hid_draw, int side);
-void DrawSilk (HID_DRAW *hid_draw, int side);
-void DrawMask (HID_DRAW *hid_draw, int side);
-void PrintAssembly (HID_DRAW *hid_draw, int side);
+void DrawLayerGroup (hidGC gc, int side);
+void DrawPaste (hidGC gc, int side);
+void DrawSilk (hidGC gc, int side);
+void DrawMask (hidGC gc, int side);
+void DrawHoles (hidGC gc, bool draw_plated, bool draw_unplated);
+void PrintAssembly (hidGC gc, int side);
 
 /* TEMPORARY */
-void ClearPad (PadType *, bool);
-void DrawPinOrViaLowLevel (PinType *, bool);
-void DrawPlainPin (PinType *, bool);
-void DrawPlainVia (PinType *, bool);
-void DrawRegularText (LayerType *, TextType *);
-void DrawEMark (ElementType *, Coord, Coord, bool);
-void DrawHole (PinType *);
-void DrawRats (HID_DRAW *hid_draw);
+//void ClearPad (hidGC gc, PadType *, bool);
+//void DrawPinOrViaLowLevel (hidGC gc, PinType *, bool);
+//void DrawPlainPin (hidGC gc, PinType *, bool);
+//void DrawPlainVia (hidGC gc, PinType *, bool);
+//void DrawRegularText (hidGC gc, LayerType *, TextType *);
+void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+void DrawRats (hidGC gc);
 /* TEMPORARY */
 
 #endif
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index af411f7..41cb651 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -10,41 +10,41 @@
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
 static void
-draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin (hidGC gc, PinType *pin, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, pin, false);
+  hid_draw_pcb_pv (gc, pin, false);
 }
 
 static void
-draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin_mask (hidGC gc, PinType *pin, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, pin, true);
 }
 
 static void
-draw_via (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via (hidGC gc, PinType *via, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, via, false);
+  hid_draw_pcb_pv (gc, via, false);
 }
 
 static void
-draw_via_mask (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via_mask (hidGC gc, PinType *via, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, via, true);
 }
 
 static void
-draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+draw_hole (hidGC gc, PinType *pv, void *userdata)
 {
   if (!TEST_FLAG (THINDRAWFLAG, PCB))
     hid_draw_fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
     {
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
 
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
 }
 
@@ -58,13 +58,13 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad (hidGC gc, PadType *pad, void *userdata)
 {
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_mask (hidGC gc, PadType *pad, void *userdata)
 {
   if (pad->Mask <= 0)
     return;
@@ -73,25 +73,25 @@ draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
 }
 
 static void
-draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_paste (hidGC gc, PadType *pad, void *userdata)
 {
   if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
     return;
 
   if (pad->Mask < pad->Thickness)
-    _draw_pad (Output.fgGC, pad, true, true);
+    _draw_pad (gc, pad, true, true);
   else
-    _draw_pad (Output.fgGC, pad, false, false);
+    _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+draw_line (hidGC gc, LineType *line, void *userdata)
 {
-  hid_draw_pcb_line (Output.fgGC, line);
+  hid_draw_pcb_line (gc, line);
 }
 
 static void
-draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+draw_rat (hidGC gc, RatType *rat, void *userdata)
 {
   if (Settings.RatThickness < 100)
     rat->Thickness = pixel_slop * Settings.RatThickness;
@@ -101,29 +101,29 @@ draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        hid_draw_set_line_width (Output.fgGC, 0);
+        hid_draw_set_line_width (gc, 0);
       else
-        hid_draw_set_line_width (Output.fgGC, w);
-      hid_draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
+        hid_draw_set_line_width (gc, w);
+      hid_draw_arc (gc, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    hid_draw_pcb_line (Output.fgGC, (LineType *) rat);
+    hid_draw_pcb_line (gc, (LineType *) rat);
 }
 
 static void
-draw_arc (ArcType *arc, const BoxType *drawn_area, void *userdata)
+draw_arc (hidGC gc, ArcType *arc, void *userdata)
 {
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  hid_draw_pcb_arc (gc, arc);
 }
 
 static void
-draw_poly (PolygonType *polygon, const BoxType *drawn_area, void *userdata)
+draw_poly (hidGC gc, PolygonType *polygon, void *userdata)
 {
-  hid_draw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  hid_draw_pcb_polygon (gc, polygon);
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -134,142 +134,153 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
+struct layer_info {
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  dapi->draw_line (line, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  dapi->draw_line (info->gc, line, NULL);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  dapi->draw_arc (arc, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  dapi->draw_arc (info->gc, arc, NULL);
   return 1;
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  dapi->draw_poly (info->gc, polygon, NULL);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                             : PCB->PinSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                   hid_draw_set_color (Output.fgGC, layer->Color);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                    : PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (gc, PCB->ConnectedColor);
+  else                                   hid_draw_set_color (gc, layer->Color);
 }
 
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, PIN_TYPE);
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, PIN_TYPE);
+  dapi->draw_pin (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, VIA_TYPE);
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, VIA_TYPE);
+  dapi->draw_via (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
+struct side_info {
+  hidGC gc;
+  LayerType *layer;
+  int side;
+};
+
 static int
 pad_inlayer_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *)b;
-  LayerType *layer = cl;
-  int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int group = GetLayerGroupNumberByPointer (layer);
+  struct side_info *info = cl;
 
-  int side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
-
-  if (ON_SIDE (pad, side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (Output.fgGC, PCB->PinSelectedColor);
-      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-      else                                    hid_draw_set_color (Output.fgGC, layer->Color);
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (info->gc, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (info->gc, PCB->PinSelectedColor);
+      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (info->gc, PCB->ConnectedColor);
+      else                                    hid_draw_set_color (info->gc, info->layer->Color);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
+struct hole_info {
+  hidGC gc;
+  int plated;
+};
+
 static int
 pin_hole_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)pin);
+  set_object_color (info->gc, (AnyObjectType *) pin, PCB->WarnColor,
                     PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_pin_hole (pin, NULL, NULL);
+  dapi->draw_pin_hole (info->gc, pin, NULL);
   return 1;
 }
 
@@ -277,41 +288,45 @@ static int
 via_hole_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)via);
+  set_object_color (info->gc, (AnyObjectType *) via, PCB->WarnColor,
                     PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_via_hole (via, NULL, NULL);
+  dapi->draw_via_hole (info->gc, via, NULL);
   return 1;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  dapi->draw_pin (gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  dapi->draw_via (gc, (PinType *)b, NULL);
   return 1;
 }
 
@@ -319,91 +334,109 @@ static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_ppv (int group, const BoxType *drawn_area, void *userdata)
+draw_ppv (hidGC gc, int group, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int side;
 
   if (PCB->PinOn || !gui->gui)
     {
+      struct side_info info;
+
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
+
+      info.gc = gc;
+      info.layer = NULL; /* Nasty, but saves creating a load of different info types */
 
       /* draw element pads */
       if (group == top_group)
         {
-          side = TOP_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = TOP_SIDE;
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
 
       if (group == bottom_group)
         {
-          side = BOTTOM_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = BOTTOM_SIDE;
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
-  dapi->draw_holes (-1, drawn_area, NULL);
+  dapi->draw_holes (gc, -1, NULL);
 }
 
 static void
-draw_holes (int plated, const BoxType *drawn_area, void *userdata)
+draw_holes (hidGC gc, int plated, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+  struct hole_info info;
+
+  info.gc = gc;
+  info.plated = plated;
+
   if (PCB->PinOn)
-    r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, &plated);
+    r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &info);
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, &plated);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &info);
 }
 
 static void
-draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+draw_layer (hidGC gc, LayerType *layer, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int layer_num = GetLayerNumber (PCB->Data, layer);
   int group = GetLayerGroupNumberByPointer (layer);
-  struct poly_info info = {drawn_area, layer};
   bool is_outline;
+  struct hole_info h_info;
+  struct layer_info l_info;
+
+  h_info.gc = gc;
+  h_info.plated = -1; /* Draw both plated and unplated holes */
+  l_info.gc = gc;
+  l_info.layer = layer;
 
   is_outline = strcmp (layer->Name, "outline") == 0 ||
                strcmp (layer->Name, "route") == 0;
 
   if (layer_num < max_copper_layer && !is_outline)
     {
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, NULL);
-      r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &h_info);
+      r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &h_info);
     }
 
   /* print the non-clearing polys */
-  r_search (layer->polygon_tree, drawn_area, NULL, poly_callback, &info);
+  r_search (layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &l_info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
   /* draw all visible lines this layer */
-  r_search (layer->line_tree, drawn_area, NULL, line_callback, layer);
-  r_search (layer->arc_tree,  drawn_area, NULL, arc_callback,  layer);
-  r_search (layer->text_tree, drawn_area, NULL, text_callback, layer);
+  r_search (layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (layer->arc_tree,  hid_draw->clip_box, NULL, arc_callback,  &l_info);
+  r_search (layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
@@ -413,9 +446,9 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
     {
       if (IsLayerEmpty (layer))
         {
-          hid_draw_set_color (Output.fgGC, layer->Color);
-          hid_draw_set_line_width (Output.fgGC, PCB->minWid);
-          hid_draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+          hid_draw_set_color (gc, layer->Color);
+          hid_draw_set_line_width (gc, PCB->minWid);
+          hid_draw_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
         }
       return;
     }
@@ -428,17 +461,22 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
   if (!gui->gui)
     return;
 
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_inlayer_callback, layer);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
 
   /* draw element pads */
-  if (group == top_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+  if (group == top_group ||
+      group == bottom_group)
+    {
+      struct side_info s_info;
 
-  if (group == bottom_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+      s_info.gc = gc;
+      s_info.layer = layer;
+      s_info.side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_inlayer_callback, &s_info);
+    }
 
   /* draw vias */
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_inlayer_callback, layer);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
 }
 
 struct draw_funcs d_f = {
diff --git a/src/draw_funcs.h b/src/draw_funcs.h
index ba4982d..677b397 100644
--- a/src/draw_funcs.h
+++ b/src/draw_funcs.h
@@ -1,20 +1,20 @@
 struct draw_funcs {
-  void (*draw_pin)       (PinType *,     const BoxType *, void *);
-  void (*draw_pin_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_pin_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_via)       (PinType *,     const BoxType *, void *);
-  void (*draw_via_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_via_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_pad)       (PadType *,     const BoxType *, void *);
-  void (*draw_pad_mask)  (PadType *,     const BoxType *, void *);
-  void (*draw_pad_paste) (PadType *,     const BoxType *, void *);
-  void (*draw_line)      (LineType *,    const BoxType *, void *);
-  void (*draw_rat)       (RatType *,     const BoxType *, void *);
-  void (*draw_arc)       (ArcType *,     const BoxType *, void *);
-  void (*draw_poly)      (PolygonType *, const BoxType *, void *);
-  void (*draw_ppv)       (int,           const BoxType *, void *);
-  void (*draw_holes)     (int,           const BoxType *, void *);
-  void (*draw_layer)     (LayerType *,   const BoxType *, void *);
+  void (*draw_pin)       (hidGC, PinType *,     void *);
+  void (*draw_pin_mask)  (hidGC, PinType *,     void *);
+  void (*draw_pin_hole)  (hidGC, PinType *,     void *);
+  void (*draw_via)       (hidGC, PinType *,     void *);
+  void (*draw_via_mask)  (hidGC, PinType *,     void *);
+  void (*draw_via_hole)  (hidGC, PinType *,     void *);
+  void (*draw_pad)       (hidGC, PadType *,     void *);
+  void (*draw_pad_mask)  (hidGC, PadType *,     void *);
+  void (*draw_pad_paste) (hidGC, PadType *,     void *);
+  void (*draw_line)      (hidGC, LineType *,    void *);
+  void (*draw_rat)       (hidGC, RatType *,     void *);
+  void (*draw_arc)       (hidGC, ArcType *,     void *);
+  void (*draw_poly)      (hidGC, PolygonType *, void *);
+  void (*draw_ppv)       (hidGC, int,           void *);
+  void (*draw_holes)     (hidGC, int,           void *);
+  void (*draw_layer)     (hidGC, LayerType *,   void *);
 };
 
 extern struct draw_funcs *dapi;
diff --git a/src/global.h b/src/global.h
index b36aebf..050d804 100644
--- a/src/global.h
+++ b/src/global.h
@@ -182,8 +182,7 @@ typedef struct
  */
 typedef struct			/* holds information about output window */
 {
-  hidGC bgGC,			/* background and foreground; */
-    fgGC,			/* changed from some routines */
+  hidGC bgGC,			/* background GC */
     pmGC;			/* depth 1 pixmap GC to store clip */
 }
 OutputType;
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 872ff8b..fc16f3c 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -203,7 +203,7 @@ fill_contour_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
+fill_clipped_contour (hidGC gc, PLINE *pl)
 {
   HID_DRAW *hid_draw = gc->hid_draw;
   PLINE *pl_copy;
@@ -238,20 +238,21 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
  */
 #define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
 static int
-should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
+should_compute_no_holes (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   Coord x1, x2, y1, y2;
   double poly_bounding_area;
   double clipped_poly_area;
 
   /* If there is no passed clip box, compute the whole thing */
-  if (clip_box == NULL)
+  if (hid_draw->clip_box == NULL)
     return 1;
 
-  x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, clip_box->Y2);
+  x1 = MAX (poly->BoundingBox.X1, hid_draw->clip_box->X1);
+  x2 = MIN (poly->BoundingBox.X2, hid_draw->clip_box->X2);
+  y1 = MAX (poly->BoundingBox.Y1, hid_draw->clip_box->Y1);
+  y2 = MIN (poly->BoundingBox.Y2, hid_draw->clip_box->Y2);
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
@@ -270,15 +271,15 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
 void
-common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon)
 {
   if (polygon->Clipped == NULL)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    hid_draw__thin_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__thin_pcb_polygon (gc, polygon);
   else
-    hid_draw__fill_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__fill_pcb_polygon (gc, polygon);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
@@ -288,12 +289,12 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        hid_draw__thin_pcb_polygon (gc, &poly, gc->hid_draw->clip_box);
+        hid_draw__thin_pcb_polygon (gc, &poly);
     }
 }
 
 void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   HID_DRAW *hid_draw = gc->hid_draw;
 
@@ -306,7 +307,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
        * NoHoles version and cache it for later rendering, otherwise
        * just compute what we need to render now.
        */
-      if (should_compute_no_holes (poly, hid_draw->clip_box))
+      if (should_compute_no_holes (gc, poly))
         ComputeNoHoles (poly);
       else
         NoHolesPolygonDicer (poly, hid_draw->clip_box, fill_contour_cb, gc);
@@ -320,7 +321,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
           if (hid_draw->clip_box == NULL)
             fill_contour (gc, pl);
           else
-            fill_clipped_contour (gc, pl, hid_draw->clip_box);
+            fill_clipped_contour (gc, pl);
         }
     }
 
@@ -346,8 +347,7 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
 }
 
 void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   HID_DRAW *hid_draw = gc->hid_draw;
 
@@ -743,6 +743,6 @@ common_draw_helpers_class_init (HID_DRAW_CLASS *klass)
 }
 
 void
-common_draw_helpers_init (HID_DRAW *graphics)
+common_draw_helpers_init (HID_DRAW *hid_draw)
 {
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 93623c4..ea5c880 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -1,6 +1,6 @@
-void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly);
 void common_gui_draw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
@@ -11,5 +11,5 @@ void common_fill_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_thindraw_pcb_pv (hidGC gc, PinType *pv, bool mask);
 void common_thindraw_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_draw_helpers_class_init (HID_DRAW_CLASS *klass);
-void common_draw_helpers_init (HID_DRAW *graphics);
+void common_draw_helpers_init (HID_DRAW *hid_draw);
 void common_set_clip_box (HID_DRAW *hid_draw, BoxType *clip_box);
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 4ef080e..19c4708 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -916,7 +916,7 @@ gerber_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       hidGC gc = hid_draw_make_gc (&gerber_graphics);
       if (outline_layer
 	  && outline_layer != PCB->Data->Layer+idx)
-	dapi->draw_layer (outline_layer, gerber_graphics.clip_box, NULL);
+	dapi->draw_layer (gc, outline_layer, NULL);
       else if (!outline_layer)
 	{
 	  printf("name %s idx %d\n", name, idx);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 4d5ffa8..0ce72fb 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -53,8 +53,6 @@ extern HID ghid_hid;
 static HID_DRAW ghid_graphics;
 extern HID_DRAW_CLASS ghid_graphics_class;
 
-static hidGC current_gc = NULL;
-
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
@@ -806,12 +804,6 @@ ghid_set_line_cap_angle (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
-static void
-ghid_invalidate_current_gc (void)
-{
-  current_gc = NULL;
-}
-
 static int
 use_gc (hidGC gc)
 {
@@ -821,10 +813,10 @@ use_gc (hidGC gc)
       abort ();
     }
 
-  if (current_gc == gc)
-    return 1;
+//  if (current_gc == gc)
+//    return 1;
 
-  current_gc = gc;
+//  current_gc = gc;
 
   set_gl_color_for_gc (gc);
   return 1;
@@ -877,7 +869,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 void
-ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   USE_GC (gc);
 
@@ -885,15 +877,14 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 }
 
 void
-ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  HID_DRAW *hid_draw = gc->hid_draw;
   gtkGC gtk_gc = (gtkGC)gc;
 
   double old_alpha_mult = gtk_gc->alpha_mult;
-  common_thindraw_pcb_polygon (gc, poly, hid_draw->clip_box);
+  common_thindraw_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
-  hid_draw__fill_pcb_polygon (gc, poly, hid_draw->clip_box);
+  hid_draw__fill_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, old_alpha_mult);
 }
 
@@ -1202,13 +1193,14 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -1219,26 +1211,26 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  ghid_set_lock_effects (Output.fgGC, obj);
-  hid_draw_set_color (Output.fgGC, color);
+  ghid_set_lock_effects (gc, obj);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+  ghid_set_lock_effects (gc, (AnyObjectType *) pv);
 
-  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                              : PCB->PinSelectedColor);
-  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (Output.fgGC, PCB->FoundColor);
+  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                     : PCB->PinSelectedColor);
+  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (gc, PCB->ConnectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (gc, PCB->FoundColor);
   else
     {
       int top_group    = GetLayerGroupNumberBySide (TOP_SIDE);
@@ -1246,15 +1238,15 @@ set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
       int this_group   = GetLayerGroupNumberByPointer (layer);
 
       if (this_group == top_group || this_group == bottom_group)
-        hid_draw_set_color (Output.fgGC, (SWAP_IDENT == (this_group == bottom_group)) ?
-                                          PCB->ViaColor : PCB->InvisibleObjectsColor);
+        hid_draw_set_color (gc, (SWAP_IDENT == (this_group == bottom_group)) ?
+                                PCB->ViaColor : PCB->InvisibleObjectsColor);
       else
-        hid_draw_set_color (Output.fgGC, layer->Color);
+        hid_draw_set_color (gc, layer->Color);
     }
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (hidGC gc, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -1278,8 +1270,8 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -1288,46 +1280,47 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
-_draw_pv (PinType *pv, bool draw_hole)
+_draw_pv (hidGC gc, PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
-      hid_draw__thin_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__thin_pcb_pv (gc, pv, false);
       if (draw_hole)
-        hid_draw__thin_pcb_pv_hole (Output.fgGC, pv);
+        hid_draw__thin_pcb_pv_hole (gc, pv);
     }
   else
     {
-      hid_draw__fill_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__fill_pcb_pv (gc, pv, false);
       if (draw_hole)
         hid_draw__fill_pcb_pv_hole (Output.bgGC, pv);
     }
 
   if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
+    _draw_pv_name (gc, pv);
 }
 
 static void
-draw_pin (PinType *pin, bool draw_hole)
+draw_pin (hidGC gc, PinType *pin, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
+  set_object_color (gc, (AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  _draw_pv (pin, draw_hole);
+  _draw_pv (gc, pin, draw_hole);
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
-  draw_pin (pin, TEST_FLAG (THINDRAWFLAG, PCB));
+    _draw_pv_name (gc, pin);
+  draw_pin (gc, pin, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
@@ -1335,46 +1328,59 @@ static int
 pin_name_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
+    _draw_pv_name (gc, pin);
   return 1;
 }
 
+struct layer_info
+{
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, PIN_TYPE);
-  _draw_pv ((PinType *) b, false);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, PIN_TYPE);
+  _draw_pv (info->gc, (PinType *) b, false);
   return 1;
 }
 
 static void
-draw_via (PinType *via, bool draw_hole)
+draw_via (hidGC gc, PinType *via, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
+  set_object_color (gc, (AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  _draw_pv (via, draw_hole);
+  _draw_pv (gc, via, draw_hole);
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  hidGC gc = cl;
+
+  draw_via (gc, (PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, VIA_TYPE);
-  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, VIA_TYPE);
+  _draw_pv (info->gc, (PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (hidGC gc, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -1403,8 +1409,8 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pad thickness */
@@ -1413,7 +1419,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
@@ -1430,29 +1436,34 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad)
+draw_pad (hidGC gc, PadType *pad)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 
   if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+    draw_pad_name (gc, pad);
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side)) {
+  if (ON_SIDE (pad, info->side)) {
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-      draw_pad_name (pad);
-    draw_pad (pad);
+      draw_pad_name (info->gc, pad);
+    draw_pad (info->gc, pad);
   }
   return 1;
 }
@@ -1462,7 +1473,9 @@ static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  hidGC gc = cl;
+//  int plated = cl ? *(int *) cl : -1;
+  int plated = -1;
 
   if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
@@ -1472,10 +1485,9 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-          hid_draw_set_line_width (Output.fgGC, 0);
-          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (gc, Round_Cap);
+          hid_draw_set_line_width (gc, 0);
+          hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
@@ -1483,14 +1495,13 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-      set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
+      ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+      set_object_color (gc, (AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -1498,92 +1509,86 @@ hole_callback (const BoxType * b, void *cl)
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  hid_draw_pcb_line (Output.fgGC, line);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  hid_draw_pcb_line (info->gc, line);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  hid_draw_pcb_arc (info->gc, arc);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
-struct poly_info
-{
-  LayerType *layer;
-  const BoxType *drawn_area;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_no_clear (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_clearing (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
@@ -1602,8 +1607,9 @@ static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     _draw_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1620,8 +1626,9 @@ static int
 clearPad_callback_solid (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     hid_draw__fill_pcb_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1653,7 +1660,7 @@ fill_board_outline (hidGC gc)
     polygon.BoundingBox = *hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (gc, &polygon, hid_draw->clip_box);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -1684,8 +1691,8 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
-//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
-  hid_draw__fill_pcb_polygon (info->gc, &polygon, NULL);
+//  common_fill_pcb_polygon (info->gc, &polygon);
+  hid_draw__fill_pcb_polygon (info->gc, &polygon);
 
   poly_FreeContours (&polygon.NoHoles);
 
@@ -1723,15 +1730,20 @@ fill_board_outline_holes (hidGC gc)
 }
 
 static void
-GhidDrawMask (HID_DRAW *hid_draw, int side)
+GhidDrawMask (hidGC gc, int side)
 {
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct layer_info l_info;
+  struct side_info s_info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
-  OutputType *out = &Output;
+  l_info.gc = gc;
+  l_info.layer = Layer;
+  s_info.gc = gc;
+  s_info.side = side;
 
   if (thin)
     {
@@ -1739,24 +1751,24 @@ GhidDrawMask (HID_DRAW *hid_draw, int side)
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
       r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
       r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback, &side);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_CLEAR);
+  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
 
-  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &info);
-  r_search (Layer->line_tree,    hid_draw->clip_box, NULL, line_callback, Layer);
-  r_search (Layer->arc_tree,     hid_draw->clip_box, NULL, arc_callback,  Layer);
-  r_search (Layer->text_tree,    hid_draw->clip_box, NULL, text_callback, Layer);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
   r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
   r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback_solid, &side);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_AFTER);
-  hid_draw_set_color (out->fgGC, PCB->MaskColor);
-  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
 #if 0
   if (first_run) {
@@ -1797,13 +1809,13 @@ GhidDrawMask (HID_DRAW *hid_draw, int side)
     polygon.BoundingBox = *hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (out->fgGC, &polygon, hid_draw->clip_box);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 #endif
 
-  fill_board_outline (out->fgGC);
+  fill_board_outline (gc);
 
-  ghid_set_alpha_mult (out->fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 //  hidgl_flush_triangles (priv->hid_draw);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
@@ -1813,7 +1825,7 @@ GhidDrawMask (HID_DRAW *hid_draw, int side)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_OFF);
+  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1861,7 +1873,7 @@ outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-ghid_draw_outline_between_layers (int from_layer, int to_layer)
+ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 {
   render_priv *priv = gport->render_priv;
   HID_DRAW *hid_draw = priv->hid_draw;
@@ -1872,19 +1884,19 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (hid_draw->clip_box)
-    polygon.BoundingBox = *hid_draw->clip_box;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
-  info.gc = Output.fgGC;
+  info.gc = gc;
   info.z1 = compute_depth (from_layer);
   info.z2 = compute_depth (to_layer);
 
   p = polygon;
   do {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, hid_draw->clip_box, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->hid_draw->clip_box, outline_hole_cb, &info);
   } while ((p.Clipped = p.Clipped->f) != polygon.Clipped);
 
   poly_FreeContours (&polygon.NoHoles);
@@ -1899,8 +1911,6 @@ GhidDrawLayerGroup (hidGC gc, int group)
   HID_DRAW *hid_draw = gc->hid_draw;
   int i;
   int layernum;
-  int side;
-  struct poly_info info;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
@@ -1908,8 +1918,13 @@ GhidDrawLayerGroup (hidGC gc, int group)
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   bool is_outline;
+  struct layer_info l_info;
+  struct side_info s_info;
+
+  l_info.gc = gc;
+  s_info.gc = gc;
 
-  if (!hid_draw_set_layer (&ghid_graphics, 0, group, 0))
+  if (!hid_draw_set_layer (hid_draw, 0, group, 0))
     return 0;
 
   /* HACK: Subcomposite each layer in a layer group separately */
@@ -1920,10 +1935,13 @@ GhidDrawLayerGroup (hidGC gc, int group)
     is_outline = strcmp (Layer->Name, "outline") == 0 ||
                  strcmp (Layer->Name, "route") == 0;
 
+    l_info.layer = Layer;
+
+
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
       first_run = 0;
 
@@ -1934,8 +1952,8 @@ GhidDrawLayerGroup (hidGC gc, int group)
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
         fill_board_outline_holes (Output.bgGC);
         hidgl_flush_triangles (priv->hid_draw);
         glPopAttrib ();
@@ -1943,15 +1961,14 @@ GhidDrawLayerGroup (hidGC gc, int group)
 
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
-        info.layer = Layer;
-        info.drawn_area = hid_draw->clip_box;
-        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_no_clear, &info);
-        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_clearing, &info);
+        l_info.layer = Layer;
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        hid_draw_end_layer (&ghid_graphics);
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_end_layer (hid_draw);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
           hidgl_flush_triangles (priv->hid_draw);
@@ -1959,8 +1976,8 @@ GhidDrawLayerGroup (hidGC gc, int group)
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
           fill_board_outline_holes (Output.bgGC);
           hidgl_flush_triangles (priv->hid_draw);
           glPopAttrib ();
@@ -1971,31 +1988,31 @@ GhidDrawLayerGroup (hidGC gc, int group)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, Layer);
+          r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
-            side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &side);
+            s_info.side = TOP_SIDE;
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
-            side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &side);
+            s_info.side = BOTTOM_SIDE;
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, Layer);
-      r_search (Layer->arc_tree,  hid_draw->clip_box, NULL, arc_callback,  Layer);
-      r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, Layer);
+      r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
     }
   }
 
-  hid_draw_end_layer (&ghid_graphics);
+  hid_draw_end_layer (hid_draw);
 
   return (n_entries > 1);
 }
@@ -2046,6 +2063,7 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
 }
 
 struct cyl_info {
+  hidGC gc;
   int from_layer;
   int to_layer;
   double scale;
@@ -2067,9 +2085,9 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
-  hid_draw_set_color (Output.fgGC, color);
-  DrawDrillChannel (Output.fgGC, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)Pin);
+  hid_draw_set_color (info->gc, color);
+  DrawDrillChannel (info->gc, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
@@ -2129,20 +2147,19 @@ frontE_package_callback (const BoxType * b, void *cl)
 }
 
 static void
-ghid_draw_packages (BoxType *drawn_area)
+ghid_draw_packages (hidGC gc)
 {
   /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, gc->hid_draw->clip_box, NULL, frontE_package_callback, NULL);
 }
 
 void
-ghid_draw_everything (void)
+ghid_draw_everything (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   HID_DRAW *hid_draw = priv->hid_draw;
   int i, ngroups;
   int number_phys_on_top;
-  int side;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
   /* This is the reverse of the order in which we draw them.  */
@@ -2154,6 +2171,10 @@ ghid_draw_everything (void)
   int bottom_group;
   int min_phys_group;
   int max_phys_group;
+  struct side_info info;
+
+  cyl_info.gc = gc;
+  info.gc = gc;
 
   priv->current_colorname = NULL;
 
@@ -2203,23 +2224,23 @@ ghid_draw_everything (void)
   /*
    * first draw all 'invisible' stuff
    */
-  side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+  info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
-      hid_draw_set_layer (&ghid_graphics, "invisible", SL (INVISIBLE, 0), 0)) {
-    DrawSilk (&ghid_graphics, side);
+      hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
 
-    hid_draw_end_layer (&ghid_graphics);
+    hid_draw_end_layer (hid_draw);
 
     /* Draw the reverse-side solder mask if turned on */
     if (!global_view_2d &&
-        hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "componentmask" : "soldermask",
-                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
-        GhidDrawMask (&ghid_graphics, side);
-        hid_draw_end_layer (&ghid_graphics);
+        hid_draw_set_layer (hid_draw, SWAP_IDENT ? "componentmask" : "soldermask",
+                            SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (gc, info.side);
+        hid_draw_end_layer (hid_draw);
       }
   }
 
@@ -2239,17 +2260,17 @@ ghid_draw_everything (void)
     if (is_this_physical)
       number_phys_on_top --;
 
-    ghid_set_alpha_mult (Output.fgGC, alpha_mult);
-    GhidDrawLayerGroup (Output.fgGC, drawn_groups [i]);
+    ghid_set_alpha_mult (gc, alpha_mult);
+    GhidDrawLayerGroup (gc, drawn_groups [i]);
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
-      hid_draw_set_color (Output.fgGC, "drill");
-      ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
-      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer);
+      hid_draw_set_color (gc, "drill");
+      ghid_set_alpha_mult (gc, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
@@ -2257,12 +2278,12 @@ ghid_draw_everything (void)
   }
 #undef FADE_FACTOR
 
-  ghid_set_alpha_mult (Output.fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
+  info.side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
@@ -2274,41 +2295,41 @@ ghid_draw_everything (void)
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, NULL);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
       fill_board_outline_holes (Output.bgGC);
       hidgl_flush_triangles (priv->hid_draw);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &side);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, NULL);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
     end_subcomposite (hid_draw);
   }
 
   /* Draw the solder mask if turned on */
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "soldermask" : "componentmask",
-                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
-    GhidDrawMask (&ghid_graphics, side);
-    hid_draw_end_layer (&ghid_graphics);
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "soldermask" : "componentmask",
+                          SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (gc, info.side);
+    hid_draw_end_layer (hid_draw);
   }
 
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "bottomsilk" : "topsilk",
-                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
-      DrawSilk (&ghid_graphics, side);
-      hid_draw_end_layer (&ghid_graphics);
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "bottomsilk" : "topsilk",
+                          SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (gc, info.side);
+      hid_draw_end_layer (hid_draw);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, NULL);
+    r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
   if (PCB->RatOn && hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0)) {
-    DrawRats (&ghid_graphics);
-    hid_draw_end_layer (&ghid_graphics);
+    DrawRats (gc);
+    hid_draw_end_layer (hid_draw);
   }
 
   Settings.ShowBottomSide = save_show_solder;
@@ -2334,14 +2355,16 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 1, 0,
                      0, 0, 0, 1};
   bool horizon_problem = false;
+  HID_DRAW *hid_draw = priv->hid_draw;
+  hidGC gc;
 
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port, widget);
 
-  Output.fgGC = hid_draw_make_gc (&ghid_graphics);
-  Output.bgGC = hid_draw_make_gc (&ghid_graphics);
-  Output.pmGC = hid_draw_make_gc (&ghid_graphics);
+  gc = hid_draw_make_gc (hid_draw);
+  Output.bgGC = hid_draw_make_gc (hid_draw);
+  Output.pmGC = hid_draw_make_gc (hid_draw);
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2540,8 +2563,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
@@ -2584,9 +2605,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  common_set_clip_box (priv->hid_draw, &region);
-  /* hid_expose_callback (priv->hid_draw, 0); */
-  ghid_draw_everything ();
+  common_set_clip_box (hid_draw, &region);
+  /* hid_expose_callback (hid_draw, 0); */
+  ghid_draw_everything (gc);
   hidgl_flush_triangles (priv->hid_draw);
 
   glTexCoord2f (0., 0.);
@@ -2631,14 +2652,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
-  hidgl_set_depth (Output.fgGC, priv->edit_depth);
-
-  ghid_draw_grid (Output.fgGC);
+  hidgl_set_depth (gc, priv->edit_depth);
 
-  ghid_invalidate_current_gc ();
+  ghid_draw_grid (gc);
 
-  DrawAttached (Output.fgGC);
-  DrawMark (Output.fgGC);
+  DrawAttached (gc);
+  DrawMark (gc);
   hidgl_flush_triangles (priv->hid_draw);
 
   glEnable (GL_LIGHTING);
@@ -2691,7 +2710,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   if (!global_view_2d)
-    ghid_draw_packages (&region);
+    ghid_draw_packages (gc);
 
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
@@ -2699,19 +2718,18 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_COLOR_MATERIAL);
   glDisable (GL_LIGHTING);
 
-  draw_crosshair (Output.fgGC, priv);
+  draw_crosshair (gc, priv);
 
   hidgl_flush_triangles (priv->hid_draw);
 
-  draw_lead_user (Output.fgGC, priv);
+  draw_lead_user (gc, priv);
 
   ghid_end_drawing (port, widget);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
 
-  Output.fgGC = NULL;
   Output.bgGC = NULL;
   Output.pmGC = NULL;
   g_timer_start (priv->time_since_expose);
@@ -2841,7 +2859,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2871,6 +2888,7 @@ GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
   render_priv *priv = gport->render_priv;
+  HID_DRAW *hid_draw = priv->hid_draw;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
@@ -2953,7 +2971,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2973,8 +2990,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  common_set_clip_box (priv->hid_draw, &region);
-  hid_expose_callback (priv->hid_draw, NULL);
+  common_set_clip_box (hid_draw, &region);
+  hid_expose_callback (hid_draw, NULL);
   hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
@@ -3002,6 +3019,7 @@ HID_DRAW *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -3018,8 +3036,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   glDisable (GL_STENCIL_TEST);
 
@@ -3032,17 +3048,16 @@ ghid_request_debug_draw (void)
                 port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
                              -port->view.y0, 0);
 
-  return &ghid_graphics;
+  return priv->hid_draw;
 }
 
 void
 ghid_flush_debug_draw (HID_DRAW *hid_draw)
 {
-  render_priv *priv = gport->render_priv;
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (priv->hid_draw);
+  hidgl_flush_triangles (hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index ad3b3b8..f670fc1 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -819,6 +819,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   time_t start, end;
   BoxType region;
   Drawable save_main;
+  hidGC gc;
 
   save_main = main_pixmap;
   main_pixmap = window;
@@ -2501,6 +2502,8 @@ static int need_redraw = 0;
 static Boolean
 idle_proc (XtPointer dummy)
 {
+  hidGC gc;
+
   if (need_redraw)
     {
       int mx, my;
@@ -3763,6 +3766,7 @@ pinout_callback (Widget da, PinoutData * pd,
   double save_vz;
   Pixmap save_px;
   int reason = cbs ? cbs->reason : 0;
+  hidGC gc;
 
   if (pd->window == 0 && reason == XmCR_RESIZE)
     return;
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 85ab8f5..17ef7f6 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -1009,7 +1009,11 @@ ps_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, hid_draw->clip_box, NULL);
+      hidGC gc;
+
+      gc = hid_draw_make_gc (hid_draw);
+      dapi->draw_layer (gc, global.outline_layer, NULL);
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
@@ -1267,7 +1271,7 @@ ps_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
+fill_polyarea (hidGC gc, POLYAREA * pa)
 {
   /* Ignore clip_box, just draw everything */
 
@@ -1296,15 +1300,15 @@ fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
 }
 
 static void
-ps_draw_pcb_polygon (hidGC gc, PolygonType * poly, const BoxType * clip_box)
+ps_draw_pcb_polygon (hidGC gc, PolygonType * poly)
 {
-  fill_polyarea (gc, poly->Clipped, clip_box);
+  fill_polyarea (gc, poly->Clipped);
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
+        fill_polyarea (gc, pa);
     }
 }
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index a4178bd..dce9e92 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -70,14 +70,14 @@ typedef struct hid_draw_class_st
   void (*draw_pcb_line) (hidGC gc, LineType *line);
   void (*draw_pcb_arc) (hidGC gc, ArcType *arc);
   void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
-  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*draw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*draw_pcb_pv) (hidGC gc, PinType *pv, bool mask);
   void (*draw_pcb_pv_hole) (hidGC gc, PinType *pv);
 
   /* The following are not meant to be called outside of the GUI implementations of the above APIs */
-  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly);
+  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*_fill_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_thindraw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_fill_pcb_pv) (hidGC gc, PinType *pv, bool mask);
@@ -246,9 +246,9 @@ hid_draw_pcb_text (hidGC gc, TextType *text, Coord min_width)
 }
 
 inline void
-hid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->draw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->draw_pcb_polygon (gc, poly);
 }
 
 inline void
@@ -271,15 +271,15 @@ hid_draw_pcb_pv_hole (hidGC gc, PinType *pv)
 
 
 inline void
-hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly);
 }
 
 inline void
-hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly);
 }
 
 inline void
