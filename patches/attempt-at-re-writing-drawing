Bottom: 847d456e3ddd47dfbefac8d1a190fb55b588f85e
Top:    7a85ce3eff8e91888bbb04a08631b01f9a3558d7
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-11 15:42:13 +0000

Attempt at re-writing drawing routines to pass state via hidGC

Note, this appears to break clearing out of pin and via holes at the moment
Note, 3D event projection and unprojection is broken
Note, autoroute.c debug drawing cleanup is probably broken (ordering)


---

diff --git a/src/autoroute.c b/src/autoroute.c
index 0b4b9e9..e38247f 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -3673,7 +3673,7 @@ TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
 
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
-    gui->flush_debug_draw ();
+    gui->flush_debug_draw (ar_gc);
 #endif
 }
 
@@ -5333,8 +5333,8 @@ donerouting:
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
     {
+      gui->finish_debug_draw (ar_gc);
       hid_draw_destroy_gc (ar_gc);
-      gui->finish_debug_draw ();
     }
 #endif
 
diff --git a/src/draw.c b/src/draw.c
index 2993fac..c49bc84 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -76,18 +76,17 @@ static BoxType Block = {MAXINT, MAXINT, -MAXINT, -MAXINT};
 
 static int doing_pinout = 0;
 static bool doing_assy = false;
-static HID_DRAW *hid_draw = NULL;
 
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
+static void DrawEverything (hidGC gc);
 static void AddPart (void *);
-/* static */ void DrawEMark (ElementType *, Coord, Coord, bool);
-/* static */ void DrawRats (HID_DRAW *hid_draw, const BoxType *);
+/* static */ void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+/* static */ void DrawRats (hidGC gc);
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -98,7 +97,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 /*---------------------------------------------------------------------------
@@ -138,39 +137,44 @@ Redraw (void)
   gui->invalidate_all ();
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_element_name (ElementType *element)
+draw_element_name (hidGC gc, ElementType *element)
 {
-  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
+  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (gc->hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  hid_draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
+  hid_draw_pcb_text (gc, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -178,42 +182,42 @@ name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  int *side = cl;
+  struct side_info *info = cl;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
     return 0;
 
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_name (info->gc, element);
   return 0;
 }
 
 static void
-draw_element_pins_and_pads (ElementType *element)
+draw_element_pins_and_pads (hidGC gc, ElementType *element)
 {
   PAD_LOOP (element);
   {
     if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
       {
-        set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+        set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                           PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                           FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-        dapi->draw_pad (pad, NULL, NULL);
+        dapi->draw_pad (gc, pad, NULL);
       }
   }
   END_LOOP;
   PIN_LOOP (element);
   {
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
                       PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-    dapi->draw_pin (pin, NULL, NULL);
+    dapi->draw_pin (gc, pin, NULL);
 
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor,
                       PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-    dapi->draw_pin_hole (pin, NULL, NULL);
+    dapi->draw_pin_hole (gc, pin, NULL);
   }
   END_LOOP;
 }
@@ -222,8 +226,9 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -231,39 +236,40 @@ static int
 rat_callback (const BoxType * b, void *cl)
 {
   RatType *rat = (RatType *)b;
+  hidGC gc = cl;
 
-  set_object_color ((AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
+  set_object_color (gc, (AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->RatColor);
 
-  dapi->draw_rat (rat, NULL, NULL);
+  dapi->draw_rat (gc, rat, NULL);
   return 1;
 }
 
 static void
-draw_element_package (ElementType *element)
+draw_element_package (hidGC gc, ElementType *element)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    //hid_draw_pcb_line (Output.fgGC, line);
-    dapi->draw_line (line, NULL, NULL);
+    //hid_draw_pcb_line (gc, line);
+    dapi->draw_line (gc, line, NULL);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    //hid_draw_pcb_arc (Output.fgGC, arc);
-    dapi->draw_arc (arc, NULL, NULL);
+    //hid_draw_pcb_arc (gc, arc);
+    dapi->draw_arc (gc, arc, NULL);
   }
   END_LOOP;
 }
@@ -272,10 +278,10 @@ static int
 element_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_package (info->gc, element);
   return 1;
 }
 
@@ -284,17 +290,17 @@ element_callback (const BoxType * b, void *cl)
  */
 
 void
-PrintAssembly (int side, const BoxType * drawn_area)
+PrintAssembly (hidGC gc, int side)
 {
   int side_group = GetLayerGroupNumberBySide (side);
 
   doing_assy = true;
-  hid_draw_set_draw_faded (Output.fgGC, 1);
-  DrawLayerGroup (side_group, drawn_area);
-  hid_draw_set_draw_faded (Output.fgGC, 0);
+  hid_draw_set_draw_faded (gc, 1);
+  DrawLayerGroup (gc, side_group);
+  hid_draw_set_draw_faded (gc, 0);
 
   /* draw package */
-  DrawSilk (hid_draw, side, drawn_area);
+  DrawSilk (gc, side);
   doing_assy = false;
 }
 
@@ -302,9 +308,9 @@ PrintAssembly (int side, const BoxType * drawn_area)
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
 static void
-DrawEverything (const BoxType *drawn_area)
+DrawEverything (hidGC gc)
 {
-  int i, ngroups, side;
+  int i, ngroups;
   int top_group, bottom_group;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_GROUP];
@@ -312,6 +318,10 @@ DrawEverything (const BoxType *drawn_area)
   int drawn_groups[MAX_GROUP];
   int plated, unplated;
   bool paste_empty;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
 
   PCB->Data->SILKLAYER.Color = PCB->ElementColor;
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
@@ -337,14 +347,14 @@ DrawEverything (const BoxType *drawn_area)
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
       && hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0))
     {
-      side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+      info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-	  dapi->draw_layer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area, NULL);
+	  r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
+	  dapi->draw_layer (gc, &(PCB->Data->Layer[max_copper_layer + info.side]), NULL);
 	}
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -355,7 +365,7 @@ DrawEverything (const BoxType *drawn_area)
 
       if (hid_draw_set_layer (hid_draw, 0, group, 0))
         {
-          DrawLayerGroup (group, drawn_area);
+          DrawLayerGroup (gc, group);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -365,20 +375,20 @@ DrawEverything (const BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (SWAP_IDENT ? bottom_group : top_group, drawn_area, NULL);
+    dapi->draw_ppv (gc, SWAP_IDENT ? bottom_group : top_group, NULL);
   else
     {
-      CountHoles (&plated, &unplated, drawn_area);
+      CountHoles (&plated, &unplated, gc->clip_box);
 
       if (plated && hid_draw_set_layer (hid_draw, "plated-drill", SL (PDRILL, 0), 0))
         {
-          dapi->draw_holes (1, drawn_area, NULL);
+          dapi->draw_holes (gc, 1, NULL);
           hid_draw_end_layer (hid_draw);
         }
 
       if (unplated && hid_draw_set_layer (hid_draw, "unplated-drill", SL (UDRILL, 0), 0))
         {
-          dapi->draw_holes (0, drawn_area, NULL);
+          dapi->draw_holes (gc, 0, NULL);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -386,25 +396,25 @@ DrawEverything (const BoxType *drawn_area)
   /* Draw the solder mask if turned on */
   if (hid_draw_set_layer (hid_draw, "componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (TOP_SIDE, drawn_area);
+      DrawMask (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (BOTTOM_SIDE, drawn_area);
+      DrawMask (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (hid_draw, TOP_SIDE, drawn_area);
+      DrawSilk (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (hid_draw, BOTTOM_SIDE, drawn_area);
+      DrawSilk (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -412,12 +422,11 @@ DrawEverything (const BoxType *drawn_area)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
-		  NULL);
+	r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
       /* Draw rat lines on top */
       if (hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0))
         {
-          DrawRats (hid_draw, drawn_area);
+          DrawRats (gc);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -425,38 +434,38 @@ DrawEverything (const BoxType *drawn_area)
   paste_empty = IsPasteEmpty (TOP_SIDE);
   if (hid_draw_set_layer (hid_draw, "toppaste", SL (PASTE, TOP), paste_empty))
     {
-      DrawPaste (TOP_SIDE, drawn_area);
+      DrawPaste (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
   if (hid_draw_set_layer (hid_draw, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
-      DrawPaste (BOTTOM_SIDE, drawn_area);
+      DrawPaste (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topassembly", SL (ASSY, TOP), 0))
     {
-      PrintAssembly (TOP_SIDE, drawn_area);
+      PrintAssembly (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomassembly", SL (ASSY, BOTTOM), 0))
     {
-      PrintAssembly (BOTTOM_SIDE, drawn_area);
+      PrintAssembly (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "fab", SL (FAB, 0), 0))
     {
-      PrintFab (Output.fgGC);
+      PrintFab (gc);
       hid_draw_end_layer (hid_draw);
     }
 }
 
 /* static */ void
-DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
+DrawEMark (hidGC gc, ElementType *e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -477,14 +486,14 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
-  hid_draw_set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
-  hid_draw_set_line_width (Output.fgGC, 0);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  ghid_set_lock_effects (gc, (AnyObjectType *)e);
+  hid_draw_set_color (gc, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 0);
+  hid_draw_line (gc, X - mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X - mark_size, Y, X, Y + mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -493,22 +502,26 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      hid_draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      hid_draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      hid_draw_line (gc, X, Y, X + 2 * mark_size, Y);
+      hid_draw_line (gc, X, Y, X, Y - 4* mark_size);
     }
 }
 
 static int
 pin_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_pin_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_pin_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
 static int
 via_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_via_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_via_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
@@ -516,9 +529,10 @@ static int
 pad_mask_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side))
-    dapi->draw_pad_mask (pad, NULL, NULL);
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side))
+    dapi->draw_pad_mask (info->gc, pad, NULL);
   return 1;
 }
 
@@ -527,10 +541,12 @@ pad_mask_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (HID_DRAW *new_hid_draw, int side, const BoxType * drawn_area)
+DrawSilk (hidGC gc, int side)
 {
-  HID_DRAW *old_hid_draw = hid_draw;
-  hid_draw = new_hid_draw;
+  struct side_info info;
+
+  info.gc = gc;
+  info.side = side;
 
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
@@ -541,64 +557,57 @@ DrawSilk (HID_DRAW *new_hid_draw, int side, const BoxType * drawn_area)
 #if 0
   if (hid_draw->poly_before)
     {
-      hid_draw_use_mask (hid_draw, HID_MASK_BEFORE);
+      hid_draw_use_mask (gc->hid_draw, HID_MASK_BEFORE);
 #endif
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + side), drawn_area, NULL);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + side), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
 #if 0
     }
 
-  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_mask_callback, &side);
+  hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
 
   if (hid_draw->poly_after)
     {
-      hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + layer), drawn_area, NULL);
+      hid_draw_use_mask (gc, hid_draw, HID_MASK_AFTER);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + layer), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
     }
-  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
+  hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
 #endif
-
-  hid_draw = old_hid_draw;
 }
 
 
 static void
-DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
+DrawMaskBoardArea (hidGC gc, int mask_type)
 {
   /* Skip the mask drawing if the GUI doesn't want this type */
-  if ((mask_type == HID_MASK_BEFORE && !hid_draw->poly_before) ||
-      (mask_type == HID_MASK_AFTER  && !hid_draw->poly_after))
+  if ((mask_type == HID_MASK_BEFORE && !gc->hid_draw->poly_before) ||
+      (mask_type == HID_MASK_AFTER  && !gc->hid_draw->poly_after))
     return;
 
-  hid_draw_use_mask (hid_draw, mask_type);
-  hid_draw_set_color (Output.fgGC, PCB->MaskColor);
-  if (drawn_area == NULL)
-    hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  hid_draw_use_mask (gc->hid_draw, mask_type);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  if (gc->clip_box == NULL)
+    hid_draw_fill_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    hid_draw_fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                     drawn_area->X2, drawn_area->Y2);
+    hid_draw_fill_rect (gc, gc->clip_box->X1, gc->clip_box->Y1,
+                            gc->clip_box->X2, gc->clip_box->Y2);
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 mask_poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  hidGC gc = cl;
 
-  hid_draw_pcb_polygon (Output.pmGC, polygon, i->drawn_area);
+  hid_draw_pcb_polygon (Output.pmGC, polygon);
   return 1;
 }
 
@@ -606,6 +615,7 @@ static int
 mask_line_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_line (Output.pmGC, line);
   return 1;
@@ -615,6 +625,7 @@ static int
 mask_arc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_arc (Output.pmGC, arc);
   return 1;
@@ -623,16 +634,13 @@ mask_arc_callback (const BoxType * b, void *cl)
 static int
 mask_text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  hidGC gc = cl;
   int min_silk_line;
 
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
-    min_silk_line = PCB->minSlk;
-  else
-    min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  min_silk_line = PCB->minSlk;
+
+  hid_draw_pcb_text (gc, text, min_silk_line);
   return 1;
 }
 
@@ -640,37 +648,38 @@ mask_text_callback (const BoxType * b, void *cl)
  * draws solder mask layer - this will cover nearly everything
  */
 void
-DrawMask (int side, const BoxType *screen)
+DrawMask (hidGC gc, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct side_info info;
+
+  info.gc = gc;
+  info.side = side;
 
   if (thin)
     hid_draw_set_color (Output.pmGC, PCB->MaskColor);
   else
     {
-      DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
+      DrawMaskBoardArea (gc, HID_MASK_BEFORE);
+      hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
     }
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, mask_poly_callback, &info);
-  r_search (Layer->line_tree,    screen, NULL, mask_line_callback, Layer);
-  r_search (Layer->arc_tree,     screen, NULL, mask_arc_callback,  Layer);
-  r_search (Layer->text_tree,    screen, NULL, mask_text_callback, Layer);
+  r_search (Layer->polygon_tree, gc->clip_box, NULL, mask_poly_callback, gc);
+  r_search (Layer->line_tree,    gc->clip_box, NULL, mask_line_callback, gc);
+  r_search (Layer->arc_tree,     gc->clip_box, NULL, mask_arc_callback,  gc);
+  r_search (Layer->text_tree,    gc->clip_box, NULL, mask_text_callback, gc);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
 
   if (thin)
     hid_draw_set_color (Output.pmGC, "erase");
   else
     {
-      DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      hid_draw_use_mask (hid_draw, HID_MASK_OFF);
+      DrawMaskBoardArea (gc, HID_MASK_AFTER);
+      hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
     }
 }
 
@@ -678,36 +687,31 @@ DrawMask (int side, const BoxType *screen)
  * draws solder paste layer for a given side of the board
  */
 void
-DrawPaste (int side, const BoxType *drawn_area)
+DrawPaste (hidGC gc, int side)
 {
-  hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+  hid_draw_set_color (gc, PCB->ElementColor);
   ALLPAD_LOOP (PCB->Data);
   {
     if (ON_SIDE (pad, side))
-      dapi->draw_pad_paste (pad, NULL, NULL);
+      dapi->draw_pad_paste (gc, pad, NULL);
   }
   ENDALL_LOOP;
 }
 
 /* static */ void
-DrawRats (HID_DRAW *new_hid_draw, const BoxType *drawn_area)
+DrawRats (hidGC gc)
 {
-  HID_DRAW *old_hid_draw = hid_draw;
-  hid_draw = new_hid_draw;
-
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
    * XXX gtk only allows negative drawing.
    * XXX using the mask here is to get rat transparency
    */
 
-  if (hid_draw_can_draw_in_mask_clear (hid_draw))
-    hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
-  if (hid_draw_can_draw_in_mask_clear (hid_draw))
-    hid_draw_use_mask (hid_draw, HID_MASK_OFF);
-
-  hid_draw = old_hid_draw;
+  if (hid_draw_can_draw_in_mask_clear (gc->hid_draw))
+    hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
+  r_search (PCB->Data->rat_tree, gc->clip_box, NULL, rat_callback, gc);
+  if (hid_draw_can_draw_in_mask_clear (gc->hid_draw))
+    hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
 }
 
 /* ---------------------------------------------------------------------------
@@ -715,7 +719,7 @@ DrawRats (HID_DRAW *new_hid_draw, const BoxType *drawn_area)
  * also draws the pins / pads / vias in this layer group.
  */
 void
-DrawLayerGroup (int group, const BoxType *drawn_area)
+DrawLayerGroup (hidGC gc, int group)
 {
   int i, rv = 1;
   int layernum;
@@ -731,13 +735,13 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
           strcmp (Layer->Name, "route") == 0)
         rv = 0;
       if (layernum < max_copper_layer && Layer->On)
-        dapi->draw_layer (Layer, drawn_area, NULL);
+        dapi->draw_layer (gc, Layer, NULL);
     }
   if (n_entries > 1)
     rv = 1;
 
-  if (rv && !hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (group, drawn_area, NULL);
+  if (rv && !hid_draw_is_gui (gc->hid_draw))
+    dapi->draw_ppv (gc, group, NULL);
 }
 
 static void
@@ -1244,11 +1248,11 @@ DrawObject (int type, void *ptr1, void *ptr2)
 }
 
 static void
-draw_element (ElementType *element)
+draw_element (hidGC gc, ElementType *element)
 {
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
+  draw_element_package (gc, element);
+  draw_element_name (gc, element);
+  draw_element_pins_and_pads (gc, element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1256,10 +1260,11 @@ draw_element (ElementType *element)
  */
 
 void
-hid_expose_callback (HID_DRAW *expose_hid_draw, BoxType *region, void *item)
+hid_expose_callback (HID_DRAW *hid_draw, void *item)
 {
-  hid_draw = expose_hid_draw;
-  Output.fgGC = hid_draw_make_gc (hid_draw);
+  hidGC gc;
+
+  gc = hid_draw_make_gc (hid_draw);
   Output.bgGC = hid_draw_make_gc (hid_draw);
   Output.pmGC = hid_draw_make_gc (hid_draw);
 
@@ -1269,13 +1274,13 @@ hid_expose_callback (HID_DRAW *expose_hid_draw, BoxType *region, void *item)
   if (item)
     {
       doing_pinout = true;
-      draw_element ((ElementType *)item);
+      draw_element (gc, (ElementType *)item);
       doing_pinout = false;
     }
   else
-    DrawEverything (region);
+    DrawEverything (gc);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
   hid_draw = NULL;
diff --git a/src/draw.h b/src/draw.h
index e0688ee..e49e39f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -66,22 +66,22 @@ void EraseElementPinsAndPads (ElementType *);
 void EraseElementName (ElementType *);
 void EraseObject (int, void *, void *);
 
-void DrawLayerGroup (int side, const BoxType *drawn_area);
-void DrawPaste (int side, const BoxType *drawn_area);
-void DrawSilk (HID_DRAW *hid_draw, int side, const BoxType *drawn_area);
-void DrawMask (int side, const BoxType *drawn_area);
-void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
-void PrintAssembly (int side, const BoxType *drawn_area);
+void DrawLayerGroup (hidGC gc, int side);
+void DrawPaste (hidGC gc, int side);
+void DrawSilk (hidGC gc, int side);
+void DrawMask (hidGC gc, int side);
+void DrawHoles (hidGC gc, bool draw_plated, bool draw_unplated);
+void PrintAssembly (hidGC gc, int side);
 
 /* TEMPORARY */
-void ClearPad (PadType *, bool);
-void DrawPinOrViaLowLevel (PinType *, bool);
-void DrawPlainPin (PinType *, bool);
-void DrawPlainVia (PinType *, bool);
-void DrawRegularText (LayerType *, TextType *);
-void DrawEMark (ElementType *, Coord, Coord, bool);
-void DrawHole (PinType *);
-void DrawRats (HID_DRAW *hid_draw, const BoxType *);
+//void ClearPad (hidGC gc, PadType *, bool);
+//void DrawPinOrViaLowLevel (hidGC gc, PinType *, bool);
+//void DrawPlainPin (hidGC gc, PinType *, bool);
+//void DrawPlainVia (hidGC gc, PinType *, bool);
+//void DrawRegularText (hidGC gc, LayerType *, TextType *);
+void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+//void DrawHole (hidGC gc, PinType *);
+void DrawRats (hidGC gc);
 /* TEMPORARY */
 
 #endif
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index af411f7..b47e1ff 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -10,41 +10,41 @@
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
 static void
-draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin (hidGC gc, PinType *pin, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, pin, false);
+  hid_draw_pcb_pv (gc, pin, false);
 }
 
 static void
-draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin_mask (hidGC gc, PinType *pin, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, pin, true);
 }
 
 static void
-draw_via (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via (hidGC gc, PinType *via, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, via, false);
+  hid_draw_pcb_pv (gc, via, false);
 }
 
 static void
-draw_via_mask (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via_mask (hidGC gc, PinType *via, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, via, true);
 }
 
 static void
-draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+draw_hole (hidGC gc, PinType *pv, void *userdata)
 {
   if (!TEST_FLAG (THINDRAWFLAG, PCB))
     hid_draw_fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
     {
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
 
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
 }
 
@@ -58,13 +58,13 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad (hidGC gc, PadType *pad, void *userdata)
 {
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_mask (hidGC gc, PadType *pad, void *userdata)
 {
   if (pad->Mask <= 0)
     return;
@@ -73,25 +73,25 @@ draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
 }
 
 static void
-draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_paste (hidGC gc, PadType *pad, void *userdata)
 {
   if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
     return;
 
   if (pad->Mask < pad->Thickness)
-    _draw_pad (Output.fgGC, pad, true, true);
+    _draw_pad (gc, pad, true, true);
   else
-    _draw_pad (Output.fgGC, pad, false, false);
+    _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+draw_line (hidGC gc, LineType *line, void *userdata)
 {
-  hid_draw_pcb_line (Output.fgGC, line);
+  hid_draw_pcb_line (gc, line);
 }
 
 static void
-draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+draw_rat (hidGC gc, RatType *rat, void *userdata)
 {
   if (Settings.RatThickness < 100)
     rat->Thickness = pixel_slop * Settings.RatThickness;
@@ -101,29 +101,29 @@ draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        hid_draw_set_line_width (Output.fgGC, 0);
+        hid_draw_set_line_width (gc, 0);
       else
-        hid_draw_set_line_width (Output.fgGC, w);
-      hid_draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
+        hid_draw_set_line_width (gc, w);
+      hid_draw_arc (gc, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    hid_draw_pcb_line (Output.fgGC, (LineType *) rat);
+    hid_draw_pcb_line (gc, (LineType *) rat);
 }
 
 static void
-draw_arc (ArcType *arc, const BoxType *drawn_area, void *userdata)
+draw_arc (hidGC gc, ArcType *arc, void *userdata)
 {
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  hid_draw_pcb_arc (gc, arc);
 }
 
 static void
-draw_poly (PolygonType *polygon, const BoxType *drawn_area, void *userdata)
+draw_poly (hidGC gc, PolygonType *polygon, void *userdata)
 {
-  hid_draw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  hid_draw_pcb_polygon (gc, polygon);
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -134,142 +134,153 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
+struct layer_info {
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  dapi->draw_line (line, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  dapi->draw_line (info->gc, line, NULL);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  dapi->draw_arc (arc, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  dapi->draw_arc (info->gc, arc, NULL);
   return 1;
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  dapi->draw_poly (info->gc, polygon, NULL);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                             : PCB->PinSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                   hid_draw_set_color (Output.fgGC, layer->Color);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                    : PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (gc, PCB->ConnectedColor);
+  else                                   hid_draw_set_color (gc, layer->Color);
 }
 
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, PIN_TYPE);
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, PIN_TYPE);
+  dapi->draw_pin (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, VIA_TYPE);
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, VIA_TYPE);
+  dapi->draw_via (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
+struct side_info {
+  hidGC gc;
+  LayerType *layer;
+  int side;
+};
+
 static int
 pad_inlayer_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *)b;
-  LayerType *layer = cl;
-  int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int group = GetLayerGroupNumberByPointer (layer);
+  struct side_info *info = cl;
 
-  int side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
-
-  if (ON_SIDE (pad, side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (Output.fgGC, PCB->PinSelectedColor);
-      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-      else                                    hid_draw_set_color (Output.fgGC, layer->Color);
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (info->gc, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (info->gc, PCB->PinSelectedColor);
+      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (info->gc, PCB->ConnectedColor);
+      else                                    hid_draw_set_color (info->gc, info->layer->Color);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
+struct hole_info {
+  hidGC gc;
+  int plated;
+};
+
 static int
 pin_hole_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)pin);
+  set_object_color (info->gc, (AnyObjectType *) pin, PCB->WarnColor,
                     PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_pin_hole (pin, NULL, NULL);
+  dapi->draw_pin_hole (info->gc, pin, NULL);
   return 1;
 }
 
@@ -277,41 +288,45 @@ static int
 via_hole_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)via);
+  set_object_color (info->gc, (AnyObjectType *) via, PCB->WarnColor,
                     PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_via_hole (via, NULL, NULL);
+  dapi->draw_via_hole (info->gc, via, NULL);
   return 1;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  dapi->draw_pin (gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  dapi->draw_via (gc, (PinType *)b, NULL);
   return 1;
 }
 
@@ -319,91 +334,106 @@ static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_ppv (int group, const BoxType *drawn_area, void *userdata)
+draw_ppv (hidGC gc, int group, void *userdata)
 {
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int side;
 
   if (PCB->PinOn || !gui->gui)
     {
+      struct side_info info;
+
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+
+      info.gc = gc;
+      info.layer = NULL; /* Nasty, but saves creating a load of different info types */
 
       /* draw element pads */
       if (group == top_group)
         {
-          side = TOP_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = TOP_SIDE;
+          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
         }
 
       if (group == bottom_group)
         {
-          side = BOTTOM_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = BOTTOM_SIDE;
+          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
 
-  dapi->draw_holes (-1, drawn_area, NULL);
+  dapi->draw_holes (gc, -1, NULL);
 }
 
 static void
-draw_holes (int plated, const BoxType *drawn_area, void *userdata)
+draw_holes (hidGC gc, int plated, void *userdata)
 {
+  struct hole_info info;
+
+  info.gc = gc;
+  info.plated = plated;
+
   if (PCB->PinOn)
-    r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, &plated);
+    r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &info);
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, &plated);
+    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &info);
 }
 
 static void
-draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+draw_layer (hidGC gc, LayerType *layer, void *userdata)
 {
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int layer_num = GetLayerNumber (PCB->Data, layer);
   int group = GetLayerGroupNumberByPointer (layer);
-  struct poly_info info = {drawn_area, layer};
   bool is_outline;
+  struct hole_info h_info;
+  struct layer_info l_info;
+
+  h_info.gc = gc;
+  h_info.plated = -1; /* Draw both plated and unplated holes */
+  l_info.gc = gc;
+  l_info.layer = layer;
 
   is_outline = strcmp (layer->Name, "outline") == 0 ||
                strcmp (layer->Name, "route") == 0;
 
   if (layer_num < max_copper_layer && !is_outline)
     {
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, NULL);
-      r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &h_info);
+      r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &h_info);
     }
 
   /* print the non-clearing polys */
-  r_search (layer->polygon_tree, drawn_area, NULL, poly_callback, &info);
+  r_search (layer->polygon_tree, gc->clip_box, NULL, poly_callback, &l_info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
   /* draw all visible lines this layer */
-  r_search (layer->line_tree, drawn_area, NULL, line_callback, layer);
-  r_search (layer->arc_tree,  drawn_area, NULL, arc_callback,  layer);
-  r_search (layer->text_tree, drawn_area, NULL, text_callback, layer);
+  r_search (layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+  r_search (layer->arc_tree,  gc->clip_box, NULL, arc_callback,  &l_info);
+  r_search (layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
@@ -413,9 +443,9 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
     {
       if (IsLayerEmpty (layer))
         {
-          hid_draw_set_color (Output.fgGC, layer->Color);
-          hid_draw_set_line_width (Output.fgGC, PCB->minWid);
-          hid_draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+          hid_draw_set_color (gc, layer->Color);
+          hid_draw_set_line_width (gc, PCB->minWid);
+          hid_draw_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
         }
       return;
     }
@@ -428,17 +458,22 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
   if (!gui->gui)
     return;
 
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_inlayer_callback, layer);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
 
   /* draw element pads */
-  if (group == top_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+  if (group == top_group ||
+      group == bottom_group)
+    {
+      struct side_info s_info;
 
-  if (group == bottom_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+      s_info.gc = gc;
+      s_info.layer = layer;
+      s_info.side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_inlayer_callback, &s_info);
+    }
 
   /* draw vias */
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_inlayer_callback, layer);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
 }
 
 struct draw_funcs d_f = {
diff --git a/src/draw_funcs.h b/src/draw_funcs.h
index ba4982d..677b397 100644
--- a/src/draw_funcs.h
+++ b/src/draw_funcs.h
@@ -1,20 +1,20 @@
 struct draw_funcs {
-  void (*draw_pin)       (PinType *,     const BoxType *, void *);
-  void (*draw_pin_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_pin_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_via)       (PinType *,     const BoxType *, void *);
-  void (*draw_via_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_via_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_pad)       (PadType *,     const BoxType *, void *);
-  void (*draw_pad_mask)  (PadType *,     const BoxType *, void *);
-  void (*draw_pad_paste) (PadType *,     const BoxType *, void *);
-  void (*draw_line)      (LineType *,    const BoxType *, void *);
-  void (*draw_rat)       (RatType *,     const BoxType *, void *);
-  void (*draw_arc)       (ArcType *,     const BoxType *, void *);
-  void (*draw_poly)      (PolygonType *, const BoxType *, void *);
-  void (*draw_ppv)       (int,           const BoxType *, void *);
-  void (*draw_holes)     (int,           const BoxType *, void *);
-  void (*draw_layer)     (LayerType *,   const BoxType *, void *);
+  void (*draw_pin)       (hidGC, PinType *,     void *);
+  void (*draw_pin_mask)  (hidGC, PinType *,     void *);
+  void (*draw_pin_hole)  (hidGC, PinType *,     void *);
+  void (*draw_via)       (hidGC, PinType *,     void *);
+  void (*draw_via_mask)  (hidGC, PinType *,     void *);
+  void (*draw_via_hole)  (hidGC, PinType *,     void *);
+  void (*draw_pad)       (hidGC, PadType *,     void *);
+  void (*draw_pad_mask)  (hidGC, PadType *,     void *);
+  void (*draw_pad_paste) (hidGC, PadType *,     void *);
+  void (*draw_line)      (hidGC, LineType *,    void *);
+  void (*draw_rat)       (hidGC, RatType *,     void *);
+  void (*draw_arc)       (hidGC, ArcType *,     void *);
+  void (*draw_poly)      (hidGC, PolygonType *, void *);
+  void (*draw_ppv)       (hidGC, int,           void *);
+  void (*draw_holes)     (hidGC, int,           void *);
+  void (*draw_layer)     (hidGC, LayerType *,   void *);
 };
 
 extern struct draw_funcs *dapi;
diff --git a/src/global.h b/src/global.h
index b36aebf..050d804 100644
--- a/src/global.h
+++ b/src/global.h
@@ -182,8 +182,7 @@ typedef struct
  */
 typedef struct			/* holds information about output window */
 {
-  hidGC bgGC,			/* background and foreground; */
-    fgGC,			/* changed from some routines */
+  hidGC bgGC,			/* background GC */
     pmGC;			/* depth 1 pixmap GC to store clip */
 }
 OutputType;
diff --git a/src/hid.h b/src/hid.h
index 5059273..c5ba6d4 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -472,13 +472,13 @@ typedef enum
      * May be implemented as a NOOP if the GUI has chosen to send the
      * debug drawing directly to the screen.
      */
-    void (*flush_debug_draw)   (void);
+    void (*flush_debug_draw)   (hidGC gc);
 
     /* When finished, the user must inform the GUI to clean up resources
      *
      * Any remaining rendering will be flushed to the screen.
      */
-    void (*finish_debug_draw)  (void);
+    void (*finish_debug_draw)  (hidGC gc);
 
     /* Notification to the GUI around saving the PCB file.
      *
@@ -533,7 +533,7 @@ typedef enum
    Do *not* assume that the hid that is passed is the GUI hid.  This
    callback is also used for printing and exporting. */
   struct BoxType;
-  void hid_expose_callback (HID_DRAW *hid_draw, struct BoxType *region_, void *item_);
+  void hid_expose_callback (HID_DRAW *hid_draw, void *item_);
 
 /* This is initially set to a "no-gui" gui, and later reset by
    main. hid_expose_callback also temporarily set it for drawing. */
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index f4de2c0..4a3952c 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -7,6 +7,20 @@
 #include "draw_helpers.h"
 
 
+/* Takes a copy of clip_box so we own it */
+void
+common_set_clip_box (HID_DRAW *graphics, BoxType *clip_box)
+{
+  free (graphics->clip_box);
+  graphics->clip_box = NULL;
+
+  if (clip_box == NULL)
+    return;
+
+  graphics->clip_box = malloc (sizeof (BoxType));
+  *graphics->clip_box = *clip_box;
+}
+
 static void
 common_draw_pcb_line (hidGC gc, LineType *line)
 {
@@ -189,7 +203,7 @@ fill_contour_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
+fill_clipped_contour (hidGC gc, PLINE *pl)
 {
   PLINE *pl_copy;
   POLYAREA *clip_poly;
@@ -198,8 +212,8 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
   POLYAREA *draw_piece;
   int x;
 
-  clip_poly = RectPoly (clip_box->X1, clip_box->X2,
-                        clip_box->Y1, clip_box->Y2);
+  clip_poly = RectPoly (gc->clip_box->X1, gc->clip_box->X2,
+                        gc->clip_box->Y1, gc->clip_box->Y2);
   poly_CopyContour (&pl_copy, pl);
   piece_poly = poly_Create ();
   poly_InclContour (piece_poly, pl_copy);
@@ -223,20 +237,20 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
  */
 #define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
 static int
-should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
+should_compute_no_holes (hidGC gc, PolygonType *poly)
 {
   Coord x1, x2, y1, y2;
   double poly_bounding_area;
   double clipped_poly_area;
 
   /* If there is no passed clip box, compute the whole thing */
-  if (clip_box == NULL)
+  if (gc->clip_box == NULL)
     return 1;
 
-  x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, clip_box->Y2);
+  x1 = MAX (poly->BoundingBox.X1, gc->clip_box->X1);
+  x2 = MIN (poly->BoundingBox.X2, gc->clip_box->X2);
+  y1 = MAX (poly->BoundingBox.Y1, gc->clip_box->Y1);
+  y2 = MIN (poly->BoundingBox.Y2, gc->clip_box->Y2);
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
@@ -255,15 +269,15 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
 void
-common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon)
 {
   if (polygon->Clipped == NULL)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    hid_draw__thin_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__thin_pcb_polygon (gc, polygon);
   else
-    hid_draw__fill_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__fill_pcb_polygon (gc, polygon);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
@@ -273,12 +287,12 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        hid_draw__thin_pcb_polygon (gc, &poly, clip_box);
+        hid_draw__thin_pcb_polygon (gc, &poly);
     }
 }
 
 void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   if (poly->Clipped == NULL)
     return;
@@ -289,10 +303,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
        * NoHoles version and cache it for later rendering, otherwise
        * just compute what we need to render now.
        */
-      if (should_compute_no_holes (poly, clip_box))
+      if (should_compute_no_holes (gc, poly))
         ComputeNoHoles (poly);
       else
-        NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (poly, gc->clip_box, fill_contour_cb, gc);
     }
   if (poly->NoHolesValid && poly->NoHoles)
     {
@@ -300,10 +314,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
         {
-          if (clip_box == NULL)
+          if (gc->clip_box == NULL)
             fill_contour (gc, pl);
           else
-            fill_clipped_contour (gc, pl, clip_box);
+            fill_clipped_contour (gc, pl);
         }
     }
 
@@ -316,7 +330,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
       for (p.Clipped = poly->Clipped->f;
            p.Clipped != poly->Clipped;
            p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (&p, gc->clip_box, fill_contour_cb, gc);
     }
 }
 
@@ -329,14 +343,13 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
 }
 
 void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   if (poly->Clipped == NULL)
     return;
 
   thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
+  PolygonHoles (poly, gc->clip_box, thindraw_hole_cb, gc);
 
   /* Draw other parts of the polygon if fullpoly flag is set */
   if (TEST_FLAG (FULLPOLYFLAG, poly))
@@ -348,7 +361,7 @@ common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
            p.Clipped = p.Clipped->f)
         {
           thindraw_contour (gc, p.Clipped->contours);
-          PolygonHoles (&p, clip_box, thindraw_hole_cb, gc);
+          PolygonHoles (&p, gc->clip_box, thindraw_hole_cb, gc);
         }
     }
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 4fca617..1c13d34 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -1,6 +1,6 @@
-void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly);
 void common_gui_draw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
@@ -12,3 +12,4 @@ void common_thindraw_pcb_pv (hidGC gc, PinType *pv, bool mask);
 void common_thindraw_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_draw_helpers_class_init (HID_DRAW_CLASS *klass);
 void common_draw_helpers_init (HID_DRAW *graphics);
+void common_set_clip_box (HID_DRAW *graphics, BoxType *clip_box);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 3838864..93c467d 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -210,11 +210,15 @@ hid_extents_init (void)
 BoxType *
 hid_get_extents (void *item)
 {
+  hidGC gc;
   BoxType region;
 
   /* As this isn't a real "HID", we need to ensure we are initialised. */
   hid_extents_init ();
 
+#warning NULL gc
+  gc = NULL;
+
   box.X1 = COORD_MAX;
   box.Y1 = COORD_MAX;
   box.X2 = -COORD_MAX - 1;
@@ -224,7 +228,9 @@ hid_get_extents (void *item)
   region.Y1 = -COORD_MAX - 1;
   region.X2 = COORD_MAX;
   region.Y2 = COORD_MAX;
-  hid_expose_callback (&extents_graphics, &region, item);
+
+  common_set_clip_box (&extents_graphics, &region);
+  hid_expose_callback (&extents_graphics, item);
 
   return &box;
 }
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..ca0bcc7 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -130,9 +130,9 @@ static bool in_context = false;
 
 /* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
-hidgl_reset_triangle_array (hidgl_instance *hidgl)
+hidgl_reset_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     /* Hint to the driver that we're done with the previous buffer contents */
@@ -158,9 +158,9 @@ hidgl_reset_triangle_array (hidgl_instance *hidgl)
 }
 
 static void
-hidgl_init_triangle_array (hidgl_instance *hidgl)
+hidgl_init_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -193,9 +193,9 @@ hidgl_init_triangle_array (hidgl_instance *hidgl)
 }
 
 static void
-hidgl_finish_triangle_array (hidgl_instance *hidgl)
+hidgl_finish_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
@@ -212,9 +212,9 @@ hidgl_finish_triangle_array (hidgl_instance *hidgl)
 }
 
 void
-hidgl_flush_triangles (hidgl_instance *hidgl)
+hidgl_flush_triangles (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   GLfloat *data_pointer = NULL;
 
   CHECK_IS_IN_CONTEXT ();
@@ -260,8 +260,8 @@ void
 hidgl_ensure_vertex_space (hidGC gc, int count)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -286,7 +286,7 @@ hidgl_ensure_triangle_space (hidGC gc, int count)
 }
 
 void
-hidgl_set_depth (hidGC gc, float depth)
+hidgl_set_depth (HID_DRAW *hid_draw, float depth)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
@@ -294,7 +294,7 @@ hidgl_set_depth (hidGC gc, float depth)
 }
 
 void
-hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
+hidgl_draw_grid (hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
@@ -306,10 +306,10 @@ hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth,  drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, gc->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, gc->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  gc->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, gc->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -753,6 +753,7 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 
   myFreeCombined ();
   free (vertices);
+  tesselator_gc = NULL;
 }
 
 static inline void
@@ -774,8 +775,8 @@ fill_contour (hidGC gc, PLINE *contour)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 #if MEMCPY_VERTEX_DATA
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 #endif
   int i;
   int vertex_comp;
@@ -913,11 +914,11 @@ polygon_contains_user_holes (PolygonType *polygon)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
+fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
@@ -970,20 +971,19 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, gc);
+  r_search (pa->contour_tree, gc->clip_box, NULL, do_hole, gc);
   hidgl_flush_triangles (hidgl);
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
-
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
+  glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                       /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);        /* This allows us to toggle the bit on the subcompositing bitplane */
+                                                    /* If the stencil test has passed, we know that bit is 0, so we're */
+                                                    /* effectively just setting it to 1. */
+  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);/* Pass stencil test if all assigned bits clear, */
+                                                    /* reference is all assigned bits so we set */
+                                                    /* any bits permitted by the stencil writemask */
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
@@ -999,7 +999,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
 }
 
 void
-hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   bool use_new_stencil;
 
@@ -1009,14 +1009,14 @@ hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
   use_new_stencil = polygon_contains_user_holes (poly) ||
                     TEST_FLAG (FULLPOLYFLAG, poly);
 
-  fill_polyarea (gc, poly->Clipped, clip_box, use_new_stencil);
+  fill_polyarea (gc, poly->Clipped, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box, use_new_stencil);
+        fill_polyarea (gc, pa, use_new_stencil);
     }
 }
 
@@ -1136,15 +1136,15 @@ hidgl_init (void)
   called = true;
 }
 
-hidgl_instance *
+HID_DRAW *
 hidgl_new_instance (void)
 {
-  hidgl_instance *hidgl;
+  HID_DRAW *hid_draw;
   hidgl_priv *priv;
 
-  hidgl = calloc (1, sizeof (hidgl_instance));
+  hid_draw = calloc (1, sizeof (*hid_draw));
   priv = calloc (1, sizeof (hidgl_priv));
-  hidgl->priv = priv;
+  hid_draw->priv = priv;
 
 #if 0
   glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
@@ -1166,24 +1166,23 @@ hidgl_new_instance (void)
 #endif
 //  hidgl_init_triangle_array (hidgl);
 
-  return hidgl;
+  return hid_draw;
 }
 
 void
-hidgl_free_instance (hidgl_instance *hidgl)
+hidgl_free_instance (HID_DRAW *hid_draw)
 {
-  free (hidgl->priv);
-  free (hidgl);
+  free (hid_draw->priv);
+  free (hid_draw);
 }
 
 void
-hidgl_init_gc (hidgl_instance *hidgl, hidGC gc)
+hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_gc->hidgl = hidgl;
   hidgl_gc->depth = 0.0;
 }
 
@@ -1193,9 +1192,9 @@ hidgl_finish_gc (hidGC gc)
 }
 
 void
-hidgl_start_render (hidgl_instance *hidgl)
+hidgl_start_render (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   static bool called = false;
 
   if (in_context)
@@ -1235,28 +1234,28 @@ hidgl_start_render (hidgl_instance *hidgl)
 }
 
 void
-hidgl_finish_render (hidgl_instance *hidgl)
+hidgl_finish_render (HID_DRAW *hid_draw)
 {
   if (!in_context)
     fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
 
-  hidgl_finish_triangle_array (hidgl);
+  hidgl_finish_triangle_array (hid_draw);
   hidgl_shader_activate (NULL);
   in_context = false;
 }
 
 int
-hidgl_stencil_bits (hidgl_instance *hidgl)
+hidgl_stencil_bits (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   return priv->stencil_bits;
 }
 
 static void
-hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
+hidgl_clean_unassigned_stencil (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -1268,9 +1267,9 @@ hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
 }
 
 int
-hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
+hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   int stencil_bitmask = (1 << priv->stencil_bits) - 1;
   int test;
@@ -1307,17 +1306,17 @@ hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
 }
 
 void
-hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit)
+hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits &= ~bit;
 }
 
 void
-hidgl_reset_stencil_usage (hidgl_instance *hidgl)
+hidgl_reset_stencil_usage (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits = 0;
   priv->dirty_bits = 0;
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index e2d7f67..8f353f2 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -52,18 +52,11 @@ typedef struct {
 
 } hidgl_priv;
 
-/* NB: hidgl_instance is a public type, intended to be used as an opaque pointer */
-typedef struct {
-  hidgl_priv *priv;
-
-} hidgl_instance;
 
 /* NB: hidglGC is a semi-private type, only defined here to enable inlining of geometry creation, and for derived GUIs to extend */
 typedef struct hidgl_gc_struct {
   struct hid_gc_struct gc; /* Parent */
 
-  hidgl_instance *hidgl;
-
   float depth;
 
 } *hidglGC;
@@ -71,7 +64,7 @@ typedef struct hidgl_gc_struct {
 extern hidgl_shader *circular_program;
 extern hidgl_shader *resistor_program;
 
-void hidgl_flush_triangles (hidgl_instance *hidgl);
+void hidgl_flush_triangles (HID_DRAW *hid_draw);
 void hidgl_ensure_vertex_space (hidGC gc, int count);
 void hidgl_ensure_triangle_space (hidGC gc, int count);
 
@@ -81,9 +74,8 @@ hidgl_add_vertex_3D_tex (hidGC gc,
                          GLfloat x, GLfloat y, GLfloat z,
                          GLfloat s, GLfloat t)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x;
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y;
@@ -155,27 +147,27 @@ hidgl_add_triangle (hidGC gc,
                              x3, y3, hidgl_gc->depth);
 }
 
-void hidgl_draw_grid (hidGC gc, BoxType *drawn_area);
-void hidgl_set_depth (hidGC gc, float depth);
+void hidgl_draw_grid (hidGC gc);
+void hidgl_set_depth (HID_DRAW *hid_draw, float depth);
 void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
 void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
 void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr);
 void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly);
 void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
-hidgl_instance *hidgl_new_instance (void);
-void hidgl_free_instance (hidgl_instance *hidgl);
-void hidgl_init_gc (hidgl_instance *hidgl, hidGC gc);
+HID_DRAW *hidgl_new_instance (void);
+void hidgl_free_instance (HID_DRAW *hid_draw);
+void hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc);
 void hidgl_finish_gc (hidGC gc);
-void hidgl_start_render (hidgl_instance *hidgl);
-void hidgl_finish_render (hidgl_instance *hidgl);
-int hidgl_stencil_bits (hidgl_instance *hidgl);
-int hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl);
-void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
-void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
+void hidgl_start_render (HID_DRAW *hid_draw);
+void hidgl_finish_render (HID_DRAW *hid_draw);
+int hidgl_stencil_bits (HID_DRAW *hid_draw);
+int hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw);
+void hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit);
+void hidgl_reset_stencil_usage (HID_DRAW *hid_draw);
 
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 127d204..6bd2834 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -143,7 +143,7 @@ nogui_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   CRASH;
 }
@@ -425,12 +425,12 @@ nogui_request_debug_draw (void)
 }
 
 static void
-nogui_flush_debug_draw (void)
+nogui_flush_debug_draw (hidGC gc)
 {
 }
 
 static void
-nogui_finish_debug_draw (void)
+nogui_finish_debug_draw (hidGC gc)
 {
 }
 
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index a81ebb1..c0f8b4a 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -467,10 +467,12 @@ gcode_start_png_export ()
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+
   linewidth = -1;
   lastbrush = (gdImagePtr)((void *) -1);
 
-  hid_expose_callback (&gcode_graphics, &region, 0);
+  common_set_clip_box (&gcode_graphics, &region);
+  hid_expose_callback (&gcode_graphics, 0);
 }
 
 static FILE *
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index fed47bc..d815a0c 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -676,17 +676,20 @@ gerber_do_export (HID_Attr_Val * options)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
   pagecount = 1;
   resetApertures ();
 
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_graphics, &region, 0);
+  hid_expose_callback (&gerber_graphics, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_graphics, &region, 0);
+  hid_expose_callback (&gerber_graphics, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
@@ -910,12 +913,12 @@ gerber_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       && strcmp (name, "outline")
       && strcmp (name, "route"))
     {
+      hidGC gc = hid_draw_make_gc (&gerber_graphics);
       if (outline_layer
 	  && outline_layer != PCB->Data->Layer+idx)
-	dapi->draw_layer (outline_layer, &region, NULL);
+	dapi->draw_layer (gc, outline_layer, NULL);
       else if (!outline_layer)
 	{
-	  hidGC gc = hid_draw_make_gc (&gerber_graphics);
 	  printf("name %s idx %d\n", name, idx);
 	  if (SL_TYPE (idx) == SL_SILK)
 	    hid_draw_set_line_width (gc, PCB->minSlk);
@@ -927,8 +930,8 @@ gerber_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 	  hid_draw_line (gc, 0, 0, 0, PCB->MaxHeight);
 	  hid_draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
 	  hid_draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  hid_draw_destroy_gc (gc);
 	}
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 332a0a2..8dce980 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -816,6 +816,9 @@ redraw_region (GdkRectangle *rect)
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
+#warning NULL gc
+//  common_set_clip_box (NULL, &region);
+
   eleft = Vx (0);
   eright = Vx (PCB->MaxWidth);
   etop = Vy (0);
@@ -860,7 +863,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_graphics, &region, 0);
+  hid_expose_callback (&ghid_graphics, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1238,7 +1241,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
+  hid_expose_callback (&ghid_graphics, pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1295,7 +1298,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_graphics, &region, NULL);
+  common_set_clip_box (&ghid_graphics, &region);
+  hid_expose_callback (&ghid_graphics, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1314,16 +1318,16 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   ghid_screen_update ();
   gdk_flush ();
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  ghid_flush_debug_draw ();
+  ghid_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index f0915f7..862db7f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -55,8 +55,6 @@ extern HID ghid_hid;
 extern HID_DRAW ghid_graphics;
 extern HID_DRAW_CLASS ghid_graphics_class;
 
-static hidGC current_gc = NULL;
-
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
@@ -95,7 +93,7 @@ typedef struct render_priv {
   Coord lead_user_x;
   Coord lead_user_y;
 
-  hidgl_instance *hidgl;
+  HID_DRAW *hid_draw;
   GList *active_gc_list;
   double edit_depth;
 
@@ -238,18 +236,18 @@ compute_depth (int group)
 }
 
 static void
-start_subcomposite (hidgl_instance *hidgl)
+start_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
   int stencil_bit;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
 
-  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);       /* Get a new (clean) bitplane to stencil with */
+  stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);    /* Get a new (clean) bitplane to stencil with */
   glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
   glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
 
@@ -257,14 +255,14 @@ start_subcomposite (hidgl_instance *hidgl)
 }
 
 static void
-end_subcomposite (hidgl_instance *hidgl)
+end_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
-  hidgl_return_stencil_bit (hidgl, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (hid_draw, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
 
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
@@ -273,21 +271,6 @@ end_subcomposite (hidgl_instance *hidgl)
   priv->subcomposite_stencil_bit = 0;
 }
 
-static void
-set_depth_on_all_active_gc (render_priv *priv, float depth)
-{
-  GList *iter;
-
-  for (iter = priv->active_gc_list;
-       iter != NULL;
-       iter = g_list_next (iter))
-    {
-      hidGC gc = iter->data;
-
-      hidgl_set_depth (gc, depth);
-    }
-}
-
 /* Compute group visibility based upon on copper layers only */
 static bool
 is_layer_group_visible (int group)
@@ -307,7 +290,6 @@ int
 ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   bool group_visible = false;
   bool subcomposite = true;
 
@@ -352,24 +334,21 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 	}
     }
 
-  end_subcomposite (hidgl);
+  end_subcomposite (hid_draw);
 
   if (group_visible && subcomposite)
-    start_subcomposite (hidgl);
+    start_subcomposite (hid_draw);
 
   /* Drawing is already flushed by {start,end}_subcomposite */
-  set_depth_on_all_active_gc (priv, compute_depth (group));
+  hidgl_set_depth (hid_draw, compute_depth (group));
 
   return group_visible;
 }
 
 static void
-ghid_end_layer ()
+ghid_end_layer (HID_DRAW *graphics)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
-
-  end_subcomposite (hidgl);
+  end_subcomposite (graphics);
 }
 
 void
@@ -384,7 +363,7 @@ ghid_destroy_gc (hidGC gc)
 }
 
 hidGC
-ghid_make_gc (void)
+ghid_make_gc (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
   hidGC gc = (hidGC) g_new0 (struct gtk_gc_struct, 1);
@@ -393,7 +372,7 @@ ghid_make_gc (void)
   gc->hid = &ghid_hid;
   gc->hid_draw = &ghid_graphics;
 
-  hidgl_init_gc (priv->hidgl, gc);
+  hidgl_init_gc (hid_draw, gc);
 
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
@@ -406,7 +385,7 @@ ghid_make_gc (void)
 }
 
 static void
-ghid_draw_grid (hidGC gc, BoxType *drawn_area)
+ghid_draw_grid (hidGC gc)
 {
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
@@ -428,7 +407,7 @@ ghid_draw_grid (hidGC gc, BoxType *drawn_area)
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  hidgl_draw_grid (gc, drawn_area);
+  hidgl_draw_grid (gc);
 
   glDisable (GL_COLOR_LOGIC_OP);
   glEnable (GL_STENCIL_TEST);
@@ -543,15 +522,13 @@ ghid_draw_bg_image (void)
 void
 ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   static int stencil_bit = 0;
 
   if (mode == cur_mask)
     return;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   switch (mode)
     {
@@ -564,7 +541,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
       glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); /* Get a new (clean) bitplane to stencil with */
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw); /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
       glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value (with 1) */
@@ -580,7 +557,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 
     case HID_MASK_OFF:
       /* Disable stenciling */
-      hidgl_return_stencil_bit (hidgl, stencil_bit);        /* Relinquish any bitplane we previously used */
+      hidgl_return_stencil_bit (hid_draw, stencil_bit);     /* Relinquish any bitplane we previously used */
       glDisable (GL_STENCIL_TEST);                          /* Disable Stencil test */
       break;
     }
@@ -736,7 +713,7 @@ set_gl_color_for_gc (hidGC gc)
   g = g * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
   b = b * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gtk_gc->hidgl_gc.gc.hid_draw);
   glColor4d (r, g, b, a);
 }
 
@@ -814,12 +791,6 @@ ghid_set_line_cap_angle (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
-static void
-ghid_invalidate_current_gc (void)
-{
-  current_gc = NULL;
-}
-
 static int
 use_gc (hidGC gc)
 {
@@ -829,10 +800,10 @@ use_gc (hidGC gc)
       abort ();
     }
 
-  if (current_gc == gc)
-    return 1;
+//  if (current_gc == gc)
+//    return 1;
 
-  current_gc = gc;
+//  current_gc = gc;
 
   set_gl_color_for_gc (gc);
   return 1;
@@ -885,22 +856,22 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 void
-ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (gc, poly, clip_box);
+  hidgl_fill_pcb_polygon (gc, poly);
 }
 
 void
-ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   gtkGC gtk_gc = (gtkGC)gc;
 
   double old_alpha_mult = gtk_gc->alpha_mult;
-  common_thindraw_pcb_polygon (gc, poly, clip_box);
+  common_thindraw_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
-  hid_draw__fill_pcb_polygon (gc, poly, clip_box);
+  hid_draw__fill_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, old_alpha_mult);
 }
 
@@ -1045,6 +1016,7 @@ static void
 draw_crosshair (hidGC gc, render_priv *priv)
 {
   gtkGC gtk_gc = (gtkGC)gc;
+
   gint x, y, z;
   static int done_once = 0;
   static GdkColor cross_color;
@@ -1106,7 +1078,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
     }
 
   hidgl_init ();
-  priv->hidgl = hidgl_new_instance ();
+  priv->hid_draw = hidgl_new_instance ();
 
   /* Setup HID function pointers specific to the GL renderer*/
   ghid_graphics_class.end_layer = ghid_end_layer;
@@ -1119,7 +1091,7 @@ ghid_shutdown_renderer (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
 
-  hidgl_free_instance (priv->hidgl);
+  hidgl_free_instance (priv->hid_draw);
 
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
@@ -1164,7 +1136,7 @@ ghid_start_drawing (GHidPort *port, GtkWidget *widget)
 
   port->render_priv->in_context = true;
 
-  hidgl_start_render (port->render_priv->hidgl);
+  hidgl_start_render (port->render_priv->hid_draw);
 
   return TRUE;
 }
@@ -1174,7 +1146,7 @@ ghid_end_drawing (GHidPort *port, GtkWidget *widget)
 {
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_finish_render (port->render_priv->hidgl);
+  hidgl_finish_render (port->render_priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -1196,13 +1168,14 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -1213,42 +1186,42 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  ghid_set_lock_effects (Output.fgGC, obj);
-  hid_draw_set_color (Output.fgGC, color);
+  ghid_set_lock_effects (gc, obj);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+  ghid_set_lock_effects (gc, (AnyObjectType *) pv);
 
-  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                              : PCB->PinSelectedColor);
-  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (Output.fgGC, PCB->FoundColor);
+  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                     : PCB->PinSelectedColor);
+  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (gc, PCB->ConnectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (gc, PCB->FoundColor);
   else
     {
-      int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
+      int top_group    = GetLayerGroupNumberBySide (TOP_SIDE);
       int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-      int this_group      = GetLayerGroupNumberByPointer (layer);
+      int this_group   = GetLayerGroupNumberByPointer (layer);
 
       if (this_group == top_group || this_group == bottom_group)
-        hid_draw_set_color (Output.fgGC, (SWAP_IDENT == (this_group == bottom_group)) ?
-                                         PCB->ViaColor : PCB->InvisibleObjectsColor);
+        hid_draw_set_color (gc, (SWAP_IDENT == (this_group == bottom_group)) ?
+                                PCB->ViaColor : PCB->InvisibleObjectsColor);
       else
-        hid_draw_set_color (Output.fgGC, layer->Color);
+        hid_draw_set_color (gc, layer->Color);
     }
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (hidGC gc, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -1272,8 +1245,8 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -1282,46 +1255,47 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
-_draw_pv (PinType *pv, bool draw_hole)
+_draw_pv (hidGC gc, PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
-      hid_draw__thin_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__thin_pcb_pv (gc, pv, false);
       if (draw_hole)
-        hid_draw__thin_pcb_pv_hole (Output.fgGC, pv);
+        hid_draw__thin_pcb_pv_hole (gc, pv);
     }
   else
     {
-      hid_draw__fill_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__fill_pcb_pv (gc, pv, false);
       if (draw_hole)
         hid_draw__fill_pcb_pv_hole (Output.bgGC, pv);
     }
 
   if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
+    _draw_pv_name (gc, pv);
 }
 
 static void
-draw_pin (PinType *pin, bool draw_hole)
+draw_pin (hidGC gc, PinType *pin, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
+  set_object_color (gc, (AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  _draw_pv (pin, draw_hole);
+  _draw_pv (gc, pin, draw_hole);
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
-  draw_pin (pin, TEST_FLAG (THINDRAWFLAG, PCB));
+    _draw_pv_name (gc, pin);
+  draw_pin (gc, pin, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
@@ -1329,46 +1303,59 @@ static int
 pin_name_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
+    _draw_pv_name (gc, pin);
   return 1;
 }
 
+struct layer_info
+{
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, PIN_TYPE);
-  _draw_pv ((PinType *) b, false);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, PIN_TYPE);
+  _draw_pv (info->gc, (PinType *) b, false);
   return 1;
 }
 
 static void
-draw_via (PinType *via, bool draw_hole)
+draw_via (hidGC gc, PinType *via, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
+  set_object_color (gc, (AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  _draw_pv (via, draw_hole);
+  _draw_pv (gc, via, draw_hole);
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  hidGC gc = cl;
+
+  draw_via (gc, (PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, VIA_TYPE);
-  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, VIA_TYPE);
+  _draw_pv (info->gc, (PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (hidGC gc, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -1397,8 +1384,8 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pad thickness */
@@ -1407,7 +1394,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
@@ -1424,29 +1411,34 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad)
+draw_pad (hidGC gc, PadType *pad)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 
   if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+    draw_pad_name (gc, pad);
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side)) {
+  if (ON_SIDE (pad, info->side)) {
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-      draw_pad_name (pad);
-    draw_pad (pad);
+      draw_pad_name (info->gc, pad);
+    draw_pad (info->gc, pad);
   }
   return 1;
 }
@@ -1456,7 +1448,9 @@ static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  hidGC gc = cl;
+//  int plated = cl ? *(int *) cl : -1;
+  int plated = -1;
 
   if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
@@ -1466,10 +1460,9 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-          hid_draw_set_line_width (Output.fgGC, 0);
-          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (gc, Round_Cap);
+          hid_draw_set_line_width (gc, 0);
+          hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
@@ -1477,14 +1470,13 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-      set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
+      ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+      set_object_color (gc, (AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -1492,92 +1484,86 @@ hole_callback (const BoxType * b, void *cl)
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  hid_draw_pcb_line (Output.fgGC, line);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  hid_draw_pcb_line (info->gc, line);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  hid_draw_pcb_arc (info->gc, arc);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
-struct poly_info
-{
-  LayerType *layer;
-  const BoxType *drawn_area;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_no_clear (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_clearing (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
@@ -1596,8 +1582,9 @@ static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     _draw_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1614,8 +1601,9 @@ static int
 clearPad_callback_solid (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     hid_draw__fill_pcb_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1634,7 +1622,7 @@ ensure_board_outline (void)
 }
 
 static void
-fill_board_outline (hidGC gc, const BoxType *drawn_area)
+fill_board_outline (hidGC gc)
 {
   PolygonType polygon;
 
@@ -1642,11 +1630,11 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -1677,8 +1665,8 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
-//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
-  hid_draw__fill_pcb_polygon (info->gc, &polygon, NULL);
+//  common_fill_pcb_polygon (info->gc, &polygon);
+  hid_draw__fill_pcb_polygon (info->gc, &polygon);
 
   poly_FreeContours (&polygon.NoHoles);
 
@@ -1688,7 +1676,7 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+fill_board_outline_holes (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1698,64 +1686,66 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   info.gc = gc;
 
-  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, fill_outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
-    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, fill_outline_hole_cb, &info);
   }
 
 //  poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static void
-GhidDrawMask (int side, BoxType * screen)
+GhidDrawMask (hidGC gc, int side)
 {
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct layer_info l_info;
+  struct side_info s_info;
 
-  OutputType *out = &Output;
+  l_info.gc = gc;
+  l_info.layer = Layer;
+  s_info.gc = gc;
+  s_info.side = side;
 
   if (thin)
     {
       hid_draw_set_line_width (Output.pmGC, 0);
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
-      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_CLEAR);
+  hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
-  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+  r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_AFTER);
-  hid_draw_set_color (out->fgGC, PCB->MaskColor);
-  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  hid_draw_use_mask (gc->hid_draw, HID_MASK_AFTER);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
 #if 0
   if (first_run) {
@@ -1792,18 +1782,18 @@ GhidDrawMask (int side, BoxType * screen)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (screen)
-    polygon.BoundingBox = *screen;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (out->fgGC, &polygon, screen);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 #endif
 
-  fill_board_outline (out->fgGC, screen);
+  fill_board_outline (gc);
 
-  ghid_set_alpha_mult (out->fgGC, 1.0);
-//  hidgl_flush_triangles (priv->hidgl);
+  ghid_set_alpha_mult (gc, 1.0);
+//  hidgl_flush_triangles (priv->hid_draw);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1812,7 +1802,7 @@ GhidDrawMask (int side, BoxType * screen)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_OFF);
+  hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1860,7 +1850,7 @@ outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1870,39 +1860,37 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
-  info.gc = Output.fgGC;
+  info.gc = gc;
   info.z1 = compute_depth (from_layer);
   info.z2 = compute_depth (to_layer);
 
   draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
-  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, outline_hole_cb, &info);
   }
 
   poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static int
-GhidDrawLayerGroup (int group, const BoxType * screen)
+GhidDrawLayerGroup (hidGC gc, int group)
 {
   render_priv *priv = gport->render_priv;
   int i;
   int layernum;
-  int side;
-  struct poly_info info;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
@@ -1910,6 +1898,11 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   bool is_outline;
+  struct layer_info l_info;
+  struct side_info s_info;
+
+  l_info.gc = gc;
+  s_info.gc = gc;
 
   if (!hid_draw_set_layer (&ghid_graphics, 0, group, 0))
     return 0;
@@ -1922,6 +1915,9 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
     is_outline = strcmp (Layer->Name, "outline") == 0 ||
                  strcmp (Layer->Name, "route") == 0;
 
+    l_info.layer = Layer;
+
+
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
@@ -1931,24 +1927,23 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
 
       if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
         /* Mask out drilled holes on this layer */
-        hidgl_flush_triangles (priv->hidgl);
+        hidgl_flush_triangles (priv->hid_draw);
         glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-        fill_board_outline_holes (Output.bgGC, screen);
-        hidgl_flush_triangles (priv->hidgl);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+        fill_board_outline_holes (Output.bgGC);
+        hidgl_flush_triangles (priv->hid_draw);
         glPopAttrib ();
       }
 
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
-        info.layer = Layer;
-        info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
+        l_info.layer = Layer;
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
@@ -1956,15 +1951,15 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         hid_draw_set_layer (&ghid_graphics, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
-          hidgl_flush_triangles (priv->hidgl);
+          hidgl_flush_triangles (priv->hid_draw);
           glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-          fill_board_outline_holes (Output.bgGC, screen);
-          hidgl_flush_triangles (priv->hidgl);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+          fill_board_outline_holes (Output.bgGC);
+          hidgl_flush_triangles (priv->hid_draw);
           glPopAttrib ();
         }
       }
@@ -1973,27 +1968,27 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+          r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
-            side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = TOP_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
-            side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = BOTTOM_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+      r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
     }
   }
 
@@ -2048,6 +2043,7 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
 }
 
 struct cyl_info {
+  hidGC gc;
   int from_layer;
   int to_layer;
   double scale;
@@ -2069,9 +2065,9 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
-  hid_draw_set_color (Output.fgGC, color);
-  DrawDrillChannel (Output.fgGC, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)Pin);
+  hid_draw_set_color (info->gc, color);
+  DrawDrillChannel (info->gc, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
@@ -2131,19 +2127,18 @@ frontE_package_callback (const BoxType * b, void *cl)
 }
 
 static void
-ghid_draw_packages (BoxType *drawn_area)
+ghid_draw_packages (hidGC gc)
 {
   /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, gc->clip_box, NULL, frontE_package_callback, NULL);
 }
 
 void
-ghid_draw_everything (BoxType *drawn_area)
+ghid_draw_everything (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   int i, ngroups;
   int number_phys_on_top;
-  int side;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
   /* This is the reverse of the order in which we draw them.  */
@@ -2155,6 +2150,10 @@ ghid_draw_everything (BoxType *drawn_area)
   int bottom_group;
   int min_phys_group;
   int max_phys_group;
+  struct side_info info;
+
+  cyl_info.gc = gc;
+  info.gc = gc;
 
   priv->current_colorname = NULL;
 
@@ -2204,14 +2203,14 @@ ghid_draw_everything (BoxType *drawn_area)
   /*
    * first draw all 'invisible' stuff
    */
-  side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+  info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       hid_draw_set_layer (&ghid_graphics, "invisible", SL (INVISIBLE, 0), 0)) {
-    DrawSilk (&ghid_graphics, side, drawn_area);
+    DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
 
     hid_draw_end_layer (&ghid_graphics);
 
@@ -2219,7 +2218,7 @@ ghid_draw_everything (BoxType *drawn_area)
     if (!global_view_2d &&
         hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "componentmask" : "soldermask",
                         SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
-        GhidDrawMask (side, drawn_area);
+        GhidDrawMask (gc, info.side);
         hid_draw_end_layer (&ghid_graphics);
       }
   }
@@ -2240,75 +2239,75 @@ ghid_draw_everything (BoxType *drawn_area)
     if (is_this_physical)
       number_phys_on_top --;
 
-    ghid_set_alpha_mult (Output.fgGC, alpha_mult);
-    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+    ghid_set_alpha_mult (gc, alpha_mult);
+    GhidDrawLayerGroup (gc, drawn_groups [i]);
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
-      hid_draw_set_color (Output.fgGC, "drill");
-      ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
-      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      hid_draw_set_color (gc, "drill");
+      ghid_set_alpha_mult (gc, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
 #endif
   }
 #undef FADE_FACTOR
 
-  ghid_set_alpha_mult (Output.fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
+  info.side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    start_subcomposite (priv->hidgl);
+    start_subcomposite (gc->hid_draw);
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
-      hidgl_flush_triangles (priv->hidgl);
+      hidgl_flush_triangles (priv->hid_draw);
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
-      fill_board_outline_holes (Output.bgGC, drawn_area);
-      hidgl_flush_triangles (priv->hidgl);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+      fill_board_outline_holes (Output.bgGC);
+      hidgl_flush_triangles (priv->hid_draw);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
 
-    end_subcomposite (priv->hidgl);
+    end_subcomposite (gc->hid_draw);
   }
 
   /* Draw the solder mask if turned on */
   if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "soldermask" : "componentmask",
                       SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
-    GhidDrawMask (side, drawn_area);
+    GhidDrawMask (gc, info.side);
     hid_draw_end_layer (&ghid_graphics);
   }
 
   if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "bottomsilk" : "topsilk",
                       SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
-      DrawSilk (&ghid_graphics, side, drawn_area);
+      DrawSilk (gc, info.side);
       hid_draw_end_layer (&ghid_graphics);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+    r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
   if (PCB->RatOn && hid_draw_set_layer (&ghid_graphics, "rats", SL (RATS, 0), 0)) {
-    DrawRats (&ghid_graphics, drawn_area);
+    DrawRats (gc);
     hid_draw_end_layer (&ghid_graphics);
   }
 
@@ -2336,6 +2335,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 0, 1};
   bool horizon_problem = false;
   static bool do_once = true;
+  hidGC gc;
 
   if (do_once) {
     do_once = false;
@@ -2346,14 +2346,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port, widget);
 
-  Output.fgGC = hid_draw_make_gc (&ghid_graphics);
+  gc = hid_draw_make_gc (&ghid_graphics);
   Output.bgGC = hid_draw_make_gc (&ghid_graphics);
   Output.pmGC = hid_draw_make_gc (&ghid_graphics);
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits (priv->hidgl) == 0)
+  if (hidgl_stencil_bits (priv->hid_draw) == 0)
     ghid_graphics_class._fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
@@ -2439,7 +2439,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2538,8 +2538,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
@@ -2582,9 +2580,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  /* hid_expose_callback (&ghid_graphics, &region, 0); */
-  ghid_draw_everything (&region);
-  hidgl_flush_triangles (priv->hidgl);
+  common_set_clip_box (&ghid_graphics, &region);
+  /* hid_expose_callback (&ghid_graphics, 0); */
+  ghid_draw_everything (gc);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glTexCoord2f (0., 0.);
   glColor3f (1., 1., 1.);
@@ -2628,15 +2627,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
-  hidgl_set_depth (Output.fgGC, priv->edit_depth);
-
-  ghid_draw_grid (Output.fgGC, &region);
+  hidgl_set_depth (&ghid_graphics, priv->edit_depth);
 
-  ghid_invalidate_current_gc ();
+  ghid_draw_grid (gc);
 
-  DrawAttached (Output.fgGC);
-  DrawMark (Output.fgGC);
-  hidgl_flush_triangles (priv->hidgl);
+  DrawAttached (gc);
+  DrawMark (gc);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glEnable (GL_LIGHTING);
 
@@ -2688,7 +2685,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   if (!global_view_2d)
-    ghid_draw_packages (&region);
+    ghid_draw_packages (gc);
 
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
@@ -2696,20 +2693,19 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_COLOR_MATERIAL);
   glDisable (GL_LIGHTING);
 
-  draw_crosshair (Output.fgGC, priv);
+  draw_crosshair (gc, priv);
   object3d_draw_debug ();
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
-  draw_lead_user (Output.fgGC, priv);
+  draw_lead_user (gc, priv);
 
   ghid_end_drawing (port, widget);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
 
-  Output.fgGC = NULL;
   Output.bgGC = NULL;
   Output.pmGC = NULL;
   g_timer_start (priv->time_since_expose);
@@ -2830,7 +2826,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2838,7 +2834,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2848,8 +2843,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_set_depth (&ghid_graphics, 0.);
+  hid_expose_callback (&ghid_graphics, pinout->element);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, widget);
@@ -2917,7 +2913,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
-  hidgl_start_render (priv->hidgl);
+  hidgl_start_render (priv->hid_draw);
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2942,7 +2938,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2950,7 +2946,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2970,13 +2965,14 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_graphics, &region, NULL);
-  hidgl_flush_triangles (priv->hidgl);
+  common_set_clip_box (&ghid_graphics, &region);
+  hid_expose_callback (&ghid_graphics, NULL);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   glFlush ();
 
-  hidgl_finish_render (priv->hidgl);
+  hidgl_finish_render (priv->hid_draw);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -3014,8 +3010,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   glDisable (GL_STENCIL_TEST);
 
@@ -3032,13 +3026,13 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -3047,11 +3041,11 @@ ghid_flush_debug_draw (void)
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  render_priv *priv = gport->render_priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, gport->drawing_area);
@@ -3413,7 +3407,6 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
 static void
 draw_lead_user (hidGC gc, render_priv *priv)
 {
-  gtkGC gtk_gc = (gtkGC)gc;
   int i;
   double radius = priv->lead_user_radius;
   double width = MM_TO_COORD (LEAD_USER_WIDTH);
@@ -3440,7 +3433,7 @@ draw_lead_user (hidGC gc, render_priv *priv)
                       radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gc->hid_draw);
   glPopAttrib ();
 }
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 538e547..48b8c3c 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -474,8 +474,8 @@ void ghid_pinout_window_show (GHidPort *out, ElementType *Element);
 
 /* gtkhid-gdk.c AND gtkhid-gl.c */
 int ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty);
-hidGC ghid_make_gc (void);
-void ghid_destroy_gc (hidGC);
+hidGC ghid_make_gc (HID_DRAW *hid_draw);
+void ghid_destroy_gc (hidGC gc);
 void ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode);
 void ghid_set_color (hidGC gc, const char *name);
 void ghid_set_line_cap (hidGC gc, EndCapStyle style);
@@ -504,8 +504,8 @@ gboolean ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev);
 GdkPixmap *ghid_render_pixmap (int cx, int cy, double zoom,
                                int width, int height, int depth);
 HID_DRAW *ghid_request_debug_draw (void);
-void ghid_flush_debug_draw (void);
-void ghid_finish_debug_draw (void);
+void ghid_flush_debug_draw (hidGC gc);
+void ghid_finish_debug_draw (hidGC gc);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 6fed87f..3f4e445 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -816,6 +816,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   time_t start, end;
   BoxType region;
   Drawable save_main;
+  hidGC gc;
 
   save_main = main_pixmap;
   main_pixmap = window;
@@ -825,13 +826,18 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   pixmap = window;
   XSync (display, 0);
   time (&start);
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_graphics, &region, 0);
+      hid_expose_callback (&lesstif_graphics, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2496,6 +2502,11 @@ static int need_redraw = 0;
 static Boolean
 idle_proc (XtPointer dummy)
 {
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
+
   if (need_redraw)
     {
       int mx, my;
@@ -2578,8 +2589,11 @@ idle_proc (XtPointer dummy)
 			      rightmost-leftmost+1, view_height-bottommost+1);
 	    }
 	}
+
+      common_set_clip_box (gc, &region);
+
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_graphics, &region, 0);
+      hid_expose_callback (&lesstif_graphics, 0);
       draw_grid ();
       lesstif_use_mask (&lesstif_graphics, HID_MASK_OFF);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
@@ -3754,6 +3768,7 @@ pinout_callback (Widget da, PinoutData * pd,
   double save_vz;
   Pixmap save_px;
   int reason = cbs ? cbs->reason : 0;
+  hidGC gc;
 
   if (pd->window == 0 && reason == XmCR_RESIZE)
     return;
@@ -3802,8 +3817,13 @@ pinout_callback (Widget da, PinoutData * pd,
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_graphics, &region, pd->item);
+  hid_expose_callback (&lesstif_graphics, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
@@ -4034,7 +4054,7 @@ lesstif_request_debug_draw (void)
 }
 
 static void
-lesstif_flush_debug_draw (void)
+lesstif_flush_debug_draw (hidGC gc)
 {
   /* Copy the backing pixmap to the display and redraw any attached objects */
   XSetFunction (display, my_gc, GXcopy);
@@ -4050,9 +4070,9 @@ lesstif_flush_debug_draw (void)
 }
 
 static void
-lesstif_finish_debug_draw (void)
+lesstif_finish_debug_draw (hidGC gc)
 {
-  lesstif_flush_debug_draw ();
+  lesstif_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 1f84a3a..96f052f 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -646,10 +646,13 @@ nelma_start_png_export()
 	region.X2 = PCB->MaxWidth;
 	region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
 	linewidth = -1;
 	lastbrush = (gdImagePtr)((void *) -1);
 
-	hid_expose_callback(&nelma_graphics, &region, 0);
+	hid_expose_callback(&nelma_graphics, 0);
 }
 
 static void 
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index c9a06ed..4695572 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -550,6 +550,10 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int saved_show_bottom_side;
   BoxType region;
   FlagType save_flags;
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
 
   f = the_file;
 
@@ -563,6 +567,8 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   else
     bounds = &region;
 
+  common_set_clip_box (gc, bounds);
+
   memset (print_group, 0, sizeof (print_group));
   memset (print_layer, 0, sizeof (print_layer));
 
@@ -655,7 +661,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_graphics, bounds, 0);
+  hid_expose_callback (&png_graphics, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 5d2766b..8263839 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -301,7 +301,8 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_graphics, bounds, 0);
+  common_set_clip_box (&eps_graphics, bounds);
+  hid_expose_callback (&eps_graphics, 0);
 
   fprintf (f, "showpage\n");
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index da02628..1a4f2ae 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -399,8 +399,6 @@ static struct {
 
   double scale_factor;
 
-  BoxType region;
-
   HID_Attr_Val ps_values[NUM_OPTIONS];
 
   bool is_mask;
@@ -598,6 +596,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int i;
   static int saved_layer_stack[MAX_LAYER];
   FlagType save_thindraw;
+  BoxType region;
 
   save_thindraw = PCB->Flags;
   CLEAR_FLAG(THINDRAWFLAG, PCB);
@@ -678,10 +677,12 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   ps_set_layer (&ps_graphics, NULL, 0, -1);
   use_gc (NULL);
 
-  global.region.X1 = 0;
-  global.region.Y1 = 0;
-  global.region.X2 = PCB->MaxWidth;
-  global.region.Y2 = PCB->MaxHeight;
+  region.X1 = 0;
+  region.Y1 = 0;
+  region.X2 = PCB->MaxWidth;
+  region.Y2 = PCB->MaxHeight;
+
+  common_set_clip_box (&ps_graphics, &region);
 
   if (!global.multi_file)
     {
@@ -694,13 +695,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_graphics, &global.region, 0);
+      hid_expose_callback (&ps_graphics, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (&ps_graphics, NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_graphics, &global.region, 0);
+  hid_expose_callback (&ps_graphics, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -1008,7 +1009,7 @@ ps_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, &global.region, NULL);
+      dapi->draw_layer (gc, global.outline_layer, NULL);
     }
 
   return 1;
@@ -1266,7 +1267,7 @@ ps_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
+fill_polyarea (hidGC gc, POLYAREA * pa)
 {
   /* Ignore clip_box, just draw everything */
 
@@ -1295,15 +1296,15 @@ fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
 }
 
 static void
-ps_draw_pcb_polygon (hidGC gc, PolygonType * poly, const BoxType * clip_box)
+ps_draw_pcb_polygon (hidGC gc, PolygonType * poly)
 {
-  fill_polyarea (gc, poly->Clipped, clip_box);
+  fill_polyarea (gc, poly->Clipped);
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
+        fill_polyarea (gc, pa);
     }
 }
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index d59b0da..57a4275 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -31,7 +31,7 @@ typedef struct hid_draw_class_st
      and 90 being "up" (positive Y).  */
 
   /* Make an empty graphics context.  */
-  hidGC (*make_gc) (void);
+  hidGC (*make_gc) (HID_DRAW *hid_draw);
   void (*destroy_gc) (hidGC gc);
   void (*use_mask) (HID_DRAW *hid_draw, enum mask_mode mode);
 
@@ -70,14 +70,14 @@ typedef struct hid_draw_class_st
   void (*draw_pcb_line) (hidGC gc, LineType *line);
   void (*draw_pcb_arc) (hidGC gc, ArcType *arc);
   void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
-  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*draw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*draw_pcb_pv) (hidGC gc, PinType *pv, bool mask);
   void (*draw_pcb_pv_hole) (hidGC gc, PinType *pv);
 
   /* The following are not meant to be called outside of the GUI implementations of the above APIs */
-  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly);
+  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*_fill_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_thindraw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_fill_pcb_pv) (hidGC gc, PinType *pv, bool mask);
@@ -101,12 +101,15 @@ struct hid_draw_st
   /* Note that both of these may be set, in which case polygons will be drawn twice: */
   bool poly_before; /* If set, the redraw code will draw polygons before erasing the clearances. */
   bool poly_after;  /* If set, the redraw code will draw polygons after  erasing the clearances. */
+
+  void *priv; /* XXX: TEMPORARY */
 };
 
 /* Base hidGC elements visible to any module */
 struct hid_gc_struct {
   HID *hid;   /* Used by HIDs to validate the GCs passed belong to them */
   HID_DRAW *hid_draw;
+  BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
 };
 
 
@@ -141,7 +144,7 @@ hid_draw_end_layer (HID_DRAW *hid_draw)
 inline hidGC
 hid_draw_make_gc (HID_DRAW *hid_draw)
 {
-  return hid_draw->klass->make_gc ();
+  return hid_draw->klass->make_gc (hid_draw);
 }
 
 inline void
@@ -242,9 +245,9 @@ hid_draw_pcb_text (hidGC gc, TextType *text, Coord min_width)
 }
 
 inline void
-hid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->draw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->draw_pcb_polygon (gc, poly);
 }
 
 inline void
@@ -267,15 +270,15 @@ hid_draw_pcb_pv_hole (hidGC gc, PinType *pv)
 
 
 inline void
-hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly);
 }
 
 inline void
-hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly);
 }
 
 inline void
