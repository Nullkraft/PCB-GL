Bottom: 7d57224c2311ca027b1fdd5a05bf9fa90b4c40c9
Top:    685cd71d36d58a2c2cc597af72a3c0fb1a13f7ad
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 19:04:08 +0100

Major re-write to drawing routines

FIXME: FULLY OF NASTY API HACKS TO draw.c

Notes from squashed patches:
  Pin and via hole cores are drawn in the appropriate colour
  Playing with stack rendering order
  Fix mask display in 3D (Allow both side masks to display at once)
  Fix rendering depths for silk and mask layers
  Fixup depth for layers and element marks
  Move more rendering to world coordinates
  Fix get_coords function
  Re-write parts of the PCB+GL set_layer function
  Fix layer on/off rendering after commit 9768e060fad7bc3dfc366da76ea1db8154005018
  Only assign stencil planes where sub-compositing is required - that is, not the far-side, mask, rat or switched off layers.


---

diff --git a/src/draw.c b/src/draw.c
index b5dafe3..9e9bdbe 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -84,8 +84,8 @@ static bool doing_assy = false;
  */
 static void DrawEverything (const BoxType *);
 static void AddPart (void *);
-static void DrawEMark (ElementTypePtr, Coord, Coord, bool);
-static void DrawRats (const BoxType *);
+/* static */ void DrawEMark (ElementTypePtr, Coord, Coord, bool);
+/* static */ void DrawRats (const BoxType *);
 
 
 /*---------------------------------------------------------------------------
@@ -455,7 +455,7 @@ DrawEverything (const BoxType *drawn_area)
     }
 }
 
-static void
+/* static */ void
 DrawEMark (ElementTypePtr e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
@@ -626,7 +626,7 @@ DrawPaste (int side, const BoxType *drawn_area)
   ENDALL_LOOP;
 }
 
-static void
+/* static */ void
 DrawRats (const BoxType *drawn_area)
 {
   /*
diff --git a/src/draw.h b/src/draw.h
index cec3a16..f6dc31f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -77,4 +77,15 @@ void DrawMask (int side, const BoxType *drawn_area);
 void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
 void PrintAssembly (int side, const BoxType *drawn_area);
 
+/* TEMPORARY */
+void ClearPad (PadTypePtr, bool);
+void DrawPinOrViaLowLevel (PinTypePtr, bool);
+void DrawPlainPin (PinTypePtr, bool);
+void DrawPlainVia (PinTypePtr, bool);
+void DrawRegularText (LayerTypePtr, TextTypePtr);
+void DrawEMark (ElementTypePtr, Coord, Coord, bool);
+void DrawHole (PinTypePtr);
+void DrawRats (const BoxType *);
+/* TEMPORARY */
+
 #endif
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index bb9fdd5..d5aa92f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -10,6 +10,9 @@
 #include "clip.h"
 #include "../hidint.h"
 #include "gui.h"
+#include "draw.h"
+#include "draw_funcs.h"
+#include "rtree.h"
 #include "gui-pinout-preview.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
@@ -203,64 +206,78 @@ end_subcomposite (void)
   priv->subcomposite_stencil_bit = 0;
 }
 
+/* Compute group visibility based upon on copper layers only */
+static bool
+is_layer_group_visible (int group)
+{
+  int entry;
+  for (entry = 0; entry < PCB->LayerGroups.Number[group]; entry++)
+    {
+      int layer_idx = PCB->LayerGroups.Entries[group][entry];
+      if (layer_idx >= 0 && layer_idx < max_copper_layer &&
+          LAYER_PTR (layer_idx)->On)
+        return true;
+    }
+  return false;
+}
 
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  int idx = group;
-  if (idx >= 0 && idx < max_group)
-    {
-      int n = PCB->LayerGroups.Number[group];
-      for (idx = 0; idx < n-1; idx ++)
-	{
-	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_copper_layer + 2
-	      && PCB->Data->Layer[ni].On)
-	    break;
-	}
-      idx = PCB->LayerGroups.Entries[group][idx];
-  }
-
-  end_subcomposite ();
-  start_subcomposite ();
-
-  /* Drawing is already flushed by {start,end}_subcomposite */
-  hidgl_set_depth (compute_depth (group));
+  bool group_visible = false;
+  bool subcomposite = true;
 
-  if (idx >= 0 && idx < max_copper_layer + 2)
+  if (group >= 0 && group < max_group)
     {
       priv->trans_lines = true;
-      return PCB->Data->Layer[idx].On;
+      subcomposite = true;
+      group_visible = is_layer_group_visible (group);
     }
-
-  if (idx < 0)
+  else
     {
-      switch (SL_TYPE (idx))
+      switch (SL_TYPE (group))
 	{
 	case SL_INVISIBLE:
-	  return PCB->InvisibleObjectsOn;
+	  priv->trans_lines = false;
+	  subcomposite = false;
+	  group_visible = PCB->InvisibleObjectsOn;
+	  break;
 	case SL_MASK:
-	  if (SL_MYSIDE (idx))
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
+	  priv->trans_lines = true;
+	  subcomposite = false;
+	  group_visible = TEST_FLAG (SHOWMASKFLAG, PCB);
+	  break;
 	case SL_SILK:
 	  priv->trans_lines = true;
-	  if (SL_MYSIDE (idx))
-	    return PCB->ElementOn;
-	  return 0;
+	  subcomposite = true;
+	  group_visible = PCB->ElementOn;
+	  break;
 	case SL_ASSY:
-	  return 0;
+	  break;
 	case SL_PDRILL:
 	case SL_UDRILL:
-	  return 1;
+	  priv->trans_lines = true;
+	  subcomposite = true;
+	  group_visible = true;
+	  break;
 	case SL_RATS:
-	  if (PCB->RatOn)
-	    priv->trans_lines = true;
-	  return PCB->RatOn;
+	  priv->trans_lines = true;
+	  subcomposite = false;
+	  group_visible = PCB->RatOn;
+	  break;
 	}
     }
-  return 0;
+
+  end_subcomposite ();
+
+  if (group_visible && subcomposite)
+    start_subcomposite ();
+
+  /* Drawing is already flushed by {start,end}_subcomposite */
+  hidgl_set_depth (compute_depth (group));
+
+  return group_visible;
 }
 
 static void
@@ -300,6 +317,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
+  glDisable (GL_STENCIL_TEST);
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
 
@@ -310,6 +328,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
   hidgl_draw_grid (drawn_area);
 
   glDisable (GL_COLOR_LOGIC_OP);
+  glEnable (GL_STENCIL_TEST);
 }
 
 static void
@@ -930,6 +949,10 @@ ghid_start_drawing (GHidPort *port)
 
   port->render_priv->in_context = true;
 
+  Output.fgGC = gui->make_gc ();
+  Output.bgGC = gui->make_gc ();
+  Output.pmGC = gui->make_gc ();
+
   return TRUE;
 }
 
@@ -948,6 +971,14 @@ ghid_end_drawing (GHidPort *port)
 
   /* end drawing to current GL-context */
   gdk_gl_drawable_gl_end (pGlDrawable);
+
+  gui->destroy_gc (Output.fgGC);
+  gui->destroy_gc (Output.bgGC);
+  gui->destroy_gc (Output.pmGC);
+
+  Output.fgGC = NULL;
+  Output.bgGC = NULL;
+  Output.pmGC = NULL;
 }
 
 void
@@ -955,6 +986,856 @@ ghid_screen_update (void)
 {
 }
 
+static int
+EMark_callback (const BoxType * b, void *cl)
+{
+  ElementTypePtr element = (ElementTypePtr) b;
+
+  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  return 1;
+}
+
+static void
+SetPVColor (PinTypePtr Pin, int Type)
+{
+  char *color;
+
+  if (Type == VIA_TYPE)
+    {
+      if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
+	{
+	  if (TEST_FLAG (WARNFLAG, Pin))
+	    color = PCB->WarnColor;
+	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+	    color = PCB->ViaSelectedColor;
+	  else
+	    color = PCB->ConnectedColor;
+	}
+      else
+	color = PCB->ViaColor;
+    }
+  else
+    {
+      if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
+	{
+	  if (TEST_FLAG (WARNFLAG, Pin))
+	    color = PCB->WarnColor;
+	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+	    color = PCB->PinSelectedColor;
+	  else
+	    color = PCB->ConnectedColor;
+	}
+      else
+	color = PCB->PinColor;
+    }
+
+  gui->set_color (Output.fgGC, color);
+}
+
+static void
+SetPVColor_inlayer (PinTypePtr Pin, LayerTypePtr Layer, int Type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    {
+      int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+      int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+      int this_group      = GetLayerGroupNumberByPointer (Layer);
+
+      if (this_group == component_group || this_group == solder_group)
+        color = (SWAP_IDENT == (this_group == solder_group))
+                  ? PCB->ViaColor : PCB->InvisibleObjectsColor;
+      else
+        color = Layer->Color;
+    }
+
+  gui->set_color (Output.fgGC, color);
+}
+
+static void
+_draw_pv_name (PinType *pv)
+{
+  BoxType box;
+  bool vert;
+  TextType text;
+
+  if (!pv->Name || !pv->Name[0])
+    text.TextString = EMPTY (pv->Number);
+  else
+    text.TextString = EMPTY (TEST_FLAG (SHOWNUMBERFLAG, PCB) ? pv->Number : pv->Name);
+
+  vert = TEST_FLAG (EDGE2FLAG, pv);
+
+  if (vert)
+    {
+      box.X1 = pv->X - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
+      box.Y1 = pv->Y - pv->DrillingHole / 2 - Settings.PinoutTextOffsetX;
+    }
+  else
+    {
+      box.X1 = pv->X + pv->DrillingHole / 2 + Settings.PinoutTextOffsetX;
+      box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
+    }
+
+  gui->set_color (Output.fgGC, PCB->PinNameColor);
+
+  text.Flags = NoFlags ();
+  /* Set font height to approx 56% of pin thickness */
+  text.Scale = 56 * pv->Thickness / FONT_CAPHEIGHT;
+  text.X = box.X1;
+  text.Y = box.Y1;
+  text.Direction = vert ? 1 : 0;
+
+  DrawTextLowLevel (&text, 0);
+}
+
+static void
+_draw_pv (PinTypePtr pv, bool draw_hole)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+  else
+    gui->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+
+  if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
+    _draw_pv_name (pv);
+}
+
+static void
+draw_pin (PinTypePtr pin, bool draw_hole)
+{
+  SetPVColor (pin, PIN_TYPE);
+  _draw_pv (pin, draw_hole);
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  draw_pin ((PinType *)b, false);
+  return 1;
+}
+
+static int
+pin_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, PIN_TYPE);
+  _draw_pv ((PinType *) b, false);
+  return 1;
+}
+
+static void
+draw_via (PinTypePtr via, bool draw_hole)
+{
+  SetPVColor (via, VIA_TYPE);
+  _draw_pv (via, draw_hole);
+}
+
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  return 1;
+}
+
+static int
+via_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, VIA_TYPE);
+  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  return 1;
+}
+
+static void
+draw_pad_name (PadType *pad)
+{
+  BoxType box;
+  bool vert;
+  TextType text;
+
+  if (!pad->Name || !pad->Name[0])
+    text.TextString = EMPTY (pad->Number);
+  else
+    text.TextString = EMPTY (TEST_FLAG (SHOWNUMBERFLAG, PCB) ? pad->Number : pad->Name);
+
+  /* should text be vertical ? */
+  vert = (pad->Point1.X == pad->Point2.X);
+
+  if (vert)
+    {
+      box.X1 = pad->Point1.X                      - pad->Thickness / 2;
+      box.Y1 = MAX (pad->Point1.Y, pad->Point2.Y) + pad->Thickness / 2;
+      box.X1 += Settings.PinoutTextOffsetY;
+      box.Y1 -= Settings.PinoutTextOffsetX;
+    }
+  else
+    {
+      box.X1 = MIN (pad->Point1.X, pad->Point2.X) - pad->Thickness / 2;
+      box.Y1 = pad->Point1.Y                      - pad->Thickness / 2;
+      box.X1 += Settings.PinoutTextOffsetX;
+      box.Y1 += Settings.PinoutTextOffsetY;
+    }
+
+  gui->set_color (Output.fgGC, PCB->PinNameColor);
+
+  text.Flags = NoFlags ();
+  /* Set font height to approx 90% of pad thickness */
+  text.Scale = 90 * pad->Thickness / FONT_CAPHEIGHT;
+  text.X = box.X1;
+  text.Y = box.Y1;
+  text.Direction = vert ? 1 : 0;
+
+  DrawTextLowLevel (&text, 0);
+}
+
+static void
+_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  if (clear && !mask && pad->Clearance <= 0)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_pad (gc, pad, clear, mask);
+  else
+    gui->fill_pcb_pad (gc, pad, clear, mask);
+}
+
+static void
+draw_pad (PadType *pad)
+{
+  if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, pad))
+   {
+     if (TEST_FLAG (WARNFLAG, pad))
+       gui->set_color (Output.fgGC, PCB->WarnColor);
+     else if (TEST_FLAG (SELECTEDFLAG, pad))
+       gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+     else
+       gui->set_color (Output.fgGC, PCB->ConnectedColor);
+   }
+  else if (FRONT (pad))
+   gui->set_color (Output.fgGC, PCB->PinColor);
+  else
+   gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+
+  _draw_pad (Output.fgGC, pad, false, false);
+
+  if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
+    draw_pad_name (pad);
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+
+  if (ON_SIDE (pad, *side))
+    draw_pad (pad);
+  return 1;
+}
+
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pv = (PinTypePtr) b;
+  int plated = cl ? *(int *) cl : -1;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
+    return 1;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    {
+      if (!TEST_FLAG (HOLEFLAG, pv))
+        {
+          gui->set_line_cap (Output.fgGC, Round_Cap);
+          gui->set_line_width (Output.fgGC, 0);
+          gui->draw_arc (Output.fgGC,
+                         pv->X, pv->Y, pv->DrillingHole / 2,
+                         pv->DrillingHole / 2, 0, 360);
+        }
+    }
+  else
+    gui->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+
+  if (TEST_FLAG (HOLEFLAG, pv))
+    {
+      if (TEST_FLAG (WARNFLAG, pv))
+        gui->set_color (Output.fgGC, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pv))
+        gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+      else
+        gui->set_color (Output.fgGC, Settings.BlackColor);
+
+      gui->set_line_cap (Output.fgGC, Round_Cap);
+      gui->set_line_width (Output.fgGC, 0);
+      gui->draw_arc (Output.fgGC,
+                     pv->X, pv->Y, pv->DrillingHole / 2,
+                     pv->DrillingHole / 2, 0, 360);
+    }
+  return 1;
+}
+
+static void
+_draw_line (LineType *line)
+{
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, line->Thickness);
+
+  gui->draw_line (Output.fgGC,
+		  line->Point1.X, line->Point1.Y,
+		  line->Point2.X, line->Point2.Y);
+}
+
+static void
+draw_line (LayerType *layer, LineType *line)
+{
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, line))
+        gui->set_color (Output.fgGC, layer->SelectedColor);
+      else
+        gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+  _draw_line (line);
+}
+
+static int
+line_callback (const BoxType * b, void *cl)
+{
+  draw_line ((LayerType *) cl, (LineType *) b);
+  return 1;
+}
+
+static void
+_draw_arc (ArcType *arc)
+{
+  if (!arc->Thickness)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, arc->Thickness);
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+
+  gui->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
+                 arc->Height, arc->StartAngle, arc->Delta);
+}
+
+static void
+draw_arc (LayerType *layer, ArcType *arc)
+{
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, arc))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, arc))
+        gui->set_color (Output.fgGC, layer->SelectedColor);
+      else
+        gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+
+  _draw_arc (arc);
+}
+
+static int
+arc_callback (const BoxType * b, void *cl)
+{
+  draw_arc ((LayerTypePtr) cl, (ArcTypePtr) b);
+  return 1;
+}
+
+static int
+text_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  TextType *text = (TextType *)b;
+  int min_silk_line;
+
+  if (TEST_FLAG (SELECTEDFLAG, text))
+    gui->set_color (Output.fgGC, layer->SelectedColor);
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+  if (layer == &PCB->Data->SILKLAYER ||
+      layer == &PCB->Data->BACKSILKLAYER)
+    min_silk_line = PCB->minSlk;
+  else
+    min_silk_line = PCB->minWid;
+  DrawTextLowLevel (text, min_silk_line);
+  return 1;
+}
+
+static void
+DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, const BoxType *drawn_area)
+{
+  static char *color;
+
+  if (!Polygon->Clipped)
+    return;
+
+  if (TEST_FLAG (SELECTEDFLAG, Polygon))
+    color = Layer->SelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Polygon))
+    color = PCB->ConnectedColor;
+  else
+    color = Layer->Color;
+  gui->set_color (Output.fgGC, color);
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, Polygon))
+    {
+      PolygonType poly = *Polygon;
+
+      for (poly.Clipped = Polygon->Clipped->f;
+           poly.Clipped != Polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+struct poly_info
+{
+  LayerTypePtr Layer;
+  const BoxType *drawn_area;
+};
+
+static int
+poly_callback (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+
+  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->drawn_area);
+  return 1;
+}
+
+static int
+clearPin_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinTypePtr) b;
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  return 1;
+}
+
+static int
+clearPad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+  if (ON_SIDE (pad, *side) && pad->Mask)
+    _draw_pad (Output.pmGC, pad, true, true);
+  return 1;
+}
+
+static int
+clearPin_callback_solid (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  return 1;
+}
+
+static int
+clearPad_callback_solid (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+  if (ON_SIDE (pad, *side) && pad->Mask)
+    gui->fill_pcb_pad (Output.pmGC, pad, true, true);
+  return 1;
+}
+
+static void
+GhidDrawMask (int side, BoxType * screen)
+{
+  int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+
+  OutputType *out = &Output;
+
+  if (thin)
+    {
+      gui->set_line_width (Output.pmGC, 0);
+      gui->set_color (Output.pmGC, PCB->MaskColor);
+      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      gui->set_color (Output.pmGC, "erase");
+    }
+
+  gui->use_mask (HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+
+  gui->use_mask (HID_MASK_AFTER);
+  gui->set_color (out->fgGC, PCB->MaskColor);
+  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  ghid_set_alpha_mult (out->fgGC, 1.0);
+
+  gui->use_mask (HID_MASK_OFF);
+}
+
+static int
+GhidDrawLayerGroup (int group, const BoxType * screen)
+{
+  int i, rv = 1;
+  int layernum;
+  int side;
+  struct poly_info info;
+  LayerTypePtr Layer;
+  int n_entries = PCB->LayerGroups.Number[group];
+  Cardinal *layers = PCB->LayerGroups.Entries[group];
+  int first_run = 1;
+  int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  if (!gui->set_layer (0, group, 0))
+    return 0;
+
+  /* HACK: Subcomposite each layer in a layer group separately */
+  for (i = n_entries - 1; i >= 0; i--) {
+    layernum = layers[i];
+    Layer = PCB->Data->Layer + layers[i];
+
+    if (strcmp (Layer->Name, "outline") == 0 ||
+        strcmp (Layer->Name, "route") == 0)
+      rv = 0;
+
+    if (layernum < max_copper_layer && Layer->On) {
+
+      if (!first_run)
+        gui->set_layer (0, group, 0);
+
+      first_run = 0;
+
+      if (rv && !TEST_FLAG (THINDRAWFLAG, PCB)) {
+        /* Mask out drilled holes on this layer */
+        hidgl_flush_triangles (&buffer);
+        glPushAttrib (GL_COLOR_BUFFER_BIT);
+        glColorMask (0, 0, 0, 0);
+        gui->set_color (Output.bgGC, PCB->MaskColor);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        hidgl_flush_triangles (&buffer);
+        glPopAttrib ();
+      }
+
+      /* draw all polygons on this layer */
+      if (Layer->PolygonN) {
+        info.Layer = Layer;
+        info.drawn_area = screen;
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+
+        /* HACK: Subcomposite polygons separately from other layer primitives */
+        /* Reset the compositing */
+        gui->end_layer ();
+        gui->set_layer (0, group, 0);
+
+        if (rv && !TEST_FLAG (THINDRAWFLAG, PCB)) {
+          hidgl_flush_triangles (&buffer);
+          glPushAttrib (GL_COLOR_BUFFER_BIT);
+          glColorMask (0, 0, 0, 0);
+          /* Mask out drilled holes on this layer */
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          hidgl_flush_triangles (&buffer);
+          glPopAttrib ();
+        }
+      }
+
+      /* Draw pins, vias and pads on this layer */
+      if (!global_view_2d && rv) {
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+        if (PCB->PinOn && group == component_group)
+          {
+            side = COMPONENT_LAYER;
+            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+          }
+        if (PCB->PinOn && group == solder_group)
+          {
+            side = SOLDER_LAYER;
+            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+          }
+      }
+
+      if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+        continue;
+
+      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
+      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
+      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+    }
+  }
+
+  gui->end_layer ();
+
+  return (n_entries > 1);
+}
+
+static void
+DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double scale)
+{
+#define PIXELS_PER_CIRCLINE 5.
+#define MIN_FACES_PER_CYL 6
+#define MAX_FACES_PER_CYL 360
+  float radius = vr;
+  float x1, y1;
+  float x2, y2;
+  float z1, z2;
+  int i;
+  int slices;
+
+  slices = M_PI * 2 * vr / scale / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_FACES_PER_CYL)
+    slices = MIN_FACES_PER_CYL;
+
+  if (slices > MAX_FACES_PER_CYL)
+    slices = MAX_FACES_PER_CYL;
+
+  z1 = compute_depth (from_layer);
+  z2 = compute_depth (to_layer);
+
+  x1 = vx + vr;
+  y1 = vy;
+
+  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+  for (i = 0; i < slices; i++)
+    {
+      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
+      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
+      x1 = x2;
+      y1 = y2;
+    }
+}
+
+struct cyl_info {
+  int from_layer;
+  int to_layer;
+  double scale;
+};
+
+static int
+draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    color = "drill";
+
+  gui->set_color (Output.fgGC, color);
+  DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  return 0;
+}
+
+static int
+pin_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, PIN_TYPE);
+}
+
+static int
+via_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, VIA_TYPE);
+}
+
+void
+ghid_draw_everything (BoxTypePtr drawn_area)
+{
+  render_priv *priv = gport->render_priv;
+  int i, ngroups;
+  int side;
+  /* This is the list of layer groups we will draw.  */
+  int do_group[MAX_LAYER];
+  /* This is the reverse of the order in which we draw them.  */
+  int drawn_groups[MAX_LAYER];
+  struct cyl_info cyl_info;
+  int reverse_layers;
+  int save_show_solder;
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
+
+  priv->current_colorname = NULL;
+
+  /* Test direction of rendering */
+  /* Look at sign of eye coordinate system z-coord when projecting a
+     world vector along +ve Z axis, (0, 0, 1). */
+  /* XXX: This isn't strictly correct, as I've ignored the matrix
+          elements for homogeneous coordinates. */
+  /* NB: last_modelview_matrix is transposed in memory! */
+  reverse_layers = (last_modelview_matrix[2][2] < 0);
+
+  save_show_solder = Settings.ShowSolderSide;
+  Settings.ShowSolderSide = reverse_layers;
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
+
+  memset (do_group, 0, sizeof (do_group));
+  if (global_view_2d) {
+    /* Draw in layer stack order when in 2D view */
+    for (ngroups = 0, i = 0; i < max_copper_layer; i++) {
+      int group = GetLayerGroupNumberByNumber (LayerStack[i]);
+
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
+    }
+  } else {
+    /* Draw in group order when in 3D view */
+    for (ngroups = 0, i = 0; i < max_group; i++) {
+      int group = reverse_layers ? max_group - 1 - i : i;
+
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
+    }
+  }
+
+  /*
+   * first draw all 'invisible' stuff
+   */
+  side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+
+  if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (side, drawn_area);
+
+    if (global_view_2d)
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+
+    gui->end_layer ();
+
+    /* Draw the reverse-side solder mask if turned on */
+    if (!global_view_2d &&
+        gui->set_layer (SWAP_IDENT ? "componentmask" : "soldermask",
+                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (side, drawn_area);
+        gui->end_layer ();
+      }
+  }
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--) {
+    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+
+#if 1
+    if (!global_view_2d && i > 0 &&
+        drawn_groups[i] >= min_phys_group &&
+        drawn_groups[i] <= max_phys_group &&
+        drawn_groups[i - 1] >= min_phys_group &&
+        drawn_groups[i - 1] <= max_phys_group) {
+      cyl_info.from_layer = drawn_groups[i];
+      cyl_info.to_layer = drawn_groups[i - 1];
+      cyl_info.scale = gport->view.coord_per_px;
+      gui->set_color (Output.fgGC, "drill");
+      ghid_set_alpha_mult (Output.fgGC, 0.75);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      ghid_set_alpha_mult (Output.fgGC, 1.0);
+    }
+#endif
+  }
+
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  side = SWAP_IDENT ? SOLDER_LAYER : COMPONENT_LAYER;
+
+  /* Draw pins, pads, vias below silk */
+  if (global_view_2d) {
+    start_subcomposite ();
+
+    if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
+      /* Mask out drilled holes */
+      hidgl_flush_triangles (&buffer);
+      glPushAttrib (GL_COLOR_BUFFER_BIT);
+      glColorMask (0, 0, 0, 0);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      hidgl_flush_triangles (&buffer);
+      glPopAttrib ();
+    }
+
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+
+    end_subcomposite ();
+  }
+
+  /* Draw the solder mask if turned on */
+  if (gui->set_layer (SWAP_IDENT ? "soldermask" : "componentmask",
+                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (side, drawn_area);
+    gui->end_layer ();
+  }
+
+  if (gui->set_layer (SWAP_IDENT ? "bottomsilk" : "topsilk",
+                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (side, drawn_area);
+      gui->end_layer ();
+  }
+
+  /* Draw element Marks */
+  if (PCB->PinOn)
+    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+
+  /* Draw rat lines on top */
+  if (PCB->RatOn && gui->set_layer ("rats", SL (RATS, 0), 0)) {
+    DrawRats(drawn_area);
+    gui->end_layer ();
+  }
+
+  Settings.ShowSolderSide = save_show_solder;
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -1025,8 +1906,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50; /* FIXME */
-  max_depth =  0;  /* FIXME */
+  min_depth = -50 + compute_depth (0);                    /* FIXME: NEED TO USE PHYSICAL GROUPS */
+  max_depth =  50 + compute_depth (max_copper_layer - 1); /* FIXME: NEED TO USE PHYSICAL GROUPS */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1092,18 +1973,50 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  glBegin (GL_QUADS);
-  glVertex3i (0,             0,              -50);
-  glVertex3i (PCB->MaxWidth, 0,              -50);
-  glVertex3i (PCB->MaxWidth, PCB->MaxHeight, -50);
-  glVertex3i (0,             PCB->MaxHeight, -50);
-  glEnd ();
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+  /* glStencilFunc (GL_GREATER, 1, 1); */           /* Draw only where stencil buffer is 0 */
+
+  if (global_view_2d) {
+    glBegin (GL_QUADS);
+    glVertex3i (0,             0,              0);
+    glVertex3i (PCB->MaxWidth, 0,              0);
+    glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
+    glVertex3i (0,             PCB->MaxHeight, 0);
+    glEnd ();
+  } else {
+    int solder_group;
+    int component_group;
+    int min_phys_group;
+    int max_phys_group;
+    int i;
+
+    solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+    component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+
+    min_phys_group = MIN (solder_group, component_group);
+    max_phys_group = MAX (solder_group, component_group);
+
+    glBegin (GL_QUADS);
+    for (i = min_phys_group; i <= max_phys_group; i++) {
+      int depth = compute_depth (i);
+      glVertex3i (0,             0,              depth);
+      glVertex3i (PCB->MaxWidth, 0,              depth);
+      glVertex3i (PCB->MaxWidth, PCB->MaxHeight, depth);
+      glVertex3i (0,             PCB->MaxHeight, depth);
+    }
+    glEnd ();
+  }
 
   ghid_draw_bg_image ();
 
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-  hid_expose_callback (&ghid_hid, &region, 0);
+  /* hid_expose_callback (&ghid_hid, &region, 0); */
+  ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
 
   /* Set the current depth to the right value for the layer we are editing */
