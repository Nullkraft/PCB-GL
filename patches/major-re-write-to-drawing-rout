Bottom: 229e7874c04f4c437ae8b647dc4a300923185aa3
Top:    5981bd1c7791b7e1fd425ffae860d1427c2a85f4
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 14:47:23 +0100

Major re-write to drawing routines


---

diff --git a/src/draw.c b/src/draw.c
index 4359225..4b5c79e 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -76,7 +76,7 @@ FloatPolyType, *FloatPolyTypePtr;
  * some local identifiers
  */
 static BoxType Block;
-static Boolean Gathering = True;
+/* static */ Boolean Gathering = True;
 static int Erasing = False;
 
 static int doing_pinout = False;
@@ -88,29 +88,29 @@ static const BoxType *clip_box = NULL;
  */
 static void Redraw (Boolean, BoxTypePtr);
 static void DrawEverything (BoxTypePtr);
-static void DrawTop (const BoxType *);
+/* static */ void DrawTop (const BoxType *);
 static int DrawLayerGroup (int, const BoxType *);
-static void DrawPinOrViaLowLevel (PinTypePtr, Boolean);
+/* static */ void DrawPinOrViaLowLevel (PinTypePtr, Boolean);
 static void ClearOnlyPin (PinTypePtr, Boolean);
-static void DrawPlainPin (PinTypePtr, Boolean);
-static void DrawPlainVia (PinTypePtr, Boolean);
+/* static */ void DrawPlainPin (PinTypePtr, Boolean);
+/* static */ void DrawPlainVia (PinTypePtr, Boolean);
 static void DrawPinOrViaNameLowLevel (PinTypePtr);
 static void DrawPadLowLevel (hidGC, PadTypePtr, Boolean, Boolean);
 static void DrawPadNameLowLevel (PadTypePtr);
 static void DrawLineLowLevel (LineTypePtr, Boolean);
-static void DrawRegularText (LayerTypePtr, TextTypePtr, int);
+/* static */ void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
 static void AddPart (void *);
 static void SetPVColor (PinTypePtr, int);
-static void DrawEMark (ElementTypePtr, LocationType, LocationType, Boolean);
+/* static */ void DrawEMark (ElementTypePtr, LocationType, LocationType, Boolean);
 static void ClearPad (PadTypePtr, Boolean);
-static void DrawHole (PinTypePtr);
-static void DrawMask (BoxType *);
-static void DrawRats (BoxType *);
-static void DrawSilk (int, int, BoxType *);
+/* static */ void DrawHole (PinTypePtr);
+/* static */ void DrawMask (BoxType *);
+/* static */ void DrawRats (BoxType *);
+/* static */ void DrawSilk (int, int, BoxType *);
 static int pin_callback (const BoxType * b, void *cl);
 static int pad_callback (const BoxType * b, void *cl);
 
@@ -591,7 +591,7 @@ DrawEverything (BoxTypePtr drawn_area)
     }
 }
 
-static void
+/* static */ void
 DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
 	   Boolean invisible)
 {
@@ -653,7 +653,7 @@ pad_callback (const BoxType * b, void *cl)
 /* ---------------------------------------------------------------------------
  * draws pins pads and vias
  */
-static void
+/* static */ void
 DrawTop (const BoxType * screen)
 {
   if (PCB->PinOn || doing_assy)
@@ -679,7 +679,7 @@ struct pin_info
   LayerTypePtr Layer;
 };
 
-static int
+/* static */ int
 clearPin_callback (const BoxType * b, void *cl)
 {
   PinTypePtr pin = (PinTypePtr) b;
@@ -697,7 +697,7 @@ poly_callback (const BoxType * b, void *cl)
   return 1;
 }
 
-static int
+/* static */ int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
@@ -710,7 +710,7 @@ clearPad_callback (const BoxType * b, void *cl)
  * Draws silk layer.
  */
 
-static void
+/* static */ void
 DrawSilk (int new_swap, int layer, BoxTypePtr drawn_area)
 {
 #if 0
@@ -760,7 +760,7 @@ DrawSilk (int new_swap, int layer, BoxTypePtr drawn_area)
 /* ---------------------------------------------------------------------------
  * draws solder mask layer - this will cover nearly everything
  */
-static void
+/* static */ void
 DrawMask (BoxType * screen)
 {
   struct pin_info info;
@@ -817,7 +817,7 @@ DrawMask (BoxType * screen)
 #endif
 }
 
-static void
+/* static */ void
 DrawRats (BoxTypePtr drawn_area)
 {
   /*
@@ -952,7 +952,7 @@ DrawLayerGroup (int group, const BoxType * screen)
  *         \       /
  *          2 --- 1
   */
-static void
+/* static */ void
 DrawSpecialPolygon (HID * hid, hidGC DrawGC,
 		    LocationType X, LocationType Y, int Thickness)
 {
@@ -1015,7 +1015,7 @@ DrawSpecialPolygon (HID * hid, hidGC DrawGC,
 /* ---------------------------------------------------------------------------
  * lowlevel drawing routine for pins and vias
  */
-static void
+/* static */ void
 DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
 {
   if (Gathering)
@@ -1103,7 +1103,7 @@ DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
 /**************************************************************
  * draw pin/via hole
  */
-static void
+/* static */ void
 DrawHole (PinTypePtr Ptr)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
@@ -1770,7 +1770,7 @@ DrawVia (PinTypePtr Via, int unused)
 /* ---------------------------------------------------------------------------
  * draw a via without dealing with polygon clearance 
  */
-static void
+/* static */ void
 DrawPlainVia (PinTypePtr Via, Boolean holeToo)
 {
   if (!Gathering)
@@ -1818,7 +1818,7 @@ DrawPin (PinTypePtr Pin, int unused)
 /* ---------------------------------------------------------------------------
  * draw a pin without clearing around polygons 
  */
-static void
+/* static */ void
 DrawPlainPin (PinTypePtr Pin, Boolean holeToo)
 {
   if (!Gathering)
@@ -2008,7 +2008,7 @@ DrawText (LayerTypePtr Layer, TextTypePtr Text, int unused)
 /* ---------------------------------------------------------------------------
  * draws text on a layer
  */
-static void
+/* static */ void
 DrawRegularText (LayerTypePtr Layer, TextTypePtr Text, int unused)
 {
   int min_silk_line;
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 27b7721..2abd05a 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -519,81 +519,99 @@ ghid_invalidate_all ()
   gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
 }
 
+int compute_depth (int group)
+{
+  static int last_depth_computed = 0;
+
+  int depth = last_depth_computed;
+  int newgroup;
+  int idx = (group >= 0
+             && group <
+             max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  if (group >= 0 && group < max_layer) {
+    newgroup = group;
+#if 0
+    /* Re-ordering doesn't work, since we also need to adjust the rendering order */
+    if (group == 1)
+      newgroup = max_layer - 1;
+    else if (group > 1)
+      newgroup = group - 1;
+#endif
+    depth = ((max_layer - newgroup) * 10) * 200 / gport->zoom;
+  } else if (SL_TYPE (idx) == SL_MASK) {
+    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+      depth = (max_layer * 10 + 3) * 200 / gport->zoom;
+    } else {
+      depth = (10 - 3) * 200 / gport->zoom;
+    }
+  } else if (SL_TYPE (idx) == SL_SILK) {
+    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+      depth = (max_layer * 10 + 5) * 200 / gport->zoom;
+    } else {
+      depth = (10 - 5) * 200 / gport->zoom;
+    }
+  } else if (SL_TYPE (idx) == SL_INVISIBLE) {
+    depth = (10 - 3) * 200 / gport->zoom;
+  }
+
+  last_depth_computed = depth;
+  return depth;
+}
+
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
   static int stencil_bit = 0;
-  int idx = (group >= 0
-	     && group <
-	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+  int idx = (group >= 0 && group < max_layer) ?
+              PCB->LayerGroups.Entries[group][0] : group;
 
-#define SUBCOMPOSITE_LAYERS
-#ifdef SUBCOMPOSITE_LAYERS
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
-  if (group >= 0 && group < max_layer) {
-    hidgl_set_depth ((max_layer - group) * 10);
+  hidgl_set_depth (compute_depth (group));
+
+  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
+  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
+  if (SL_TYPE (idx) != SL_FINISHED) {
+    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
   } else {
-    if (SL_TYPE (idx) == SL_SILK) {
-      if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
-        hidgl_set_depth (max_layer * 10 + 3);
-      } else {
-        hidgl_set_depth (10 - 3);
-      }
-    }
+    stencil_bit = 0;
+    glStencilMask (0);
+    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
 
-  glEnable (GL_STENCIL_TEST);                // Enable Stencil test
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
-  /* Reset stencil buffer so we can paint anywhere */
-  hidgl_return_stencil_bit (stencil_bit);               // Relinquish any bitplane we previously used
-  if (SL_TYPE (idx) != SL_FINISHED)
-    {
-      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
-      glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
-      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
-    }
-  else
-    {
-#endif
-      stencil_bit = 0;
-      glStencilMask (0);
-      glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
-#ifdef SUBCOMPOSITE_LAYERS
-    }
-#endif
-
   if (idx >= 0 && idx < max_layer + 2) {
     gport->trans_lines = TRUE;
-    return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
+    return PCB->Data->Layer[idx].On;
   }
-  if (idx < 0)
-    {
-      switch (SL_TYPE (idx))
-	{
-	case SL_INVISIBLE:
-	  return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
-	case SL_MASK:
-	  if (SL_MYSIDE (idx) /*&& !pinout */ )
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
-	case SL_SILK:
-          gport->trans_lines = TRUE;
-//          gport->trans_lines = FALSE;
-	  if (SL_MYSIDE (idx) /*|| pinout */ )
-	    return PCB->ElementOn;
-	  return 0;
-	case SL_ASSY:
-	  return 0;
-	case SL_RATS:
-	  gport->trans_lines = TRUE;
-	  return 1;
-	case SL_PDRILL:
-	case SL_UDRILL:
-	  return 1;
-	}
+
+  if (idx < 0) {
+    switch (SL_TYPE (idx)) {
+      case SL_INVISIBLE:
+        return PCB->InvisibleObjectsOn;
+      case SL_MASK:
+        if (SL_MYSIDE (idx))
+          return TEST_FLAG (SHOWMASKFLAG, PCB);
+        return 0;
+      case SL_SILK:
+        gport->trans_lines = TRUE;
+        if (SL_MYSIDE (idx))
+          return PCB->ElementOn;
+        return 0;
+      case SL_ASSY:
+        return 0;
+      case SL_RATS:
+        gport->trans_lines = TRUE;
+        return 1;
+      case SL_PDRILL:
+      case SL_UDRILL:
+        return 1;
     }
+  }
   return 0;
 }
 
@@ -702,9 +720,9 @@ ghid_set_special_colors (HID_Attribute * ha)
     }
 }
 
-static char *current_color = NULL;
-static double global_alpha_mult = 1.0;
-static int alpha_changed = 0;
+/* static */ char *current_color = NULL;
+/* static */ double global_alpha_mult = 1.0;
+/* static */ int alpha_changed = 0;
 
 void
 ghid_set_color (hidGC gc, const char *name)
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index d005136..3dfd9ac 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -961,6 +961,13 @@ ghid_screen_update (void)
 void DrawAttached (Boolean);
 void draw_grid (BoxTypePtr drawn_area);
 
+struct pin_info
+{
+  Boolean arg;
+  LayerTypePtr Layer;
+  BoxTypePtr drawn_area;
+};
+
 void
 ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata)
 {
@@ -991,6 +998,629 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
   ghid_invalidate_all ();
 }
 
+static int
+backE_callback (const BoxType * b, void *cl)
+{
+  ElementTypePtr element = (ElementTypePtr) b;
+
+  if (!FRONT (element))
+    {
+      DrawElementPackage (element, 0);
+    }
+  return 1;
+}
+
+static int
+backN_callback (const BoxType * b, void *cl)
+{
+  TextTypePtr text = (TextTypePtr) b;
+  ElementTypePtr element = (ElementTypePtr) text->Element;
+
+  if (!FRONT (element) && !TEST_FLAG (HIDENAMEFLAG, element))
+    DrawElementName (element, 0);
+  return 0;
+}
+
+static int
+backPad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+
+  if (!FRONT (pad))
+    DrawPad (pad, 0);
+  return 1;
+}
+
+static int
+EMark_callback (const BoxType * b, void *cl)
+{
+  ElementTypePtr element = (ElementTypePtr) b;
+
+  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  return 1;
+}
+
+static void
+SetPVColor_inlayer (PinTypePtr Pin, LayerTypePtr Layer, int Type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    color = Layer->Color;
+
+  gui->set_color (Output.fgGC, color);
+}
+
+
+static int
+pin_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, PIN_TYPE);
+  DrawPinOrViaLowLevel ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+via_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, VIA_TYPE);
+  DrawPinOrViaLowLevel ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  DrawPlainPin ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  if (FRONT (pad))
+    DrawPad (pad, 0);
+  return 1;
+}
+
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  int plated = cl ? *(int *) cl : -1;
+
+#if 0
+  switch (plated)
+    {
+    case -1:
+      break;
+    case 0:
+      if (!TEST_FLAG (HOLEFLAG, pin))
+	return 1;
+      break;
+    case 1:
+      if (TEST_FLAG (HOLEFLAG, pin))
+	return 1;
+      break;
+    }
+#endif
+  DrawHole ((PinTypePtr) b);
+  return 1;
+}
+
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr via = (PinTypePtr) b;
+  DrawPlainVia (via, False);
+  return 1;
+}
+
+static int
+line_callback (const BoxType * b, void *cl)
+{
+  DrawLine ((LayerTypePtr) cl, (LineTypePtr) b, 0);
+  return 1;
+}
+
+static int
+arc_callback (const BoxType * b, void *cl)
+{
+  DrawArc ((LayerTypePtr) cl, (ArcTypePtr) b, 0);
+  return 1;
+}
+
+static int
+text_callback (const BoxType * b, void *cl)
+{
+  DrawRegularText ((LayerTypePtr) cl, (TextTypePtr) b, 0);
+  return 1;
+}
+
+static void
+DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, BoxTypePtr drawn_area)
+{
+  static char *color;
+
+  if (!Polygon->Clipped)
+    return;
+
+  if (TEST_FLAG (SELECTEDFLAG, Polygon))
+    color = Layer->SelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Polygon))
+    color = PCB->ConnectedColor;
+  else
+    color = Layer->Color;
+  gui->set_color (Output.fgGC, color);
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, Polygon))
+    {
+      PolygonType poly = *Polygon;
+
+      for (poly.Clipped = Polygon->Clipped->f;
+           poly.Clipped != Polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+static int
+poly_callback (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+
+  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->drawn_area);
+  return 1;
+}
+
+static void
+DrawPadLowLevelSolid (hidGC gc, PadTypePtr Pad, Boolean clear, Boolean mask)
+{
+  int w = clear ? (mask ? Pad->Mask : Pad->Thickness + Pad->Clearance)
+		: Pad->Thickness;
+
+  if (Pad->Point1.X == Pad->Point2.X &&
+      Pad->Point1.Y == Pad->Point2.Y)
+    {
+      if (TEST_FLAG (SQUAREFLAG, Pad))
+        {
+          int l, r, t, b;
+          l = Pad->Point1.X - w / 2;
+          b = Pad->Point1.Y - w / 2;
+          r = l + w;
+          t = b + w;
+          gui->fill_rect (gc, l, b, r, t);
+        }
+      else
+        {
+          gui->fill_circle (gc, Pad->Point1.X, Pad->Point1.Y, w / 2);
+        }
+    }
+  else
+    {
+      gui->set_line_cap (gc,
+                         TEST_FLAG (SQUAREFLAG,
+                                    Pad) ? Square_Cap : Round_Cap);
+      gui->set_line_width (gc, w);
+
+      gui->draw_line (gc,
+                      Pad->Point1.X, Pad->Point1.Y,
+                      Pad->Point2.X, Pad->Point2.Y);
+    }
+}
+
+static void
+ClearPadSolid (PadTypePtr Pad, Boolean mask)
+{
+  DrawPadLowLevelSolid(Output.pmGC, Pad, True, mask);
+}
+
+static void
+ClearOnlyPinSolid (PinTypePtr Pin, Boolean mask)
+{
+  BDimension half =
+    (mask ? Pin->Mask / 2 : (Pin->Thickness + Pin->Clearance) / 2);
+
+  if (!mask && TEST_FLAG (HOLEFLAG, Pin))
+    return;
+  if (half == 0)
+    return;
+  if (!mask && Pin->Clearance <= 0)
+    return;
+
+  /* Clear the area around the pin */
+  if (TEST_FLAG (SQUAREFLAG, Pin))
+    {
+      int l, r, t, b;
+      l = Pin->X - half;
+      b = Pin->Y - half;
+      r = l + half * 2;
+      t = b + half * 2;
+      gui->fill_rect (Output.pmGC, l, b, r, t);
+    }
+  else if (TEST_FLAG (OCTAGONFLAG, Pin))
+    {
+      gui->set_line_cap (Output.pmGC, Round_Cap);
+      gui->set_line_width (Output.pmGC, (Pin->Clearance + Pin->Thickness
+					 - Pin->DrillingHole));
+
+      DrawSpecialPolygon (gui, Output.pmGC, Pin->X, Pin->Y, half * 2);
+    }
+  else
+    {
+      gui->fill_circle (Output.pmGC, Pin->X, Pin->Y, half);
+    }
+}
+
+static int
+clearPin_callback_solid (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  struct pin_info *i = (struct pin_info *) cl;
+  if (i->arg)
+    ClearOnlyPinSolid (pin, True);
+  return 1;
+}
+
+static int
+clearPad_callback_solid (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  if (!XOR (TEST_FLAG (ONSOLDERFLAG, pad), SWAP_IDENT))
+    ClearPadSolid (pad, True);
+  return 1;
+}
+
+int clearPin_callback (const BoxType * b, void *cl);
+int clearPad_callback (const BoxType * b, void *cl);
+
+
+static void
+DrawMask (BoxType * screen)
+{
+  struct pin_info info;
+  int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+
+  OutputType *out = &Output;
+
+  info.arg = True;
+  info.drawn_area = screen;
+
+  if (thin)
+    {
+      gui->set_line_width (Output.pmGC, 0);
+      gui->set_color (Output.pmGC, PCB->MaskColor);
+      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, &info);
+      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, &info);
+      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &info);
+      gui->set_color (Output.pmGC, "erase");
+    }
+
+  gui->use_mask (HID_MASK_BEFORE);
+  gui->set_color (out->fgGC, PCB->MaskColor);
+  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+
+  gui->use_mask (HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, &info);
+  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, &info);
+  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &info);
+
+  gui->use_mask (HID_MASK_AFTER);
+  gui->set_color (out->fgGC, PCB->MaskColor);
+  ghid_global_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  ghid_global_alpha_mult (out->fgGC, 1.0);
+
+  gui->use_mask (HID_MASK_OFF);
+}
+
+static int
+DrawLayerGroup (int group, const BoxType * screen)
+{
+  int i, rv = 1;
+  int layernum;
+  struct pin_info info;
+  LayerTypePtr Layer;
+  int n_entries = PCB->LayerGroups.Number[group];
+  Cardinal *layers = PCB->LayerGroups.Entries[group];
+  int first_run = 1;
+
+  if (!gui->set_layer (0, group, 0)) {
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    return 0;
+  }
+
+  /* HACK: Subcomposite each layer in a layer group separately */
+  for (i = n_entries - 1; i >= 0; i--) {
+    layernum = layers[i];
+    Layer = PCB->Data->Layer + layers[i];
+
+    if (strcmp (Layer->Name, "outline") == 0 ||
+        strcmp (Layer->Name, "route") == 0)
+      rv = 0;
+
+    if (layernum < max_layer /*&& Layer->On*/) {
+
+      if (!first_run)
+        gui->set_layer (0, group, 0);
+
+      first_run = 0;
+
+      if (rv) {
+        /* Mask out drilled holes on this layer */
+        hidgl_flush_triangles (&buffer);
+        glPushAttrib (GL_COLOR_BUFFER_BIT);
+        glColorMask (0, 0, 0, 0);
+        gui->set_color (Output.bgGC, PCB->MaskColor);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        hidgl_flush_triangles (&buffer);
+        glPopAttrib ();
+      }
+
+      /* draw all polygons on this layer */
+      if (Layer->PolygonN) {
+        info.Layer = Layer;
+        info.drawn_area = screen;
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+
+        /* HACK: Subcomposite polygons separately from other layer primitives */
+        /* Reset the compositing */
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        gui->set_layer (0, group, 0);
+
+        if (rv) {
+          hidgl_flush_triangles (&buffer);
+          glPushAttrib (GL_COLOR_BUFFER_BIT);
+          glColorMask (0, 0, 0, 0);
+          /* Mask out drilled holes on this layer */
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          hidgl_flush_triangles (&buffer);
+          glPopAttrib ();
+        }
+      }
+
+      /* Draw pins and vias on this layer */
+      if (!global_view_2d && rv) {
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+      }
+
+      if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+        continue;
+
+      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
+      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
+      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+    }
+  }
+
+  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+
+  return (n_entries > 1);
+}
+
+extern int compute_depth (int group);
+
+static void
+DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double scale)
+{
+#define PIXELS_PER_CIRCLINE 5.
+#define MIN_FACES_PER_CYL 6
+#define MAX_FACES_PER_CYL 360
+  float radius = vr;
+  float x1, y1;
+  float x2, y2;
+  float z1, z2;
+  int i;
+  int slices;
+
+  slices = M_PI * 2 * vr / scale / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_FACES_PER_CYL)
+    slices = MIN_FACES_PER_CYL;
+
+  if (slices > MAX_FACES_PER_CYL)
+    slices = MAX_FACES_PER_CYL;
+
+  z1 = compute_depth (from_layer);
+  z2 = compute_depth (to_layer);
+
+  x1 = vx + vr;
+  y1 = vy;
+
+  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+  for (i = 0; i < slices; i++)
+    {
+      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
+      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
+      x1 = x2;
+      y1 = y2;
+    }
+}
+
+struct cyl_info {
+  int from_layer;
+  int to_layer;
+  double scale;
+};
+
+static int
+hole_cyl_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr Pin = (PinTypePtr) b;
+  struct cyl_info *info = cl;
+  DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+}
+
+void
+ghid_draw_everything (BoxTypePtr drawn_area)
+{
+  int i, ngroups, side;
+  int plated;
+  /* This is the list of layer groups we will draw.  */
+  int do_group[MAX_LAYER];
+  /* This is the reverse of the order in which we draw them.  */
+  int drawn_groups[MAX_LAYER];
+  struct cyl_info cyl_info;
+  int reverse_layers;
+
+  extern char *current_color;
+  extern Boolean Gathering;
+
+  current_color = NULL;
+  Gathering = False;
+
+  /* Test direction of rendering */
+  /* Look at sign of eye coordinate system z-coord when projecting a
+     world vector along +ve Z axis, (0, 0, 1). */
+  /* FIXME: This isn't strictly correct, as I've ignored the matrix
+            elements for homogeneous coordinates. */
+  /* NB: last_modelview_matrix is transposed in memory! */
+  reverse_layers = (last_modelview_matrix[2][2] < 0);
+  if (Settings.ShowSolderSide)
+    reverse_layers = !reverse_layers;
+
+  Settings.ShowSolderSide = reverse_layers ? !Settings.ShowSolderSide : Settings.ShowSolderSide;
+
+  memset (do_group, 0, sizeof (do_group));
+  for (ngroups = 0, i = 0; i < max_layer; i++) {
+    LayerType *l;
+    int group;
+    int orderi;
+
+    orderi = reverse_layers ? max_layer - i - 1 : i;
+
+    // Draw in numerical order when in 3D view
+    l = global_view_2d ? LAYER_ON_STACK (i) : LAYER_PTR (orderi);
+    group = GetLayerGroupNumberByNumber (global_view_2d ? LayerStack[i] : orderi);
+
+    if (/*l->On && */!do_group[group]) {
+      do_group[group] = 1;
+      drawn_groups[ngroups++] = group;
+    }
+  }
+
+  /*
+   * first draw all 'invisible' stuff
+   */
+  if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
+    r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback, NULL);
+    if (PCB->ElementOn) {
+      r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback, NULL);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, backN_callback, NULL);
+      DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
+    }
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+  }
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--) {
+    DrawLayerGroup (drawn_groups [i], drawn_area);
+
+#if 1
+    if (!global_view_2d && i > 0) {
+      cyl_info.from_layer = drawn_groups[i];
+      cyl_info.to_layer = drawn_groups[i - 1];
+      cyl_info.scale = gport->zoom;
+//      gui->set_color (Output.fgGC, PCB->MaskColor);
+      gui->set_color (Output.fgGC, "drill");
+      ghid_global_alpha_mult (Output.fgGC, 0.75);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_cyl_callback, &cyl_info);
+      ghid_global_alpha_mult (Output.fgGC, 1.0);
+    }
+#endif
+  }
+
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  /* Draw pins, pads, vias below silk */
+  if (!Settings.ShowSolderSide)
+    gui->set_layer ("topsilk", SL (SILK, TOP), 0);
+  else
+    gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0);
+//  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+
+#if 1
+  /* Mask out drilled holes */
+  hidgl_flush_triangles (&buffer);
+  glPushAttrib (GL_COLOR_BUFFER_BIT);
+  glColorMask (0, 0, 0, 0);
+  if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+  if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+  hidgl_flush_triangles (&buffer);
+  glPopAttrib ();
+
+  if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
+  if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+  if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+#endif
+
+  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+
+  /* Draw the solder mask if turned on */
+  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0)) {
+    int save_swap = SWAP_IDENT;
+    SWAP_IDENT = 0;
+    DrawMask (drawn_area);
+    SWAP_IDENT = save_swap;
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+  }
+  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0)) {
+    int save_swap = SWAP_IDENT;
+    SWAP_IDENT = 1;
+    DrawMask (drawn_area);
+    SWAP_IDENT = save_swap;
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+  }
+  /* Draw top silkscreen */
+  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0)) {
+    DrawSilk (0, COMPONENT_LAYER, drawn_area);
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+  }
+
+  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0)) {
+    DrawSilk (1, SOLDER_LAYER, drawn_area);
+    gui->set_layer (NULL, SL (FINISHED, 0), 0);
+  }
+
+  /* Draw element Marks */
+  if (PCB->PinOn)
+    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+
+  /* Draw rat lines on top */
+  if (PCB->RatOn && gui->set_layer ("rats", SL (RATS, 0), 0))
+    DrawRats(drawn_area);
+
+  Gathering = True;
+  Settings.ShowSolderSide = reverse_layers ? !Settings.ShowSolderSide : Settings.ShowSolderSide;
+}
+
+static int one_shot = 1;
 
 #define Z_NEAR 3.0
 gboolean
@@ -1066,8 +1696,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50; /* FIXME */
-  max_depth =  0;  /* FIXME */
+  min_depth = -50 + compute_depth (0);         /* FIXME */
+  max_depth =  50 + compute_depth (max_layer); /* FIXME */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1159,7 +1789,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
                 ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
                              -gport->view_y0, 0);
 
-  hid_expose_callback (&ghid_hid, &region, 0);
+  // hid_expose_callback (&ghid_hid, &region, 0);
+  ghid_draw_everything (&region);
 
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1198,6 +1829,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   /* end drawing to current GL-context */
   gdk_gl_drawable_gl_end (pGlDrawable);
 
+  one_shot = 0;
+
   return FALSE;
 }
