Bottom: ae855d27e0eafaa1a7343e9154885fdac1a46ff2
Top:    1ffa63aa0f8637877dfbbae519e4a5ec32ab4a98
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-01-06 23:14:35 +0000

Add routines to render just a single contour

Use them rather than the GLU tessellator


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 859dd82..23b2fa3 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -578,12 +578,10 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
   free (vertices);
 }
 
-void
-tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices,
-                   double scale)
+static void
+fill_contour (hidGC gc, PLINE *contour, double scale)
 {
-  VNODE *vn = &contour->head;
-  int offset = 0;
+  borast_traps_t traps;
 
   /* If the contour is round, and hidgl_fill_circle would use
    * less slices than we have vertices to draw it, then call
@@ -592,27 +590,18 @@ tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices,
   if (contour->is_round) {
     double slices = calc_slices (contour->radius / scale, 2 * M_PI);
     if (slices < contour->Count) {
-      hidgl_fill_circle (tesselator_gc, contour->cx, contour->cy, contour->radius, scale);
+      hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius, scale);
       return;
     }
   }
 
-  gluTessBeginPolygon (tobj, NULL);
-  gluTessBeginContour (tobj);
-  do {
-    vertices [0 + offset] = vn->point[0];
-    vertices [1 + offset] = vn->point[1];
-    vertices [2 + offset] = 0.;
-    gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
-    offset += 3;
-  } while ((vn = vn->next) != &contour->head);
-  gluTessEndContour (tobj);
-  gluTessEndPolygon (tobj);
+  _borast_traps_init (&traps);
+  bo_contour_to_traps (gc, contour, &traps);
+  _borast_traps_fini (&traps);
 }
 
 struct do_hole_info {
-  GLUtesselator *tobj;
-  GLdouble *vertices;
+  hidGC gc;
   double scale;
 };
 
@@ -627,7 +616,7 @@ do_hole (const BoxType *b, void *cl)
     return 0;
   }
 
-  tesselate_contour (info->tobj, curc, info->vertices, info->scale);
+  fill_contour (info->gc, curc, info->scale);
   return 1;
 }
 
@@ -637,50 +626,37 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
   hidglGC hidgl_gc = (hidglGC)gc;
   hidgl_instance *hidgl = hidgl_gc->hidgl;
   hidgl_priv *priv = hidgl->priv;
-  int vertex_count = 0;
-  PLINE *contour;
   struct do_hole_info info;
   int stencil_bit;
-  borast_traps_t traps;
-
-  _borast_traps_init (&traps);
-  bo_poly_to_traps (gc, pa, &traps);
-  _borast_traps_fini (&traps);
-
-  return;
 
+  info.gc = gc;
   info.scale = scale;
   global_scale = scale;
 
+  /* Special case non-holed polygons which don't require a stencil bit */
+  if (pa->contour_tree->size == 1) {
+    fill_contour (gc, pa->contours, scale);
+    return;
+  }
+
+  /* Polygon has holes */
+
   stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
   if (!stencil_bit)
     {
       printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+      /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
       return;
     }
 
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (hidgl);
 
-  /* Walk the polygon structure, counting vertices */
-  /* This gives an upper bound on the amount of storage required */
-  for (contour = pa->contours; contour != NULL; contour = contour->next)
-    vertex_count = MAX (vertex_count, contour->Count);
-
-  tesselator_gc = gc;
-  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
-  info.tobj = gluNewTess ();
-  gluTessCallback(info.tobj, GLU_TESS_BEGIN,   (_GLUfuncptr)myBegin);
-  gluTessCallback(info.tobj, GLU_TESS_VERTEX,  (_GLUfuncptr)myVertex);
-  gluTessCallback(info.tobj, GLU_TESS_COMBINE, (_GLUfuncptr)myCombine);
-  gluTessCallback(info.tobj, GLU_TESS_ERROR,   (_GLUfuncptr)myError);
-
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);                 /* Save the write mask etc.. for final restore */
-  glEnable (GL_STENCIL_TEST);
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
   glStencilMask (stencil_bit);                          /* Only write to our stencil bit */
   glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, ref value is our bit */
+  glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
   glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
 
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value */
@@ -691,8 +667,10 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
   hidgl_flush_triangles (hidgl);
 
   glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on any subcompositing bitplane */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
                                                 /* If the stencil test has passed, we know that bit is 0, so we're */
                                                 /* effectively just setting it to 1. */
 
@@ -703,19 +681,13 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
   /* Draw the polygon outer */
-  tesselate_contour (info.tobj, pa->contours, info.vertices, scale);
-
+  fill_contour (gc, pa->contours, scale);
   hidgl_flush_triangles (hidgl);
 
   /* Unassign our stencil buffer bit */
   hidgl_return_stencil_bit (hidgl, stencil_bit);
 
-  glPopAttrib ();                               /* Restore the stencil buffer write-mask etc.. */
-
-  gluDeleteTess (info.tobj);
-  tesselator_gc = NULL;
-  myFreeCombined ();
-  free (info.vertices);
+  glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
 
 void
