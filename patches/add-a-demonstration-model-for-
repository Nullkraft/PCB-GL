Bottom: f140d9dbd0e899e60b55872fff09e410903d3d06
Top:    af57be3fdd9eb85c3b3c35ced89a21f410939e54
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-02-13 18:44:27 +0000

Add a demonstration model for rendering ACY series resistors

Play with some lighting effects (SLOW!!!)
Play with shaders and lighting goodness

Oops, nasty hack due to unknown code changes on merge. Left merge comments commented out for now.


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 5ee4135..47b171d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -178,6 +178,7 @@ GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
 	hid/common/glext.h \
+	hid/common/hidgl_package_acy_resistor.c \
 	hid/common/hidgl_shaders.c \
 	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
diff --git a/src/board_texture.png b/src/board_texture.png
new file mode 100644
index 0000000000000000000000000000000000000000..30e477ad2545b67e4d3d499dc7eaab53e5a2ea89
GIT binary patch
literal 20699
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
S)4|yQ0000<MNUMnLSTZSq#wQj

literal 0
HcmV?d00001

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 8cb829b..e6b1eaf 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -82,6 +82,12 @@ PFNGLLINKPROGRAMPROC        glLinkProgram       = NULL;
 PFNGLSHADERSOURCEPROC       glShaderSource      = NULL;
 PFNGLUSEPROGRAMPROC         glUseProgram        = NULL;
 
+PFNGLMULTITEXCOORD1FPROC    glMultiTexCoord1f    = NULL;
+PFNGLMULTITEXCOORD2FPROC    glMultiTexCoord2f    = NULL;
+PFNGLMULTITEXCOORD3FPROC    glMultiTexCoord3f    = NULL;
+PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation = NULL;
+PFNGLUNIFORM1IPROC          glUniform1i          = NULL;
+PFNGLACTIVETEXTUREARBPROC   glActiveTextureARB   = NULL;
 #endif
 
 #include "action.h"
@@ -105,6 +111,7 @@ PFNGLUSEPROGRAMPROC         glUseProgram        = NULL;
 //#define MEMCPY_VERTEX_DATA 1
 
 hidgl_shader *circular_program = NULL;
+hidgl_shader *resistor_program = NULL;
 
 static bool in_context = false;
 
@@ -939,9 +946,20 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
   hidgl_flush_triangles (hidgl);
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
-                GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
+                GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
+                GL_DEPTH_BUFFER_BIT);
   glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
+//=======
+//<<<<<<< current
+//                GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
+//  glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
+//=======
+//                GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
+//                GL_DEPTH_BUFFER_BIT);
+//>>>>>>> patched
   glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
+  glDepthFunc (GL_ALWAYS);
+  glDepthMask (GL_FALSE);
 
   if (use_new_stencil)
     {
@@ -1032,7 +1050,34 @@ load_built_in_shaders (void)
           "  gl_FragColor = gl_Color;\n"
           "}\n";
 
+  char *resistor_fs_source =
+          "uniform sampler1D detail_tex;\n"
+          "uniform sampler2D bump_tex;\n"
+          "\n"
+          "void main()\n"
+          "{\n"
+          "  vec3 bumpNormal = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
+          "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
+          "\n"
+          "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
+          "  vec3 lightVectorFinal = -1.0 + 2.0 * gl_Color.rgb;\n"
+          "  vec3 halfVectorFinal = -1.0 + 2.0 * gl_TexCoord[2].xyz;\n"
+          "  vec3 bumpNormalVectorFinal = -1.0 + 2.0 * bumpNormal;\n"
+          "\n"
+          "  /* Compute diffuse factor */\n"
+          "  float diffuse = clamp(dot(bumpNormalVectorFinal,\n"
+          "                            lightVectorFinal),0.0, 1.0);\n"
+          "  float specular = pow(clamp(dot(bumpNormalVectorFinal,\n"
+          "                                 halfVectorFinal), 0.0, 1.0),\n"
+          "                       2.0);\n"
+          "  specular *= 0.4;\n"
+          "\n"
+          "   gl_FragColor = vec4(detailColor * (0.3 + 0.7 * diffuse) + \n"
+          "                    vec3(specular, specular, specular), 1.0);\n"
+          "}\n";
+
   /*priv->*/circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
+  /*priv->*/resistor_program = hidgl_shader_new ("resistor_rendering", NULL, resistor_fs_source);
 }
 
 void
@@ -1071,6 +1116,14 @@ hidgl_init (void)
   glLinkProgram       = (PFNGLLINKPROGRAMPROC)       wglGetProcAddress ("glLinkProgram");
   glShaderSource      = (PFNGLSHADERSOURCEPROC)      wglGetProcAddress ("glShaderSource");
   glUseProgram        = (PFNGLUSEPROGRAMPROC)        wglGetProcAddress ("glUseProgram");
+
+  glMultiTexCoord1f    = (PFNGLMULTITEXCOORD1FPROC)    wglGetProcAddress ("glMultiTexCoord1f");
+  glMultiTexCoord2f    = (PFNGLMULTITEXCOORD2FPROC)    wglGetProcAddress ("glMultiTexCoord2f");
+  glMultiTexCoord3f    = (PFNGLMULTITEXCOORD3FPROC)    wglGetProcAddress ("glMultiTexCoord3f");
+  glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) wglGetProcAddress ("glGetUniformLocation");
+  glUniform1i          = (PFNGLUNIFORM1IPROC)          wglGetProcAddress ("glUniform1i");
+  glActiveTextureARB   = (PFNGLACTIVETEXTUREARBPROC)   wglGetProcAddress ("glActiveTextureARB");
+
 #endif
 
 #if 0 /* Need to initialise shaders with a current GL context */
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 484614c..14469b3 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -69,6 +69,7 @@ typedef struct hidgl_gc_struct {
 } *hidglGC;
 
 extern hidgl_shader *circular_program;
+extern hidgl_shader *resistor_program;
 
 void hidgl_flush_triangles (hidgl_instance *hidgl);
 void hidgl_ensure_vertex_space (hidGC gc, int count);
@@ -176,4 +177,7 @@ int hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl);
 void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
 void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
 
+/* hidgl_pacakge_acy_resistor.c */
+void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
+
 #endif /* PCB_HID_COMMON_HIDGL_H  */
diff --git a/src/hid/common/hidgl_package_acy_resistor.c b/src/hid/common/hidgl_package_acy_resistor.c
new file mode 100644
index 0000000..62ef69f
--- /dev/null
+++ b/src/hid/common/hidgl_package_acy_resistor.c
@@ -0,0 +1,1084 @@
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include "data.h"
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#   include <GL/gl.h>
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "hid_draw.h"
+#include "hidgl.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+#ifdef WIN32
+#   include "hid/common/glext.h"
+
+extern PFNGLUSEPROGRAMPROC         glUseProgram;
+
+extern PFNGLMULTITEXCOORD1FPROC    glMultiTexCoord1f;
+extern PFNGLMULTITEXCOORD2FPROC    glMultiTexCoord2f;
+extern PFNGLMULTITEXCOORD3FPROC    glMultiTexCoord3f;
+extern PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
+extern PFNGLUNIFORM1IPROC          glUniform1i;
+extern PFNGLACTIVETEXTUREARBPROC   glActiveTextureARB;
+
+#endif
+
+static int
+compute_offset (int x, int y, int width, int height)
+{
+  x = (x + width) % width;
+  y = (y + height) % height;
+  return (y * width + x) * 4;
+}
+
+static void
+load_texture_from_png (char *filename, bool bumpmap)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  /* int has_alpha; */
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+  unsigned char *new_pixels;
+  int x, y;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  /* has_alpha = gdk_pixbuf_get_has_alpha (pixbuf); */
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  new_pixels = malloc (width * height * 4);
+
+  /* XXX: Move computing bump map out of the texture loading function */
+  if (bumpmap) {
+    for (y = 0; y < height; y++)
+      for (x = 0; x < width; x++) {
+        float r, g, b;
+        float lenvec;
+
+        float dzdx = (pixels[compute_offset (x + 1, y, width, height)] - pixels[compute_offset (x - 1, y, width, height)]) / 255.;
+        float dzdy = (pixels[compute_offset (x, y + 1, width, height)] - pixels[compute_offset (x, y - 1, width, height)]) / 255.;
+
+#if 0
+        dx *= 10.;
+        dy *= 10.;
+#endif
+
+        /* Basis vectors are (x -> x+1) in X direction , z(x,y), z(x,x)+dzdx in Z direction */
+        /*                   (y -> y+1) in Y direction , z(x,y), z(x,y)+dzdy in Z direction */
+
+        /* Normal is cross product of the two basis vectors */
+        // | i  j  k    |
+        // | 1  0  dzdx |
+        // | 0  1  dzdy |
+
+        r = -dzdx;
+        g = -dzdy;
+        b = 1.;
+
+        lenvec = sqrt (r * r + g * g + b * b);
+
+        r /= lenvec;
+        g /= lenvec;
+        b /= lenvec;
+
+        new_pixels [compute_offset (x, y, width, height) + 0] =
+          (unsigned char)((r / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 1] =
+          (unsigned char)((g / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 2] =
+          (unsigned char)((b / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 3] = 255;
+      }
+
+    memcpy (pixels, new_pixels, width * height * 4);
+    gdk_pixbuf_save (pixbuf, "debug_bumps.png", "png", NULL, NULL);
+  }
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
+
+  free (new_pixels);
+  g_object_unref (pixbuf);
+}
+
+static double
+resistor_string_to_value (char *string)
+{
+  char *c = string;
+  double accum_value = 0;
+  bool before_decimal_point = true;
+  double place_value = 1.;
+  double multiplier = 1.;
+
+  while (c != NULL && *c != '\0') {
+    if (*c >= '0' && *c <= '9') {
+      unsigned char digit_value;
+      digit_value = *c - '0';
+
+      if (before_decimal_point) {
+        accum_value *= 10.;
+        accum_value += digit_value;
+      } else {
+        place_value /= 10.;
+        accum_value += digit_value * place_value;
+      }
+    } else if (before_decimal_point) {
+      switch (*c) {
+        case 'R':
+        case 'r':
+        case '.':
+          multiplier = 1.;
+          break;
+
+        case 'k':
+        case 'K':
+          multiplier = 1000.;
+          break;
+
+        case 'M':
+          multiplier = 1000000.;
+          break;
+
+        case 'm':
+          multiplier = 1 / 1000.;
+          break;
+
+        default:
+          /* XXX: Unknown multiplier */
+          break;
+      }
+      before_decimal_point = false;
+
+    } else {
+      /* XXX: Unknown input */
+    }
+    c++;
+  }
+
+  accum_value *= multiplier;
+
+  return accum_value;
+}
+
+static void
+resistor_value_to_stripes (ElementType *element, int no_stripes, int *stripes, int *mul, int *tol)
+{
+  char *value_string = element->Name[VALUE_INDEX].TextString;
+  double value;
+  double order_of_magnitude;
+  int sigfigs;
+  int i;
+
+  /* XXX: Don't know tolerenace, so assume 1% */
+  *tol = 2;
+
+  if (value_string == NULL) {
+    stripes[0] = 0;
+    stripes[1] = 0;
+    stripes[2] = 0;
+    *mul = 0;
+    return;
+  }
+
+  value = resistor_string_to_value (value_string);
+
+  order_of_magnitude = log (value) / log (10);
+  *mul = (int)order_of_magnitude - no_stripes + 3;
+  if (*mul < 0 || *mul > 9) {
+    /* Resistor multiplier out of range, e.g. zero ohm links */
+    *mul = 2; /* PUT BLACK */
+    stripes[0] = 0;
+    stripes[1] = 0;
+    stripes[2] = 0;
+    return;
+  }
+
+  /* Round to no_stripes significant figures */
+  value /= pow (10., (int)order_of_magnitude - no_stripes + 1);
+  sigfigs = (int)(value + 0.5);
+  value = round (value);
+
+  /* Start with all the sigfigs in the least significant stripes, then
+   * proceed stripe by stripe subtracting anything which can carry over
+   * into the next most significant stripe.
+   *
+   * NB: Stripe 0 is the most significant
+   */
+  stripes[no_stripes - 1] = sigfigs;
+
+  for (i = no_stripes - 1; i > 0; i--) {
+    stripes [i - 1] = stripes[i] / 10;
+    stripes [i] -= 10 * stripes[i - 1];
+
+    assert (stripes[i] >= 0 && stripes[i] <= 9);
+  }
+
+  assert (stripes[0] >= 0 && stripes[0] <= 9);
+}
+
+static void
+setup_zero_ohm_texture (GLfloat *res_body_color)
+{
+  GLfloat tex_data[32][3];
+  int strip;
+
+  for (strip = 0; strip < sizeof (tex_data) / sizeof (GLfloat[3]); strip++) {
+    tex_data[strip][0] = res_body_color[0];
+    tex_data[strip][1] = res_body_color[1];
+    tex_data[strip][2] = res_body_color[2];
+  }
+
+  tex_data[15][0] = 0.;  tex_data[15][1] = 0.;  tex_data[15][2] = 0.;
+  tex_data[16][0] = 0.;  tex_data[16][1] = 0.;  tex_data[16][2] = 0.;
+
+  glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 32, 0, GL_RGB, GL_FLOAT, tex_data);
+}
+
+static bool
+setup_resistor_texture (ElementType *element, GLfloat *res_body_color, int no_stripes)
+{
+  GLfloat val_color[10][3] = {{0.00, 0.00, 0.00},
+                              {0.52, 0.26, 0.00},
+                              {1.00, 0.00, 0.00},
+                              {1.00, 0.52, 0.00},
+                              {1.00, 1.00, 0.00},
+                              {0.00, 0.91, 0.00},
+                              {0.00, 0.00, 1.00},
+                              {0.68, 0.00, 0.68},
+                              {0.65, 0.65, 0.65},
+                              {1.00, 1.00, 1.00}};
+
+  GLfloat mul_color[10][3] = {{0.65, 0.65, 0.65},  /* 0.01  */ /* XXX: Silver */
+                              {0.72, 0.48, 0.09},  /* 0.1   */ /* XXX: Gold */
+                              {0.00, 0.00, 0.00},  /* 1     */
+                              {0.52, 0.26, 0.00},  /* 10    */
+                              {1.00, 0.00, 0.00},  /* 100   */
+                              {1.00, 0.52, 0.00},  /* 1k    */
+                              {1.00, 1.00, 0.00},  /* 10k   */
+                              {0.00, 0.91, 0.00},  /* 100k  */
+                              {0.00, 0.00, 1.00},  /* 1M    */
+                              {0.68, 0.00, 0.68}}; /* 10M   */
+
+  GLfloat tol_color[10][3] = {{0.65, 0.65, 0.65},  /* 10%   */ /* XXX: Silver */
+                              {0.72, 0.48, 0.09},  /* 5%    */ /* XXX: Gold */
+                              {0.52, 0.26, 0.00},  /* 1%    */
+                              {1.00, 0.00, 0.00},  /* 2%    */
+                              {0.00, 0.91, 0.00},  /* 0.5%  */
+                              {0.00, 0.00, 1.00},  /* 0.25% */
+                              {0.68, 0.00, 0.68}}; /* 0.1%  */
+
+  int *stripes;
+  int mul;
+  int tol;
+
+  GLfloat tex_data[32][3];
+  int texel;
+  int i;
+  bool is_zero_ohm;
+
+  if (TEST_FLAG (SELECTEDFLAG, element)) {
+    GLfloat selected_color[] = {0.00, 0.70, 0.82};
+    float mix_color_ratio = 0.5;
+    res_body_color[0] = res_body_color[0] * (1 - mix_color_ratio) + selected_color[0] * mix_color_ratio;
+    res_body_color[1] = res_body_color[1] * (1 - mix_color_ratio) + selected_color[1] * mix_color_ratio;
+    res_body_color[2] = res_body_color[2] * (1 - mix_color_ratio) + selected_color[2] * mix_color_ratio;
+  }
+
+  stripes = malloc (no_stripes * sizeof (int));
+  resistor_value_to_stripes (element, no_stripes, stripes, &mul, &tol);
+
+  is_zero_ohm = true;
+
+  for (i = 0; i < no_stripes; i++) {
+    if (stripes[i] != 0)
+      is_zero_ohm = false;
+  }
+
+  if (is_zero_ohm) {
+    setup_zero_ohm_texture (res_body_color);
+    free (stripes);
+    return true;
+  }
+
+  for (texel = 0; texel < sizeof (tex_data) / sizeof (GLfloat[3]); texel++) {
+    tex_data[texel][0] = res_body_color[0];
+    tex_data[texel][1] = res_body_color[1];
+    tex_data[texel][2] = res_body_color[2];
+  }
+
+  if (no_stripes == 2) {
+    tex_data[ 7][0] = val_color[stripes[0]][0];  tex_data[ 7][1] = val_color[stripes[0]][1];  tex_data[ 7][2] = val_color[stripes[0]][2];
+    tex_data[10][0] = val_color[stripes[1]][0];  tex_data[10][1] = val_color[stripes[1]][1];  tex_data[10][2] = val_color[stripes[1]][2];
+    tex_data[14][0] = mul_color[mul]       [0];  tex_data[14][1] = mul_color[mul]       [1];  tex_data[14][2] = mul_color[mul]       [2];
+    tex_data[24][0] = tol_color[tol]       [0];  tex_data[24][1] = tol_color[tol]       [1];  tex_data[24][2] = tol_color[tol]       [2];
+  }
+
+  if (no_stripes == 3) {
+
+    tex_data[ 7][0] = val_color[stripes[0]][0];  tex_data[ 7][1] = val_color[stripes[0]][1];  tex_data[ 7][2] = val_color[stripes[0]][2];
+
+    tex_data[10][0] = val_color[stripes[1]][0];  tex_data[10][1] = val_color[stripes[1]][1];  tex_data[10][2] = val_color[stripes[1]][2];
+    tex_data[11][0] = val_color[stripes[1]][0];  tex_data[11][1] = val_color[stripes[1]][1];  tex_data[11][2] = val_color[stripes[1]][2];
+
+    tex_data[14][0] = val_color[stripes[2]][0];  tex_data[14][1] = val_color[stripes[2]][1];  tex_data[14][2] = val_color[stripes[2]][2];
+    tex_data[15][0] = val_color[stripes[2]][0];  tex_data[15][1] = val_color[stripes[2]][1];  tex_data[15][2] = val_color[stripes[2]][2];
+
+    tex_data[18][0] = mul_color[mul]       [0];  tex_data[18][1] = mul_color[mul]       [1];  tex_data[18][2] = mul_color[mul]       [2];
+    tex_data[19][0] = mul_color[mul]       [0];  tex_data[19][1] = mul_color[mul]       [1];  tex_data[19][2] = mul_color[mul]       [2];
+
+    tex_data[24][0] = tol_color[tol]       [0];  tex_data[24][1] = tol_color[tol]       [1];  tex_data[24][2] = tol_color[tol]       [2];
+  }
+
+
+  glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 32, 0, GL_RGB, GL_FLOAT, tex_data);
+
+  free (stripes);
+  return false;
+}
+
+static void invert_4x4 (float m[4][4], float out[4][4]);
+
+static GLfloat *debug_lines = NULL;
+static int no_debug_lines = 0;
+static int max_debug_lines = 0;
+
+//#define LENG 1000
+#define LENG 0.6
+#define STRIDE_FLOATS 6
+static void
+debug_basis_vector (float x,   float y,   float z,
+                    float b1x, float b1y, float b1z,
+                    float b2x, float b2y, float b2z,
+                    float b3x, float b3y, float b3z)
+{
+  int comp_count;
+  float lenb1, lenb2, lenb3;
+
+  if (no_debug_lines + 3 > max_debug_lines) {
+    max_debug_lines += 10;
+    debug_lines = realloc (debug_lines, max_debug_lines * sizeof (GLfloat) * 2 * STRIDE_FLOATS);
+  }
+
+  lenb1 = sqrt (b1x * b1x + b1y * b1y + b1z * b1z);
+  lenb2 = sqrt (b2x * b2x + b2y * b2y + b2z * b2z);
+  lenb3 = sqrt (b3x * b3x + b3y * b3y + b3z * b3z);
+  b1x /= lenb1;  b1y /= lenb1;  b1z /= lenb1;
+  b2x /= lenb2;  b2y /= lenb2;  b2z /= lenb2;
+  b3x /= lenb3;  b3y /= lenb3;  b3z /= lenb3;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b1x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b1y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b1z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b2x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b2y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b2z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b3x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b3y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b3z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  no_debug_lines++;
+}
+
+static void
+debug_basis_display ()
+{
+  if (no_debug_lines == 0)
+    return;
+
+#if 1
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glVertexPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[0]);
+  glColorPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[3]);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glDrawArrays (GL_LINES, 0, no_debug_lines * 2);
+  glDisableClientState (GL_COLOR_ARRAY);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glPopAttrib ();
+#endif
+
+  free (debug_lines);
+  debug_lines = NULL;
+  no_debug_lines = 0;
+  max_debug_lines = 0;
+}
+
+/* b1{x,y,z} is the basis vector along "s" texture space */
+/* b2{x,y,z} is the basis vector along "t" texture space */
+/* mvm is the model view matrix (transposed in memory) */
+static void
+compute_light_vector (float b1x, float b1y, float b1z,
+                      float b2x, float b2y, float b2z,
+                      float *lx, float *ly, float *lz,
+                      float *hx, float *hy, float *hz,
+                      float x,   float y,   float z,
+                      GLfloat *mvm)
+{
+  float b3x, b3y, b3z;
+  float tb1x, tb1y, tb1z;
+  float tb2x, tb2y, tb2z;
+  float tb3x, tb3y, tb3z;
+  /* NB: light_direction is a vector _TOWARDS_ the light source position */
+//  float light_direction[] = {-0.5, 1., -1.}; /* XXX: HARDCODEED! */
+  float light_direction[] = {0.0, 0.0, 1.0}; /* XXX: HARDCODEED! */
+  float half_direction[3];
+  float texspace_to_eye[4][4];
+  float eye_to_texspace[4][4];
+  float lenb1, lenb2, lenb3;
+  float len_half;
+  float len_light;
+
+  /* Normalise the light vector */
+  len_light = sqrt (light_direction[0] * light_direction[0] +
+                    light_direction[1] * light_direction[1] +
+                    light_direction[2] * light_direction[2]);
+  light_direction[0] /= len_light;
+  light_direction[1] /= len_light;
+  light_direction[2] /= len_light;
+
+  /* Sum with the unit vector towards the viewer */
+  half_direction[0] = light_direction[0] + 0.;
+  half_direction[1] = light_direction[1] + 0.;
+  half_direction[2] = light_direction[2] + 1.;
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                        0., 0., 1.,
+                        light_direction[0], light_direction[1], light_direction[2],
+                        half_direction[0], half_direction[1], half_direction[2]);
+
+  /* Third basis vector is the cross product of tb1 and tb2 */
+  b3x = (b2y * b1z - b2z * b1y);
+  b3y = (b2z * b1x - b2x * b1z);
+  b3z = (b2x * b1y - b2y * b1x);
+
+  /* Transform the S, T texture space bases into eye coordinates */
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;
+
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;
+
+  tb3x = mvm[0] * b3x + mvm[4] * b3y + mvm[ 8] * b3z;
+  tb3y = mvm[1] * b3x + mvm[5] * b3y + mvm[ 9] * b3z;
+  tb3z = mvm[2] * b3x + mvm[6] * b3y + mvm[10] * b3z;
+
+#if 1
+  /* Normalise tb1, tb2 and tb3 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  lenb3 = sqrt (tb3x * tb3x + tb3y * tb3y + tb3z * tb3z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+  tb3x /= lenb3;  tb3y /= lenb3;  tb3z /= lenb3;
+#endif
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                         tb1x, tb1y, tb1z, tb2x, tb2y, tb2z, tb3x, tb3y, tb3z);
+
+  texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
+  texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
+  texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
+  texspace_to_eye[3][0] = 0.0;  texspace_to_eye[3][1] = 0.0;  texspace_to_eye[3][2] = 0.0;   texspace_to_eye[3][3] = 1.0;
+
+  invert_4x4 (texspace_to_eye, eye_to_texspace);
+
+  /* light_direction is in eye space, we need to transform this into texture space */
+  *lx = eye_to_texspace[0][0] * light_direction[0] +
+        eye_to_texspace[0][1] * light_direction[1] +
+        eye_to_texspace[0][2] * light_direction[2];
+  *ly = eye_to_texspace[1][0] * light_direction[0] +
+        eye_to_texspace[1][1] * light_direction[1] +
+        eye_to_texspace[1][2] * light_direction[2];
+  *lz = eye_to_texspace[2][0] * light_direction[0] +
+        eye_to_texspace[2][1] * light_direction[1] +
+        eye_to_texspace[2][2] * light_direction[2];
+
+  /* half_direction is in eye space, we need to transform this into texture space */
+  *hx = eye_to_texspace[0][0] * half_direction[0] +
+        eye_to_texspace[0][1] * half_direction[1] +
+        eye_to_texspace[0][2] * half_direction[2];
+  *hy = eye_to_texspace[1][0] * half_direction[0] +
+        eye_to_texspace[1][1] * half_direction[1] +
+        eye_to_texspace[1][2] * half_direction[2];
+  *hz = eye_to_texspace[2][0] * half_direction[0] +
+        eye_to_texspace[2][1] * half_direction[1] +
+        eye_to_texspace[2][2] * half_direction[2];
+
+  {
+    len_light = sqrt (*lx * *lx + *ly * *ly + *lz * *lz);
+    *lx /= len_light;
+    *ly /= len_light;
+    *lz /= len_light;
+
+    *lx = *lx / 2. + 0.5;
+    *ly = *ly / 2. + 0.5;
+    *lz = *lz / 2. + 0.5;
+
+    len_half = sqrt (*hx * *hx + *hy * *hy + *hz * *hz);
+    *hx /= len_half;
+    *hy /= len_half;
+    *hz /= len_half;
+
+    *hx = *hx / 2. + 0.5;
+    *hy = *hy / 2. + 0.5;
+    *hz = *hz / 2. + 0.5;
+  }
+}
+
+static void
+emit_vertex (float x,   float y,   float z,
+             float b1x, float b1y, float b1z,
+             float b2x, float b2y, float b2z,
+             float tex0_s, float tex1_s, float tex1_t,
+             GLfloat *mvm)
+{
+  GLfloat lx, ly, lz;
+  GLfloat hx, hy, hz;
+  compute_light_vector (b1x, b1y, b1z, b2x, b2y, b2z, &lx, &ly, &lz, &hx, &hy, &hz, x, y, z, mvm);
+  glColor3f (lx, ly, lz);
+  glMultiTexCoord1f (GL_TEXTURE0, tex0_s);
+  glMultiTexCoord2f (GL_TEXTURE1, tex1_s, tex1_t);
+  glMultiTexCoord3f (GL_TEXTURE2, hx, hy, hz);
+  glVertex3f (x, y, z);
+}
+
+enum geom_pos {
+  FIRST,
+  MIDDLE,
+  LAST
+};
+
+static void
+emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
+           float ang_edge2, float cos_edge2, float sin_edge2,
+           float prev_r, float prev_z,
+           float      r, float      z,
+           float next_r, float next_z,
+           float tex0_s, float resistor_width,
+           enum geom_pos pos,
+           GLfloat *mvm)
+{
+  int repeat;
+
+  tex0_s = z / resistor_width + 0.5;
+
+  for (repeat = 0; repeat < ((pos == FIRST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge1, r * sin_edge1, z,
+                 sin_edge1, -cos_edge1, 0,
+                 cos_edge1 * (next_r - prev_r) / 2., sin_edge1 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge1 / 2. / M_PI, tex0_s, mvm);
+
+  for (repeat = 0; repeat < ((pos == LAST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge2, r * sin_edge2, z,
+                 sin_edge2, -cos_edge2, 0,
+                 cos_edge2 * (next_r - prev_r) / 2., sin_edge2 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge2 / 2. / M_PI, tex0_s, mvm);
+}
+
+
+#define NUM_RESISTOR_STRIPS 100
+#define NUM_PIN_RINGS 15
+
+/* XXX: HARDCODED MAGIC */
+#define BOARD_THICKNESS MM_TO_COORD (1.6)
+
+void
+hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness)
+{
+
+  float center_x, center_y;
+  float angle;
+  GLfloat resistor_body_color[] =         {0.31, 0.47, 0.64};
+  GLfloat resistor_pin_color[] =          {0.82, 0.82, 0.82};
+  GLfloat resistor_warn_pin_color[] =     {0.82, 0.20, 0.20};
+  GLfloat resistor_found_pin_color[] =    {0.20, 0.82, 0.20};
+  GLfloat resistor_selected_pin_color[] = {0.00, 0.70, 0.82};
+  GLfloat *pin_color;
+
+  GLfloat mvm[16];
+
+  int strip;
+  int no_strips = NUM_RESISTOR_STRIPS;
+  int ring;
+  int no_rings = NUM_PIN_RINGS;
+  int end;
+  bool zero_ohm;
+
+  static bool first_run = true;
+  static GLuint texture1;
+  static GLuint texture2_resistor;
+  static GLuint texture2_zero_ohm;
+
+  GLuint restore_sp;
+
+  /* XXX: Hard-coded magic */
+  float resistor_pin_radius = MIL_TO_COORD (12.);
+  float resistor_taper1_radius = MIL_TO_COORD (16.);
+  float resistor_taper2_radius = MIL_TO_COORD (35.);
+  float resistor_bulge_radius = MIL_TO_COORD (43.);
+  float resistor_barrel_radius = MIL_TO_COORD (37.);
+
+  float resistor_taper1_offset = MIL_TO_COORD (25.);
+  float resistor_taper2_offset = MIL_TO_COORD (33.);
+  float resistor_bulge_offset = MIL_TO_COORD (45.);
+  float resistor_bulge_width = MIL_TO_COORD (50.);
+  float resistor_pin_spacing = MIL_TO_COORD (400.);
+
+  float pin_penetration_depth = MIL_TO_COORD (30.) + board_thickness;
+
+  float resistor_pin_bend_radius = resistor_bulge_radius;
+  float resistor_width = resistor_pin_spacing - 2. * resistor_pin_bend_radius;
+
+  PinType *first_pin = element->Pin->data;
+  PinType *second_pin = g_list_next (element->Pin)->data;
+  PinType *pin;
+
+  Coord pin_delta_x = second_pin->X - first_pin->X;
+  Coord pin_delta_y = second_pin->Y - first_pin->Y;
+
+  center_x = first_pin->X + pin_delta_x / 2.;
+  center_y = first_pin->Y + pin_delta_y / 2.;
+  angle = atan2f (pin_delta_y, pin_delta_x);
+
+  /* TRANSFORM MATRIX */
+  glPushMatrix ();
+  glTranslatef (center_x, center_y, surface_depth + resistor_pin_bend_radius);
+  glRotatef (angle * 180. / M_PI + 90, 0., 0., 1.);
+  glRotatef (90, 1., 0., 0.);
+
+  /* Retrieve the resulting modelview matrix for the lighting calculations */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  /* TEXTURE SETUP */
+  glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
+  hidgl_shader_activate (resistor_program);
+
+  {
+    GLuint program = hidgl_shader_get_program (resistor_program);
+    int tex0_location = glGetUniformLocation (program, "detail_tex");
+    int tex1_location = glGetUniformLocation (program, "bump_tex");
+    glUniform1i (tex0_location, 0);
+    glUniform1i (tex1_location, 1);
+  }
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+//  if (first_run) {
+    glGenTextures (1, &texture1);
+    glBindTexture (GL_TEXTURE_1D, texture1);
+    zero_ohm = setup_resistor_texture (element, resistor_body_color, 3);
+//  } else {
+//    glBindTexture (GL_TEXTURE_1D, texture1);
+//  }
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glEnable (GL_TEXTURE_1D);
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  if (first_run) {
+    glGenTextures (1, &texture2_resistor);
+    glBindTexture (GL_TEXTURE_2D, texture2_resistor);
+    load_texture_from_png ("resistor_bump.png", true);
+
+    glGenTextures (1, &texture2_zero_ohm);
+    glBindTexture (GL_TEXTURE_2D, texture2_zero_ohm);
+    load_texture_from_png ("zero_ohm_bump.png", true);
+  }
+  if (zero_ohm)
+    glBindTexture (GL_TEXTURE_2D, texture2_zero_ohm);
+  else
+    glBindTexture (GL_TEXTURE_2D, texture2_resistor);
+
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glEnable (GL_TEXTURE_2D);
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+
+  /* COLOR / MATERIAL SETUP */
+//  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+//  glEnable (GL_COLOR_MATERIAL);
+
+  glPushAttrib (GL_CURRENT_BIT);
+//  glColor4f (1., 1., 1., 1.);
+  glColor4f (0., 0., 1., 0.);
+
+  glDisable (GL_LIGHTING);
+
+  if (1) {
+    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
+    GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
+    GLfloat shininess = 20.;
+    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+  }
+
+#if 1
+  glBegin (GL_TRIANGLE_STRIP);
+
+  for (strip = 0; strip < no_strips; strip++) {
+
+    int ring;
+    int no_rings;
+    float angle_edge1 = strip * 2. * M_PI / no_strips;
+    float angle_edge2 = (strip + 1) * 2. * M_PI / no_strips;
+
+    float cos_edge1 = cosf (angle_edge1);
+    float sin_edge1 = sinf (angle_edge1);
+    float cos_edge2 = cosf (angle_edge2);
+    float sin_edge2 = sinf (angle_edge2);
+
+    struct strip_item {
+      GLfloat z;
+      GLfloat r;
+      GLfloat tex0_s;
+    } strip_data[] = {
+      {-resistor_width / 2. - 1.,                                                     resistor_pin_radius,     0.}, /* DUMMY */
+      {-resistor_width / 2.,                                                          resistor_pin_radius,     0.},
+      {-resistor_width / 2. + resistor_taper1_offset,                                 resistor_taper1_radius,  0.},
+      {-resistor_width / 2. + resistor_taper2_offset,                                 resistor_taper2_radius,  0.},
+      {-resistor_width / 2. + resistor_bulge_offset                              ,   resistor_bulge_radius, 0.},
+      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 3. / 4.,   resistor_bulge_radius, 0.},
+      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width,           resistor_barrel_radius,  0.},
+//      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width,           resistor_barrel_radius,  0.},
+                                                                                      /*********************/  
+      { 0,                                                                            resistor_barrel_radius,  0.5},
+                                                                                      /*********************/
+//      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width,           resistor_barrel_radius,  1.},
+      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width,           resistor_barrel_radius,  1.},
+      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 3. / 4.,   resistor_bulge_radius, 1.},
+      { resistor_width / 2. - resistor_bulge_offset,                                  resistor_bulge_radius, 1.},
+      { resistor_width / 2. - resistor_taper2_offset,                                 resistor_taper2_radius,  1.},
+      { resistor_width / 2. - resistor_taper1_offset,                                 resistor_taper1_radius,  1.},
+      { resistor_width / 2.,                                                          resistor_pin_radius,     1.},
+      { resistor_width / 2. + 1.,                                                     resistor_pin_radius,     1.}, /* DUMMY */
+    };
+
+    no_rings = sizeof (strip_data) / sizeof (struct strip_item);
+    for (ring = 1; ring < no_rings - 1; ring++) {
+      enum geom_pos pos = MIDDLE;
+      if (ring == 1)            pos = FIRST;
+      if (ring == no_rings - 2) pos = LAST;
+
+      emit_pair (angle_edge1, cos_edge1, sin_edge1,
+                 angle_edge2, cos_edge2, sin_edge2,
+                 strip_data[ring - 1].r, strip_data[ring - 1].z,
+                 strip_data[ring    ].r, strip_data[ring    ].z,
+                 strip_data[ring + 1].r, strip_data[ring + 1].z,
+                 strip_data[ring    ].tex0_s, resistor_width, pos, mvm);
+    }
+  }
+#endif
+
+  glEnd ();
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  glDisable (GL_TEXTURE_2D);
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+  glDisable (GL_TEXTURE_1D);
+  glBindTexture (GL_TEXTURE_1D, 0);
+  glDeleteTextures (1, &texture1);
+
+  glEnable (GL_LIGHTING);
+
+  glUseProgram (0);
+
+  /* COLOR / MATERIAL SETUP */
+  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+  glEnable (GL_COLOR_MATERIAL);
+
+  if (1) {
+//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
+    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
+    GLfloat shininess = 120.;
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+  }
+
+  for (end = 0; end < 2; end++) {
+    float end_sign = (end == 0) ? 1. : -1.;
+
+    pin = (end == 1) ? first_pin : second_pin;
+
+    if (TEST_FLAG (WARNFLAG, pin))
+      pin_color = resistor_warn_pin_color;
+    else if (TEST_FLAG (SELECTEDFLAG, pin))
+      pin_color = resistor_selected_pin_color;
+    else if (TEST_FLAG (FOUNDFLAG, pin))
+      pin_color = resistor_found_pin_color;
+    else
+      pin_color = resistor_pin_color;
+
+    glColor3f (pin_color[0] / 1.5,
+               pin_color[1] / 1.5,
+               pin_color[2] / 1.5);
+
+    for (ring = 0; ring < no_rings; ring++) {
+
+      float angle_ring_edge1 = ring * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
+      float angle_ring_edge2 = (ring + 1) * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
+      float y_strip_edge1 = cosf (angle_ring_edge1);
+      float z_strip_edge1 = sinf (angle_ring_edge1);
+      float y_strip_edge2 = cosf (angle_ring_edge2);
+      float z_strip_edge2 = sinf (angle_ring_edge2);
+      float r = resistor_pin_bend_radius;
+
+      glBegin (GL_TRIANGLE_STRIP);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = 0; strip < no_strips + 1; strip++) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x1 = resistor_pin_radius * cos (strip_angle);
+        float y1 = resistor_pin_radius * sin (strip_angle) * y_strip_edge1 + r * y_strip_edge1 - r;
+        float z1 = resistor_pin_radius * sin (strip_angle) * z_strip_edge1 + r * z_strip_edge1 + resistor_width / 2. * end_sign;
+
+        float x2 = resistor_pin_radius * cos (strip_angle);
+        float y2 = resistor_pin_radius * sin (strip_angle) * y_strip_edge2 + r * y_strip_edge2 - r;
+        float z2 = resistor_pin_radius * sin (strip_angle) * z_strip_edge2 + r * z_strip_edge2 + resistor_width / 2. * end_sign;
+
+        glNormal3f (cos (strip_angle), sin (strip_angle) * y_strip_edge1, sin (strip_angle) * z_strip_edge1);
+        glVertex3f (x1, y1, z1);
+        glNormal3f (cos (strip_angle), sin (strip_angle) * y_strip_edge2, sin (strip_angle) * z_strip_edge2);
+        glVertex3f (x2, y2, z2);
+      }
+      glEnd ();
+    }
+
+    if (1) {
+      float r = resistor_pin_bend_radius;
+      glBegin (GL_TRIANGLE_STRIP);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = 0; strip < no_strips + 1; strip++) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x1 = resistor_pin_radius * cos (strip_angle);
+        float y1 = -r;
+        float z1 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+
+        float x2 = resistor_pin_radius * cos (strip_angle);
+        float y2 = -r - pin_penetration_depth;
+        float z2 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x1, y1, z1);
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x2, y2, z2);
+      }
+      glEnd ();
+    }
+
+    if (1) {
+      float r = resistor_pin_bend_radius;
+      glBegin (GL_TRIANGLE_FAN);
+
+      glNormal3f (0, 0., -1.);
+      glVertex3f (0, -r - pin_penetration_depth - resistor_pin_radius / 2., (r + resistor_width / 2.) * end_sign);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = no_strips + 1; strip > 0; strip--) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x = resistor_pin_radius * cos (strip_angle);
+        float y = -r - pin_penetration_depth;
+        float z = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
+
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x, y, z);
+      }
+      glEnd ();
+    }
+  }
+
+  glDisable (GL_COLOR_MATERIAL);
+  glPopAttrib ();
+
+  glDisable (GL_LIGHTING);
+//  glDisable (GL_DEPTH_TEST);
+
+  glPushMatrix ();
+  glLoadIdentity ();
+  debug_basis_display ();
+  glPopMatrix ();
+//  glEnable (GL_DEPTH_TEST);
+
+  glPopMatrix ();
+  glUseProgram (restore_sp);
+
+  first_run = false;
+}
+
+static float
+determinant_4x4 (float m[4][4])
+{
+  float det;
+  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
+        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
+        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
+        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
+        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
+        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
+        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
+        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
+        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
+        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
+        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
+        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
+   return det;
+}
+
+static void
+invert_4x4 (float m[4][4], float out[4][4])
+{
+  float scale = 1 / determinant_4x4 (m);
+
+  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
+               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
+               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
+  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
+               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
+               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
+  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
+               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
+               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
+  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
+               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
+               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
+  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
+               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
+               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
+  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
+               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
+               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
+  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
+               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
+               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
+  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
+               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
+               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
+  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
+               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
+               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
+  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
+               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
+               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
+  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
+               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
+               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
+  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
+               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
+               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
+  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
+               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
+               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
+  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
+               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
+               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
+  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
+               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
+               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
+  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
+               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
+               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 35f7ebc..8adfb0d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -381,6 +381,47 @@ ghid_draw_grid (hidGC gc, BoxType *drawn_area)
   glEnable (GL_STENCIL_TEST);
 }
 
+/* XXX: Refactor this into hidgl common routines */
+static void
+load_texture_from_png (char *filename)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  /* int has_alpha; */
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  /* has_alpha = gdk_pixbuf_get_has_alpha (pixbuf); */
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
+
+  g_object_unref (pixbuf);
+}
+
 static void
 ghid_draw_bg_image (void)
 {
@@ -466,6 +507,7 @@ ghid_use_mask (enum mask_mode mode)
     case HID_MASK_CLEAR:
       /* Write '1' to the stencil buffer where the solder-mask should not be drawn. */
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
+      glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
       stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
@@ -476,6 +518,7 @@ ghid_use_mask (enum mask_mode mode)
     case HID_MASK_AFTER:
       /* Drawing operations as masked to areas where the stencil buffer is '0' */
       glColorMask (1, 1, 1, 1);                             /* Enable drawing of r, g, b & a */
+      glDepthMask (GL_TRUE);
       glStencilFunc (GL_GEQUAL, 0, stencil_bit);            /* Draw only where our bit of the stencil buffer is clear */
       glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);              /* Stencil buffer read only */
       break;
@@ -964,6 +1007,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   /* setup GL-context */
   priv->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                               GDK_GL_MODE_STENCIL |
+                                              GDK_GL_MODE_DEPTH   |
                                               GDK_GL_MODE_DOUBLE);
   if (!priv->glconfig)
     {
@@ -1469,6 +1513,9 @@ clearPad_callback_solid (const BoxType * b, void *cl)
 static void
 GhidDrawMask (int side, BoxType * screen)
 {
+  render_priv *priv = gport->render_priv;
+  static bool first_run = true;
+  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct poly_info info;
@@ -1503,6 +1550,34 @@ GhidDrawMask (int side, BoxType * screen)
   hid_draw_set_color (out->fgGC, PCB->MaskColor);
   ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
 
+  if (first_run) {
+    glGenTextures (1, &texture);
+    glBindTexture (GL_TEXTURE_2D, texture);
+    load_texture_from_png ("board_texture.png");
+  } else {
+    glBindTexture (GL_TEXTURE_2D, texture);
+  }
+  glUseProgram (0);
+
+  if (1) {
+    GLfloat s_params[] = {0.0001, 0., 0., 0.};
+    GLfloat t_params[] = {0., 0.0001, 0., 0.};
+    GLint obj_lin = GL_OBJECT_LINEAR;
+    glTexGeniv (GL_S, GL_TEXTURE_GEN_MODE, &obj_lin);
+    glTexGeniv (GL_T, GL_TEXTURE_GEN_MODE, &obj_lin);
+    glTexGenfv (GL_S, GL_OBJECT_PLANE, s_params);
+    glTexGenfv (GL_T, GL_OBJECT_PLANE, t_params);
+    glEnable (GL_TEXTURE_GEN_S);
+    glEnable (GL_TEXTURE_GEN_T);
+  }
+
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+  glEnable (GL_TEXTURE_2D);
+
   if (!PCB->Data->outline_valid) {
 
     if (PCB->Data->outline != NULL)
@@ -1521,8 +1596,16 @@ GhidDrawMask (int side, BoxType * screen)
   hid_draw_fill_pcb_polygon (out->fgGC, &polygon, screen);
   poly_FreeContours (&polygon.NoHoles);
   ghid_set_alpha_mult (out->fgGC, 1.0);
+  hidgl_flush_triangles (priv->hidgl);
+  glDisable (GL_TEXTURE_GEN_S);
+  glDisable (GL_TEXTURE_GEN_T);
+  glBindTexture (GL_TEXTURE_2D, 0);
+  glDisable (GL_TEXTURE_2D);
+  hidgl_shader_activate (circular_program);
 
   hid_draw_use_mask (&ghid_graphics, HID_MASK_OFF);
+
+  first_run = false;
 }
 
 static int
@@ -1562,8 +1645,9 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
         /* Mask out drilled holes on this layer */
         hidgl_flush_triangles (priv->hidgl);
-        glPushAttrib (GL_COLOR_BUFFER_BIT);
+        glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
+        glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
@@ -1585,8 +1669,9 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
           hidgl_flush_triangles (priv->hidgl);
-          glPushAttrib (GL_COLOR_BUFFER_BIT);
+          glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
+          glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
@@ -1712,6 +1797,31 @@ via_hole_cyl_callback (const BoxType * b, void *cl)
   return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, VIA_TYPE);
 }
 
+static int
+frontE_package_callback (const BoxType * b, void *cl)
+{
+  ElementType *element = (ElementType *) b;
+
+  if (FRONT (element))
+    {
+      if (element->Name[DESCRIPTION_INDEX].TextString == NULL)
+        return 0;
+
+      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "ACY400") == 0) {
+        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+        hidgl_draw_acy_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
+      }
+    }
+  return 1;
+}
+
+static void
+ghid_draw_packages (BoxType *drawn_area)
+{
+  /* XXX: Just the front elements for now */
+  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+}
+
 void
 ghid_draw_everything (BoxType *drawn_area)
 {
@@ -1846,8 +1956,9 @@ ghid_draw_everything (BoxType *drawn_area)
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
       hidgl_flush_triangles (priv->hidgl);
-      glPushAttrib (GL_COLOR_BUFFER_BIT);
+      glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
+      glDepthMask (GL_FALSE);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
       hidgl_flush_triangles (priv->hidgl);
@@ -1996,6 +2107,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 #endif
 
   glEnable (GL_STENCIL_TEST);
+  glEnable (GL_DEPTH_TEST);
+  glDepthFunc (GL_ALWAYS);
   glClearColor (port->bg_color.red / 65535.,
                 port->bg_color.green / 65535.,
                 port->bg_color.blue / 65535.,
@@ -2110,6 +2223,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
   /* glStencilFunc (GL_GREATER, 1, 1); */           /* Draw only where stencil buffer is 0 */
 
+  glDepthMask (GL_FALSE);
 #if 0
   if (global_view_2d) {
     glBegin (GL_QUADS);
@@ -2143,12 +2257,54 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 #endif
 
+  glDepthMask (GL_TRUE);
+
   ghid_draw_bg_image ();
 
   /* hid_expose_callback (&ghid_graphics, &region, 0); */
   ghid_draw_everything (&region);
   hidgl_flush_triangles (priv->hidgl);
 
+  glTexCoord2f (0., 0.);
+  glColor3f (1., 1., 1.);
+
+  if (0) {
+    Coord x, y;
+    Coord z = max_depth;
+
+    glBegin (GL_LINES);
+
+    ghid_unproject_to_z_plane (ev->area.x, ev->area.y, z, &x, &y);
+    glPushMatrix ();
+    glLoadIdentity ();
+    glVertex3f (0., 0., 0.);
+    glPopMatrix ();
+    glVertex3f (x, y, z);
+
+    ghid_unproject_to_z_plane (ev->area.x, ev->area.y + ev->area.height, z, &x, &y);
+    glPushMatrix ();
+    glLoadIdentity ();
+    glVertex3f (0., 0., 0.);
+    glPopMatrix ();
+    glVertex3f (x, y, z);
+
+    ghid_unproject_to_z_plane (ev->area.x + ev->area.width, ev->area.y + ev->area.height, z, &x, &y);
+    glPushMatrix ();
+    glLoadIdentity ();
+    glVertex3f (0., 0., 0.);
+    glPopMatrix ();
+    glVertex3f (x, y, z);
+
+    ghid_unproject_to_z_plane (ev->area.x + ev->area.width, ev->area.y, z, &x, &y);
+    glPushMatrix ();
+    glLoadIdentity ();
+    glVertex3f (0., 0., 0.);
+    glPopMatrix ();
+    glVertex3f (x, y, z);
+
+    glEnd ();
+  }
+
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
   hidgl_set_depth (Output.fgGC, priv->edit_depth);
@@ -2161,7 +2317,66 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   DrawMark (Output.fgGC);
   hidgl_flush_triangles (priv->hidgl);
 
+  glEnable (GL_LIGHTING);
+
+  glShadeModel (GL_SMOOTH);
+
+  glEnable (GL_LIGHT0);
+
+  /* XXX: FIX OUR NORMALS */
+  glEnable (GL_NORMALIZE);
+//  glEnable (GL_RESCALE_NORMAL);
+
+  glDepthFunc (GL_LESS);
+  glDisable (GL_STENCIL_TEST);
+
+  glEnable (GL_CULL_FACE);
+  glCullFace (GL_BACK);
+
+  if (1) {
+    GLfloat global_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};
+    glLightModelfv (GL_LIGHT_MODEL_AMBIENT, global_ambient);
+    glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
+    glLightModeli (GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);
+  }
+  if (1) {
+    GLfloat diffuse[] =  {0.6, 0.6, 0.6, 1.0};
+    GLfloat ambient[] =  {0.4, 0.4, 0.4, 1.0};
+    GLfloat specular[] = {1.0, 1.0, 1.0, 1.0};
+    glLightfv (GL_LIGHT0, GL_DIFFUSE,  diffuse);
+    glLightfv (GL_LIGHT0, GL_AMBIENT,  ambient);
+    glLightfv (GL_LIGHT0, GL_SPECULAR, specular);
+  }
+  if (1) {
+//    GLfloat position[] = {1., -1., 1., 0.};
+//    GLfloat position[] = {1., -0.5, 1., 0.};
+//    GLfloat position[] = {0., -1., 1., 0.};
+//    GLfloat position[] = {0.5, -1., 1., 0.};
+//    GLfloat position[] = {0.0, -0.5, 1., 0.};
+    GLfloat position[] = {0.0, 0.0, 1., 0.};
+    GLfloat abspos = sqrt (position[0] * position[0] +
+                           position[1] * position[1] +
+                           position[2] * position[2]);
+    position[0] /= abspos;
+    position[1] /= abspos;
+    position[2] /= abspos;
+    glPushMatrix ();
+    glLoadIdentity ();
+    glLightfv (GL_LIGHT0, GL_POSITION, position);
+    glPopMatrix ();
+  }
+
+  if (!global_view_2d)
+    ghid_draw_packages (&region);
+
+  glDisable (GL_CULL_FACE);
+  glDisable (GL_DEPTH_TEST);
+  glDisable (GL_LIGHT0);
+  glDisable (GL_COLOR_MATERIAL);
+  glDisable (GL_LIGHTING);
+
   draw_crosshair (Output.fgGC, priv);
+
   hidgl_flush_triangles (priv->hidgl);
 
   draw_lead_user (Output.fgGC, priv);
@@ -2292,7 +2507,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 1.);
   glStencilMask (~0);
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   hidgl_reset_stencil_usage (priv->hidgl);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
@@ -2355,6 +2570,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGB     |
                                         GDK_GL_MODE_STENCIL |
+                                        GDK_GL_MODE_DEPTH   |
                                         GDK_GL_MODE_SINGLE);
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
@@ -2403,7 +2619,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
                 1.);
   glStencilMask (~0);
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   hidgl_reset_stencil_usage (priv->hidgl);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
diff --git a/src/resistor_bump.png b/src/resistor_bump.png
new file mode 100644
index 0000000000000000000000000000000000000000..582007ed3a983dfe6b7c252bf778b6e224239298
GIT binary patch
literal 2258
zcmds2Ye-XJ7=F%~b2_uk$flT_3M#Wv{tyZ=jyjn$942YHZgw$JF|93HNO%lE3W=bB
zBvONd{Yb4~mPN`iyAjzH1t}X9iHJ6(QmnMsv&FF4oc<}|aQMD`-+P|-@;vXmQyE%y
zuslKzAXt;C$^=;2vIy{}<+JhC7%hxGQ=Npyj>tax;lFpYT7`+p$J}B$M<;=$skwR}
zXwl@$ptepyhcbgEJw?_X6dJZV_T%}qRyqndq~sWqONxv04;herB!7<~e?NDuz;KXL
zYtl2eRm@)k1SmDC#I45ef!B$r+c~JVY*#&8Y5%bxy7};mzFYTrOHX`K@$ka;7Spg2
zys3~y2p|x+AHdPV5Cp)}j?(acHA{1WFr7|#+RcdWHh0G~-I;Glvq)>I6V~Q8+q$>`
zc>I>ABVN}K0lZ_)O$Ve%4HEiq*8>Gi>D!x&!6|WHkqxW@Z2c13Qet8r${Fx^Fv@`8
z(J_e&+L1PJJSqmf4t09*`)eaNSX`FcbdTjY8wR~L1_G(cKCr1}<Z3v$wJ2<$ioamZ
zrsc$QbqyGg*f<K-mom9x_>=i~?v*SF_#LozI#b(OBc?X^%^9NNt{isKf$;>IB|rsZ
zUneH|iBuQ0yL<-Cd2#L$(CD&%sY>=Lt1b>`m-0nVM3TCW<}$>Hy|qMSvO1Q^r3Hj8
znGjE{r@%N1!3M{C;KR@tnNQqI+YCf}!1D{e*F}YFd>}e6b2_bW5;<DmYh|&4$nP0^
zSvFD2pp7+mt|6f)krqv#w;2ONT)jJoFuczb`^BceR~OfS+jS}7={~U^^=Cw}e(lMI
zU`0-mNKsx#ffS`whdXa9Bja%rR7&}VEYhnErc9D@<xnW+^VIZEu=gSBVb0^%OyOwf
zOT&7I!VMu11SR0m|Mz3b`Oh<Lz2;QINhDIl+{p71%#2qa<Z;BIFDVFQHwE2Z^_{63
VEP0mrC?S&Wph?lH8k6!){sgRoN=yI%

literal 0
HcmV?d00001

diff --git a/src/zero_ohm_bump.png b/src/zero_ohm_bump.png
new file mode 100644
index 0000000000000000000000000000000000000000..9a17f00cb3e7a1452b2fe0ea922adbf653ac9194
GIT binary patch
literal 2034
zcmeAS@N?(olHy`uVBq!ia0y~yU;;9k7&zE~)R&4Yzkn2Dage(c!@6@aFM%AkByV>Y
zhW{YAVDIwDKoQOYkH}&M25w;xW@MN(M*=9wUgGKN%6^Mmn3db0^L05ZP)M@GHKN2h
zKQ}iuuY|$5C^fMpHASI3vm`^o-P1Q9ypc~FsLj{Y#WAGf*4w*=T+I#wZ5In8*>YIk
z*Lxg1=4O%};W6>ep77<rr1wuv+3a#en!!QyEDM7I&}>Eq1`Y-W2OtaRd;tcA1|W-t
zfq)c=$`O_jWjaDRlAFkKC&(lcyoG8pO9LmV;es$=NO_cjKy)L#g&LY148p{v7pw*h
zK#UUU(FfkUI2jU}glna(FLN_6%y{T>|G3=C+AR_c4fi*%dwt>g^fNVQ*%-EdxtPSj
zpvKXVdwUH7!&Rn)`{mjU4dx6C2fi>qux4NgFko=2H|JpR5ny=7$k0$_^OupLjMMev
z{O1TphE=QwYVU_JG-NRr#7-AwSP;c9=XoY8!wNBm<Ap%!J-~2H+n(|)n~gz3jA5-Q
zkb9L$K?#_rMINg;pl0!gdftXJTbLL^xEcPlaWH({!Op;-wU5z&k&H3{8pp&IAs9(Q
zfnf+0MhQ%)0g2%oJo$e}d6b;m0TdWa2ZnI<@}pQjwMu^SJeSH4V4`I3boFyt=akR{
E0Bt_N*Z=?k

literal 0
HcmV?d00001
