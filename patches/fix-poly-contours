Bottom: acfee68eac0d4bed5c72642d1fe8d25151aa520c
Top:    465c5d84e66e3494689cebf908365d5993f60aa5
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-07 01:46:25 +0000

Fix poly contours (?)

XXX: Thermals are not fixed up after frac_circle() changes
 V2: Leave all but LinePoly using the old frac_circle(), new frac_circle2() fixes LinePoly
     (also use frac_circle2() in CirclePoly to avoid adding a repeat vertex)

XXX: Fix may be coincidental due to minor geometry changes

XXX: Appears to break circ_segs_test_9.pcb

Fixes bug observed with copper sliver on this layout fragment:

Element["" "" "" "unknown" 1325.00mil 1070.00mil -175.00mil -105.00mil 0 100 ""]
(
  Pad[-85.00mil -39.00mil -79.00mil -39.00mil 34.00mil 30.00mil 40.00mil "2" "2" "square"]

  )

Layer(1 "component")
(
  Line[1245.00mil 1030.00mil 1195.00mil 1030.00mil 12.00mil 20.00mil "clearline"]
  Polygon("clearpoly")
  (
    [5.00mil 5.00mil] [4195.00mil 5.00mil] [4195.00mil 2695.00mil] [5.00mil 2695.00mil]
  )
)



---

diff --git a/src/polygon.c b/src/polygon.c
index 91a16a8..21713de 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -497,6 +497,37 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
     }
 }
 
+/* add verticies in a fractional-circle starting from v
+ * centered at X, Y and going counter-clockwise
+ * does not include the first point
+ * last argument is 1 for a full circle
+ * 2 for a half circle
+ * or 4 for a quarter circle
+ */
+static void
+frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
+{
+  double e1, e2, t1;
+  int i, range;
+
+  /* move vector to origin */
+  e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
+  e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
+
+  /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
+  range = POLY_CIRC_SEGS / fraction;
+  for (i = 0; i < range; i++)
+    {
+      /* rotate the vector */
+      t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
+      e2 = rotate_circle_seg[2] * e1 + rotate_circle_seg[3] * e2;
+      e1 = t1;
+      v[0] = X + ROUND (e1);
+      v[1] = Y + ROUND (e2);
+      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+    }
+}
+
 
 /* create a circle approximation from lines */
 POLYAREA *
@@ -511,7 +542,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
   v[1] = y;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
-  frac_circle (contour, x, y, v, 1);
+  frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
   contour->cx = x;
   contour->cy = y;
@@ -689,28 +720,39 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.X += dy;
       l->Point2.Y -= dx;
     }
-  v[0] = l->Point1.X - dx;
-  v[1] = l->Point1.Y - dy;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
-    return 0;
+
+
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point2.X + dx;
+      v[1] = l->Point2.Y + dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
-  v[0] = l->Point2.X + dx;
-  v[1] = l->Point2.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point1.X - dx;
+      v[1] = l->Point1.Y - dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
+    frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
+
   return np;
 }
