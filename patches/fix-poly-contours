Bottom: f9434debb08d4cca7df41140aae7d467034bf614
Top:    f67de877d5febd3f54ad7e2f17f988506fa5320f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:23:30 +0000

Fix poly contours (?)

XXX: Thermals are not fixed up after frac_circle() changes
 V2: Leave all but LinePoly using the old frac_circle(), new frac_circle2() fixes LinePoly
     (also use frac_circle2() in CirclePoly to avoid adding a repeat vertex)


---

diff --git a/src/polygon.c b/src/polygon.c
index 23fc671..cbe398e 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -419,6 +419,37 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
     }
 }
 
+/* add verticies in a fractional-circle starting from v
+ * centered at X, Y and going counter-clockwise
+ * does not include the first point
+ * last argument is 1 for a full circle
+ * 2 for a half circle
+ * or 4 for a quarter circle
+ */
+static void
+frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
+{
+  double e1, e2, t1;
+  int i, range;
+
+  /* move vector to origin */
+  e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
+  e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
+
+  /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
+  range = POLY_CIRC_SEGS / fraction;
+  for (i = 0; i < range; i++)
+    {
+      /* rotate the vector */
+      t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
+      e2 = rotate_circle_seg[2] * e1 + rotate_circle_seg[3] * e2;
+      e1 = t1;
+      v[0] = X + ROUND (e1);
+      v[1] = Y + ROUND (e2);
+      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+    }
+}
+
 /* create a circle approximation from lines */
 POLYAREA *
 CirclePoly (Coord x, Coord y, Coord radius)
@@ -432,7 +463,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
   v[1] = y;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
-  frac_circle (contour, x, y, v, 1);
+  frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
   contour->cx = x;
   contour->cy = y;
@@ -610,28 +641,38 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.X += dy;
       l->Point2.Y -= dx;
     }
-  v[0] = l->Point1.X - dx;
-  v[1] = l->Point1.Y - dy;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
-    return 0;
+
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point2.X + dx;
+      v[1] = l->Point2.Y + dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
-  v[0] = l->Point2.X + dx;
-  v[1] = l->Point2.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point1.X - dx;
+      v[1] = l->Point1.Y - dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
+    frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
+
   return np;
 }
