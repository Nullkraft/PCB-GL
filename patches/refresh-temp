Bottom: 1c03192d1731bb01559b71ae7baac4bbc9ef27aa
Top:    1c9bf2375155d5c9d914baf56cb906e522136d68
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-18 14:11:27 +0000

Refresh of try-to-deal-with-faces-as-well

---

diff --git a/src/data.h b/src/data.h
index 1006a61..b2acc2c 100644
--- a/src/data.h
+++ b/src/data.h
@@ -72,4 +72,6 @@ extern FlagType no_flags;
 
 extern int netlist_frozen;
 
+extern int debug_integer;
+
 #endif
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 1a76e97..7b26668 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -24,6 +24,8 @@ typedef struct
   /* Rational b-splines */
   double *weights; /* Pointer to array of weights for the control points */
 
+  /* Debug */
+  bool is_placeholder; /* For some edge type we don't know how to draw */
 
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 3aa9f5c..a90a51e 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -218,13 +218,14 @@ draw_quad_edge (edge_ref e, void *data)
   double x1, y1, z1;
   double x2, y2, z2;
   int i;
+  bool debug = GPOINTER_TO_INT (data);
 
 #if 0
   int id = ID(e) % 12;
 
   glColor3f (colors[id][0], colors[id][1], colors[id][2]);
 #else
-  glColor3f (1., 1., 1.);
+  glColor4f (1., 1., 1., 0.3);
 #endif
 
   x1 = ((vertex3d *)ODATA(e))->x;
@@ -239,6 +240,14 @@ draw_quad_edge (edge_ref e, void *data)
     {
       edge_info *info = UNDIR_DATA(e);
 
+
+//        if (info->is_placeholder)
+        if (debug)
+          {
+            glColor4f (1.0, 0.0, 0.0, 1.0);
+            glDepthMask (TRUE);
+          }
+
 //      if (info->is_stitch)
 //        return;
 
@@ -271,6 +280,27 @@ draw_quad_edge (edge_ref e, void *data)
           ny = ((edge_info *)UNDIR_DATA(e))->ny;
           nz = ((edge_info *)UNDIR_DATA(e))->nz;
 
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          if ((e & 2) == 2)
+            {
+#if 0
+              /* Option 1, just draw the forward copy, which agrees with the normal */
+              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
+              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
+              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
+
+              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
+              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
+              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
+#else
+              /* Option 2, flip the normal */
+              nx = -nx;
+              ny = -ny;
+              nz = -nz;
+#endif
+            }
+
           /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
            * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
            */
@@ -363,6 +393,7 @@ draw_quad_edge (edge_ref e, void *data)
 
           glEnd ();
 
+          glDepthMask (FALSE);
           return;
         }
     }
@@ -376,27 +407,48 @@ draw_quad_edge (edge_ref e, void *data)
               STEP_Y_TO_COORD (PCB, y2),
               STEP_X_TO_COORD (PCB, z2));
   glEnd ();
+  glDepthMask (FALSE);
 }
 
 static void
 draw_contour (contour3d *contour, void *data)
 {
   edge_ref e;
+  bool debug = GPOINTER_TO_INT (data);
+  int edge_no = 0;
 
   e = contour->first_edge;
 
+//  printf ("Drawing contour\n");
+
   do
     {
-      draw_quad_edge (e, NULL);
+      edge_info *info = UNDIR_DATA(e);
+//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+      draw_quad_edge (e, data);
+
+      /* Stop if e was the only edge in a face - which we re-trace */
+      /* XXX: Probably only a development bug until we get the quad-edge links correct */
+//      if (LNEXT(e) == SYM(e))
+//        break;
+
+      /* LNEXT should take us counter-clockwise around the face */
+      /* LPREV should take us clockwise around the face */
     }
   while ((e = LNEXT(e)) != contour->first_edge);
 }
 
+static int face_no;
+
 static void
 draw_face (face3d *face, void *data)
 {
-  g_list_foreach (face->contours, (GFunc)draw_contour, NULL);
+//  if (face->contours != NULL)
+//      draw_contour (face->contours->data, NULL);
+//  printf ("Drawing face\n");
+  g_list_foreach (face->contours, (GFunc)draw_contour, GINT_TO_POINTER(face_no == debug_integer));
 
+  face_no++;
 }
 
 void
@@ -408,6 +460,10 @@ object3d_draw (object3d *object)
 //  printf ("BEGIN DRAW...\n");
 //  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
 
+//  printf ("\nDrawing object\n");
+
+  face_no = 0;
+
   g_list_foreach (object->faces, (GFunc)draw_face, NULL);
 
 //  printf ("....ENDED\n");
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d4127bc..c79113b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2818,9 +2818,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glPopMatrix ();
   }
 
+//  glDisable (GL_DEPTH_TEST); /* TEST */
+  glDepthMask (FALSE); /* TEST */
+
   if (!global_view_2d)
     ghid_draw_packages (&region);
 
+  glDepthMask (TRUE); /* TEST */
+
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
   glDisable (GL_LIGHT0);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index e8ef1d8..86c003b 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1286,6 +1286,15 @@ ghid_polygon_debug_selection_changed_cb (GtkTreeSelection *treeselection, gpoint
   ghid_invalidate_all ();
 }
 
+static void
+debug_spin_changed_cb (GtkSpinButton *spinbutton, void *user_data)
+{
+  GHidPort *port = user_data;
+
+  debug_integer = gtk_spin_button_get_value_as_int (spinbutton);
+  ghid_invalidate_all (port);
+}
+
 /* 
  * Create the top_window contents.  The config settings should be loaded
  * before this is called.
@@ -1297,6 +1306,7 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *hbox_middle, *hbox;
   GtkWidget *vbox, *frame;
   GtkWidget *label;
+  GtkWidget *debug_spin;
   GtkTreeViewColumn *column;
   GtkTreeIter iter;
   /* FIXME: IFDEF HACK */
@@ -1391,6 +1401,12 @@ ghid_build_pcb_top_window (void)
                     G_CALLBACK (ghid_view_2d), NULL);
   gtk_box_pack_start (GTK_BOX(ghidgui->left_toolbar),
                       trackball, FALSE, FALSE, 0);
+
+  debug_spin = gtk_spin_button_new_with_range (0.0, 10000.0, 1.0);
+  gtk_box_pack_start (GTK_BOX(ghidgui->left_toolbar),
+                      debug_spin, FALSE, FALSE, 0);
+  g_signal_connect (G_OBJECT (debug_spin), "value_changed",
+                    G_CALLBACK (debug_spin_changed_cb), ghidgui);
 #endif
 
   /* ghidgui->mode_buttons_frame was created above in the call to
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 1d1df63..47a3691 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -375,6 +375,7 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
    */
 
   edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
+  our_edge_info->is_placeholder = true; /* Highlight for now */
 
   SDAI_Application_instance *entity = start_entity;
   STEPcomplex *stepcomplex = NULL;
@@ -728,18 +729,18 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
   if (dist1 > 0.01 || dist2 > 0.02)
     {
       printf ("Entity #%i end point to first control point distances %f and %f\n",
-              dist1, dist2);
+              start_entity->StepFileId (), dist1, dist2);
     }
 }
 
 static void
-process_edge_geometry (SdaiEdge *edge, edge_ref our_edge, process_step_info *info)
+process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, process_step_info *info)
 {
   GHashTableIter iter;
   vertex3d *vertex;
   double x1, y1, z1;
   double x2, y2, z2;
-  bool orientation = true;
+  edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
 
   if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
       strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
@@ -816,8 +817,6 @@ process_edge_geometry (SdaiEdge *edge, edge_ref our_edge, process_step_info *inf
           transform_vertex (info->current_transform, &x1, &y1, &z1);
           transform_vertex (info->current_transform, &x2, &y2, &z2);
 
-//          our_edge = make_edge ();
-          UNDIR_DATA (our_edge) = make_edge_info ();
           object3d_add_edge (info->object, our_edge);
           vertex = make_vertex3d (x1, y1, z1);
           ODATA(our_edge) = vertex;
@@ -839,26 +838,21 @@ process_edge_geometry (SdaiEdge *edge, edge_ref our_edge, process_step_info *inf
 
           double radius = circle->radius_();
 
-          edge_info *edge_info;
-
           transform_vertex (info->current_transform, &cx, &cy, &cz);
           transform_vertex (info->current_transform, &x1, &y1, &z1);
           transform_vertex (info->current_transform, &x2, &y2, &z2);
 
           transform_vector (info->current_transform, &nx, &ny, &nz);
 
-//          our_edge = make_edge ();
-          edge_info = make_edge_info ();
           if (orientation)
             {
-              edge_info_set_round (edge_info, cx, cy, cz, nx, ny, nz, radius);
+              edge_info_set_round (our_edge_info, cx, cy, cz, nx, ny, nz, radius);
             }
           else
             {
-              edge_info_set_round (edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
+              edge_info_set_round (our_edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
             }
 
-          UNDIR_DATA (our_edge) = edge_info;
           object3d_add_edge (info->object, our_edge);
           vertex = make_vertex3d (x1, y1, z1);
           ODATA(our_edge) = vertex;
@@ -872,8 +866,6 @@ process_edge_geometry (SdaiEdge *edge, edge_ref our_edge, process_step_info *inf
           transform_vertex (info->current_transform, &x1, &y1, &z1);
           transform_vertex (info->current_transform, &x2, &y2, &z2);
 
-//          our_edge = make_edge ();
-          UNDIR_DATA (our_edge) = make_edge_info ();
           object3d_add_edge (info->object, our_edge);
           vertex = make_vertex3d (x1, y1, z1);
           ODATA(our_edge) = vertex;
@@ -884,6 +876,7 @@ process_edge_geometry (SdaiEdge *edge, edge_ref our_edge, process_step_info *inf
         }
       else
         {
+          our_edge_info->is_placeholder = true;
 #ifdef DEBUG_NOT_IMPLEMENTED
           printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
           if (curve->IsComplex())
@@ -1074,13 +1067,31 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
   return step_model;
 }
 
+static void
+debug_edge (edge_ref edge, const char *message)
+{
+  edge_ref e = edge;
+  edge_info *info;
+
+  printf ("%s\n", message);
+  info = (edge_info *)UNDIR_DATA(e);
+  printf ("e: %p (%i%s)\n", e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+  while ((e = ONEXT(e)) != edge)
+    {
+      info = (edge_info *)UNDIR_DATA(e);
+      printf ("next: %p (%i%s)\n", e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+    }
+}
+
+static int edge_no = 0;
+
 static step_model *
 process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, process_step_info *info)
 {
   step_model *step_model;
 //  object3d *object;
   GHashTable *edges_hash_set;
-  bool on_plane;
+  int face_count = 0;
 
   // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), call the specific hander
   if (strcmp (sr->EntityName (), "Shape_Representation") == 0)
@@ -1158,8 +1169,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
 
-          on_plane = false;
-
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1168,7 +1177,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
-              on_plane = true;
 //              printf ("WARNING: planar surfaces are not supported yet\n");
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
@@ -1190,15 +1198,15 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #endif
             }
 
+          info->current_face = make_face3d ((char *)"");
+          object3d_add_face (info->object, info->current_face);
+
           for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
                iter != NULL;
                iter = iter->NextNode ())
             {
               SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
 
-              info->current_face = make_face3d ((char *)"");
-              object3d_add_face (info->object, info->current_face);
-
 #if 0
               bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
 
@@ -1216,10 +1224,12 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #if 0
               std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
 #endif
+//              printf ("FACE LOOP\n");
               if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
                 {
                   SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
-                  bool first_edge_of_contour = true;
+                  edge_ref first_edge_of_contour = 0;
+                  edge_ref previous_edge_of_contour = 0;
 
                   // NB: EDGE_LOOP uses multiple inheritance from LOOP and PATH, thus needs special handling to
                   //     access the elements belonging to PATH, such as edge_list ...
@@ -1285,33 +1295,73 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 
                       our_edge = (edge_ref)g_hash_table_lookup (edges_hash_set, edge);
 
-                      if (our_edge != NULL)
+                      if (our_edge != 0)
                         {
                           /* Already processed this edge (but hopefully in the other direction!) */
+                          our_edge = SYM(our_edge);
                         }
                       else
                         {
                           our_edge = make_edge ();
 
-                          process_edge_geometry (edge, our_edge, info);
+                          /* Temporary debug hack */
+                          edge_info *our_edge_info = make_edge_info ();
+                          our_edge_info->edge_identifier = ++edge_no;
+                          UNDIR_DATA(our_edge) = our_edge_info;
+
+                          /* Populate edge geometry
+                           *
+                           * NB: Forcing orientation to true, so we create the "forward" direction oriented edge
+                           *     with the non'SYM'd edge pointer. This lets us spot the reversed edges correctly
+                           *     when processing / rendering. (Which we do by spotting the poitner manipulation
+                           *     done by SYM on the original make_edge() pointer
+                           */
+//                          process_edge_geometry (edge, true /*orientation*/, our_edge, info);
+                          process_edge_geometry (edge, orientation, our_edge, info);
+
+                          g_hash_table_insert (edges_hash_set, edge, (void *)our_edge);
+                        }
 
-                          //g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(orientation ? 1 : 0));
+//                      if (!orientation)
+//                        our_edge = SYM(our_edge);
 
-                          /* Populate edge geometry (?)... or do we leave processing until later */
+                      if (first_edge_of_contour == 0)
+                        {
+                          info->current_contour = make_contour3d (our_edge);
+                          face3d_add_contour (info->current_face, info->current_contour);
+                          first_edge_of_contour = our_edge;
                         }
 
-                    if (orientation)
-                      our_edge = SYM(our_edge);
+#if 0
+                      printf ("EDGE: (%f, %f, %f)-(%f, %f, %f)\n",
+                              ((vertex3d *)ODATA(our_edge))->x,
+                              ((vertex3d *)ODATA(our_edge))->y,
+                              ((vertex3d *)ODATA(our_edge))->x,
+                              ((vertex3d *)DDATA(our_edge))->x,
+                              ((vertex3d *)DDATA(our_edge))->y,
+                              ((vertex3d *)DDATA(our_edge))->x);
+#endif
 
-                    if (first_edge_of_contour)
-                      {
-                        info->current_contour = make_contour3d (our_edge);
-                        face3d_add_contour (info->current_face, info->current_contour);
-                        first_edge_of_contour = false;
-                      }
+                      if (previous_edge_of_contour != 0)
+                        {
+                          /* XXX: Hopefully link up the edges around this face contour */
+//                          debug_edge (our_edge, "before splice");
+//                          splice (SYM(previous_edge_of_contour), our_edge);
+                          splice (our_edge, OPREV(SYM(previous_edge_of_contour)));
+//                          splice (previous_edge_of_contour, SYM(our_edge));
+//                          debug_edge (our_edge, "after splice");
+                        }
 
+                      /* Stash reference to this edge for linking next time */
+                      previous_edge_of_contour = our_edge;
                     }
 
+                  /* XXX: Hopefully link up the edges around this face contour */
+//                  debug_edge (first_edge_of_contour, "before splice");
+//                  splice (SYM(previous_edge_of_contour), first_edge_of_contour);
+                  splice (first_edge_of_contour, OPREV(SYM(previous_edge_of_contour)));
+//                  splice (previous_edge_of_contour, SYM(first_edge_of_contour));
+//                  debug_edge (first_edge_of_contour, "after splice");
                 }
               else
                 {
@@ -1319,7 +1369,7 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                   continue;
                 }
             }
-
+          face_count ++;
         }
 
         /* Deal with edges hash set */
diff --git a/src/main.c b/src/main.c
index 7c4e95c..58c6276 100644
--- a/src/main.c
+++ b/src/main.c
@@ -77,6 +77,7 @@
 extern void stroke_init (void);
 #endif
 
+int debug_integer;
 
 /* ----------------------------------------------------------------------
  * initialize signal and error handlers
