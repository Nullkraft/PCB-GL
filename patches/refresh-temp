Bottom: 2d20d7ed447d49001ff7ea9a7c1a222d6a6738a0
Top:    63dee6b5b73a351dd419771dc91e12f660bde051
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-03 17:19:03 +0000

Refresh of add-macros-to-access-next-and

---

diff --git a/src/polygon1.c b/src/polygon1.c
index f8659a6..c4f91a9 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -484,7 +484,7 @@ node_label (VNODE * pn)
 static CVCList *
 add_descriptors (PLINE * pl, char poly, CVCList * list)
 {
-  VNODE *node = &pl->head;
+  VNODE *node = &pl->head; /* node is considered a vertex */
 
   do
     {
@@ -500,7 +500,7 @@ add_descriptors (PLINE * pl, char poly, CVCList * list)
 	    return NULL;
 	}
     }
-  while ((node = node->next) != &pl->head);
+  while ((node = NEXT_VERTEX(node)) != &pl->head);
   return list;
 }
 
@@ -570,21 +570,21 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q->intersected = 0;
   q->v = s->v;
   q->p = s->p;
-  q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
-  q->box.X2 = max (q->v->point[0], q->v->next->point[0]) + 1;
-  q->box.Y1 = min (q->v->point[1], q->v->next->point[1]);
-  q->box.Y2 = max (q->v->point[1], q->v->next->point[1]) + 1;
+  q->box.X1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (q->v)->point[0]);
+  q->box.X2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (q->v)->point[0]) + 1;
+  q->box.Y1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]);
+  q->box.Y2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]) + 1;
   r_insert_entry (tree, (const BoxType *) q, 1);
   q = (seg *)malloc (sizeof (struct seg));
   if (!q)
     return 1;
   q->intersected = 0;
-  q->v = s->v->next;
+  q->v = NEXT_EDGE (s->v);
   q->p = s->p;
-  q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
-  q->box.X2 = max (q->v->point[0], q->v->next->point[0]) + 1;
-  q->box.Y1 = min (q->v->point[1], q->v->next->point[1]);
-  q->box.Y2 = max (q->v->point[1], q->v->next->point[1]) + 1;
+  q->box.X1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (EDGE_BACKWARD_VERTEX (q->v))->point[0]);
+  q->box.X2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (EDGE_BACKWARD_VERTEX (q->v))->point[0]) + 1;
+  q->box.Y1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (EDGE_BACKWARD_VERTEX (q->v))->point[1]);
+  q->box.Y2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (EDGE_BACKWARD_VERTEX (q->v))->point[1]) + 1;
   r_insert_entry (tree, (const BoxType *) q, 1);
   r_delete_entry (tree, (const BoxType *) s);
   return 0;
@@ -650,8 +650,8 @@ seg_in_seg (const BoxType * b, void *cl)
   if (s->intersected || i->s->intersected)
     return 0;
 
-  cnt = vect_inters2 (s->v->point, s->v->next->point,
-		      i->v->point, i->v->next->point, s1, s2);
+  cnt = vect_inters2 (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point,
+		      EDGE_BACKWARD_VERTEX (i->v)->point, EDGE_FORWARD_VERTEX (i->v)->point, s1, s2);
   if (!cnt)
     return 0;
   if (i->touch)			/* if checking touches one find and we're done */
@@ -698,38 +698,38 @@ static void *
 make_edge_tree (PLINE * pb)
 {
   struct seg *s;
-  VNODE *bv;
+  VNODE *bv; /* bv is considred an edge */
   rtree_t *ans = r_create_tree (NULL, 0, 0);
   bv = &pb->head;
   do
     {
       s = (seg *)malloc (sizeof (struct seg));
       s->intersected = 0;
-      if (bv->point[0] < bv->next->point[0])
+      if (EDGE_BACKWARD_VERTEX (bv)->point[0] < EDGE_FORWARD_VERTEX (bv)->point[0])
 	{
-	  s->box.X1 = bv->point[0];
-	  s->box.X2 = bv->next->point[0] + 1;
+	  s->box.X1 = EDGE_BACKWARD_VERTEX (bv)->point[0];
+	  s->box.X2 = EDGE_FORWARD_VERTEX (bv)->point[0] + 1;
 	}
       else
 	{
-	  s->box.X2 = bv->point[0] + 1;
-	  s->box.X1 = bv->next->point[0];
+	  s->box.X2 = EDGE_BACKWARD_VERTEX (bv)->point[0] + 1;
+	  s->box.X1 = EDGE_FORWARD_VERTEX (bv)->point[0];
 	}
-      if (bv->point[1] < bv->next->point[1])
+      if (EDGE_BACKWARD_VERTEX (bv)->point[1] < EDGE_FORWARD_VERTEX (bv)->point[1])
 	{
-	  s->box.Y1 = bv->point[1];
-	  s->box.Y2 = bv->next->point[1] + 1;
+	  s->box.Y1 = EDGE_BACKWARD_VERTEX (bv)->point[1];
+	  s->box.Y2 = EDGE_FORWARD_VERTEX (bv)->point[1] + 1;
 	}
       else
 	{
-	  s->box.Y2 = bv->point[1] + 1;
-	  s->box.Y1 = bv->next->point[1];
+	  s->box.Y2 = EDGE_BACKWARD_VERTEX (bv)->point[1] + 1;
+	  s->box.Y1 = EDGE_FORWARD_VERTEX (bv)->point[1];
 	}
       s->v = bv;
       s->p = pb;
       r_insert_entry (ans, (const BoxType *) s, 1);
     }
-  while ((bv = bv->next) != &pb->head);
+  while ((bv = NEXT_EDGE (bv)) != &pb->head);
   return (void *) ans;
 }
 
@@ -772,7 +772,7 @@ contour_bounds_touch (const BoxType * b, void *cl)
   PLINE *pb = (PLINE *) b;
   PLINE *rtree_over;
   PLINE *looping_over;
-  VNODE *av;			/* node iterators */
+  VNODE *av; /* node iterators */ /* av is considered an edge */
   struct info info;
   BoxType box;
   jmp_buf restart;
@@ -799,22 +799,22 @@ contour_bounds_touch (const BoxType * b, void *cl)
     }
 
   av = &looping_over->head;
-  do				/* Loop over the nodes in the smaller contour */
+  do				/* Loop over the edges in the smaller contour */
     {
       /* check this edge for any insertions */
       double dx;
       info.v = av;
       /* compute the slant for region trimming */
-      dx = av->next->point[0] - av->point[0];
+      dx = EDGE_FORWARD_VERTEX (av)->point[0] - EDGE_BACKWARD_VERTEX (av)->point[0];
       if (dx == 0)
 	info.m = 0;
       else
 	{
-	  info.m = (av->next->point[1] - av->point[1]) / dx;
-	  info.b = av->point[1] - info.m * av->point[0];
+	  info.m = (EDGE_FORWARD_VERTEX (av)->point[1] - EDGE_BACKWARD_VERTEX (av)->point[1]) / dx;
+	  info.b = EDGE_BACKWARD_VERTEX (av)->point[1] - info.m * EDGE_BACKWARD_VERTEX (av)->point[0];
 	}
-      box.X2 = (box.X1 = av->point[0]) + 1;
-      box.Y2 = (box.Y1 = av->point[1]) + 1;
+      box.X2 = (box.X1 = EDGE_BACKWARD_VERTEX (av)->point[0]) + 1;
+      box.Y2 = (box.Y1 = EDGE_BACKWARD_VERTEX (av)->point[1]) + 1;
 
       /* fill in the segment in info corresponding to this node */
       if (setjmp (info.sego) == 0)
@@ -837,7 +837,7 @@ contour_bounds_touch (const BoxType * b, void *cl)
 				seg_in_region, seg_in_seg, &info)))
 	  assert (0); /* XXX: Memory allocation failure */
     }
-  while ((av = av->next) != &looping_over->head);
+  while ((av = NEXT_EDGE (av)) != &looping_over->head);
 
   c_info->node_insert_list = info.node_insert_list;
   if (info.need_restart)
@@ -904,10 +904,10 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       insert_node_task *next = task->next;
 
       /* Do insersion */
-      task->new_node->prev = task->node_seg->v;
-      task->new_node->next = task->node_seg->v->next;
-      task->node_seg->v->next->prev = task->new_node;
-      task->node_seg->v->next = task->new_node;
+      PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
+      NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
+      PREV_VERTEX (EDGE_FORWARD_VERTEX (task->node_seg->v)) = task->new_node;
+      EDGE_FORWARD_VERTEX (task->node_seg->v) = task->new_node;
       task->node_seg->p->Count++;
 
       cntrbox_adjust (task->node_seg->p, task->new_node->point);
