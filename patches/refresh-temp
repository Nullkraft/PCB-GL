Bottom: 84a3a7edbaffc0477060f48598f7fa21e840c8de
Top:    cf1c326cf6c494cd34338660580bcfb176462429
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-05-01 23:19:15 +0100

Refresh of extend-board-export

---

diff --git a/src/hid/common/appearance.c b/src/hid/common/appearance.c
index 92790fcc..e557b43 100644
--- a/src/hid/common/appearance.c
+++ b/src/hid/common/appearance.c
@@ -23,3 +23,9 @@ appearance_set_color (appearance *appear, float r, float g, float b)
   appear->g = g;
   appear->b = b;
 }
+
+void
+appearance_set_appearance (appearance *appear, const appearance *from)
+{
+  *appear = *from;
+}
diff --git a/src/hid/common/appearance.h b/src/hid/common/appearance.h
index d4917d7..d2bf7b3 100644
--- a/src/hid/common/appearance.h
+++ b/src/hid/common/appearance.h
@@ -3,5 +3,6 @@ typedef struct {
 } appearance;
 
 appearance *make_appearance (void);
-void destroy_appearance (appearance *appearance);
-void appearance_set_color (appearance *appearance, float r, float g, float b);
+void destroy_appearance (appearance *appear);
+void appearance_set_color (appearance *appear, float r, float g, float b);
+void appearance_set_appearance (appearance *appear, const appearance *from);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 2da2c5c..a5fa8d3 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -5,6 +5,7 @@
 
 #include <glib.h>
 
+#include "data.h"
 #include "step_id.h"
 #include "quad.h"
 #include "vertex3d.h"
@@ -14,7 +15,6 @@
 #include "edge3d.h"
 #include "object3d.h"
 #include "polygon.h"
-#include "data.h"
 
 #include "pcb-printf.h"
 
@@ -229,8 +229,372 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 
 
 GList *
+object3d_from_contours (const POLYAREA *contours,
+                        double zbot,
+                        double ztop,
+                        const appearance *master_object_appearance,
+                        const appearance *master_top_bot_appearance)
+{
+  GList *objects = NULL;
+  object3d *object;
+  appearance *object_appearance;
+  appearance *top_bot_appearance;
+  const POLYAREA *pa;
+  PLINE *contour;
+  PLINE *ct;
+  int ncontours;
+  int npoints;
+  int i;
+  vertex3d **vertices;
+  edge_ref *edges;
+  face3d **faces;
+  int start_of_ct;
+  int offset_in_ct;
+  int ct_npoints;
+
+  /* Loop over all board outline pieces */
+  pa = contours;
+  do {
+
+    contour = pa->contours;
+    ncontours = 0;
+    npoints = 0;
+
+    ct = contour;
+    while (ct != NULL) {
+      ncontours ++;
+      npoints += get_contour_npoints (ct);
+      ct = ct->next;
+    }
+
+    object = make_object3d (PCB->Name);
+    object_appearance = make_appearance ();
+    top_bot_appearance = make_appearance ();
+    appearance_set_appearance (object_appearance, master_object_appearance);
+    appearance_set_appearance (top_bot_appearance, master_top_bot_appearance);
+
+    object3d_set_appearance (object, object_appearance);
+
+    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
+    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
+    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
+
+    /* Define the vertices */
+    ct = contour;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      double x1, y1;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+      }
+
+      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+
+      vertices[i]           = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, zbot); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, ztop); /* Top */
+
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
+    }
+
+    /* Define the edges */
+    for (i = 0; i < 3 * npoints; i++) {
+      edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
+      object3d_add_edge (object, edges[i]);
+    }
+
+    /* Define the faces */
+    for (i = 0; i < npoints; i++) {
+      faces[i] = make_face3d ();
+
+      object3d_add_face (object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
+    }
+
+    faces[npoints] = make_face3d (); /* bottom_face */
+    face3d_set_normal (faces[npoints], 0., 0., 1.);
+    face3d_set_appearance (faces[npoints], top_bot_appearance);
+    object3d_add_face (object, faces[npoints]);
+
+    faces[npoints + 1] = make_face3d (); /* top_face */
+    face3d_set_normal (faces[npoints + 1], 0., 0., -1.);
+    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints + 1]);
+
+    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
+    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
+
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
+      }
+
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+#if REVERSED_PCB_CONTOURS
+      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#else
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
+
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
+
+      if (ct->is_round) {
+
+        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
+                                          COORD_TO_MM (ct->radius));
+        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+#ifdef REVERSED_PCB_CONTOURS
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+      }
+
+    }
+
+    if (0) {
+      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+      edge_ref cylinder_edges[3];
+      vertex3d *cylinder_vertices[2];
+      face3d *cylinder_faces[2];
+
+      /* Edge on top of board */
+      cylinder_edges[0] = make_edge ();
+      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
+#else
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);         /* Radius */
+#endif
+      object3d_add_edge (object, cylinder_edges[0]);
+
+      /* Edge on top of cylinder */
+      cylinder_edges[1] = make_edge ();
+      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
+                            5.);          /* Radius */
+      object3d_add_edge (object, cylinder_edges[1]);
+
+      /* Edge stitching cylinder */
+      cylinder_edges[2] = make_edge ();
+      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+      object3d_add_edge (object, cylinder_edges[2]);
+
+      /* Vertex on board top surface */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+      object3d_add_vertex (object, cylinder_vertices[0]);
+
+      /* Vertex on cylinder top surface */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+      object3d_add_vertex (object, cylinder_vertices[1]);
+
+      /* Cylindrical face */
+      cylinder_faces[0] = make_face3d ();
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
+                                        5.);                   /* Radius of cylinder */
+      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+      object3d_add_face (object, cylinder_faces[0]);
+      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+      /* Top face of cylinder */
+      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+      object3d_add_face (object, cylinder_faces[1]);
+      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+      /* Splice onto board */
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+      LDATA (cylinder_edges[0]) = cylinder_faces[0];
+      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+      LDATA (cylinder_edges[1]) = cylinder_faces[1];
+      RDATA (cylinder_edges[1]) = cylinder_faces[0];
+      LDATA (cylinder_edges[2]) = cylinder_faces[0];
+      RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+      /* Splice things together.... */
+
+      /* Link edges orbiting the cylinder bottom vertex */
+      splice (cylinder_edges[0], cylinder_edges[2]);
+      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+      /* Link edges orbiting the cylinder top vertex */
+      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+    }
+
+    objects = g_list_append (objects, object);
+
+  } while (pa = pa->f, pa != contours);
+
+  return objects;
+}
+
+GList *
 object3d_from_board_outline (void)
 {
+  POLYAREA *board_outline = board_outline_poly (true);
+  appearance *board_appearance;
+  appearance *top_bot_appearance;
+  GList *objects;
+
+  board_appearance = make_appearance ();
+  top_bot_appearance = make_appearance ();
+  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+
+#ifdef REVERSED_PCB_CONTOURS
+  objects = object3d_from_contours (board_outline,
+                                    HACK_BOARD_THICKNESS / 2, /* Bottom */
+                                    0,                        /* Top */
+                                    board_appearance,
+                                    top_bot_appearance);
+#else
+  objects = object3d_from_contours (board_outline,
+                                     HACK_BOARD_THICKNESS / 2, /* Bottom */
+                                    -HACK_BOARD_THICKNESS / 2, /* Top */
+                                    board_appearance,
+                                    top_bot_appearance);
+#endif
+
+  destroy_appearance (board_appearance);
+  destroy_appearance (top_bot_appearance);
+
+  poly_Free (&board_outline);
+
+  return objects;
+}
+
+
+GList *
+old_object3d_from_board_outline (void)
+{
   GList *board_objects = NULL;
   object3d *board_object;
   appearance *board_appearance;
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index e8c26e2..d33551e 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -15,4 +15,5 @@ void object3d_set_appearance (object3d *object, appearance *appear);
 void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
+GList *object3d_from_contours (const POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_topbot_appearance);
 GList *object3d_from_board_outline (void);
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 6879a98..167a586 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -5,6 +5,8 @@
 
 #include <glib.h>
 
+#include "data.h"
+
 #include "hid/common/step_id.h"
 #include "hid/common/quad.h"
 #include "hid/common/vertex3d.h"
