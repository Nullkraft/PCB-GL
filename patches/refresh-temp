Bottom: 606a30ea231508ce3e43154d8b227b5a007ddbee
Top:    8ed7cafe4934cc494d0ac8acf1e43e04700707f4
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 20:20:20 +0000

Refresh of more-play-with-quad-edge-data

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 66189b0..24b6ff1 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -140,32 +140,20 @@ object3d_create_test_cube (void)
   for (i = 0; i < 8; i++)
     object3d_add_vertex (object, cube_vertices[i]);
 
-<<<<<<< current
   for (i = 0; i < 12; i++)
     {
       cube_edges[i] = make_edge ();
+      UNDIR_DATA (cube_edges[i]) = make_edge_info ();
       object3d_add_edge (object, cube_edges[i]);
     }
 
   for (i = 0; i < 6; i++)
     {
       faces[i] = make_face3d ();
+      /* XXX: Face normal */
+      /* XXX: Face contours */
       object3d_add_face (object, faces[i]);
     }
-=======
-  for (i = 0; i < 12; i++) {
-    cube_edges[i] = make_edge ();
-    UNDIR_DATA (cube_edges[i]) = make_edge_info ();
-    object3d_add_edge (object, cube_edges[i]);
-  }
-
-  for (i = 0; i < 6; i++) {
-    faces[i] = make_face3d ();
-    /* XXX: Face normal */
-    /* XXX: Face contours */
-    object3d_add_face (object, faces[i]);
-  }
->>>>>>> patched
 
   for (i = 0; i < 4; i++)
     {
@@ -228,7 +216,6 @@ draw_quad_edge (edge_ref e, void *data)
   glColor3f (1., 1., 1.);
 #endif
 
-<<<<<<< current
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
@@ -240,37 +227,17 @@ draw_quad_edge (edge_ref e, void *data)
           glBegin (GL_LINES);
           for (i = 0; i < CIRC_SEGS; i++)
             {
+              /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
               glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
                           MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (((vertex3d *)ODATA(e))->z));
+                          MM_TO_COORD (info->cz));
               glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
                           MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (((vertex3d *)ODATA(e))->z));
+                          MM_TO_COORD (info->cz));
             }
           glEnd ();
           return;
         }
-=======
-  if (UNDIR_DATA(e) != NULL) {
-    edge_info *info = UNDIR_DATA(e);
-    if (info->is_stitch)
-      return;
-    if (info->is_round) {
-      int i;
-      glBegin (GL_LINES);
-      for (i = 0; i < CIRC_SEGS; i++) {
-        /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
-      }
-      glEnd ();
-      return;
->>>>>>> patched
-    }
 
   glBegin (GL_LINES);
   glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
@@ -585,72 +552,63 @@ object3d_export_to_step (object3d *object, const char *filename)
   /* Define the faces */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
     {
-<<<<<<< current
-      start_i = 0;
-      for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next)
-        {
-
-          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */ 
-          fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_edge_identifiers[i], face_contour_npoints[i]); fprintf (f, " ) ; ");
-          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n", next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-          face_bound_identifiers[icont] = next_step_identifier + 1;
-          next_step_identifier = next_step_identifier + 2;
-        }
-=======
       face3d *face = face_iter->data;
       bool outer_contour = true;
 
       for (contour_iter = face->contours;
            contour_iter != NULL;
-           contour_iter = g_list_next (contour_iter), outer_contour = false) {
-        contour3d *contour = contour_iter->data;
-        edge_ref edge;
-
-        /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */
-        fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier);
-
-        /* Emit the edges.. */
-        fprintf (f, "(");
-        for (edge = contour->first_edge;
-             edge != LPREV (contour->first_edge);
-             edge = LNEXT (edge)) {
-          fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
-        }
-        fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
-        fprintf (f, " ) ; ");
+           contour_iter = g_list_next (contour_iter), outer_contour = false)
+        {
+          contour3d *contour = contour_iter->data;
+          edge_ref edge;
 
-        fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", next_step_identifier + 1, outer_contour ? "OUTER_" : "", next_step_identifier);
-        contour->face_bound_identifier = next_step_identifier + 1;
-        next_step_identifier = next_step_identifier + 2;
-      }
->>>>>>> patched
+          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */
+          fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier);
+
+          /* Emit the edges.. */
+          fprintf (f, "(");
+          for (edge = contour->first_edge;
+               edge != LPREV (contour->first_edge);
+               edge = LNEXT (edge))
+            {
+              fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
+            }
+          fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
+          fprintf (f, " ) ; ");
+
+          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", next_step_identifier + 1, outer_contour ? "OUTER_" : "", next_step_identifier);
+          contour->face_bound_identifier = next_step_identifier + 1;
+          next_step_identifier = next_step_identifier + 2;
+        }
 
       fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier);
       fprintf (f, "(");
       for (contour_iter = face->contours;
            contour_iter != NULL && g_list_next (contour_iter) != NULL;
-           contour_iter = g_list_next (contour_iter)) {
-        fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
-      }
+           contour_iter = g_list_next (contour_iter))
+        {
+          fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
+        }
       fprintf (f, "#%i)", ((contour3d *)contour_iter->data)->face_bound_identifier);
       fprintf (f, ", #%i, %s ) ;\n", face->plane_identifier, face->plane_orientation_reversed ? ".F." : ".T.");
       face->face_identifier = next_step_identifier;
       next_step_identifier = next_step_identifier + 1;
 
-      if (face->appear != NULL) {
-        /* Face styles */
-        fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             next_step_identifier, face->appear->r, face->appear->g, face->appear->b);
-        fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        next_step_identifier + 1, next_step_identifier);
-        fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            next_step_identifier + 2, next_step_identifier + 1);
-        fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           next_step_identifier + 3, next_step_identifier + 2);
-        fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         next_step_identifier + 4, next_step_identifier + 3);
-        fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      next_step_identifier + 5, next_step_identifier + 4);
-        fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", next_step_identifier + 6, next_step_identifier + 5);
-        fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
-                 next_step_identifier + 7, next_step_identifier + 6, face->face_identifier, brep_style_identifier);
-        styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (next_step_identifier + 7));
-        next_step_identifier = next_step_identifier + 8;
-      }
+      if (face->appear != NULL)
+        {
+          /* Face styles */
+          fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             next_step_identifier, face->appear->r, face->appear->g, face->appear->b);
+          fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        next_step_identifier + 1, next_step_identifier);
+          fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            next_step_identifier + 2, next_step_identifier + 1);
+          fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           next_step_identifier + 3, next_step_identifier + 2);
+          fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         next_step_identifier + 4, next_step_identifier + 3);
+          fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      next_step_identifier + 5, next_step_identifier + 4);
+          fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", next_step_identifier + 6, next_step_identifier + 5);
+          fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
+                   next_step_identifier + 7, next_step_identifier + 6, face->face_identifier, brep_style_identifier);
+          styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (next_step_identifier + 7));
+          next_step_identifier = next_step_identifier + 8;
+        }
     }
 
   /* Closed shell which bounds the brep solid */
@@ -661,9 +619,10 @@ object3d_export_to_step (object3d *object, const char *filename)
   fprintf (f, "(");
   for (face_iter = object->faces;
        face_iter != NULL && g_list_next (face_iter) != NULL;
-       face_iter = g_list_next (face_iter)) {
-    fprintf (f, "#%i, ", ((face3d *)face_iter->data)->face_identifier);
-  }
+       face_iter = g_list_next (face_iter))
+    {
+      fprintf (f, "#%i, ", ((face3d *)face_iter->data)->face_identifier);
+    }
   fprintf (f, "#%i)", ((face3d *)face_iter->data)->face_identifier);
   fprintf (f, " ) ;\n");
 
@@ -675,9 +634,10 @@ object3d_export_to_step (object3d *object, const char *filename)
   fprintf (f, "(");
   for (styled_item_iter = styled_item_identifiers;
        styled_item_iter != NULL && g_list_next (styled_item_iter) != NULL;
-       styled_item_iter = g_list_next (styled_item_iter)) {
-    fprintf (f, "#%i, ", GPOINTER_TO_INT (styled_item_iter->data));
-  }
+       styled_item_iter = g_list_next (styled_item_iter))
+    {
+      fprintf (f, "#%i, ", GPOINTER_TO_INT (styled_item_iter->data));
+    }
   fprintf (f, "#%i)", GPOINTER_TO_INT (styled_item_iter->data));
   fprintf (f, ", #%i ) ;\n", geometric_representation_context_identifier);
   next_step_identifier = next_step_identifier + 1;
@@ -784,10 +744,10 @@ object3d_from_board_outline (void)
   }
 
   /* Define the edges */
-<<<<<<< current
   for (i = 0; i < 3 * npoints; i++)
     {
       edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
       object3d_add_edge (object, edges[i]);
     }
 
@@ -795,25 +755,11 @@ object3d_from_board_outline (void)
   for (i = 0; i < npoints; i++)
     {
       faces[i] = make_face3d ();
+
+      object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], edges[2 * npoints + i]);
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
     }
-  faces[npoints]     = make_face3d (); /* bottom_face */
-=======
-  for (i = 0; i < 3 * npoints; i++) {
-    edges[i] = make_edge ();
-    UNDIR_DATA (edges[i]) = make_edge_info ();
-    object3d_add_edge (object, edges[i]);
-  }
-
-  /* Define the faces */
-  for (i = 0; i < npoints; i++) {
-    faces[i] = make_face3d ();
-
-    object3d_add_face (object, faces[i]);
-    /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-    face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-  }
 
   faces[npoints] = make_face3d (); /* bottom_face */
   faces[npoints]->nx =  0.;
@@ -822,7 +768,6 @@ object3d_from_board_outline (void)
   face3d_set_appearance (faces[npoints], top_bot_appearance);
   object3d_add_face (object, faces[npoints]);
 
->>>>>>> patched
   faces[npoints + 1] = make_face3d (); /* top_face */
   faces[npoints + 1]->nx = 0.;
   faces[npoints + 1]->ny = 0.;
@@ -845,31 +790,17 @@ object3d_from_board_outline (void)
     int prev_i_around_ct;
 
     /* Update which contour we're looking at */
-<<<<<<< current
     if (offset_in_ct == ct_npoints)
       {
         start_of_ct = i;
-        printf ("start_of_ct = %i\n", start_of_ct);
         offset_in_ct = 0;
         ct = ct->next;
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-        face3d_add_contour (faces[npoints], edges[i]);
-        face3d_add_contour (faces[npoints + 1], edges[npoints + i]);
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
       }
-=======
-    if (offset_in_ct == ct_npoints) {
-      start_of_ct = i;
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
-
-      /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-    }
->>>>>>> patched
 
     next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
     prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
@@ -908,36 +839,26 @@ object3d_from_board_outline (void)
     splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
     splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
 
-<<<<<<< current
-    /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
-    /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
     if (ct->is_round)
       {
-        UNDIR_DATA (edges[0 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-        UNDIR_DATA (edges[1 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-        UNDIR_DATA (edges[2 * npoints + i]) = make_edge_info (true,  true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+
+        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                          COORD_TO_MM (ct->radius));
+        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
+        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
       }
-=======
-    if (ct->is_round) {
-
-      face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                        COORD_TO_MM (ct->radius));
-      face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-
-      edge_info_set_round (UNDIR_DATA (edges[i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                           0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                           0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-    }
 
   }
->>>>>>> patched
 
   poly_Free (&outline);
 
@@ -981,11 +902,12 @@ object3d_from_tracking (void)
   contour = outline->contours;
 
   ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
+  while (ct != NULL)
+    {
+      ncontours ++;
+      npoints += get_contour_npoints (ct);
+      ct = ct->next;
+    }
 
   object = make_object3d (PCB->Name);
   board_appearance = make_appearance ();
@@ -1005,39 +927,43 @@ object3d_from_tracking (void)
   offset_in_ct = 0;
   ct_npoints = get_contour_npoints (ct);
 
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    double x1, y1;
+  for (i = 0; i < npoints; i++, offset_in_ct++)
+    {
+      double x1, y1;
 
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
-    }
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints)
+        {
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
+        }
 
-    get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-    vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-    vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
+      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
 
-    object3d_add_vertex (object, vertices[i]);
-    object3d_add_vertex (object, vertices[npoints + i]);
-  }
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
+    }
 
   /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++) {
-    edges[i] = make_edge ();
-    UNDIR_DATA (edges[i]) = make_edge_info ();
-    object3d_add_edge (object, edges[i]);
-  }
+  for (i = 0; i < 3 * npoints; i++)
+    {
+      edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
+      object3d_add_edge (object, edges[i]);
+    }
 
   /* Define the faces */
-  for (i = 0; i < npoints; i++) {
-    faces[i] = make_face3d ();
+  for (i = 0; i < npoints; i++)
+    {
+      faces[i] = make_face3d ();
 
-    object3d_add_face (object, faces[i]);
-    /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-    face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-  }
+      object3d_add_face (object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+    }
 
   faces[npoints] = make_face3d (); /* bottom_face */
   face3d_set_normal (faces[npoints], 0., 0., -1.);
@@ -1058,77 +984,80 @@ object3d_from_tracking (void)
   offset_in_ct = 0;
   ct_npoints = get_contour_npoints (ct);
 
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    int next_i_around_ct;
-    int prev_i_around_ct;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      start_of_ct = i;
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
+  for (i = 0; i < npoints; i++, offset_in_ct++)
+    {
+      int next_i_around_ct;
+      int prev_i_around_ct;
 
-      /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-    }
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints)
+        {
+          start_of_ct = i;
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
 
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        }
 
-    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-    /* Define the (non-normalized) face normal to point to the outside of the contour */
-    face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
 
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[              i]) = vertices[0 * npoints + i];
-    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-    LDATA (edges[              i]) = faces[i];
-    RDATA (edges[              i]) = faces[npoints];
-    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-    RDATA (edges[1 * npoints + i]) = faces[i];
-    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-    RDATA (edges[2 * npoints + i]) = faces[i];
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
-    /* NB: Contours are counter clockwise in XY plane.
-     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-     */
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
 
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[2 * npoints + i]);
-    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+      if (ct->is_round)
+        {
 
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                            COORD_TO_MM (ct->radius));
+          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+        }
 
-    if (ct->is_round) {
-
-      face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                        COORD_TO_MM (ct->radius));
-      face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-      edge_info_set_round (UNDIR_DATA (edges[i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                           0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                           0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
     }
 
-  }
-
   poly_Free (&outline);
 
   return object;
