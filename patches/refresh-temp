Bottom: 67193597f974fbfab35cfdcc13f40b6d170636f9
Top:    91c780575073cb0986c2d46d968f9b4b3e7d2ee0
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-10 14:31:44 +0000

Refresh of toy-rendering-attempt

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 6e3d281..1f06e79 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -28,6 +28,8 @@ else
 AM_CFLAGS= -DNDEBUG
 endif
 
+AM_CFLAGS= -Wno-unused-parameter
+
 PCB_SRCS = \
 	action.c \
 	action.h \
diff --git a/src/data.c b/src/data.c
index 9d6588c..99df27a 100644
--- a/src/data.c
+++ b/src/data.c
@@ -41,7 +41,7 @@
  */
 
 CrosshairType Crosshair;	/* information about cursor settings */
-MarkType Marked;		/* a cross-hair mark */
+_MarkType Marked;		/* a cross-hair mark */
 OutputType Output;		/* some widgets ... used for drawing */
 PCBType *PCB;			/* pointer to layout struct */
 
diff --git a/src/data.h b/src/data.h
index 89d9b87..1006a61 100644
--- a/src/data.h
+++ b/src/data.h
@@ -39,7 +39,7 @@
 
 extern CrosshairType Crosshair;
 
-extern MarkType Marked;
+extern _MarkType Marked;
 
 extern OutputType Output;
 
diff --git a/src/global.h b/src/global.h
index b8efc7b..2186c0f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -609,7 +609,7 @@ typedef struct
 {
   bool status;
   Coord X, Y;
-} MarkType;
+} _MarkType;
 
 /* ---------------------------------------------------------------------------
  * our resources
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index eaa13dd..771e803 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -153,11 +153,14 @@ float colors[12][3] = {{1., 0., 0.},
                        {0.5, 1., 1.}};
 
 
-#define CIRC_SEGS 64
+#define CIRC_SEGS_D 64.0
 
 static void
 draw_quad_edge (edge_ref e, void *data)
 {
+  double x1, y1, z1;
+  double x2, y2, z2;
+
 #if 0
   int id = ID(e) % 12;
 
@@ -166,6 +169,14 @@ draw_quad_edge (edge_ref e, void *data)
   glColor3f (1., 1., 1.);
 #endif
 
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
@@ -174,39 +185,141 @@ draw_quad_edge (edge_ref e, void *data)
       if (info->is_round)
         {
           int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
           glBegin (GL_LINES);
-          for (i = 0; i < CIRC_SEGS; i++)
+
+          for (i = 0; i < segs; i++)
             {
-              /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
             }
+
           glEnd ();
+
           return;
         }
     }
 
   glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
   glEnd ();
 }
 
 void
-object3d_draw (obejct3d *object)
+object3d_draw (object3d *object)
 {
   g_return_if_fail (object->edges != NULL);
 
 //  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
   g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+//  printf ("....ENDED\n");
 }
 
 static void
@@ -679,7 +792,7 @@ object3d_from_contours (POLYAREA *contours,
         }
 
 #ifndef NDEBUG
-      ct = contour;
+      ct = outer_contour;
       start_of_ct = 0;
       offset_in_ct = 0;
       ct_npoints = get_contour_npoints (ct);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cdeafbb..4c2d39d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -123,7 +123,7 @@ static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_
 
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
-object3d *step_read_test = NULL
+object3d *step_read_test = NULL;
 
 
 /* Coordinate conversions */
@@ -1129,10 +1129,15 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
 
-//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step");
-//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step");
-//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step");
-  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/object3d_test.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step", &step_read_test);
+  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/object3d_test.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/step_interlayer_manual.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/DPAK.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Inductor_R1.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Capacitor_100V_10uF.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/", &step_read_test);
 }
 
 void
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c9eb567..3c7eae3 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -2600,7 +2600,7 @@ idle_proc (XtPointer dummy)
 
   {
     static int c_x = -2, c_y = -2;
-    static MarkType saved_mark;
+    static _MarkType saved_mark;
     static const Unit *old_grid_unit = NULL;
     if (crosshair_x != c_x || crosshair_y != c_y
 	|| Settings.grid_unit != old_grid_unit
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 5705425..7828fb9 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -42,6 +42,20 @@
 
 #include "utils.h"
 
+extern "C" {
+#include <glib.h>
+/* XXX: Sdai and PCB clash.. both define MarkType */
+#include "global.h"
+#include "../hid/common/appearance.h"
+#include "../hid/common/step_id.h"
+#include "../hid/common/quad.h"
+#include "../hid/common/edge3d.h"
+#include "../hid/common/contour3d.h"
+#include "../hid/common/face3d.h"
+#include "../hid/common/vertex3d.h"
+#include "../hid/common/object3d.h"
+}
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
@@ -135,9 +149,168 @@ find_manifold_solid_brep (Registry *registry,
     }
 }
 
+static void process_edges (GHashTable *edges_hash_set, object3d *object)
+{
+  GHashTableIter iter;
+  SdaiEdge *edge;
+  edge_ref our_edge;
+  vertex3d *vertex;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  bool orientation;
+  gpointer foo;
+  int bar;
+  bool kludge;
+
+  g_hash_table_iter_init (&iter, edges_hash_set);
+  while (g_hash_table_iter_next (&iter, (void **)&edge, &foo))
+    {
+      bar = GPOINTER_TO_INT (foo);
+      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+        {
+          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+          continue;
+        }
+
+      orientation = (bar & 1) != 0;
+      kludge = (bar & 2) != 0;
+
+      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+      //     In practice, edge should point to an EDGE_CURVE sub-type
+      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+          continue;
+        }
+
+      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+          continue;
+        }
+
+      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+      x1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ())->value;
+      y1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      x2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ())->value;
+      y2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+#if 0
+      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+              edge->StepFileId (), x1, y1, z1, x2, y2, z2);
+#endif
+
+      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+        {
+          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+          SdaiCurve *curve = ec->edge_geometry_ ();
+          bool same_sense = ec->same_sense_ ();
+
+#if 0
+          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+#endif
+
+          if (strcmp (curve->EntityName (), "Line") == 0)
+            {
+              our_edge = make_edge ();
+              UNDIR_DATA (our_edge) = make_edge_info ();
+              object3d_add_edge (object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//              continue;
+            }
+          else if (strcmp (curve->EntityName (), "Circle") == 0)
+            {
+              SdaiCircle *circle = (SdaiCircle *)curve;
+              double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+              double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+              double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+              double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+              double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+              double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+              double radius = circle->radius_();
+
+              edge_info *info;
+
+              our_edge = make_edge ();
+              info = make_edge_info ();
+              if (!kludge) //(same_sense)
+                {
+                  edge_info_set_round (info, cx, cy, cz, nx, ny, nz, radius);
+                }
+              else
+                {
+                  printf ("URM................\n");
+                  edge_info_set_round (info, cx, cy, cz, -nx, -ny, -nz, radius);
+                }
+              UNDIR_DATA (our_edge) = info;
+              object3d_add_edge (object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//              continue;
+            }
+          else
+            {
+              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+              // XXX: Various derived types of the above, e.g.:
+              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+              continue;
+            }
+
+        }
+      else
+        {
+          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+          continue;
+        }
+    }
+}
+
 extern "C" struct step_model *
-step_model_to_shape_master (const char *filename)
+step_model_to_shape_master (const char *filename, object3d **out_object)
 {
+  object3d *object;
+  edge_ref edge;
+  vertex3d *vertex;
+  GHashTable *edges_hash_set;
+  bool on_plane;
+
+  object = make_object3d ((char *)"Test");
+
   Registry * registry = new Registry (SchemaInit);
   InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
 
@@ -175,6 +348,9 @@ step_model_to_shape_master (const char *filename)
 
       std::cout << "Closed shell is " << cs << std::endl;
 
+      /* NB: NULLs give g_direct_hash and g_direct_equal */
+      edges_hash_set = g_hash_table_new (NULL, NULL);
+
       for (SingleLinkNode *iter = cs->cfs_faces_ ()->GetHead ();
            iter != NULL;
            iter = iter->NextNode ())
@@ -195,7 +371,11 @@ step_model_to_shape_master (const char *filename)
 
           SdaiSurface *surface = fs->face_geometry_ ();
 
+#if 0
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
+#endif
+
+          on_plane = false;
 
           if (surface->IsComplex ())
             {
@@ -203,6 +383,7 @@ step_model_to_shape_master (const char *filename)
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
+              on_plane = true;
               printf ("WARNING: planar surfaces are not supported yet\n");
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
@@ -231,17 +412,21 @@ step_model_to_shape_master (const char *filename)
 
               bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
 
+#if 0
               if (is_outer_bound)
                 std::cout << "  Outer bounds of face include ";
               else
                 std::cout << "  Bounds of face include ";
+#endif
 
               // NB: SdaiFace_bound has SdaiLoop *bound_ (), and Boolean orientation_ ()
               // NB: SdaiLoop is a SdaiTopological_representation_item, which is a SdaiRepresentation_item, which has a name_ ().
               // NB: Expect bounds_ () may return a SUBTYPE of SdaiLoop, such as, but not necessarily: SdaiEdge_loop
               SdaiLoop *loop = fb->bound_ ();
 
+#if 0
               std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
+#endif
               if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
                 {
                   SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
@@ -259,6 +444,7 @@ step_model_to_shape_master (const char *filename)
                        iter = iter->NextNode ())
                     {
                       SdaiOriented_edge *oe = (SdaiOriented_edge *)((EntityNode *)iter)->node;
+                      /* XXX: Will it _always?_ be an SdaiOriented_edge? */
 
                       // NB: Stepcode does not compute derived attributes, so we need to look at the EDGE
                       //     "edge_element" referred to by the ORIENTED_EDGE, to find the start and end vertices
@@ -266,6 +452,29 @@ step_model_to_shape_master (const char *filename)
                       SdaiEdge *edge = oe->edge_element_ ();
                       bool orientation = oe->orientation_ ();
 
+                      if (on_plane)
+                        {
+                          if (fs->same_sense_())
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                          else
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                        }
+                      else
+                        {
+                          g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                        }
+
+
                       if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
                           strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
                         {
@@ -308,6 +517,7 @@ step_model_to_shape_master (const char *filename)
                       SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
                       SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
 
+#if 0
                       printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
                               edge->StepFileId (),
                               ((RealNode *)edge_start_cp->coordinates_ ()->GetHead())->value,
@@ -328,13 +538,13 @@ step_model_to_shape_master (const char *filename)
 
                           if (strcmp (curve->EntityName (), "Line") == 0)
                             {
-                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
-                              continue;
+//                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//                              continue;
                             }
                           else if (strcmp (curve->EntityName (), "Circle") == 0)
                             {
-                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
-                              continue;
+//                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//                              continue;
                             }
                           else
                             {
@@ -351,6 +561,7 @@ step_model_to_shape_master (const char *filename)
                           printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
                           continue;
                         }
+#endif
 
                     }
 
@@ -363,11 +574,18 @@ step_model_to_shape_master (const char *filename)
             }
 
         }
+
+        process_edges (edges_hash_set, object);
+
+        /* Deal with edges hash set */
+        g_hash_table_destroy (edges_hash_set);
     }
 
   delete instance_list;
   delete registry;
 
+  *out_object = object;
+
   return NULL;
 }
 
diff --git a/src/hid/step/model.h b/src/hid/step/model.h
index f776512..707c2bb 100644
--- a/src/hid/step/model.h
+++ b/src/hid/step/model.h
@@ -20,4 +20,4 @@ struct step_model {
   double rz;
 };
 
-struct step_model *step_model_to_shape_master (const char *filename);
+struct step_model *step_model_to_shape_master (const char *filename, object3d **out_object);
diff --git a/src/polygon1.c b/src/polygon1.c
index 24e9dfa..3d0615c 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -4742,7 +4742,7 @@ line_segments_can_merge (VNODE *s1, VNODE *s2)
 {
   Vector p1, p2;
 
-  assert (EDGE_FOWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
+  assert (EDGE_FORWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
   Vsub2 (p1, EDGE_BACKWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s1)->point); /* See assert above for first arg */
   Vsub2 (p2, EDGE_FORWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s2)->point);
 
diff --git a/src/set.c b/src/set.c
index 03b452a..46938eb 100644
--- a/src/set.c
+++ b/src/set.c
@@ -345,7 +345,7 @@ SetRouteStyle (char *name)
 void
 SetLocalRef (Coord X, Coord Y, bool Showing)
 {
-  static MarkType old;
+  static _MarkType old;
   static int count = 0;
 
   if (Showing)
