Bottom: ee4bb1b3b1b5d408ecb373f132744ab041194164
Top:    0c746dc185603612b1f87f711d18eef0b233b6f1
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 15:50:34 +0000

Refresh of play-with-quad-edge-data-STEP

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index b6219e4..457a190 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -501,194 +501,6 @@ object3d_from_board_outline (void)
   return object;
 }
 
-object3d *
-object3d_from_tracking (void)
-{
-  object3d *object;
-  appearance *board_appearance;
-  appearance *top_bot_appearance;
-  POLYAREA *outline;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  face3d **faces;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  outline = board_outline_poly (true);
-  ncontours = 0;
-  npoints = 0;
-
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
-
-  ct = contour;
-  while (ct != NULL)
-    {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-  object = make_object3d (PCB->Name);
-  board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
-  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-  object3d_set_appearance (object, board_appearance);
-
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-  faces    = malloc (sizeof (face3d *) * (2 + npoints));
-
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      double x1, y1;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
-        {
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-        }
-
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-      object3d_add_vertex (object, vertices[i]);
-      object3d_add_vertex (object, vertices[npoints + i]);
-    }
-
-  /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++)
-    {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (object, edges[i]);
-    }
-
-  /* Define the faces */
-  for (i = 0; i < npoints; i++)
-    {
-      faces[i] = make_face3d ();
-
-      object3d_add_face (object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-    }
-
-  faces[npoints] = make_face3d (); /* bottom_face */
-  face3d_set_normal (faces[npoints], 0., 0., -1.);
-  face3d_set_appearance (faces[npoints], top_bot_appearance);
-  object3d_add_face (object, faces[npoints]);
-
-  faces[npoints + 1] = make_face3d (); /* top_face */
-  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-  object3d_add_face (object, faces[npoints + 1]);
-
-  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      int next_i_around_ct;
-      int prev_i_around_ct;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
-        {
-          start_of_ct = i;
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-
-          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-        }
-
-      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-      /* Define the (non-normalized) face normal to point to the outside of the contour */
-      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[              i]) = vertices[0 * npoints + i];
-      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-      if (ct->is_round)
-        {
-
-          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                            COORD_TO_MM (ct->radius));
-          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-          edge_info_set_round (UNDIR_DATA (edges[i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-        }
-
-    }
-
-  poly_Free (&outline);
-
-  return object;
-}
-
 void
 object3d_test_board_outline (void)
 {
