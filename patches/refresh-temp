Bottom: 1e763784adb58abb432b2f5a2e644d00b2731893
Top:    ef9e079da327d1ac5af5d3bc52813ba00a4f18dd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 21:20:36 +0000

Refresh of well-on-the-way-to-completely

---

diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index c3dafff..77db6b9 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -138,91 +138,103 @@ object3d_export_to_step (object3d *object, const char *filename)
 #define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
 
   /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
-    face3d *face = face_iter->data;
-
-    if (face->is_cylindrical) {
-      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
-       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
-       */
-      face->surface_identifier =
-        step_cylindrical_surface (step, "NONE",
-                                  step_axis2_placement_3d (step, "NONE",
-                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
-                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
-                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
-                                  face->radius);
-    } else {
-      contour3d *outer_contour = face->contours->data;
-      vertex3d *ov = ODATA (outer_contour->first_edge);
-      vertex3d *dv = DDATA (outer_contour->first_edge);
-
-      double rx, ry, rz;
-
-      rx = dv->x - ov->x;
-      ry = dv->y - ov->y;
-      rz = dv->z - ov->z;
-
-      /* Catch the circular face case where the start and end vertices are identical */
-      if (rx < EPSILON && -rx < EPSILON &&
-          ry < EPSILON && -ry < EPSILON &&
-          rz < EPSILON && -rz < EPSILON) {
-        rx = 1., ry = 0., rz = 0.;
-      }
-
-      face->surface_identifier =
-        step_plane (step, "NONE",
-                    step_axis2_placement_3d (step, "NONE",
-                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
-                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
-                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
-                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                 ry,         /* Define this to be along the first edge this */
-                                                                                 rz)));      /* contour links to in the quad edge structure */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
+    {
+      face3d *face = face_iter->data;
+
+      if (face->is_cylindrical)
+        {
+          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+           * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+           */
+          face->surface_identifier =
+            step_cylindrical_surface (step, "NONE",
+                                      step_axis2_placement_3d (step, "NONE",
+                                                               step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                     step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                     step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                      face->radius);
+        }
+      else
+        {
+          contour3d *outer_contour = face->contours->data;
+          vertex3d *ov = ODATA (outer_contour->first_edge);
+          vertex3d *dv = DDATA (outer_contour->first_edge);
+
+          double rx, ry, rz;
+
+          rx = dv->x - ov->x;
+          ry = dv->y - ov->y;
+          rz = dv->z - ov->z;
+
+          /* Catch the circular face case where the start and end vertices are identical */
+          if (rx < EPSILON && -rx < EPSILON &&
+              ry < EPSILON && -ry < EPSILON &&
+              rz < EPSILON && -rz < EPSILON)
+            {
+              rx = 1., ry = 0., rz = 0.;
+            }
+
+          face->surface_identifier =
+            step_plane (step, "NONE",
+                        step_axis2_placement_3d (step, "NONE",
+                                                 step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
+                                                                                     ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                     ov->z),     /* this contour links to in the quad edge structure. */
+                                                       step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                       step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                     ry,         /* Define this to be along the first edge this */
+                                                                                     rz)));      /* contour links to in the quad edge structure */
+        }
     }
 
   /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
-    edge_ref edge = (edge_ref)edge_iter->data;
-    edge_info *info = UNDIR_DATA (edge);
-
-    if (info->is_round) {
-      info->infinite_line_identifier =
-        step_circle (step, "NONE",
-                     step_axis2_placement_3d (step, "NONE",
-                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
-                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
-                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
-                                                    info->radius);
-    } else {
-      vertex3d *ov = ODATA (edge);
-      vertex3d *dv = DDATA (edge);
-
-      double dir_x, dir_y, dir_z;
-
-      dir_x = dv->x - ov->x;
-      dir_y = dv->y - ov->y;
-      dir_z = dv->z - ov->z;
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
+    {
+      edge_ref edge = (edge_ref)edge_iter->data;
+      edge_info *info = UNDIR_DATA (edge);
+
+      if (info->is_round)
+        {
+          info->infinite_line_identifier =
+            step_circle (step, "NONE",
+                         step_axis2_placement_3d (step, "NONE",
+                                                  step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                        step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                        step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                        info->radius);
+        }
+      else
+        {
+          vertex3d *ov = ODATA (edge);
+          vertex3d *dv = DDATA (edge);
+
+          double dir_x, dir_y, dir_z;
+
+          dir_x = dv->x - ov->x;
+          dir_y = dv->y - ov->y;
+          dir_z = dv->z - ov->z;
 
 #if 1
-      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
-      if (dir_x < EPSILON && -dir_x < EPSILON &&
-          dir_y < EPSILON && -dir_y < EPSILON &&
-          dir_z < EPSILON && -dir_z < EPSILON) {
-        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
-        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
-        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
-      }
+          /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+          if (dir_x < EPSILON && -dir_x < EPSILON &&
+              dir_y < EPSILON && -dir_y < EPSILON &&
+              dir_z < EPSILON && -dir_z < EPSILON)
+            {
+              printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+              pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+              dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+            }
 #endif
 
-      info->infinite_line_identifier =
-        step_line (step, "NONE",
-                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
-                   step_vector (step, "NONE",
-                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
-                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+          info->infinite_line_identifier =
+            step_line (step, "NONE",
+                       step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                       step_vector (step, "NONE",
+                                    step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
+                                    1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
 
+        }
     }
 
   /* Define the vertices */
