Bottom: 3007a833f2e75c54ad1b77ad2f8c1ca806b44edc
Top:    43287e2d7e8e1efd5d617575d7f7489bc3df7fa8
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 20:45:55 +0000

Refresh of continue-tinkering-with-3d

---

diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index 8791abf..0926001 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -55,3 +55,9 @@ face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax
   face->az = az;
   face->radius = radius;
 }
+
+void
+face3d_set_surface_orientation_reversed (face3d *face)
+{
+  face->surface_orientation_reversed = true;
+}
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 842d251..a4d81a4 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -11,8 +11,8 @@ typedef struct {
   appearance *appear;
 
   /* XXX: STEP specific - breaks encapsulation */
-  int plane_identifier;
-  bool plane_orientation_reversed;
+  int surface_identifier;
+  bool surface_orientation_reversed;
   int face_identifier;
   int face_bound_identifier;
 } face3d;
@@ -23,3 +23,4 @@ void face3d_add_contour (face3d *face, contour3d *contour);
 void face3d_set_appearance (face3d *face, appearance *appear);
 void face3d_set_normal (face3d *face, double nx, double ny, double nz);
 void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
+void face3d_set_surface_orientation_reversed (face3d *face);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index a97f98c..770c1f8 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -35,7 +35,7 @@
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
 
-static object3d *object3d_test_object = NULL;
+static GList *object3d_test_objects = NULL;
 
 static void
 print_edge_id (edge_ref e)
@@ -61,8 +61,8 @@ debug_print_edge (edge_ref e, void *data)
 void
 object3d_test_init (void)
 {
-  //object3d_test_object = object3d_create_test_cube ();
-  object3d_test_object = object3d_from_board_outline ();
+  //object3d_test_objects = g_list_append (NULL, object3d_create_test_cube ());
+  object3d_test_objects = object3d_from_board_outline ();
   object3d_test_board_outline ();
 }
 
@@ -219,8 +219,8 @@ draw_quad_edge (edge_ref e, void *data)
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
-      if (info->is_stitch)
-        return;
+//      if (info->is_stitch)
+//        return;
       if (info->is_round)
         {
           int i;
@@ -246,12 +246,19 @@ draw_quad_edge (edge_ref e, void *data)
   glEnd ();
 }
 
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  g_return_if_fail (object->edges != NULL);
+
+//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+}
+
 void
 object3d_draw_debug (void)
 {
-  g_return_if_fail (object3d_test_object->edges != NULL);
-
-  quad_enum ((edge_ref)object3d_test_object->edges->data, draw_quad_edge, NULL);
+  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, NULL);
 }
 
 /*********************************************************************************************************/
@@ -304,6 +311,7 @@ object3d_export_to_step (object3d *object, const char *filename)
   struct tm utc;
   int next_step_identifier;
   int geometric_representation_context_identifier;
+  int shape_representation_identifier;
   int brep_identifier;
   int pcb_shell_identifier;
   int brep_style_identifier;
@@ -374,12 +382,13 @@ object3d_export_to_step (object3d *object, const char *filename)
               "#16 =( NAMED_UNIT ( * ) PLANE_ANGLE_UNIT ( ) SI_UNIT ( $, .RADIAN. ) );\n"
               "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
               "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
+  geometric_representation_context_identifier = 18;
 
-  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( /* Manifold_solid_brep */ #21, #13 ), #18 ) ;\n"
-              "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
-              "test_pcb_absr_name");
+  /* Save a place for the advanced_brep_shape_representation identifier */
+  next_step_identifier = 19;
+  shape_representation_identifier = next_step_identifier++;
 
-  geometric_representation_context_identifier = 18;
+  fprintf (f, "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #%i ) ;\n", shape_representation_identifier);
 
   /* Save a place for the brep identifier */
   next_step_identifier = 21;
@@ -427,8 +436,7 @@ object3d_export_to_step (object3d *object, const char *filename)
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3, face->radius);
 
-          face->plane_orientation_reversed = true;
-          face->plane_identifier = next_step_identifier + 4;
+          face->surface_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
       else
@@ -470,8 +478,7 @@ object3d_export_to_step (object3d *object, const char *filename)
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3);
 
-          face->plane_orientation_reversed = false;
-          face->plane_identifier = next_step_identifier + 4;
+          face->surface_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
     }
@@ -490,7 +497,8 @@ object3d_export_to_step (object3d *object, const char *filename)
                       "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ; "
                       "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
                    next_step_identifier,     /* Center of the circle   */ info->cx, info->cy, info->cz, // <--- Center of coordinate placement
-                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
+                   next_step_identifier + 1, /* Normal of circle?      */ info->nx, info->ny, info->nz, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
+//                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3, info->radius);
@@ -563,7 +571,6 @@ object3d_export_to_step (object3d *object, const char *filename)
           contour3d *contour = contour_iter->data;
           edge_ref edge;
 
-          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */
           fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier);
 
           /* Emit the edges.. */
@@ -574,43 +581,36 @@ object3d_export_to_step (object3d *object, const char *filename)
             {
               fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
             }
-          fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
-          fprintf (f, " ) ; ");
-
-          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", next_step_identifier + 1, outer_contour ? "OUTER_" : "", next_step_identifier);
-          contour->face_bound_identifier = next_step_identifier + 1;
-          next_step_identifier = next_step_identifier + 2;
-        }
-
-      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier);
-      fprintf (f, "(");
-      for (contour_iter = face->contours;
-           contour_iter != NULL && g_list_next (contour_iter) != NULL;
-           contour_iter = g_list_next (contour_iter))
-        {
-          fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
-        }
-      fprintf (f, "#%i)", ((contour3d *)contour_iter->data)->face_bound_identifier);
-      fprintf (f, ", #%i, %s ) ;\n", face->plane_identifier, face->plane_orientation_reversed ? ".F." : ".T.");
-      face->face_identifier = next_step_identifier;
-      next_step_identifier = next_step_identifier + 1;
 
-      if (face->appear != NULL)
-        {
-          /* Face styles */
-          fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             next_step_identifier, face->appear->r, face->appear->g, face->appear->b);
-          fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        next_step_identifier + 1, next_step_identifier);
-          fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            next_step_identifier + 2, next_step_identifier + 1);
-          fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           next_step_identifier + 3, next_step_identifier + 2);
-          fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         next_step_identifier + 4, next_step_identifier + 3);
-          fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      next_step_identifier + 5, next_step_identifier + 4);
-          fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", next_step_identifier + 6, next_step_identifier + 5);
-          fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
-                   next_step_identifier + 7, next_step_identifier + 6, face->face_identifier, brep_style_identifier);
-          styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (next_step_identifier + 7));
-          next_step_identifier = next_step_identifier + 8;
-        }
-    }
+        fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier);
+        fprintf (f, "(");
+        for (contour_iter = face->contours;
+             contour_iter != NULL && g_list_next (contour_iter) != NULL;
+             contour_iter = g_list_next (contour_iter))
+          {
+            fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
+          }
+        fprintf (f, "#%i)", ((contour3d *)contour_iter->data)->face_bound_identifier);
+        fprintf (f, ", #%i, %s ) ;\n", face->surface_identifier, face->surface_orientation_reversed ? ".F." : ".T.");
+        face->face_identifier = next_step_identifier;
+        next_step_identifier = next_step_identifier + 1;
+
+        if (face->appear != NULL)
+          {
+            /* Face styles */
+            fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             next_step_identifier, face->appear->r, face->appear->g, face->appear->b);
+            fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        next_step_identifier + 1, next_step_identifier);
+            fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            next_step_identifier + 2, next_step_identifier + 1);
+            fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           next_step_identifier + 3, next_step_identifier + 2);
+            fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         next_step_identifier + 4, next_step_identifier + 3);
+            fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      next_step_identifier + 5, next_step_identifier + 4);
+            fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", next_step_identifier + 6, next_step_identifier + 5);
+            fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
+                     next_step_identifier + 7, next_step_identifier + 6, face->face_identifier, brep_style_identifier);
+            styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (next_step_identifier + 7));
+            next_step_identifier = next_step_identifier + 8;
+          }
+      }
 
   /* Closed shell which bounds the brep solid */
   pcb_shell_identifier = next_step_identifier;
@@ -643,10 +643,12 @@ object3d_export_to_step (object3d *object, const char *filename)
   fprintf (f, ", #%i ) ;\n", geometric_representation_context_identifier);
   next_step_identifier = next_step_identifier + 1;
 
+  fprintf (f, "#%i = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( #%i, #13 ), #%i ) ;\n",
+           shape_representation_identifier, "test_pcb_absr_name", brep_identifier, geometric_representation_context_identifier);
 
+#undef ORIENTED_EDGE_IDENTIFIER
 #undef FWD
 #undef REV
-#undef ORIENTED_EDGE_IDENTIFIER
 
   fprintf (f, "ENDSEC;\n" );
   fprintf (f, "END-ISO-10303-21;\n" );
@@ -654,13 +656,15 @@ object3d_export_to_step (object3d *object, const char *filename)
   fclose (f);
 }
 
-object3d *
+GList *
 object3d_from_board_outline (void)
 {
+  GList *objects = NULL;
   object3d *object;
   appearance *board_appearance;
   appearance *top_bot_appearance;
-  POLYAREA *outline;
+  POLYAREA *board_outline;
+  POLYAREA *pa;
   PLINE *contour;
   PLINE *ct;
   int ncontours;
@@ -673,388 +677,293 @@ object3d_from_board_outline (void)
   int offset_in_ct;
   int ct_npoints;
 
-  outline = board_outline_poly (true);
-  //outline = board_outline_poly (false); /* (FOR NOW - just the outline, no holes) */
-  ncontours = 0;
-  npoints = 0;
+  board_outline = board_outline_poly (true);
 
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
+  if (board_outline == NULL)
+    return NULL;
 
-  ct = contour;
-  while (ct != NULL)
+  /* Loop over all board outline pieces */
+  pa = board_outline;
+  do
     {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-  /* We know how many edges and vertices we need now...
-   *
-   * let n = npoints
-   * bodies = 1             (FOR NOW - just the first board outline)
-   * vertices = 2n          (n-top, n-bottom)
-   * edges = 3n             (n-top, n-bottom, n-sides)
-   * faces = 2 + n          (1-top, 1-bottom, n-sides)
-   *
-   * holes = 0              (FOR NOW - just the outline, no holes)
-   * holes = ncontours - 1  (LATER)
-   */
-
-  object = make_object3d (PCB->Name);
-  board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
-  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-  object3d_set_appearance (object, board_appearance);
-
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-  faces    = malloc (sizeof (face3d *) * (2 + npoints));
 
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
+      contour = pa->contours;
+      ncontours = 0;
+      npoints = 0;
 
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      double x1, y1;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
+      ct = contour;
+      while (ct != NULL)
         {
-          offset_in_ct = 0;
+          ncontours ++;
+          npoints += get_contour_npoints (ct);
           ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
         }
 
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-      object3d_add_vertex (object, vertices[i]);
-      object3d_add_vertex (object, vertices[npoints + i]);
-    }
-
-  /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++)
-    {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (object, edges[i]);
-    }
-
-  /* Define the faces */
-  for (i = 0; i < npoints; i++)
-    {
-      faces[i] = make_face3d ();
+      /* We know how many edges and vertices we need now...
+       *
+       * let n = npoints
+       * bodies = 1             (FOR NOW - just the first board outline)
+       * vertices = 2n          (n-top, n-bottom)
+       * edges = 3n             (n-top, n-bottom, n-sides)
+       * faces = 2 + n          (1-top, 1-bottom, n-sides)
+       *
+       * holes = 0              (FOR NOW - just the outline, no holes)
+       * holes = ncontours - 1  (LATER)
+       */
 
-      object3d_add_face (object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-    }
+      object = make_object3d (PCB->Name);
+      board_appearance = make_appearance ();
+      top_bot_appearance = make_appearance ();
+      appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+      appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-  faces[npoints] = make_face3d (); /* bottom_face */
-  faces[npoints]->nx =  0.;
-  faces[npoints]->ny =  0.;
-  faces[npoints]->nz = -1.;
-  face3d_set_appearance (faces[npoints], top_bot_appearance);
-  object3d_add_face (object, faces[npoints]);
-
-  faces[npoints + 1] = make_face3d (); /* top_face */
-  faces[npoints + 1]->nx = 0.;
-  faces[npoints + 1]->ny = 0.;
-  faces[npoints + 1]->nz = 1.;
-  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-  object3d_add_face (object, faces[npoints + 1]);
-
-  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-  {
-    int next_i_around_ct;
-    int prev_i_around_ct;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints)
-      {
-        start_of_ct = i;
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-
-        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-      }
+      object3d_set_appearance (object, board_appearance);
 
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-    /* Define the (non-normalized) face normal to point to the outside of the contour */
-    faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
-    faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
-    faces[i]->nz = 0.;
-
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[              i]) = vertices[0 * npoints + i];
-    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-    LDATA (edges[              i]) = faces[i];
-    RDATA (edges[              i]) = faces[npoints];
-    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-    RDATA (edges[1 * npoints + i]) = faces[i];
-    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-    RDATA (edges[2 * npoints + i]) = faces[i];
-
-    /* NB: Contours are counter clockwise in XY plane.
-     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-     */
-
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[2 * npoints + i]);
-    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-    if (ct->is_round)
-      {
-
-        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                          COORD_TO_MM (ct->radius));
-        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-      }
-
-  }
+      vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
+      edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
+      faces    = malloc (sizeof (face3d *) * (2 + npoints));
 
-  poly_Free (&outline);
+      /* Define the vertices */
+      ct = contour;
+      start_of_ct = 0;
+      offset_in_ct = 0;
+      ct_npoints = get_contour_npoints (ct);
 
-  return object;
-}
+      for (i = 0; i < npoints; i++, offset_in_ct++)
+        {
+          double x1, y1;
 
-void
-object3d_test_board_outline (void)
-{
-  object3d *board_outline;
+          /* Update which contour we're looking at */
+          if (offset_in_ct == ct_npoints)
+            {
+              offset_in_ct = 0;
+              ct = ct->next;
+              ct_npoints = get_contour_npoints (ct);
+            }
 
-  board_outline = object3d_from_board_outline ();
-  object3d_export_to_step (board_outline, "object3d_test.step");
-  destroy_object3d (board_outline);
-}
+          get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
+          vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
+          vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
 
-object3d *
-object3d_from_tracking (void)
-{
-  object3d *object;
-  appearance *board_appearance;
-  appearance *top_bot_appearance;
-  POLYAREA *outline;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  face3d **faces;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  outline = board_outline_poly (true);
-  ncontours = 0;
-  npoints = 0;
+          object3d_add_vertex (object, vertices[i]);
+          object3d_add_vertex (object, vertices[npoints + i]);
+        }
 
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
+      /* Define the edges */
+      for (i = 0; i < 3 * npoints; i++)
+        {
+          edges[i] = make_edge ();
+          UNDIR_DATA (edges[i]) = make_edge_info ();
+          object3d_add_edge (object, edges[i]);
+        }
 
-  ct = contour;
-  while (ct != NULL)
-    {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
+      /* Define the faces */
+      for (i = 0; i < npoints; i++)
+        {
+          faces[i] = make_face3d ();
 
-  object = make_object3d (PCB->Name);
-  board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
-  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+          object3d_add_face (object, faces[i]);
+          /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+          face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+        }
 
-  object3d_set_appearance (object, board_appearance);
+      faces[npoints] = make_face3d (); /* bottom_face */
+      face3d_set_normal (faces[npoints], 0., 0., -1.);
+      face3d_set_appearance (faces[npoints], top_bot_appearance);
+      object3d_add_face (object, faces[npoints]);
 
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-  faces    = malloc (sizeof (face3d *) * (2 + npoints));
+      faces[npoints + 1] = make_face3d (); /* top_face */
+      face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+      face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+      object3d_add_face (object, faces[npoints + 1]);
 
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
+      /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
 
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      double x1, y1;
+      ct = contour;
+      start_of_ct = 0;
+      offset_in_ct = 0;
+      ct_npoints = get_contour_npoints (ct);
 
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
+      for (i = 0; i < npoints; i++, offset_in_ct++)
         {
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-        }
-
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-      object3d_add_vertex (object, vertices[i]);
-      object3d_add_vertex (object, vertices[npoints + i]);
-    }
-
-  /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++)
-    {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (object, edges[i]);
-    }
+          int next_i_around_ct;
+          int prev_i_around_ct;
 
-  /* Define the faces */
-  for (i = 0; i < npoints; i++)
-    {
-      faces[i] = make_face3d ();
+          /* Update which contour we're looking at */
+          if (offset_in_ct == ct_npoints)
+            {
+              start_of_ct = i;
+              offset_in_ct = 0;
+              ct = ct->next;
+              ct_npoints = get_contour_npoints (ct);
+
+              /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+              face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+              face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+            }
 
-      object3d_add_face (object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-    }
+          next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+          prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+          /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+          /* Define the (non-normalized) face normal to point to the outside of the contour */
+          face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                      -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+
+          /* Assign the appropriate vertex geometric data to each edge end */
+          ODATA (edges[              i]) = vertices[0 * npoints + i];
+          DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+          ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+          DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+          ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+          DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+          LDATA (edges[              i]) = faces[i];
+          RDATA (edges[              i]) = faces[npoints];
+          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          RDATA (edges[1 * npoints + i]) = faces[i];
+          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          RDATA (edges[2 * npoints + i]) = faces[i];
+
+          /* NB: Contours are counter clockwise in XY plane.
+           *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+           *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+           *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+           */
 
-  faces[npoints] = make_face3d (); /* bottom_face */
-  face3d_set_normal (faces[npoints], 0., 0., -1.);
-  face3d_set_appearance (faces[npoints], top_bot_appearance);
-  object3d_add_face (object, faces[npoints]);
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (edges[i], edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
-  faces[npoints + 1] = make_face3d (); /* top_face */
-  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-  object3d_add_face (object, faces[npoints + 1]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
 
-  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+          if (ct->is_round)
+            {
 
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
+              face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                                0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                                COORD_TO_MM (ct->radius));
+              face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+              face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                        /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+
+              edge_info_set_round (UNDIR_DATA (edges[i]),
+                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                                   0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                   COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                                   0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+              edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+            }
 
-  for (i = 0; i < npoints; i++, offset_in_ct++)
-    {
-      int next_i_around_ct;
-      int prev_i_around_ct;
+        }
 
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints)
+      if (1)
         {
-          start_of_ct = i;
-          offset_in_ct = 0;
-          ct = ct->next;
-          ct_npoints = get_contour_npoints (ct);
-
-          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+          edge_ref cylinder_edges[3];
+          vertex3d *cylinder_vertices[2];
+          face3d *cylinder_faces[2];
+
+          /* Edge on top of board */
+          cylinder_edges[0] = make_edge ();
+          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               45., 45., 0., /* Center of circle */
+                                0.,  0., 1., /* Normal */
+                                5.);         /* Radius */
+          object3d_add_edge (object, cylinder_edges[0]);
+
+          /* Edge on top of cylinder */
+          cylinder_edges[1] = make_edge ();
+          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                               45., 45., 10., /* Center of circle */
+                                0.,  0., 1.,  /* Normal */
+                                5.);          /* Radius */
+          object3d_add_edge (object, cylinder_edges[1]);
+
+          /* Edge stitching cylinder */
+          cylinder_edges[2] = make_edge ();
+          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+          object3d_add_edge (object, cylinder_edges[2]);
+
+          /* Vertex on board top surface */
+          cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+          object3d_add_vertex (object, cylinder_vertices[0]);
+
+          /* Vertex on cylinder top surface */
+          cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+          object3d_add_vertex (object, cylinder_vertices[1]);
+
+          /* Cylindrical face */
+          cylinder_faces[0] = make_face3d ();
+          face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,            /* Direction of the cylindrical axis */
+                                            5.);                   /* Radius of cylinder */
+          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+          object3d_add_face (object, cylinder_faces[0]);
+          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+          /* Top face of cylinder */
+          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+          object3d_add_face (object, cylinder_faces[1]);
+          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+          /* Splice onto board */
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+          /* Assign the appropriate vertex geometric data to each edge end */
+          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+          LDATA (cylinder_edges[0]) = cylinder_faces[0];
+          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+          LDATA (cylinder_edges[1]) = cylinder_faces[1];
+          RDATA (cylinder_edges[1]) = cylinder_faces[0];
+          LDATA (cylinder_edges[2]) = cylinder_faces[0];
+          RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+          /* Splice things together.... */
+
+          /* Link edges orbiting the cylinder bottom vertex */
+          splice (cylinder_edges[0], cylinder_edges[2]);
+          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+          /* Link edges orbiting the cylinder top vertex */
+          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
         }
 
-      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-      /* Define the (non-normalized) face normal to point to the outside of the contour */
-      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[              i]) = vertices[0 * npoints + i];
-      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+      objects = g_list_append (objects, object);
 
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+    }
+  while (pa = pa->f, pa != board_outline);
 
-      if (ct->is_round)
-        {
+  poly_Free (&board_outline);
 
-          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                            COORD_TO_MM (ct->radius));
-          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-          edge_info_set_round (UNDIR_DATA (edges[i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-        }
+  return objects;
+}
 
-    }
+void
+object3d_test_board_outline (void)
+{
+  GList *board_outlines;
 
-  poly_Free (&outline);
+  board_outlines = object3d_from_board_outline ();
+  object3d_export_to_step (board_outlines->data, "object3d_test.step");
 
-  return object;
+  g_list_free_full (board_outlines, (GDestroyNotify)destroy_object3d);
 }
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 9a34fa8..f396295 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -16,6 +16,6 @@ void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
 object3d *object3d_create_test_cube (void);
-object3d *object3d_from_board_outline (void);
+GList *object3d_from_board_outline (void);
 void object3d_export_to_step (object3d *object, const char *filename);
 void object3d_test_board_outline (void);
