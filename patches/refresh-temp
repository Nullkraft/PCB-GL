Bottom: a7a29e7328d72c667dcd30def75b2c9850fff5dc
Top:    f6655bf6b8b1670251bdbe99cc45c5873e5e1122
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-19 19:25:54 +0000

Refresh of work-in-progress

---

diff --git a/src/polygon1.c b/src/polygon1.c
index e844f86..7850ec3 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -416,16 +416,19 @@ node_add_single_point (VNODE * a, Vector p)
   return new_node;
 }				/* node_add_point */
 
+#if 1
 static void
 cvc_list_dump (CVCList *list)
 {
   VNODE *node = list->parent;
   CVCList *iter;
+  int count = 0;
 
   pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
 
   iter = list;
   do {
+    count ++;
     pcb_fprintf (stderr, "angle = %.30e, poly = %c, side = %c, (%mn, %mn)-(%mn, %mn), Vertices: %p-%p Edge: %p\n",
                  iter->angle,
                  iter->poly,
@@ -438,7 +441,11 @@ cvc_list_dump (CVCList *list)
                  EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side)),
                  VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side));
   } while ((iter = iter->next) != list);
+
+  if ((count & 1) != 0)
+    g_error ("Ended up with odd number of entries in CVC list");
 }
+#endif
 
 /*
 edge_label
@@ -533,7 +540,7 @@ edge_label (VNODE * pn, int existing_label)
        */
       if (!(l->poly != this_poly))
         {
-          g_warning ("Wrapped around entire CVCList without finding any edges from the other polygon");
+          g_info ("Wrapped around entire CVCList without finding any edges from the other polygon");
           /* This is now an expected condition for some cases where we deleted hairline edge pairs */
           region = existing_label;
           LABEL_EDGE (pn, region);
@@ -1231,6 +1238,7 @@ label_contour (PLINE * a)
       LABEL_EDGE (cure, label);
     }
   while ((cure = NEXT_EDGE (cure)) != first_labelled);
+#warning The above loop could run forever if we encounter a contour where the only intersection gets nuked due to shared edges
 #ifdef DEBUG_ALL_LABELS
   print_labels (a);
   DEBUGP ("\n\n");
@@ -2448,16 +2456,23 @@ add_dummy_descriptors_at_point (Vector point, PLINE * pl, char poly, CVCList * l
 static void
 remove_cvc_list_entry (CVCList *l)
 {
+  bool last = false;
+
   if (l == NULL)
     return;
 
+//  fprintf (stderr, "Removing node from CVC list..\nBEFORE:\n");
+  //cvc_list_dump (l);
+
   /* XXX: What about when we remove the last edge - e.g. likely
    *      inthe case of a dummy entry with connection degree 1.
    */
 
   if (l->prev == l || l->next == l) /* XXX: Are these conditions equivalent for the last in list case? */
     {
-//      g_critical ("Removing last node in circular CVC list..");
+      last = true;
+//      fprintf (stderr, "EMPTY AFTERWARDS\n");
+      g_critical ("Removing last node in circular CVC list..");
     }
 
   {
@@ -2485,6 +2500,29 @@ remove_cvc_list_entry (CVCList *l)
    */
   l->parent = NULL;
 //  free (l);
+
+  if (!last)
+    {
+//      fprintf (stderr, "AFTERWARDS:\n");
+//      cvc_list_dump (l->prev);
+    }
+}
+
+static CVCList *
+next_cvc_from_same_poly (CVCList *start)
+{
+  CVCList *n;
+
+  n = start->next;
+
+  /* Find the next edge from the same polygon */
+  while (n->poly != start->poly && n != start)
+    n = n->next;
+
+//  if (n == start)
+//    return NULL;
+
+  return n;
 }
 
 /* NOTE: If any contour is split into multiple pieces due to hairline edge pairs
@@ -2499,8 +2537,9 @@ static void
 PLINE_check_hairline_edges (PLINE *contour)
 {
   VNODE *v;
-  CVCList *l, *first_l, *n, *nn;
+  CVCList *l, *first_l, /**new_first_l,*/*n, *nn;
   int test_count;
+  bool terminate_after_this_iteration;
 
 //  /* Lets just try this for now */
 //  if (poly_ChkContour (contour))
@@ -2510,20 +2549,34 @@ PLINE_check_hairline_edges (PLINE *contour)
   v = &contour->head;
   do
     {
-      if (v->cvc_prev == NULL)
+      if (v->cvc_prev == NULL &&
+          v->cvc_next == NULL) /* Careful, these can be NULL independantly now! */
         continue;
 
-      if (v->cvc_prev->parent == NULL)
+#if 0
+      if (v->cvc_prev != NULL && v->cvc_prev->parent == NULL &&
+          v->cvc_next != NULL && v->cvc_next->parent == NULL)
         {
           g_critical ("Skipping zombie vertex we left behind");
           continue;
         }
+#endif
 
 //      fprintf (stderr, "Vertex is cross connected, checking for hairline edge pairs\n");
 
-      first_l = v->cvc_prev;
+      /* Just pick one which isn't NULL, doesn't matter where we start
+       * circling the CVCList, as long as we start from a descriptor
+       * belonging to this polygon
+       */
+      if (v->cvc_prev != NULL)
+        first_l = v->cvc_prev;
+      else
+        first_l = v->cvc_next;
 
-//      cvc_list_dump (first_l);
+#if 0
+      fprintf (stderr, "Iteration begins with CVCList:\n");
+      cvc_list_dump (first_l);
+#endif
 
       test_count = 0;
       l = first_l;
@@ -2531,45 +2584,66 @@ PLINE_check_hairline_edges (PLINE *contour)
         {
           n = l->next;
 
+#if 0
           if (l->parent == NULL) /* Deleted node we were too lazy to remove during this early development phase */
             continue;
+#endif
 
           /* Skip edges from the other polygon */
           if (l->poly != first_l->poly)
             continue;
 
           /* Find the next edge from this polygon */
-          while ((n->poly != first_l->poly || n->parent == NULL) && n != first_l)
+          while ((n->poly != first_l->poly /* || n->parent == NULL*/) && n != first_l)
             n = n->next;
 
           /* Skip testing if we wrapped around, and only had one pair to test */
           if (n == first_l && test_count == 1)
             break;
 
+          /* Not sure why we get this, but apparently we can! */
+          if (n == l)
+            {
+              g_warning ("Wrapped around and found ourselves in the CVCList.. not quite sure how we managed that\n"
+                         "Did we perhaps delete the start descriptor?");
+
+              cvc_list_dump (n);
+              break;
+            }
+#if 0
           if (n->parent == NULL) /* Wrap-around to a node we deleted */
             break;
+#endif
+
+          g_assert (l->parent != NULL);
+          g_assert (n->parent != NULL);
+
+          g_assert (l->poly == first_l->poly);
+          g_assert (n->poly == first_l->poly);
 
           /* Check for hairline pairs of edges in the CVCList, they may be sorted in incorrect order,
            * and would thus mislead as to whether we are inside or outside a given contour. It is a
            * bug if such edges are present, so test for it here where we may detect it. We compare
            * l->prev and l, as we know both are still in this_poly.. l->next may not be.
            */
-
-          g_assert (l->poly == first_l->poly);
-          g_assert (n->poly == first_l->poly);
 //              fprintf (stderr, "Checking CVCNode %p against %p. (Angles %f and %f)\n", l, n, l->angle, n->angle);
           if (compare_cvc_nodes (l, n) == 0)
             {
               VNODE *l_otherend = EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->parent, l->side), l->side);
               VNODE *n_otherend = EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (n->parent, n->side), n->side);
 
+              g_assert (l != n);
+
               if (vect_equal (l_otherend->point, n_otherend->point))
                 {
-                  g_warning ("Check found hairline edge pair");
+//                  g_warning ("Check found hairline edge pair");
 
                   if (vect_equal (l->parent->point, l_otherend->point))
                     g_error ("Edges are zero length");
 
+                  g_assert (l->parent != NULL);
+                  g_assert (n->parent != NULL);
+
                   /* Simple approach - just mark the edges as visited, so we don't traverse them!
                    * Doing it this way ensures that both pieces of the contour are reachable if
                    * the hairline edge pair splits this PLINE into two pieces. Since we will ensure
@@ -2602,10 +2676,42 @@ PLINE_check_hairline_edges (PLINE *contour)
                   while ((nn->poly != first_l->poly || nn->parent == NULL) && nn != first_l)
                     nn = nn->next;
 
+                  g_assert (l->parent != NULL);
+//                  g_warn_if_fail (l != first_l);
+                  if (l == first_l)
+                    {
+                      first_l = next_cvc_from_same_poly (first_l);
+                      if (l == first_l)
+                        terminate_after_this_iteration = true;
+                    }
+                  g_warn_if_fail (l != NULL);
                   remove_cvc_list_entry (l);
+                  g_assert (n->parent != NULL);
+//                  g_warn_if_fail (n != first_l);
+                  if (n == first_l)
+                    {
+                      terminate_after_this_iteration = true;
+#if 0
+                      /* Find the next edge from this polygon */
+                      new_first_l = first_l->next;
+                      while ((new_first_l->poly != first_l->poly) && new_first_l != first_l)
+                        new_first_l = new_first_l->next;
+                      if (new_first_l == first_l)
+                        new_first_l = NULL;
+                    }
+                  else
+                    {
+                      new_first_l = first_l;
+#endif
+                    }
+                  g_warn_if_fail (n != NULL);
                   remove_cvc_list_entry (n);
 
                   n = nn;
+//                  first_l = new_first_l;
+
+//                  if (first_l == NULL)
+//                    break;
 
                 }
               else
@@ -2622,31 +2728,76 @@ PLINE_check_hairline_edges (PLINE *contour)
 
 #warning THIS IS ALMOST CERTAINLY VERY VERY WRONG
 
-                  VERTEX_SIDE_DIR_EDGE (l->parent, l->side)->Flags.mark = true;
-                  VERTEX_SIDE_DIR_EDGE (n->parent, n->side)->Flags.mark = true;
+                  if (vect_equal (l->parent->point, l_otherend->point))
+                    g_error ("Edges are zero length");
+
+                  g_assert (l->parent != NULL);
+                  g_assert (n->parent != NULL);
 
+//                  VERTEX_SIDE_DIR_EDGE (l->parent, l->side)->Flags.mark = true;
+//                  VERTEX_SIDE_DIR_EDGE (n->parent, n->side)->Flags.mark = true;
+
+#warning FOR SOME REASON THIS ENDS UP GIVING ODD-NUMBERS OF DESCRIPTORS IN THE CVCLIST - PROBABLY BECAUSE WE DONT ADD THE MARKED EDGES..
+#warning THIS IS ALMOST CERTAINLY VERY VERY WRONG, UNLESS WE ACTUALLY PERFORM THE INTERSECTION TO INSERT AN ADDITIONAL VERTEX IN THE APPROPRIATE EDGE
                   add_dummy_descriptors_at_point (l_otherend->point, contour, first_l->poly, l); /* Picking 'l' for an arbitrary start CVCList */
                   add_dummy_descriptors_at_point (n_otherend->point, contour, first_l->poly, l); /* Picking 'l' for an arbitrary start CVCList */
 
                   /* NOTE: 'P' at this node means 'N' at otherend */
-                  remove_cvc_list_entry ((l->side == 'P') ? l_otherend->cvc_next : l_otherend->cvc_prev);
-                  remove_cvc_list_entry ((n->side == 'P') ? n_otherend->cvc_next : n_otherend->cvc_prev);
+//                  remove_cvc_list_entry ((l->side == 'P') ? l_otherend->cvc_next : l_otherend->cvc_prev);
+//                  remove_cvc_list_entry ((n->side == 'P') ? n_otherend->cvc_next : n_otherend->cvc_prev);
 
                   nn = n->next;
                   /* Find the next edge from this polygon */
                   while (nn->poly != first_l->poly && nn != first_l)
                     nn = nn->next;
 
+                  g_assert (l->parent != NULL);
+//                  g_warn_if_fail (l != first_l);
+                  if (l == first_l)
+                    {
+                      first_l = next_cvc_from_same_poly (first_l);
+                      if (l == first_l)
+                        terminate_after_this_iteration = true;
+                    }
+                  g_warn_if_fail (l != NULL);
                   remove_cvc_list_entry (l);
+                  g_assert (n->parent != NULL);
+//                  g_warn_if_fail (n != first_l);
+                  if (n == first_l)
+                    {
+                      terminate_after_this_iteration = true;
+#if 0
+                      /* Find the next edge from this polygon */
+                      new_first_l = first_l->next;
+                      while ((new_first_l->poly != first_l->poly) && new_first_l != first_l)
+                        new_first_l = new_first_l->next;
+                      if (new_first_l == first_l)
+                        new_first_l = NULL;
+                    }
+                  else
+                    {
+                      new_first_l = first_l;
+#endif
+                    }
+                  g_warn_if_fail (n != NULL);
                   remove_cvc_list_entry (n);
 
                   n = nn;
+//                  first_l = new_first_l;
+
+#if 0
+                  if (first_l == NULL)
+                    break;
+#endif
                 }
             }
 
           test_count++;
 
-          if (n->parent == NULL) /* Wrap-around to a node we deleted */
+//          if (n->parent == NULL) /* Wrap-around to a node we deleted */
+//            break;
+
+          if (terminate_after_this_iteration)
             break;
 
           /* Stop if we wrapped around to the end of the list */
@@ -2801,6 +2952,8 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 //      fprintf (stderr, "Checking B intersected contours\n");
       M_POLYAREA_check_hairline_edges (b);
 
+      M_POLYAREA_check_hairline_edges (a);
+
       /* We could speed things up a lot here if we only processed the relevant contours */
       /* NB: Relevant parts of a are labeled below */
 //      fprintf (stderr, "Labeling B intersected contours\n");
