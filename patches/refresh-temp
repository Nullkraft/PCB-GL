Bottom: defcb1f96316581c08393df7bb40c9b19da12071
Top:    ccb766ca3b62574d75d9742aac5be07d63db907b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 20:38:46 +0000

Refresh of wip-on-quad-edge-play

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 6d36874..73a9ee9 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -419,8 +419,8 @@ object3d_export_to_step (object3d *object, const char *filename)
           fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 1,  -(y2 - y1), (x2 - x1), 0.0);  /* An axis direction pointing into the shape */ // <-- Or is this the z-axis of the coordinate placement -> plane normal?
           fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 2, 0.0, 0.0, 1.0);          // <-- Reference x-axis, should be orthogonal to the z-axis above.
           fprintf (f, "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
+                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2);
           fprintf (f, "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3);
           plane_identifiers[i] = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
@@ -443,7 +443,7 @@ object3d_export_to_step (object3d *object, const char *filename)
                    next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                   next_step_identifier + 4, next_step_identifier + 3, edge_info->radius;
+                   next_step_identifier + 4, next_step_identifier + 3, edge_info->radius);
           infinite_line_identifiers[i] = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
@@ -482,8 +482,8 @@ object3d_export_to_step (object3d *object, const char *filename)
   /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
   for (;;)
     {
-      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; ", next_step_identifier, start_vertex_identifiers[i], end_vertex_identifiers[i], infinite_line_identifier[i],
-      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; ",    next_step_identifier + 1, next_step_identifier,
+      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; ", next_step_identifier, start_vertex_identifiers[i], end_vertex_identifiers[i], infinite_line_identifier[i]);
+      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; ",    next_step_identifier + 1, next_step_identifier);
       fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",   next_step_identifier + 2, next_step_identifier);
       edge_identifiers[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
       next_step_identifier = next_step_identifier + 3;
@@ -604,15 +604,10 @@ object3d_from_board_outline (void)
       get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
       vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
       vertices[npoints + i] = make_vertex3d (x1, y1, 0); /* Top */
-    }
-
-    get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-    vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-    vertices[npoints + i] = make_vertex3d (x1, y1, 0); /* Top */
 
-    object3d_add_vertex (object, vertices[i]);
-    object3d_add_vertex (object, vertices[npoints + i]);
-  }
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
+    }
 
   /* Define the edges */
   for (i = 0; i < 3 * npoints; i++)
@@ -641,57 +636,58 @@ object3d_from_board_outline (void)
   ct_npoints = get_contour_npoints (ct);
 
   for (i = 0; i < npoints; i++, offset_in_ct++)
-  {
-    int next_i_around_ct;
-    int prev_i_around_ct;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints)
-      {
-        start_of_ct = i;
-        printf ("start_of_ct = %i\n", start_of_ct);
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-
-        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-        face3d_add_contour (faces[npoints], edges[i]);
-        face3d_add_contour (faces[npoints + 1], edges[npoints + i]);
-      }
-
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[0 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[0 * npoints + i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-    LDATA (edges[0 * npoints + i]) = faces[i];
-    RDATA (edges[0 * npoints + i]) = faces[npoints];
-    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-    RDATA (edges[1 * npoints + i]) = faces[i];
-    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-    RDATA (edges[2 * npoints + i]) = faces[i];
-
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[next_i_around_ct]));
-
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (edges[npoints + i], SYM(edges[npoints + next_i_around_ct]));
-    splice (SYM(edges[npoints + next_i_around_ct]), SYM(edges[2 * npoints + i]));
-
-    /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
-    /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
-    if (ct->is_round)
-      {
-        UNDIR_DATA (edges[0 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-        UNDIR_DATA (edges[1 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-        UNDIR_DATA (edges[2 * npoints + i]) = make_edge_info (true,  true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-      }
+    {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints)
+        {
+          start_of_ct = i;
+          printf ("start_of_ct = %i\n", start_of_ct);
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
+
+          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+          face3d_add_contour (faces[npoints], edges[i]);
+          face3d_add_contour (faces[npoints + 1], edges[npoints + i]);
+        }
+
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[0 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[0 * npoints + i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+      LDATA (edges[0 * npoints + i]) = faces[i];
+      RDATA (edges[0 * npoints + i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[npoints + i]);
+      splice (edges[npoints + i], SYM(edges[next_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[npoints + next_i_around_ct]));
+      splice (SYM(edges[npoints + next_i_around_ct]), SYM(edges[2 * npoints + i]));
+
+      /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
+      /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
+      if (ct->is_round)
+        {
+          UNDIR_DATA (edges[0 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+          UNDIR_DATA (edges[1 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+          UNDIR_DATA (edges[2 * npoints + i]) = make_edge_info (true,  true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+        }
+    }
 
   poly_Free (&outline);
