Bottom: 320435433d37691efad653993473a90a756d844a
Top:    a7c7761df93956fa6c67f93177738f44433c3a41
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-21 13:37:58 +0000

Refresh of fix-polygon-hairline-handling

---

diff --git a/src/polyarea.h b/src/polyarea.h
index d255863..6f0f6b0 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -77,6 +77,7 @@ struct CVCList
     VNODE *parent;
     CVCList *prev, *next, *head;
     char poly, side;
+    bool skip_me;
 };
 struct VNODE
 {
diff --git a/src/polygon1.c b/src/polygon1.c
index aaa8c96..2f2ee7a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -110,12 +110,12 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 
 #define error(code)  longjmp(*(e), code)
 
-#undef DEBUG_LABEL
-#undef DEBUG_ALL_LABELS
-#undef DEBUG_JUMP
-#undef DEBUG_GATHER
-#undef DEBUG_ANGLE
-#undef DEBUG
+#define DEBUG_LABEL
+#define DEBUG_ALL_LABELS
+#define DEBUG_JUMP
+#define DEBUG_GATHER
+#define DEBUG_ANGLE
+#define DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -236,6 +236,7 @@ new_descriptor (VNODE * a, char poly, char side)
   l->poly = poly;
   l->side = side;
   l->next = l->prev = l;
+  l->skip_me = false;
   if (side == 'P')		/* previous */
     vect_sub (v, PREV_VERTEX (a)->point, a->point);
   else				/* next */
@@ -421,6 +422,56 @@ node_add_single_point (VNODE * a, Vector p)
   return new_node;
 }				/* node_add_point */
 
+
+/* \brief Find the previous valid CVCList entry belonging to the next polygon
+ *
+ * Skips over any edges which have the "skip_me" flag set, as those
+ * will be from hairline edge pairs which are not considered in the
+ * labeling code (note, they can only ever be started from - ie..
+ * start->skip_me can legitimately be true).
+ *
+ * \c NULL if no valid edge from the other polygon was found
+ */
+static CVCList *
+prev_cvc_from_other_poly (CVCList *start)
+{
+  char this_poly = start->poly;
+  CVCList *l = start;
+
+  while ((l->poly == this_poly || l->skip_me) && l != start->next)
+    l = l->prev;
+
+  if (l->poly == this_poly || l->skip_me)
+    return NULL;
+
+  return l;
+}
+
+
+/* \brief Find the next valid CVCList entry belonging to the next polygon
+ *
+ * Skips over any edges which have the "skip_me" flag set, as those
+ * will be from hairline edge pairs which are not considered in the
+ * labeling code (note, they can only ever be started from - ie..
+ * start->skip_me can legitimately be true).
+ *
+ * \c NULL if no valid edge from the other polygon was found
+ */
+static CVCList *
+next_cvc_from_other_poly (CVCList *start)
+{
+  char this_poly = start->poly;
+  CVCList *l = start;
+
+  while ((l->poly == this_poly || l->skip_me) && l != start->prev)
+    l = l->next;
+
+  if (l->poly == this_poly || l->skip_me)
+    return NULL;
+
+  return l;
+}
+
 /*
 edge_label
  (C) 2006 harry eaton
@@ -430,7 +481,7 @@ edge_label
 static unsigned int
 edge_label (VNODE * pn, int existing_label)
 {
-  CVCList *first_l, *l;
+  CVCList *first_l, *l, *test;
   char this_poly;
   int region;
   bool shared_edge_case = false;
@@ -449,30 +500,36 @@ edge_label (VNODE * pn, int existing_label)
   this_poly = l->poly;
 
   /* Shared edges can be sorted in either order, so need to check l->prev as well */
-  if (compare_cvc_nodes (l, l->prev) == 0)
+  test = prev_cvc_from_other_poly (l);
+
+  if (test == NULL)
+    {
+      /* Didn't find anything from the other polygon, this is a point where
+       * contours from the same polygon join, e.g. either end of a shared
+       * edge generated during intersection. Treat as if it were not cross-
+       * connected, by labeling with the current label.
+       */
+      region = existing_label;
+      LABEL_EDGE (pn, region);
+      return region;
+    }
+
+  if (compare_cvc_nodes (l, test) == 0)
     {
       shared_edge_case = true;
-      l = l->prev;
+      l = test;
     }
   else
     {
-      if (compare_cvc_nodes (l, l->next) == 0)
+      test = next_cvc_from_other_poly (l);
+      if (compare_cvc_nodes (l, test) == 0)
         shared_edge_case = true;
 
-      /* Both the shared with next, or general non-shared cases need l = l->next */
-      l = l->next;
+      l = test;
     }
 
   if (shared_edge_case)
     {
-      /* Should be the shared edge case.. but we will make a few checks to be sure! */
-
-      /* If this fires, we found a hairline edge pair within our own polygon, as no edge
-       * from the same polygon should compare identically in the CVCList
-       */
-      if (!(l->poly != this_poly))
-        g_critical ("Encountered edge from our polygon when expecting a shared edge");
-
       /* If this fires, we found two geometrically distinct edges which for some reason compare as equal in our cvc_list.
        * Shared edges should be geometrically identical (but may be in opposite directions).
        */
@@ -488,53 +545,6 @@ edge_label (VNODE * pn, int existing_label)
     }
   else
     {
-      first_l = l;
-      /* Skip edges unil we find one from the next polygon */
-      while ((l->poly == this_poly) && (l != first_l->prev))
-        {
-          /* Check for hairline pairs of edges in the CVCList, they may be sorted in incorrect order,
-           * and would thus mislead as to whether we are inside or outside a given contour. It is a
-           * bug if such edges are present, so test for it here where we may detect it. We compare
-           * l->prev and l, as we know both are still in this_poly.. l->next may not be.
-           */
-          if (!(compare_cvc_nodes (l->prev, l) != 0))
-            {
-              if (vect_equal (EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->prev->parent, l->prev->side), l->prev->side)->point,
-                              EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->      parent, l->      side), l->      side)->point))
-                g_critical ("Encountered identical edge in our own polygon (hairline edge pair)");
-              else
-                g_critical ("Encountered ambiguous edge in our own polygon (by compare_cvc_nodes), but geometry of each edge is different!");
-            }
-
-          l = l->next;
-        }
-
-      /* If this fires, we must have wrapped around the entire CVCList wihthout finding any edges from
-       * the other polygon.
-       */
-      if (!(l->poly != this_poly))
-        {
-          g_warning ("Wrapped around entire CVCList without finding any edges from the other polygon");
-          /* This is now an expected condition for some cases where we deleted hairline edge pairs */
-          region = existing_label;
-          LABEL_EDGE (pn, region);
-          return region;
-        }
-
-      /* Check the other polygon edge we landed on in the CVCList is not a hairline edge pair
-       * from the same polygon. If so, they may be sorted in incorrect order and would thus
-       * mislead as to whether we are inside or outside that contour. It is a bug if such edges
-       * are present.
-       */
-      if (!((l->poly != l->next->poly || compare_cvc_nodes (l, l->next) != 0)))
-        {
-          if (vect_equal (EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->      parent, l->      side), l->      side)->point,
-                          EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->next->parent, l->next->side), l->next->side)->point))
-            g_critical ("Encountered identical edge in the other polygon (hairline edge pair)");
-          else
-            g_critical ("Encountered ambiguous edge in the other polygon (by compare_cvc_nodes), but geometry of each edge is different!");
-        }
-
       region = (l->side == 'P') ? INSIDE : OUTSIDE;
     }
 
@@ -1480,7 +1490,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
       pa_info = (struct polyarea_info *) heap_remove_smallest (heap);
       if (heap_is_empty (heap))
 	{			/* only one possibility it must be the right one */
-	  assert (poly_ContourInContour (pa_info->pa->contours, curh));
+//	  assert (poly_ContourInContour (pa_info->pa->contours, curh));
 	  container = pa_info->pa->contours;
 	}
       else
@@ -2398,14 +2408,14 @@ add_dummy_descriptors_at_point_from_pline (Vector point, PLINE * pl, char poly,
         {
           count++;
           if (node->cvc_prev == NULL &&
-              !VERTEX_BACKWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
+1)//              !VERTEX_BACKWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
             {
               prev_count++;
               list = node->cvc_prev = insert_descriptor (node, poly, 'P', list);
               g_return_val_if_fail (node->cvc_prev != NULL, NULL);
             }
           if (node->cvc_next == NULL &&
-              !VERTEX_FORWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
+1)//              !VERTEX_FORWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
             {
               next_count++;
               list = node->cvc_next = insert_descriptor (node, poly, 'N', list);
@@ -2419,7 +2429,7 @@ add_dummy_descriptors_at_point_from_pline (Vector point, PLINE * pl, char poly,
 }
 
 static void
-add_dummy_descriptors_at_point (Vector point, PLINE * pl, char poly, CVCList * list, POLYAREA *bfst)
+add_dummy_descriptors_at_point (Vector point, char poly, CVCList * list, POLYAREA *bfst)
 {
   POLYAREA *b = bfst;
   PLINE *cur;
@@ -2451,6 +2461,10 @@ remove_cvc_list_entry (CVCList *l)
   if (l == NULL)
     return;
 
+  l->skip_me = true;
+
+  return;
+
   last_at_vertex = (l->prev == l || l->next == l); /* XXX: Are these conditions equivalent for the last in list case? */
 
   if (l->side == 'P')
@@ -2815,7 +2829,7 @@ PLINE_check_hairline_edges (CVCList *the_list, PLINE *contour, POLYAREA *bfst)
 
               fprintf (stderr, "Dumping CVC list prior to adding our new nodes\n");
               cvc_list_dump (find_cvc_at_point (the_list, point));
-              add_dummy_descriptors_at_point (point_v->point, contour, first_l->poly, l, bfst); /* Picking 'l' for an arbitrary start CVCList */
+              add_dummy_descriptors_at_point (point_v->point, first_l->poly, l, bfst); /* Picking 'l' for an arbitrary start CVCList */
               fprintf (stderr, "Dumping CVC list after adding our new nodes\n");
               cvc_list_dump (find_cvc_at_point (the_list, point));
 
@@ -2898,6 +2912,7 @@ M_POLYAREA_check_hairline_edges (CVCList *the_list, POLYAREA *bfst)
   while ((b = b->f) != bfst);
 }
 
+
 /* determine if two polygons touch or overlap */
 BOOLp
 Touching (POLYAREA * a, POLYAREA * b)
@@ -3034,8 +3049,10 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
 
+#if 1
       M_POLYAREA_check_hairline_edges (the_list, a);
       M_POLYAREA_check_hairline_edges (the_list, b);
+#endif
 
 #if 0
       /* Second pass gives us a chance to catch any bad-geometry hairlines we convert by inserting nodes */
@@ -3079,7 +3096,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
     }
 
 out:
-  assert (!*res || poly_Valid (*res));
+//  assert (!*res || poly_Valid (*res));
 
   /* Store perantage information */
   if (*res != NULL)
