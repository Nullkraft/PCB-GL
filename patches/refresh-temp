Bottom: 787faa1d08643eb92c29f5b653ad73f9d69885fa
Top:    029b416e5f4fedb78e2cd29301672da1875e343c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-18 15:54:27 +0000

Refresh of well-on-the-way-to-completely

---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index c67fa95..23e335e 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -17,7 +17,7 @@ make_edge_info (void)
 }
 
 void
-edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius)
+edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius)
 {
   info->is_round = true;
   info->cx = cx;
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 696ace3..38fd6c1 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -5,13 +5,13 @@ typedef struct
 
   /* For circular curves */
   bool is_round;
-  float cx;
-  float cy;
-  float cz;
-  float nx;
-  float ny;
-  float nz;
-  float radius;
+  double cx;
+  double cy;
+  double cz;
+  double nx;
+  double ny;
+  double nz;
+  double radius;
 
   /* STEP crap - to hell with encapsulation */
   step_id infinite_line_identifier;
@@ -19,6 +19,6 @@ typedef struct
 } edge_info;
 
 edge_info *make_edge_info (void);
-void edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius);
+void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index 0f9f327..13d7501 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -38,7 +38,7 @@ face3d_set_appearance (face3d *face, appearance *appear)
 }
 
 void
-face3d_set_normal (face3d *face, float nx, float ny, float nz)
+face3d_set_normal (face3d *face, double nx, double ny, double nz)
 {
   face->nx = nx;
   face->ny = ny;
@@ -46,7 +46,7 @@ face3d_set_normal (face3d *face, float nx, float ny, float nz)
 }
 
 void
-face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius)
+face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius)
 {
   face->is_cylindrical = true;
   face->cx = cx;
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 44f6e88..0998a22 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,12 +1,12 @@
 typedef struct {
-  float nx, ny, nz; /* Face normal?*/
+  double nx, ny, nz; /* Face normal?*/
   GList *contours;
 
   /* For cylindrical surfaces */
   bool is_cylindrical;
-  float cx, cy, cz; /* A point on the axis */
-  float ax, ay, az; /* Direction of the axis */
-  float radius;
+  double cx, cy, cz; /* A point on the axis */
+  double ax, ay, az; /* Direction of the axis */
+  double radius;
 
   appearance *appear;
 
@@ -21,6 +21,6 @@ face3d *make_face3d (void);
 void destroy_face3d (face3d *face);
 void face3d_add_contour (face3d *face, contour3d *contour);
 void face3d_set_appearance (face3d *face, appearance *appear);
-void face3d_set_normal (face3d *face, float nx, float ny, float nz);
-void face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius);
+void face3d_set_normal (face3d *face, double nx, double ny, double nz);
+void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
 void face3d_set_surface_orientation_reversed (face3d *face);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 704540b..f51a0be 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -16,6 +16,30 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -93,7 +117,7 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -129,12 +153,12 @@ draw_quad_edge (edge_ref e, void *data)
       glBegin (GL_LINES);
       for (i = 0; i < CIRC_SEGS; i++) {
         /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
       }
       glEnd ();
       return;
@@ -142,8 +166,12 @@ draw_quad_edge (edge_ref e, void *data)
   }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -175,7 +203,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -187,8 +215,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -198,291 +226,6 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
     n--;
   }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
-}
-
-GList *
-object3d_from_board_outline (void)
-{
-  GList *board_objects = NULL;
-  object3d *board_object;
-  appearance *board_appearance;
-  appearance *top_bot_appearance;
-  POLYAREA *board_outline;
-  POLYAREA *pa;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  face3d **faces;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  board_outline = board_outline_poly (true);
-
-  /* Loop over all board outline pieces */
-  pa = board_outline;
-  do {
-
-    contour = pa->contours;
-    ncontours = 0;
-    npoints = 0;
-
-    ct = contour;
-    while (ct != NULL) {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    board_object = make_object3d (PCB->Name);
-    board_appearance = make_appearance ();
-    top_bot_appearance = make_appearance ();
-    appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-    appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-    object3d_set_appearance (board_object, board_appearance);
-
-    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
-    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
-    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
-
-    /* Define the vertices */
-    ct = contour;
-    offset_in_ct = 0;
-    ct_npoints = get_contour_npoints (ct);
-
-    for (i = 0; i < npoints; i++, offset_in_ct++) {
-      double x1, y1;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints) {
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-      }
-
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-      object3d_add_vertex (board_object, vertices[i]);
-      object3d_add_vertex (board_object, vertices[npoints + i]);
-    }
-
-    /* Define the edges */
-    for (i = 0; i < 3 * npoints; i++) {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (board_object, edges[i]);
-    }
-
-    /* Define the faces */
-    for (i = 0; i < npoints; i++) {
-      faces[i] = make_face3d ();
-
-      object3d_add_face (board_object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-    }
-
-    faces[npoints] = make_face3d (); /* bottom_face */
-    face3d_set_normal (faces[npoints], 0., 0., -1.);
-    face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (board_object, faces[npoints]);
-
-    faces[npoints + 1] = make_face3d (); /* top_face */
-    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-    object3d_add_face (board_object, faces[npoints + 1]);
-
-    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-    ct = contour;
-    start_of_ct = 0;
-    offset_in_ct = 0;
-    ct_npoints = get_contour_npoints (ct);
-
-    for (i = 0; i < npoints; i++, offset_in_ct++) {
-      int next_i_around_ct;
-      int prev_i_around_ct;
-
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints) {
-        start_of_ct = i;
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-
-        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-      }
-
-      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-      /* Define the (non-normalized) face normal to point to the outside of the contour */
-      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[              i]) = vertices[0 * npoints + i];
-      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-      if (ct->is_round) {
-
-        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                          COORD_TO_MM (ct->radius));
-        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
-        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-      }
-
-    }
-
-    if (1) {
-      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
-
-      edge_ref cylinder_edges[3];
-      vertex3d *cylinder_vertices[2];
-      face3d *cylinder_faces[2];
-
-      /* Edge on top of board */
-      cylinder_edges[0] = make_edge ();
-      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
-      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                           45., 45., 0., /* Center of circle */
-                            0.,  0., 1., /* Normal */
-                            5.);         /* Radius */
-      object3d_add_edge (board_object, cylinder_edges[0]);
-
-      /* Edge on top of cylinder */
-      cylinder_edges[1] = make_edge ();
-      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                           45., 45., 10., /* Center of circle */
-                            0.,  0., 1.,  /* Normal */
-                            5.);          /* Radius */
-      object3d_add_edge (board_object, cylinder_edges[1]);
-
-      /* Edge stitching cylinder */
-      cylinder_edges[2] = make_edge ();
-      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-      object3d_add_edge (board_object, cylinder_edges[2]);
-
-      /* Vertex on board top surface */
-      cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
-      object3d_add_vertex (board_object, cylinder_vertices[0]);
-
-      /* Vertex on cylinder top surface */
-      cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
-      object3d_add_vertex (board_object, cylinder_vertices[1]);
-
-      /* Cylindrical face */
-      cylinder_faces[0] = make_face3d ();
-      face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,            /* Direction of the cylindrical axis */
-                                        5.);                   /* Radius of cylinder */
-      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-      object3d_add_face (board_object, cylinder_faces[0]);
-      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-      /* Top face of cylinder */
-      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-      object3d_add_face (board_object, cylinder_faces[1]);
-      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-      /* Splice onto board */
-      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-      LDATA (cylinder_edges[0]) = cylinder_faces[0];
-      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-      LDATA (cylinder_edges[1]) = cylinder_faces[1];
-      RDATA (cylinder_edges[1]) = cylinder_faces[0];
-      LDATA (cylinder_edges[2]) = cylinder_faces[0];
-      RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-      /* Splice things together.... */
-
-      /* Link edges orbiting the cylinder bottom vertex */
-      splice (cylinder_edges[0], cylinder_edges[2]);
-      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-      /* Link edges orbiting the cylinder top vertex */
-      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-    }
-
-    board_objects = g_list_append (board_objects, board_object);
-
-  } while (pa = pa->f, pa != board_outline);
-
-  poly_Free (&board_outline);
-
-  return board_objects;
-}
-
-void
-object3d_test_board_outline (void)
-{
-  GList *board_outlines;
-
-  board_outlines = object3d_from_board_outline ();
-  object3d_export_to_step (board_outlines->data, "object3d_test.step");
-
-  g_list_free_full (board_outlines, (GDestroyNotify)destroy_object3d);
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
diff --git a/src/hid/common/vertex3d.c b/src/hid/common/vertex3d.c
index ff3ab98..cf20fb2 100644
--- a/src/hid/common/vertex3d.c
+++ b/src/hid/common/vertex3d.c
@@ -9,7 +9,7 @@
 static int global_vertex3d_count;
 
 vertex3d *
-make_vertex3d (float x, float y, float z)
+make_vertex3d (double x, double y, double z)
 {
   vertex3d *v;
 
diff --git a/src/hid/common/vertex3d.h b/src/hid/common/vertex3d.h
index a150934..cad586d 100644
--- a/src/hid/common/vertex3d.h
+++ b/src/hid/common/vertex3d.h
@@ -1,13 +1,13 @@
 typedef struct
 {
-  float x;
-  float y;
-  float z;
+  double x;
+  double y;
+  double z;
   int id;
 
   /* STEP crap - to hell with encapsulation */
   step_id vertex_identifier;
 } vertex3d;
 
-vertex3d *make_vertex3d (float x, float y, float z);
+vertex3d *make_vertex3d (double x, double y, double z);
 void destroy_vertex3d (vertex3d *v);
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 0a04ea0..33a3d4a 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -144,7 +144,7 @@ step_vertex_point (step_file *file, char *name, step_id pnt)
 step_id
 step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense)
 {
-  fprintf (file->f, "#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ;\n",
+  fprintf (file->f, "\n#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ; ",
                     file->next_id, name, edge_start, edge_end, edge_geometry, step_bool (same_sense));
   return file->next_id++;
 }
@@ -152,7 +152,7 @@ step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_e
 step_id
 step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation)
 {
-  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ; ",
                     file->next_id, name, edge_element, step_bool (orientation));
   return file->next_id++;
 }
@@ -171,7 +171,7 @@ step_edge_loop (step_file *file, char *name, step_id_list edge_list)
 step_id
 step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
 {
-  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ; ",
                     file->next_id, name, bound, step_bool (orientation));
 
   return file->next_id++;
@@ -191,7 +191,7 @@ step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id fa
 {
   fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, bounds);
-  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
   destroy_step_id_list (bounds);
 
   return file->next_id++;
