Bottom: 369725aaf1f321e7c7f077051ae8ac7e75189e8b
Top:    13aa7e73e70281e7b96c02ff40061a04e4398bdc
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-31 14:43:58 +0000

Refresh of fix-ellipse-sampling

---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index 026fc9f..11ab47b 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -165,7 +165,7 @@ sample_ellipse (edge_ref e)
   double cosa;
   double sina;
   double recip_length;
-  double sa;
+  double sa, ea;
   double da;
   int segs;
   double angle_step;
@@ -197,29 +197,22 @@ sample_ellipse (edge_ref e)
       nz = -nz;
     }
 
-  startx = x1 - cx;
-  starty = y1 - cy;
-  startz = z1 - cz;
-
-  /* Normalise startx */
-  recip_length = 1. / hypot (hypot (startx, starty), startz);
-  startx *= recip_length;
-  starty *= recip_length;
-  startz *= recip_length;
-
-
-  /* Find start angle (w.r.t. ellipse parameterisation */
-
-  /* start cross normal */
   /* ort will be orthogonal to normal and r vector */
   ortx = ny * rz - nz * ry;
   orty = nz * rx - nx * rz;
   ortz = nx * ry - ny * rx;
 
+
+  /* Find start angle (w.r.t. ellipse parameterisation */
+
+  startx = x1 - cx;
+  starty = y1 - cy;
+  startz = z1 - cz;
+
   /* Cosine is dot product of start (normalised) and start (normalised) */
-  cosa = rx * startx + ry * starty + rz * startz; // cos (phi)
+  cosa = (rx * startx + ry * starty + rz * startz) / info->radius; // cos (phi)
   /* Sine is dot product of ort (normalised) and start (normalised) */
-  sina = ortx * startx + orty * starty + ortz * startz; // sin (phi) = cos (phi - 90)
+  sina = (ortx * startx + orty * starty + ortz * startz) / info->radius2; // sin (phi) = cos (phi - 90)
 
   /* Start angle */
   sa = atan2 (sina, cosa);
@@ -227,28 +220,22 @@ sample_ellipse (edge_ref e)
   if (sa < 0.0)
     sa += 2.0 * M_PI;
 
+  /* Find end angle (w.r.t ellipse parameterisation) */
+
   endx = x2 - cx;
   endy = y2 - cy;
   endz = z2 - cz;
 
-  /* Normalise endx */
-  recip_length = 1. / hypot (hypot (endx, endy), endz);
-  endx *= recip_length;
-  endy *= recip_length;
-  endz *= recip_length;
-
-  /* Find delta angle */
-
-  /* start cross normal */
-  /* ort will be orthogonal to normal and start vector */
-  ortx = ny * startz - nz * starty;
-  orty = nz * startx - nx * startz;
-  ortz = nx * starty - ny * startx;
-
   /* Cosine is dot product of start (normalised) and end (normalised) */
-  cosa = startx * endx + starty * endy + startz * endz; // cos (phi)
+  cosa = (rx * endx + ry * endy + rz * endz) / info->radius; // cos (phi)
   /* Sine is dot product of ort (normalised) and end (normalised) */
-  sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+  sina = (ortx * endx + orty * endy + ortz * endz) / info->radius2; // sin (phi) = cos (phi - 90)
+
+  /* Start angle */
+  ea = atan2 (sina, cosa);
+
+  if (ea < 0.0)
+    ea += 2.0 * M_PI;
 
   if (x1 == x2 &&
       y1 == y2 &&
@@ -258,8 +245,7 @@ sample_ellipse (edge_ref e)
     }
   else
     {
-      /* Delta angled */
-      da = atan2 (sina, cosa);
+      da = ea - sa;
 
       if (da < 0.0)
         da += 2.0 * M_PI;
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
index 3b93861..eb5dbb5 100644
--- a/src/hid/common/object3d_gl.c
+++ b/src/hid/common/object3d_gl.c
@@ -116,6 +116,7 @@ object3d_test_init (void)
   object_default_edge_appearance = make_appearance();
   appearance_set_color (object_default_edge_appearance, 0.0f, 0.0f, 0.0f); /* 1.0f */
   appearance_set_alpha (object_default_edge_appearance, 1.0f);
+//  appearance_set_color (object_default_edge_appearance, 1.0f, 0.0f, 1.0f); /* 1.0f */
 //  appearance_set_color (object_default_edge_appearance, 1.0f, 1.0f, 1.0f); /* 1.0f */
 //  appearance_set_alpha (object_default_edge_appearance, 0.3f);
 
@@ -210,7 +211,7 @@ draw_quad_edge (edge_ref e, void *data)
       (info->is_placeholder ||
       d_info->debug_face))
     {
-//      glColor4f (1.0, 0.0, 0.0, 1.0);
+      glColor4f (1.0, 0.0, 0.0, 1.0);
       glDepthMask (TRUE);
       glDisable(GL_DEPTH_TEST);
     }
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 588f3c1..2a4b992 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -1084,21 +1084,14 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
 
           SdaiAxis2_placement_3d *placement = *circle->position_ ();
           unpack_axis_geom (placement, &cx, &cy, &cz, &nx, &ny, &nz, &rx, &ry, &rz);
-#if 0
-          double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
-          double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-          double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-          double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-          double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-          double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-#endif
 
           double radius = circle->radius_();
 
-          transform_vertex (info->current_transform, &cx, &cy, &cz);
           transform_vertex (info->current_transform, &x1, &y1, &z1);
           transform_vertex (info->current_transform, &x2, &y2, &z2);
 
+          transform_vertex (info->current_transform, &cx, &cy, &cz);
+          transform_vector (info->current_transform, &rx, &ry, &rz);
           transform_vector (info->current_transform, &nx, &ny, &nz);
 
           if (orientation) // NOT REQUIRED, SINCE WE ADDED same_sense to the edge info ----> (orientation == same_sense)
@@ -1126,27 +1119,19 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
 
           SdaiAxis2_placement_3d *placement = *ellipse->position_ ();
           unpack_axis_geom (placement, &cx, &cy, &cz, &nx, &ny, &nz, &rx, &ry, &rz);
-#if 0
-          double cx = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
-          double cy = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-          double cz = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-          double nx = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-          double ny = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-          double nz = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-#endif
 
           transform_vertex (info->current_transform, &x1, &y1, &z1);
           transform_vertex (info->current_transform, &x2, &y2, &z2);
 
+          transform_vertex (info->current_transform, &cx, &cy, &cz);
+          transform_vector (info->current_transform, &rx, &ry, &rz);
+          transform_vector (info->current_transform, &nx, &ny, &nz);
+
           our_edge_info->is_ellipse = true;
 
           double radius1 = ellipse->semi_axis_1_ ();
           double radius2 = ellipse->semi_axis_2_ ();
 
-          transform_vertex (info->current_transform, &cx, &cy, &cz);
-
-          transform_vector (info->current_transform, &nx, &ny, &nz);
-
           if (orientation) // NOT REQUIRED, SINCE WE ADDED same_sense to the edge info ----> (orientation == same_sense)
             {
               edge_info_set_round2 (our_edge_info, cx, cy, cz, nx, ny, nz, rx, ry, rz, radius1);
@@ -1156,6 +1141,7 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
               edge_info_set_round2 (our_edge_info, cx, cy, cz, -nx, -ny, -nz, rx, ry, rz, radius1);
             }
           our_edge_info->radius2 = radius2;
+          our_edge_info->is_round = false; /* NB: set_round* makes us a circle.. this cancels it! */
 
           object3d_add_edge (info->object, our_edge);
           vertex = make_vertex3d (x1, y1, z1);
