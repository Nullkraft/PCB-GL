Bottom: b66ba603fd863d4c13a7b57a7159f93ff96d65d1
Top:    a55eaa117d55814a8072e877a074975d5c3c5d0f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-13 22:30:23 +0000

Refresh of more-changes

---

diff --git a/src/polygon1.c b/src/polygon1.c
index d4ec9ae..c0aab81 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1072,7 +1072,7 @@ vertex_in_seg_rounded (const BoxType * b, void *cl)
     longjmp (*i->touch, TOUCHES);
 
 //  i->s->p->Flags.status = ISECTED; /* XXX */
-  s->p->Flags.status = ISECTED;
+//  s->p->Flags.status = ISECTED;
 
   new_node = node_add_single_point (s->v, i->v->point);
   if (new_node != NULL)
@@ -1377,15 +1377,57 @@ static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add, CVCList **list_out)
 {
   POLYAREA *a = afst, *b = bfst;
+  POLYAREA *a2, *b2;
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
   if (a == NULL || b == NULL)
     error (err_bad_parm);
 
-  if (1)
+  if (add)
     {
 #if 1
+      /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+      do
+        {
+          a2 = a->f;
+          for (a2 = a->f; a2 != a; a2 = a2->f)
+            {
+              if (a->contours->xmax >= a2->contours->xmin &&
+                  a->contours->ymax >= a2->contours->ymin &&
+                  a->contours->xmin <= a2->contours->xmax &&
+                  a->contours->ymin <= a2->contours->ymax)
+                {
+                  intersect_rounded (e, a, a2, true);
+                }
+            }
+          while (add && (a = a->f) != afst);
+        }
+      while ((a = a->f) != afst);
+
+#endif
+    }
+
+#if 1
+      /* Intersect all a outer contours against all other piece outer + inner contours (and vice-versa) */
+      do
+        {
+          b2 = b->f;
+          for (b2 = b->f; b2 != b; b2 = b2->f)
+            {
+              if (b->contours->xmax >= b2->contours->xmin &&
+                  b->contours->ymax >= b2->contours->ymin &&
+                  b->contours->xmin <= b2->contours->xmax &&
+                  b->contours->ymin <= b2->contours->ymax)
+                {
+                  intersect_rounded (e, b, b2, true);
+                }
+            }
+        }
+      while ((b = b->f) != bfst);
+#endif
+
+#if 0
       do
         {
           do
@@ -1603,7 +1645,7 @@ label_contour (PLINE * a)
         }
       else
         {
-          g_warning ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
+          g_info ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
           /* Head was marked, so presumably the entire contour is either SHARED or SHARED2 */
         }
     }
@@ -2192,7 +2234,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir, char **
 
   if (*contour_name != NULL)
     {
-      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
+//      fprintf (stderr, "Setting contour name on intersected contour as %s\n", *contour_name);
       (*result)->name = strdup (*contour_name);
     }
 
@@ -2480,8 +2522,8 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
 	  int is_first = contour_is_first (a, curc);
 	  int is_last = contour_is_last (curc);
 	  int isect_contour = (curc->Flags.status == ISECTED);
-          if (isect_contour && curc->name != NULL)
-            printf ("A contour with name %s was ISECTED\n", curc->name);
+//          if (isect_contour && curc->name != NULL)
+//            printf ("A contour with name %s was ISECTED\n", curc->name);
 
 	  next = curc->next;
 
@@ -3367,6 +3409,10 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
 
+      /* XXX - Need to loop the intersection routines until the geometry stabalises???
+       */
+//      M_POLYAREA_intersect (&e, a, b, TRUE, &the_list);
+
 #if 1
       M_POLYAREA_check_hairline_edges (the_list, a);
       M_POLYAREA_check_hairline_edges (the_list, b);
