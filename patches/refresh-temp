Bottom: 74238d321f28dce56ea540080f9a1df37f3d9693
Top:    9ce5c0d51b6c6c63b972c68f3a90bf5e68ae1df1
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 22:15:42 +0000

Refresh of extend-object3d_from_contours

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index c95b6bb..8fb24ef 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -548,12 +548,12 @@ object3d_from_contours (const POLYAREA *contours,
                                                   0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
                                                   radius);
 
-               /* NOTE: Surface orientation is only fixed up during emission if we flag the need here..
-                *       cylindrical surface orientation is always pointing outward from its axis, so
-                *       orientation reversed is used for holes
-                */
-               /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! - THIS IS NOT EXACTLY CORRECT!.. NEEDS TO TAKE ACOUNT FOR cw / ccw WHEN DEALING WITH ARC CONTOUR SEGMENTS */
-               if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
+                /* NOTE: Surface orientation is only fixed up during emission if we flag the need here..
+                 *       cylindrical surface orientation is always pointing outward from its axis, so
+                 *       orientation reversed is used for holes
+                 */
+                /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! - THIS IS NOT EXACTLY CORRECT!.. NEEDS TO TAKE ACOUNT FOR cw / ccw WHEN DEALING WITH ARC CONTOUR SEGMENTS */
+                if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
                   face3d_set_surface_orientation_reversed (faces[i]);
 
                 face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
@@ -619,149 +619,149 @@ object3d_from_contours (const POLYAREA *contours,
               }
           }
 
-      if (0)
-        {
-          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+        if (0)
+          {
+            /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
-          edge_ref cylinder_edges[3];
-          vertex3d *cylinder_vertices[2];
-          face3d *cylinder_faces[2];
+            edge_ref cylinder_edges[3];
+            vertex3d *cylinder_vertices[2];
+            face3d *cylinder_faces[2];
 
-          /* Edge on top of board */
-          cylinder_edges[0] = make_edge ();
-          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+            /* Edge on top of board */
+            cylinder_edges[0] = make_edge ();
+            UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 #ifdef REVERSED_PCB_CONTOURS
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                0.,   0., 1., /* Normal */
-                                5.);          /* Radius */
+            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                  0.,   0., 1., /* Normal */
+                                  5.);          /* Radius */
 #else
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                0.,   0., 1., /* Normal */
-                                5.);         /* Radius */
+            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                  0.,   0., 1., /* Normal */
+                                  5.);         /* Radius */
 #endif
-          object3d_add_edge (object, cylinder_edges[0]);
-
-          /* Edge on top of cylinder */
-          cylinder_edges[1] = make_edge ();
-          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
-                                0.,   0., 1.,  /* Normal */
-                                5.);          /* Radius */
-          object3d_add_edge (object, cylinder_edges[1]);
-
-          /* Edge stitching cylinder */
-          cylinder_edges[2] = make_edge ();
-          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-          object3d_add_edge (object, cylinder_edges[2]);
-
-          /* Vertex on board top surface */
-          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-          object3d_add_vertex (object, cylinder_vertices[0]);
-
-          /* Vertex on cylinder top surface */
-          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-          object3d_add_vertex (object, cylinder_vertices[1]);
-
-          /* Cylindrical face */
-          cylinder_faces[0] = make_face3d ();
-          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,             /* Direction of the cylindrical axis */
-                                            5.);                   /* Radius of cylinder */
-          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-          object3d_add_face (object, cylinder_faces[0]);
-          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-          /* Top face of cylinder */
-          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-          object3d_add_face (object, cylinder_faces[1]);
-          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-          /* Splice onto board */
-          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-          /* Assign the appropriate vertex geometric data to each edge end */
-          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-          LDATA (cylinder_edges[0]) = cylinder_faces[0];
-          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-          LDATA (cylinder_edges[1]) = cylinder_faces[1];
-          RDATA (cylinder_edges[1]) = cylinder_faces[0];
-          LDATA (cylinder_edges[2]) = cylinder_faces[0];
-          RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-          /* Splice things together.... */
-
-          /* Link edges orbiting the cylinder bottom vertex */
-          splice (cylinder_edges[0], cylinder_edges[2]);
-          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-          /* Link edges orbiting the cylinder top vertex */
-          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-        }
+            object3d_add_edge (object, cylinder_edges[0]);
+
+            /* Edge on top of cylinder */
+            cylinder_edges[1] = make_edge ();
+            UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+            edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                                  0.,   0., 1.,  /* Normal */
+                                  5.);          /* Radius */
+            object3d_add_edge (object, cylinder_edges[1]);
+
+            /* Edge stitching cylinder */
+            cylinder_edges[2] = make_edge ();
+            UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+            edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+            object3d_add_edge (object, cylinder_edges[2]);
+
+            /* Vertex on board top surface */
+            cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+            object3d_add_vertex (object, cylinder_vertices[0]);
+
+            /* Vertex on cylinder top surface */
+            cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+            object3d_add_vertex (object, cylinder_vertices[1]);
+
+            /* Cylindrical face */
+            cylinder_faces[0] = make_face3d ();
+            face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                              0., 0., 1.,             /* Direction of the cylindrical axis */
+                                              5.);                   /* Radius of cylinder */
+            face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                         /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+            object3d_add_face (object, cylinder_faces[0]);
+            face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+            /* Top face of cylinder */
+            cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+            face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+            face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+            object3d_add_face (object, cylinder_faces[1]);
+            face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+            /* Splice onto board */
+            face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+            /* Assign the appropriate vertex geometric data to each edge end */
+            ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+            DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+            ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+            DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+            ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+            DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+            LDATA (cylinder_edges[0]) = cylinder_faces[0];
+            RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+            LDATA (cylinder_edges[1]) = cylinder_faces[1];
+            RDATA (cylinder_edges[1]) = cylinder_faces[0];
+            LDATA (cylinder_edges[2]) = cylinder_faces[0];
+            RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+            /* Splice things together.... */
+
+            /* Link edges orbiting the cylinder bottom vertex */
+            splice (cylinder_edges[0], cylinder_edges[2]);
+            splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+            /* Link edges orbiting the cylinder top vertex */
+            splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+            splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+          }
 
 #ifndef NDEBUG
-      ct = contour;
-      start_of_ct = 0;
-      offset_in_ct = 0;
-      ct_npoints = get_contour_npoints (ct);
+        ct = contour;
+        start_of_ct = 0;
+        offset_in_ct = 0;
+        ct_npoints = get_contour_npoints (ct);
 
-      for (i = 0; i < npoints; i++, offset_in_ct++)
-        {
-          int next_i_around_ct;
-          int prev_i_around_ct;
+        for (i = 0; i < npoints; i++, offset_in_ct++)
+          {
+            int next_i_around_ct;
+            int prev_i_around_ct;
 
-          /* Update which contour we're looking at */
-          if (offset_in_ct == ct_npoints)
-            {
-              start_of_ct = i;
-              offset_in_ct = 0;
-              ct = ct->next;
-              ct_npoints = get_contour_npoints (ct);
-            }
+            /* Update which contour we're looking at */
+            if (offset_in_ct == ct_npoints)
+              {
+                start_of_ct = i;
+                offset_in_ct = 0;
+                ct = ct->next;
+                ct_npoints = get_contour_npoints (ct);
+              }
 
-          next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-          prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+            next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+            prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-          if (!extrude_inverted)
-            {
-              g_assert (RDATA (edges[              i]) == faces[i]);
-              g_assert (LDATA (edges[              i]) == faces[npoints]);
-              g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
-              g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
-              g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
-              g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
-
-              g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
-              g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
-              g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
-              g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
-              g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
-              g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
-
-              g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
-              g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
-              g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
-            }
-          else
-            {
-              /* XXX: No debug checks for this yet. LDATA and RDATA should be swapped from the
-               *      above case, and ONEXT order should be reversed. It works, so have not
-               *      written in the debug checks.
-               */
-            }
-        }
+            if (!extrude_inverted)
+              {
+                g_assert (RDATA (edges[              i]) == faces[i]);
+                g_assert (LDATA (edges[              i]) == faces[npoints]);
+                g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+                g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+                g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+                g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+                g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+                g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+                g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+                g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+                g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+                g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+                g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+                g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+                g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+              }
+            else
+              {
+                /* XXX: No debug checks for this yet. LDATA and RDATA should be swapped from the
+                 *      above case, and ONEXT order should be reversed. It works, so have not
+                 *      written in the debug checks.
+                 */
+              }
+          }
 #endif
 
       objects = g_list_append (objects, object);
