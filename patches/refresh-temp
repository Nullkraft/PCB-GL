Bottom: 41dc75f0036316f239a4d13dfe83da28a8768157
Top:    4dec3aa66e723b2f5b6d3bc0c072efc6122bd71a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-03 10:28:25 +0000

Refresh of try-from-first-principles-on

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 10caa3e..57d49a0 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -355,15 +355,15 @@ object3d_from_contours (POLYAREA *contours,
   int offset_in_ct;
   int ct_npoints;
   polygon_3d_link *link;
-  bool invert;
+  bool invert_face_normals;
   double length;
   double nx, ny;
 
-//#ifdef REVERSED_PCB_CONTOURS
-//  invert = extrude_inverted ? false : true;
-//#else
-  invert = extrude_inverted ? true : false;
-//#endif
+#ifdef REVERSED_PCB_CONTOURS
+  invert_face_normals = extrude_inverted ? false : true;
+#else
+  invert_face_normals = extrude_inverted ? true : false;
+#endif
 
   if (contours == NULL)
     return NULL;
@@ -427,8 +427,6 @@ object3d_from_contours (POLYAREA *contours,
 
       get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
 
-      fprintf (stderr, "Vertex %i at (%f, %f, %f)\n", i, x1, y1);
-
       vertices[i]           = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, zbot)); /* Bottom */
       vertices[npoints + i] = make_vertex3d (x1, y1, COORD_TO_STEP_Z (PCB, ztop)); /* Top */
 
@@ -449,7 +447,7 @@ object3d_from_contours (POLYAREA *contours,
 
       object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      if (!extrude_inverted) //invert)
+      if (!extrude_inverted)
         face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
       else
         face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
@@ -457,7 +455,7 @@ object3d_from_contours (POLYAREA *contours,
 
     faces[npoints    ] = make_face3d (); /* bottom_face */
     faces[npoints + 1] = make_face3d (); /* top_face */
-    if (invert)
+    if (invert_face_normals)
       {
         face3d_set_normal (faces[npoints    ], 0., 0., -1.); /* bottom_face */
         face3d_set_normal (faces[npoints + 1], 0., 0.,  1.); /* top_face */
@@ -473,7 +471,7 @@ object3d_from_contours (POLYAREA *contours,
     object3d_add_face (object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-    if (!extrude_inverted) //1) //(invert)
+    if (!extrude_inverted)
       {
         face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
         face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
@@ -502,7 +500,7 @@ object3d_from_contours (POLYAREA *contours,
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
         /* XXX: Haven't properly thought through how (if) inverting works with multiple contours */
-      if (!extrude_inverted)//1) //invert)
+      if (!extrude_inverted)
         {
           face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
           face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
@@ -527,7 +525,7 @@ object3d_from_contours (POLYAREA *contours,
       nx /= length;
       ny /= length;
 
-      if (invert)
+      if (invert_face_normals)
         {
           nx = -nx;
           ny = -ny;
@@ -544,113 +542,6 @@ object3d_from_contours (POLYAREA *contours,
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
       /* XXX: Do we need to differently with this for inverted contours? */
 
-      if (!extrude_inverted) //1) //(invert) // IS THIS CASE CORRECT IN ANY CASE - OR IS IT THE CRUX OF CREATING AN INVERTED CONTOUR??
-        {
-          RDATA (edges[              i]) = faces[i];
-          LDATA (edges[              i]) = faces[npoints];
-          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          LDATA (edges[1 * npoints + i]) = faces[i];
-          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          LDATA (edges[2 * npoints + i]) = faces[i];
-        }
-      else
-        {
-          LDATA (edges[              i]) = faces[i];
-          RDATA (edges[              i]) = faces[npoints];
-          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          RDATA (edges[1 * npoints + i]) = faces[i];
-          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          RDATA (edges[2 * npoints + i]) = faces[i];
-        }
-
-#if 0
-#if REVERSED_PCB_CONTOURS
-      RDATA (edges[              i]) = faces[i];
-      LDATA (edges[              i]) = faces[npoints];
-      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      LDATA (edges[1 * npoints + i]) = faces[i];
-      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      LDATA (edges[2 * npoints + i]) = faces[i];
-#else
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-#endif
-#endif
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-#if 1 //def REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
-      if (extrude_inverted)
-        {
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (edges[prev_i_around_ct], SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]), SYM(edges[i]));
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[npoints + i]), edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], edges[npoints + prev_i_around_ct]);
-        }
-      else // IS THIS CASE CORRECT IN ANY SITUATION? REVERSED CONTOURS OR NOT?
-        {
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], edges[i]);
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
-        }
-#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
-      if (extrude_inverted)
-        {
-          g_assert_not_reached (); // FOR NOW..
-
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (SYM(edges[i]), SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]), edges[prev_i_around_ct]);
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (edges[npoints + prev_i_around_ct], edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i],  SYM(edges[npoints + i]));
-        }
-      else
-        {
-#if 0
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (edges[i], edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
-#else
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (edges[2 * npoints + i]       , edges[i]              );
-          splice (SYM(edges[prev_i_around_ct]) , edges[2 * npoints + i]);
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[2 * npoints + i]) , SYM(edges[npoints + prev_i_around_ct]));
-          splice (edges[npoints + i]          , SYM(edges[2 * npoints + i])           );
-#endif
-        }
-#endif
-
-#if 0
-      g_assert (RDATA (edges[              i]) == faces[i]);
-      g_assert (LDATA (edges[              i]) == faces[npoints]);
-      g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
-      g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
-      g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
-      g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
-      g_assert (       ONEXT (edges[              i])  == SYM (edges[prev_i_around_ct]));
-      g_assert (ONEXT (ONEXT (edges[              i])) == edges[2 * npoints + i]);
-      g_assert (       ONEXT (edges[1 * npoints + i])  == SYM (edges[2 * npoints + i]));
-      g_assert (ONEXT (ONEXT (edges[1 * npoints + i])) == SYM (edges[1 * npoints + prev_i_around_ct]));
-#endif
-
       if (get_contour_edge_n_is_round (ct, offset_in_ct)) {
         double cx;
         double cy;
@@ -662,7 +553,7 @@ object3d_from_contours (POLYAREA *contours,
 
         /* AXIS DIRECTON NOT DEPEND ON WHETHER WE INVERT THE TOP/BOT CONTOUR.. THE EDGE LOOP IS APPROPRIATE ALREADY */
         face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1., /* Direction of the cylindrical axis */
+                                          0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
                                           radius);
 
         /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
@@ -670,21 +561,21 @@ object3d_from_contours (POLYAREA *contours,
          *      CYLINDRICAL SURFACE ORIENTATION IS ALWAYS POINTING OUTWARD FROM ITS AXIS, SO
          *      ORIENTATION REVERSED IS USED FOR HOLES
          */
-        if ((ct->Flags.orient == PLF_INV) == extrude_inverted)
+        if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
           face3d_set_surface_orientation_reversed (faces[i]);
 
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
-        /* DOES NOT DEPEND ON WHETHER WE INVERT THE CONTOUR.. THE EDGE TRAVERSAL IS REVERSED DURING EMISSION */
-//#ifdef REVERSED_PCB_CONTOURS
-        if (invert)
+        /* DOES NOT DEPEND ON WHETHER WE INVERT THE CONTOUR.. THE EDGE TRAVERSAL IS REVERSED DURING EMISSION.
+         * Only depends on the coordinate system transform, and what Z values it requires to create a
+         * clockwise / counterclockwise circular edge consistent with the the polygon data.
+         */
+#ifdef REVERSED_PCB_CONTOURS
           normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-//#else
-        else
-        /* XXX: NOT SURE THIS IS CORRECT! */
+#else
           normal_z = cw ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-//#endif
+#endif
 
         edge_info_set_round (UNDIR_DATA (edges[i]),
                              cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
@@ -696,8 +587,47 @@ object3d_from_contours (POLYAREA *contours,
           edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
       }
 
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
+      if (extrude_inverted)
+        {
+          LDATA (edges[              i]) = faces[i];
+          RDATA (edges[              i]) = faces[npoints];
+          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          RDATA (edges[1 * npoints + i]) = faces[i];
+          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          RDATA (edges[2 * npoints + i]) = faces[i];
+
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[i]);
+          splice (edges[i], edges[2 * npoints + i]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+        }
+      else
+        {
+          RDATA (edges[              i]) = faces[i];
+          LDATA (edges[              i]) = faces[npoints];
+          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          LDATA (edges[1 * npoints + i]) = faces[i];
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
+
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[i]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+        }
     }
 
+#ifndef NDEBUG
     ct = contour;
     start_of_ct = 0;
     offset_in_ct = 0;
@@ -719,27 +649,35 @@ object3d_from_contours (POLYAREA *contours,
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
       prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-#if 0
-      g_assert (RDATA (edges[              i]) == faces[i]);
-      g_assert (LDATA (edges[              i]) == faces[npoints]);
-      g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
-      g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
-      g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
-      g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
-
-      g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
-      g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
-      g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
-      g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
-      g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
-      g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
-
-      g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
-      g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
-      g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
-#endif
+      if (!extrude_inverted)
+        {
+          g_assert (RDATA (edges[              i]) == faces[i]);
+          g_assert (LDATA (edges[              i]) == faces[npoints]);
+          g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+          g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+          g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+          g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+          g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+          g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+          g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+          g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+          g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+          g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+          g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+          g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+          g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+        }
+      else
+        {
+          /* XXX: No debug checks for this yet. LDATA and RDATA should be swapped from the
+           *      above case, and ONEXT order should be reversed. It works, so have not
+           *      written in the debug checks.
+           */
+        }
     }
-
+#endif
 
     objects = g_list_prepend (objects, object);
 
@@ -1649,7 +1587,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 #endif
     }
 
-  if (0) //drill_m_polyarea != NULL) /* Drill holes */
+  if (drill_m_polyarea != NULL) /* Drill holes */
     {
       Coord top_depth;
       Coord bottom_depth;
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 99d259b..9b9c34a 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -245,7 +245,7 @@ object3d_to_step_body_fragment (step_file *step,
       dir_y = dv->y - ov->y;
       dir_z = dv->z - ov->z;
 
-#if 1
+#if 0
       /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
       if (dir_x < EPSILON && -dir_x < EPSILON &&
           dir_y < EPSILON && -dir_y < EPSILON &&
@@ -282,8 +282,8 @@ object3d_to_step_body_fragment (step_file *step,
     step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
 
     /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
-    //info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
-    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, !info->is_round);
+    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+    //info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, !info->is_round); /* XXX: WHY ARE OUR ROUND CONTOURS BASS-ACKWARDS? */
     step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
     step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
   }
