Bottom: 722a48430a4d1db811fa307158797393fdb49c2c
Top:    a6ec2587f3cb2c6fc4b92388c8f9f1b8ed51a9df
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 21:15:15 +0000

Refresh of attempt-to-refactor-the-step

---

diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 573a12c..1687042 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -124,144 +124,161 @@ object3d_export_to_step (object3d *object, const char *filename)
 #define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
 
   /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
-    face3d *face = face_iter->data;
-
-    if (face->is_cylindrical) {
-      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
-       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
-       */
-      face->surface_identifier =
-        step_cylindrical_surface (step, "NONE",
-                                  step_axis2_placement_3d (step, "NONE",
-                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
-                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
-                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
-                                  face->radius);
-    } else {
-      contour3d *outer_contour = face->contours->data;
-      vertex3d *ov = ODATA (outer_contour->first_edge);
-      vertex3d *dv = DDATA (outer_contour->first_edge);
-
-      face->surface_identifier =
-        step_plane (step, "NONE",
-                    step_axis2_placement_3d (step, "NONE",
-                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
-                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
-                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
-                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                   step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                 dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                 dv->z - ov->z)));      /* contour links to in the quad edge structure */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
+    {
+      face3d *face = face_iter->data;
+
+      if (face->is_cylindrical)
+        {
+          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+           * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+           */
+          face->surface_identifier =
+            step_cylindrical_surface (step, "NONE",
+                                      step_axis2_placement_3d (step, "NONE",
+                                                               step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                     step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                     step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                      face->radius);
+        }
+      else
+        {
+          contour3d *outer_contour = face->contours->data;
+          vertex3d *ov = ODATA (outer_contour->first_edge);
+          vertex3d *dv = DDATA (outer_contour->first_edge);
+
+          face->surface_identifier =
+            step_plane (step, "NONE",
+                        step_axis2_placement_3d (step, "NONE",
+                                                 step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */
+                                                                                     ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                     ov->z),     /* this contour links to in the quad edge structure. */
+                                                       step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                       step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                     dv->y - ov->y,         /* Define this to be along the first edge this */
+                                                                                     dv->z - ov->z)));      /* contour links to in the quad edge structure */
+        }
     }
-  }
 
   /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
-    edge_ref edge = (edge_ref)edge_iter->data;
-    edge_info *info = UNDIR_DATA (edge);
-
-    if (info->is_round) {
-      info->infinite_line_identifier =
-        step_circle (step, "NONE",
-                     step_axis2_placement_3d (step, "NONE",
-                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
-                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
-                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
-                                                    info->radius);
-    } else {
-      vertex3d *ov = ODATA (edge);
-      vertex3d *dv = DDATA (edge);
-
-      info->infinite_line_identifier =
-        step_line (step, "NONE",
-                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
-                   step_vector (step, "NONE",
-                                step_direction (step, "NONE", dv->x - ov->x,
-                                                              dv->y - ov->y,
-                                                              dv->z - ov->z),  // <--- Direction along the line
-                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
+    {
+      edge_ref edge = (edge_ref)edge_iter->data;
+      edge_info *info = UNDIR_DATA (edge);
+
+      if (info->is_round)
+        {
+          info->infinite_line_identifier =
+            step_circle (step, "NONE",
+                         step_axis2_placement_3d (step, "NONE",
+                                                  step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                        step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                        step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                        info->radius);
+        }
+      else
+        {
+          vertex3d *ov = ODATA (edge);
+          vertex3d *dv = DDATA (edge);
+
+          info->infinite_line_identifier =
+            step_line (step, "NONE",
+                       step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                       step_vector (step, "NONE",
+                                    step_direction (step, "NONE", dv->x - ov->x,
+                                                                  dv->y - ov->y,
+                                                                  dv->z - ov->z),  // <--- Direction along the line
+                                    1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+        }
     }
-  }
 
   /* Define the vertices */
-  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter)) {
-    vertex3d *vertex = vertex_iter->data;
+  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter))
+    {
+      vertex3d *vertex = vertex_iter->data;
 
-    vertex->vertex_identifier =
-      step_vertex_point (step, "NONE", step_cartesian_point (step, "NONE", vertex->x, vertex->y, vertex->z));
-  }
+      vertex->vertex_identifier =
+        step_vertex_point (step, "NONE", step_cartesian_point (step, "NONE", vertex->x, vertex->y, vertex->z));
+    }
 
   /* Define the Edges */
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
-    edge_ref edge = (edge_ref)edge_iter->data;
-    edge_info *info = UNDIR_DATA (edge);
-    step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
-    step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
-
-    /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
-    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
-    step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
-    step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
-  }
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
+    {
+      edge_ref edge = (edge_ref)edge_iter->data;
+      edge_info *info = UNDIR_DATA (edge);
+      step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
+      step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
+
+      /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
+      info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+      step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
+      step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
+    }
 
   /* Define the faces */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
-    face3d *face = face_iter->data;
-    bool outer_contour = true;
-    step_id_list face_contour_list = NULL;
-
-    for (contour_iter = face->contours;
-         contour_iter != NULL;
-         contour_iter = g_list_next (contour_iter), outer_contour = false) {
-      contour3d *contour = contour_iter->data;
-      edge_ref edge;
-      step_id edge_loop;
-      step_id_list edge_loop_edges = NULL;
-
-      edge = contour->first_edge;
-      do {
-        edge_loop_edges = g_list_append (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
-      } while (edge = LNEXT (edge), edge != contour->first_edge);
-
-      edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
-
-      if (outer_contour)
-        contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, true);
-      else
-        contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
-
-      face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
+    {
+      face3d *face = face_iter->data;
+      bool outer_contour = true;
+      step_id_list face_contour_list = NULL;
+
+      for (contour_iter = face->contours;
+           contour_iter != NULL;
+           contour_iter = g_list_next (contour_iter), outer_contour = false)
+        {
+          contour3d *contour = contour_iter->data;
+          edge_ref edge;
+          step_id edge_loop;
+          step_id_list edge_loop_edges = NULL;
+
+          edge = contour->first_edge;
+          do
+            {
+              edge_loop_edges = g_list_append (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
+            }
+          while (edge = LNEXT (edge), edge != contour->first_edge);
+
+          edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
+
+          if (outer_contour)
+            contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, true);
+          else
+            contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
+
+          face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
+        }
+
+      face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
+      shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
     }
 
-    face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
-    shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
-  }
-
   /* Closed shell which bounds the brep solid */
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
 
   /* Body style */
-  if (1) {
-    /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
-    brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
-    step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+  if (1)
+    {
+      /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+      brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+      step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-    styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
-  }
+      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
+    }
 
   /* Face styles */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
-    face3d *face = face_iter->data;
-
-    if (face->appear != NULL) {
-      step_id orsi = step_over_riding_styled_item (step, "NONE",
-                                                   presentation_style_assignments_from_appearance (step, face->appear),
-                                                   face->face_identifier, brep_style_identifier);
-      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
+    {
+      face3d *face = face_iter->data;
+
+      if (face->appear != NULL)
+        {
+          step_id orsi = step_over_riding_styled_item (step, "NONE",
+                                                       presentation_style_assignments_from_appearance (step, face->appear),
+                                                       face->face_identifier, brep_style_identifier);
+          styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+        }
     }
-  }
 
   /* Emit references to the styled and over_ridden styled items */
   step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
index 79c492f..54f7210 100644
--- a/src/hid/step/step_writer.c
+++ b/src/hid/step/step_writer.c
@@ -19,9 +19,10 @@ fprint_id_list (FILE *f, step_id_list list)
   fprintf (f, "( ");
   for (iter = list;
        iter != NULL && g_list_next (iter) != NULL;
-       iter = g_list_next (iter)) {
-    fprintf (f, "#%i, ", GPOINTER_TO_INT (iter->data));
-  }
+       iter = g_list_next (iter))
+    {
+      fprintf (f, "#%i, ", GPOINTER_TO_INT (iter->data));
+    }
   if (iter == NULL)
     fprintf (f, ")");
   else
@@ -44,10 +45,11 @@ make_step_id_list (int count, ...)
 
   va_start (args, NULL);
 
-  for (i = 0; i < count; i++) {
-    step_id id = va_arg (args, step_id);
-    list = g_list_append (list, GINT_TO_POINTER (id));
-  }
+  for (i = 0; i < count; i++)
+    {
+      step_id id = va_arg (args, step_id);
+      list = g_list_append (list, GINT_TO_POINTER (id));
+    }
 
   va_end (args);
