Bottom: ffb1a3edbc554de2dc2cd6fb7258db7e1ed009c9
Top:    76672b87e28d5405d34692681df78732d64d1263
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-15 00:55:02 +0000

Refresh of toy-rendering-attempt

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 3263782..4e0acb4 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -180,6 +180,10 @@ draw_quad_edge (edge_ref e, void *data)
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
+
+//      if (!info->is_bspline)
+//        return;
+
 //      if (info->is_stitch)
 //        return;
       if (info->is_round)
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index ec44a2c..d4127bc 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1139,7 +1139,8 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
 
-//  test_model = 
+  test_model =
+    NULL;
 //    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step");
 //    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step");
 //    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step");
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index a0ee678..f01cf76 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -157,19 +157,9 @@ find_manifold_solid_brep_possible_voids (SdaiShape_representation *sr,
     {
       SDAI_Application_instance *node = ((EntityNode *)iter)->node;
 
-      if (strcmp (node->EntityName (), "Manifold_Solid_Brep") == 0)
-        msb_list->push_back ((SdaiManifold_solid_brep *)node);
-
-      iter = iter->NextNode ();
-    }
+      if (strcmp (node->EntityName (), "Manifold_Solid_Brep") == 0 ||
+          strcmp (node->EntityName (), "Brep_With_Voids") == 0)
 
-
-  iter = sr->items_ ()->GetHead ();
-  while (iter != NULL)
-    {
-      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
-
-      if (strcmp (node->EntityName (), "Brep_With_Voids") == 0)
         msb_list->push_back ((SdaiManifold_solid_brep *)node);
 
       iter = iter->NextNode ();
@@ -364,6 +354,200 @@ transform_vector (double m[4][4], double *x, double *y, double *z)
 }
 
 static void
+process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, process_step_info *info)
+{
+  /* Code using lazy binding approach, since many of the B_SPLINE_* types we will encounter
+   * are used in complex entities.. no sense witing code to handle them twice
+   */
+
+  edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
+
+  SDAI_Application_instance *entity = start_entity;
+  STEPcomplex *stepcomplex = NULL;
+  STEPattribute *attr;
+
+  bool is_complex;
+  bool found_bounded_curve = false;
+  bool found_b_spline_curve = false;
+  bool found_b_spline_curve_with_knots = false;
+  bool found_curve = false;
+  bool found_geometric_representation_item = false;
+  bool found_rational_b_spline_curve = false;
+  bool found_representation_item = false;
+
+  /* Potential Complex pieces:
+   *
+   * BOUNDED_CURVE
+   * B_SPLINE_CURVE
+   * B_SPLINE_CURVE_WITH_KNOTS
+   * CURVE
+   * GEOMETRIC_REPRESENTATION_ITEM
+   * RATIONAL_B_SPLINE_CURVE
+   * REPRESENTATION_ITEM
+   */
+
+  /* Things we take note of for futher processing.. */
+
+  /* B_SPLINE_CURVE */
+  SDAI_Integer b_spline_curve_degree;
+  EntityAggregate *control_points = NULL;
+
+  /* B_SPLINE_CURVE_WITH_KNOTS */
+  IntAggregate *knot_multiplicities = NULL;
+  RealAggregate *knots = NULL;
+
+  /* RATIONAL_B_SPLINE_CURVE */
+  RealAggregate *weights = NULL;
+
+  is_complex = entity->IsComplex();
+
+  if (is_complex)
+    {
+      stepcomplex = dynamic_cast<STEPcomplex *>(entity)->head;
+      entity = stepcomplex;
+    }
+
+  while (entity)
+    {
+      if (entity->EntityName() == NULL)
+        {
+          std::cout << "ERROR: NULL whilst traversing complex / entity" << std::endl;
+          return;
+        }
+      else if (!strcmp (entity->EntityName (), "Bounded_Curve"))
+        {
+          found_bounded_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "B_Spline_Curve"))
+        {
+          found_b_spline_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "B_Spline_Curve_With_Knots"))
+        {
+          found_b_spline_curve_with_knots = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Curve"))
+        {
+          found_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Geometric_Representation_Item"))
+        {
+          found_geometric_representation_item = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Rational_B_Spline_Curve"))
+        {
+          found_rational_b_spline_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Representation_Item"))
+        {
+          found_representation_item = true;
+        }
+      else
+        {
+          printf ("INFO: Unchecked entity name in complex, \"%s\"\n", entity->EntityName ());
+        }
+
+      entity->ResetAttributes ();
+      while ((attr = entity->NextAttribute()) != NULL)
+        {
+          if (!strcmp (attr->Name (), "name"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "degree"))
+            {
+              b_spline_curve_degree = *attr->Integer ();
+            }
+          else if (!strcmp (attr->Name (), "control_points_list"))
+            {
+              control_points = dynamic_cast<EntityAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "curve_form"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "closed_curve"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "self_intersect"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "knot_multiplicities"))
+            {
+              knot_multiplicities = dynamic_cast<IntAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "knots"))
+            {
+              knots = dynamic_cast<RealAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "knot_spec"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "weights_data"))
+            {
+              weights = dynamic_cast<RealAggregate *>(attr->Aggregate ());
+            }
+          else
+            {
+              printf ("INFO: Unchecked attribute name in entity, \"%s\"\n", attr->Name ());
+            }
+        }
+
+      if (stepcomplex != NULL)
+        stepcomplex = stepcomplex->sc;
+
+      entity = stepcomplex;
+    }
+
+  /* Now we see what we found .... */
+
+  printf ("------\n");
+  printf ("b_spline_curve_degree = %i\n",b_spline_curve_degree);
+  printf ("control_points = %p\n",control_points);
+  printf ("knot_multiplicities = %p\n", knot_multiplicities);
+  printf ("knots = %p\n", knots);
+  printf ("weights = %p\n", weights);
+  printf ("is_complex = %s\n",                          is_complex                          ? "true" : "false");
+  printf ("found_bounded_curve = %s\n",                 found_bounded_curve                 ? "true" : "false");
+  printf ("found_b_spline_curve = %s\n",                found_b_spline_curve                ? "true" : "false");
+  printf ("found_b_spline_curve_with_knots = %s\n",     found_b_spline_curve_with_knots     ? "true" : "false");
+  printf ("found_curve = %s\n",                         found_curve                         ? "true" : "false");
+  printf ("found_geometric_representation_item = %s\n", found_geometric_representation_item ? "true" : "false");
+  printf ("found_rational_b_spline_curve = %s\n",       found_rational_b_spline_curve       ? "true" : "false");
+  printf ("found_representation_item = %s\n",           found_representation_item           ? "true" : "false");
+
+  if (control_points != NULL)
+    printf ("Number of control points = %i\n", control_points->EntryCount ());
+
+  if (knot_multiplicities != NULL)
+    printf ("Number of knot_multiplicities = %i\n", knot_multiplicities->EntryCount ());
+
+  if (knots != NULL)
+    printf ("Number of knots = %i\n", knots->EntryCount ());
+
+  if (weights != NULL) {
+    printf ("Number of weights = %i\n", weights->EntryCount ());
+
+  printf ("------\n");
+
+    if (weights->EntryCount () != control_points->EntryCount ())
+      {
+        printf ("ERROR: Weights not null, but entry length doesn't equal the number of control points\n");
+      }
+  }
+
+  if (control_points == NULL)
+    {
+      printf ("ERROR: control points == NULL\n");
+      return;
+    }
+
+  our_edge_info->is_bspline = true;
+  our_edge_info->degree = b_spline_curve_degree;
+  our_edge_info->num_control_points = control_points->EntryCount ();
+
+  /* XXX: TODO: Iterate over control points, knots, weights etc.. filling in these details */
+}
+
+static void
 process_edges (GHashTable *edges_hash_set, process_step_info *info) //object3d *object)
 {
   GHashTableIter iter;
@@ -512,6 +696,22 @@ process_edges (GHashTable *edges_hash_set, process_step_info *info) //object3d *
 //              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
 //              continue;
             }
+          else if (curve->IsComplex() || /* This is a guess - assuming complex curves are likely to be B_SPLINE_* complexes */
+                   strcmp (curve->EntityName (), "B_Spline_Curve_With_Knots") == 0)
+            {
+              transform_vertex (info->current_transform, &x1, &y1, &z1);
+              transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+              our_edge = make_edge ();
+              UNDIR_DATA (our_edge) = make_edge_info ();
+              object3d_add_edge (info->object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+              process_bscwk (curve, our_edge, info);
+            }
           else
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -846,7 +1046,7 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                   //     (Not sure if this is a bug in STEPcode, as the SdaiEdge_loop class DOES define
                   //     an accessor edge_list_ (), yet it appears to return an empty aggregate.
 
-                  char path_entity_name[] = "Path"; /* SdaiApplication_instance::GetMiEntity() should take const char *, but doesn't */
+                  char path_entity_name[] = "Path"; /* SDAI_Application_instance::GetMiEntity() should take const char *, but doesn't */
                   SdaiPath *path = (SdaiPath *)el->GetMiEntity (path_entity_name);
 
                   for (SingleLinkNode *iter = path->edge_list_ ()->GetHead ();
@@ -1122,26 +1322,29 @@ step_model_to_shape_master (const char *filename)
 
   step_model = process_sr_or_subtype (instance_list, sr, &info);
 
-  /* KLUDGE */
-  SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
-  if (part_origin == NULL)
-    std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
-
-  if (part_origin != NULL)
+  if (step_model != NULL)
     {
-      step_model->ox = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ())->value;
-      step_model->oy = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      step_model->oz = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      step_model->ax = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      step_model->ay = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      step_model->az = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      step_model->rx = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      step_model->ry = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      step_model->rz = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-    }
+      /* KLUDGE */
+      SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+      if (part_origin == NULL)
+        std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
 
-  /* KLUDGE */
-  step_model->object = info.object;
+      if (part_origin != NULL)
+        {
+          step_model->ox = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ())->value;
+          step_model->oy = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+          step_model->oz = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          step_model->ax = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+          step_model->ay = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          step_model->az = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          step_model->rx = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+          step_model->ry = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          step_model->rz = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+        }
+
+      /* KLUDGE */
+      step_model->object = info.object;
+    }
 
   delete instance_list;
   delete registry;
