Bottom: f6655bf6b8b1670251bdbe99cc45c5873e5e1122
Top:    e6c0a66d6dacbfd45680b5e065b7b1be88bb2d31
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-19 19:30:59 +0000

Refresh of remove-debug-from-hairline

---

diff --git a/src/polyarea.h b/src/polyarea.h
index 45ddd77..1b8e9b3 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -87,7 +87,6 @@ struct VNODE
     } Flags;
     CVCList *cvc_prev;
     CVCList *cvc_next;
-    bool cvc_is_dummy;
     Vector point;
 };
 
diff --git a/src/polygon1.c b/src/polygon1.c
index 7850ec3..fa46ebd 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2396,26 +2396,6 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   while ((a = a->f) != afst);
 }
 
-#if 0
-static bool
-is_in_cvc_list (VNODE *v, CVCList *first_l)
-{
-  CVCList *l;
-
-  g_return_val_if_fail (first_l != NULL, false);
-
-  l = first_l;
-  do
-    {
-      if (l->parent == v)
-        return true;
-    }
-  while ((l = l->next) != first_l);
-
-  return false;
-}
-#endif
-
 static CVCList *
 add_dummy_descriptors_at_point (Vector point, PLINE * pl, char poly, CVCList * list)
 {
@@ -2423,30 +2403,20 @@ add_dummy_descriptors_at_point (Vector point, PLINE * pl, char poly, CVCList * l
 
   do
     {
-      if (//node->cvc_next == NULL &&       /* Node is not corss-connected already */ /* XXX: BAD TEST.. IT WILL BE ONCE WE ADD THE FIRST DESCRIPTOR */
-          vect_equal (node->point, point)) // && /* Matches the target location */
-//          (node->cvc_next == NULL || !is_in_cvc_list (node, node->cvc_next)))
+      if (vect_equal (node->point, point))
         {
           if (node->cvc_prev == NULL &&
               !VERTEX_BACKWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
             {
               list = node->cvc_prev = insert_descriptor (node, poly, 'P', list);
               g_return_val_if_fail (node->cvc_prev != NULL, NULL);
-//              if (!node->cvc_prev)
-//                return NULL;
             }
           if (node->cvc_next == NULL &&
               !VERTEX_FORWARD_EDGE (node)->Flags.mark) /* Don't bother re-adding an edge we've decided we don't want traversed */
             {
               list = node->cvc_next = insert_descriptor (node, poly, 'N', list);
               g_return_val_if_fail (node->cvc_next != NULL, NULL);
-//              if (!node->cvc_next)
-//                return NULL;
             }
-          /* Mark the vertex as being "dummy", to allow skipping A-B connected sanity checks in the edge labeling
-           * without reducing the level of security afforded to normal cross-connected node processing.
-           */
-//          node->cvc_is_dummy = true;
         }
     }
   while ((node = NEXT_VERTEX(node)) != &pl->head);
@@ -2456,22 +2426,11 @@ add_dummy_descriptors_at_point (Vector point, PLINE * pl, char poly, CVCList * l
 static void
 remove_cvc_list_entry (CVCList *l)
 {
-  bool last = false;
-
   if (l == NULL)
     return;
 
-//  fprintf (stderr, "Removing node from CVC list..\nBEFORE:\n");
-  //cvc_list_dump (l);
-
-  /* XXX: What about when we remove the last edge - e.g. likely
-   *      inthe case of a dummy entry with connection degree 1.
-   */
-
   if (l->prev == l || l->next == l) /* XXX: Are these conditions equivalent for the last in list case? */
     {
-      last = true;
-//      fprintf (stderr, "EMPTY AFTERWARDS\n");
       g_critical ("Removing last node in circular CVC list..");
     }
 
@@ -2500,12 +2459,6 @@ remove_cvc_list_entry (CVCList *l)
    */
   l->parent = NULL;
 //  free (l);
-
-  if (!last)
-    {
-//      fprintf (stderr, "AFTERWARDS:\n");
-//      cvc_list_dump (l->prev);
-    }
 }
 
 static CVCList *
@@ -2519,9 +2472,6 @@ next_cvc_from_same_poly (CVCList *start)
   while (n->poly != start->poly && n != start)
     n = n->next;
 
-//  if (n == start)
-//    return NULL;
-
   return n;
 }
 
@@ -2537,14 +2487,10 @@ static void
 PLINE_check_hairline_edges (PLINE *contour)
 {
   VNODE *v;
-  CVCList *l, *first_l, /**new_first_l,*/*n, *nn;
+  CVCList *l, *first_l, *n, *nn;
   int test_count;
   bool terminate_after_this_iteration;
 
-//  /* Lets just try this for now */
-//  if (poly_ChkContour (contour))
-//    g_critical ("Wonky contour - oops\n");
-
   /* Scan the PLINE and check for naughty shared edge segments */
   v = &contour->head;
   do
@@ -2553,17 +2499,6 @@ PLINE_check_hairline_edges (PLINE *contour)
           v->cvc_next == NULL) /* Careful, these can be NULL independantly now! */
         continue;
 
-#if 0
-      if (v->cvc_prev != NULL && v->cvc_prev->parent == NULL &&
-          v->cvc_next != NULL && v->cvc_next->parent == NULL)
-        {
-          g_critical ("Skipping zombie vertex we left behind");
-          continue;
-        }
-#endif
-
-//      fprintf (stderr, "Vertex is cross connected, checking for hairline edge pairs\n");
-
       /* Just pick one which isn't NULL, doesn't matter where we start
        * circling the CVCList, as long as we start from a descriptor
        * belonging to this polygon
@@ -2573,22 +2508,12 @@ PLINE_check_hairline_edges (PLINE *contour)
       else
         first_l = v->cvc_next;
 
-#if 0
-      fprintf (stderr, "Iteration begins with CVCList:\n");
-      cvc_list_dump (first_l);
-#endif
-
       test_count = 0;
       l = first_l;
       do
         {
           n = l->next;
 
-#if 0
-          if (l->parent == NULL) /* Deleted node we were too lazy to remove during this early development phase */
-            continue;
-#endif
-
           /* Skip edges from the other polygon */
           if (l->poly != first_l->poly)
             continue;
@@ -2610,10 +2535,6 @@ PLINE_check_hairline_edges (PLINE *contour)
               cvc_list_dump (n);
               break;
             }
-#if 0
-          if (n->parent == NULL) /* Wrap-around to a node we deleted */
-            break;
-#endif
 
           g_assert (l->parent != NULL);
           g_assert (n->parent != NULL);
@@ -2626,24 +2547,13 @@ PLINE_check_hairline_edges (PLINE *contour)
            * bug if such edges are present, so test for it here where we may detect it. We compare
            * l->prev and l, as we know both are still in this_poly.. l->next may not be.
            */
-//              fprintf (stderr, "Checking CVCNode %p against %p. (Angles %f and %f)\n", l, n, l->angle, n->angle);
           if (compare_cvc_nodes (l, n) == 0)
             {
               VNODE *l_otherend = EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->parent, l->side), l->side);
               VNODE *n_otherend = EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (n->parent, n->side), n->side);
 
-              g_assert (l != n);
-
               if (vect_equal (l_otherend->point, n_otherend->point))
                 {
-//                  g_warning ("Check found hairline edge pair");
-
-                  if (vect_equal (l->parent->point, l_otherend->point))
-                    g_error ("Edges are zero length");
-
-                  g_assert (l->parent != NULL);
-                  g_assert (n->parent != NULL);
-
                   /* Simple approach - just mark the edges as visited, so we don't traverse them!
                    * Doing it this way ensures that both pieces of the contour are reachable if
                    * the hairline edge pair splits this PLINE into two pieces. Since we will ensure
@@ -2676,42 +2586,18 @@ PLINE_check_hairline_edges (PLINE *contour)
                   while ((nn->poly != first_l->poly || nn->parent == NULL) && nn != first_l)
                     nn = nn->next;
 
-                  g_assert (l->parent != NULL);
-//                  g_warn_if_fail (l != first_l);
                   if (l == first_l)
                     {
                       first_l = next_cvc_from_same_poly (first_l);
                       if (l == first_l)
                         terminate_after_this_iteration = true;
                     }
-                  g_warn_if_fail (l != NULL);
                   remove_cvc_list_entry (l);
-                  g_assert (n->parent != NULL);
-//                  g_warn_if_fail (n != first_l);
                   if (n == first_l)
-                    {
-                      terminate_after_this_iteration = true;
-#if 0
-                      /* Find the next edge from this polygon */
-                      new_first_l = first_l->next;
-                      while ((new_first_l->poly != first_l->poly) && new_first_l != first_l)
-                        new_first_l = new_first_l->next;
-                      if (new_first_l == first_l)
-                        new_first_l = NULL;
-                    }
-                  else
-                    {
-                      new_first_l = first_l;
-#endif
-                    }
-                  g_warn_if_fail (n != NULL);
+                    terminate_after_this_iteration = true;
                   remove_cvc_list_entry (n);
 
                   n = nn;
-//                  first_l = new_first_l;
-
-//                  if (first_l == NULL)
-//                    break;
 
                 }
               else
@@ -2728,12 +2614,6 @@ PLINE_check_hairline_edges (PLINE *contour)
 
 #warning THIS IS ALMOST CERTAINLY VERY VERY WRONG
 
-                  if (vect_equal (l->parent->point, l_otherend->point))
-                    g_error ("Edges are zero length");
-
-                  g_assert (l->parent != NULL);
-                  g_assert (n->parent != NULL);
-
 //                  VERTEX_SIDE_DIR_EDGE (l->parent, l->side)->Flags.mark = true;
 //                  VERTEX_SIDE_DIR_EDGE (n->parent, n->side)->Flags.mark = true;
 
@@ -2751,52 +2631,24 @@ PLINE_check_hairline_edges (PLINE *contour)
                   while (nn->poly != first_l->poly && nn != first_l)
                     nn = nn->next;
 
-                  g_assert (l->parent != NULL);
-//                  g_warn_if_fail (l != first_l);
                   if (l == first_l)
                     {
                       first_l = next_cvc_from_same_poly (first_l);
                       if (l == first_l)
                         terminate_after_this_iteration = true;
                     }
-                  g_warn_if_fail (l != NULL);
                   remove_cvc_list_entry (l);
-                  g_assert (n->parent != NULL);
-//                  g_warn_if_fail (n != first_l);
                   if (n == first_l)
-                    {
-                      terminate_after_this_iteration = true;
-#if 0
-                      /* Find the next edge from this polygon */
-                      new_first_l = first_l->next;
-                      while ((new_first_l->poly != first_l->poly) && new_first_l != first_l)
-                        new_first_l = new_first_l->next;
-                      if (new_first_l == first_l)
-                        new_first_l = NULL;
-                    }
-                  else
-                    {
-                      new_first_l = first_l;
-#endif
-                    }
+                    terminate_after_this_iteration = true;
                   g_warn_if_fail (n != NULL);
                   remove_cvc_list_entry (n);
 
                   n = nn;
-//                  first_l = new_first_l;
-
-#if 0
-                  if (first_l == NULL)
-                    break;
-#endif
                 }
             }
 
           test_count++;
 
-//          if (n->parent == NULL) /* Wrap-around to a node we deleted */
-//            break;
-
           if (terminate_after_this_iteration)
             break;
 
@@ -2807,40 +2659,21 @@ PLINE_check_hairline_edges (PLINE *contour)
       while ((l = n) != first_l);
     }
   while ((v = v->next) != &contour->head);
-
 }
 
-#if 0
-static void
-M_PLINE_check_hairline_edges (PLINE *first)
-{
-  PLINE *curc;
-//  fprintf (stderr, "Checking M_PLINE\n");
-  for (curc = first; curc != NULL; curc = curc->next)
-    {
-//      fprintf (stderr, "Checking PLINE\n");
-      PLINE_check_hairline_edges (curc);
-    }
-}
-#endif
-
 static void
 M_POLYAREA_check_hairline_edges (POLYAREA *bfst)
 {
   POLYAREA *b = bfst;
   PLINE *cur;
 
-//  fprintf (stderr, "Checking M_POLYAREA_check_hairline_edges\n");
   assert (b != NULL);
   do
     {
-//      fprintf (stderr, "Checking POLYAREA\n");
       for (cur = b->contours; cur != NULL; cur = cur->next)
         {
-//          fprintf (stderr, "Checking contour\n");
           if (cur->Flags.status == ISECTED)
             {
-//              fprintf (stderr, "Checking contour, it was ISECTED\n");
               PLINE_check_hairline_edges (cur);
             }
         }
@@ -2940,29 +2773,19 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       assert (poly_Valid (b));
 #endif
 
-//      fprintf (stderr, "Non-trivial polygon boolean operation\n");
-
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE);
 
-//      fprintf (stderr, "Checking A intersected contours\n");
-      //M_PLINE_check_hairline_edges (a_isected);
       M_POLYAREA_check_hairline_edges (a);
-
-//      fprintf (stderr, "Checking B intersected contours\n");
       M_POLYAREA_check_hairline_edges (b);
 
-      M_POLYAREA_check_hairline_edges (a);
-
       /* We could speed things up a lot here if we only processed the relevant contours */
       /* NB: Relevant parts of a are labeled below */
-//      fprintf (stderr, "Labeling B intersected contours\n");
       M_POLYAREA_label (b, a, FALSE);
 
       *res = a;
       M_POLYAREA_update_primary (&e, res, &holes, action, b);
       M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
-//      fprintf (stderr, "Labeling A intersected contours\n");
       M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action,
 				    FALSE);
@@ -2991,7 +2814,6 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       return code;
     }
   assert (!*res || poly_Valid (*res));
-//  fprintf (stderr, "END OF BOOLEAN\n\n");
   return code;
 }				/* poly_Boolean_free */
