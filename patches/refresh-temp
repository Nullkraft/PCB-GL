Bottom: bfc8629a7ae9afb987ba0e7b1c7fc0562950223f
Top:    e3dcb43c603f81b23578234ff53792c7a723d65a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 00:09:29 +0000

Refresh of fix-3d-contour-export

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 5437690..0154912 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -294,6 +294,15 @@ object3d_from_contours (const POLYAREA *contours,
   int start_of_ct;
   int offset_in_ct;
   int ct_npoints;
+  bool invert_face_normals;
+  double length;
+  double nx, ny;
+
+#ifdef REVERSED_PCB_CONTOURS
+  invert_face_normals = true;
+#else
+  invert_face_normals = false;
+#endif
 
   if (contours == NULL)
     return NULL;
@@ -376,40 +385,232 @@ object3d_from_contours (const POLYAREA *contours,
 
           object3d_add_face (object, faces[i]);
           /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-#ifdef REVERSED_PCB_CONTOURS
           face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
-#else
-          face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-#endif
         }
 
-      faces[npoints] = make_face3d (); /* bottom_face */
-#ifdef REVERSED_PCB_CONTOURS
-      face3d_set_normal (faces[npoints], 0., 0., -1.);
-#else
-      face3d_set_normal (faces[npoints], 0., 0., 1.);
-#endif
-      face3d_set_appearance (faces[npoints], top_bot_appearance);
-      object3d_add_face (object, faces[npoints]);
+        faces[npoints    ] = make_face3d (); /* bottom_face */
+        faces[npoints + 1] = make_face3d (); /* top_face */
+        if (invert_face_normals)
+          {
+            face3d_set_normal (faces[npoints    ], 0., 0., -1.); /* bottom_face */
+            face3d_set_normal (faces[npoints + 1], 0., 0.,  1.); /* top_face */
+          }
+        else
+          {
+            face3d_set_normal (faces[npoints    ], 0., 0.,  1.); /* bottom_face */ /* PCB bottom is at positive Z in this scheme */
+            face3d_set_normal (faces[npoints + 1], 0., 0., -1.); /* top_face */    /* PCB top is at negative Z in this scheme */
+          }
+        face3d_set_appearance (faces[npoints    ], top_bot_appearance);
+        face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+        object3d_add_face (object, faces[npoints    ]);
+        object3d_add_face (object, faces[npoints + 1]);
+
+        /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+        face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+
+        ct = contour;
+        start_of_ct = 0;
+        offset_in_ct = 0;
+        ct_npoints = get_contour_npoints (ct);
+
+        for (i = 0; i < npoints; i++, offset_in_ct++)
+          {
+            int next_i_around_ct;
+            int prev_i_around_ct;
+
+            /* Update which contour we're looking at */
+            if (offset_in_ct == ct_npoints)
+              {
+                start_of_ct = i;
+                offset_in_ct = 0;
+                ct = ct->next;
+                ct_npoints = get_contour_npoints (ct);
+
+                /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+                face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
+                face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+              }
+
+            next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+            prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+            /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+            /* Define the (non-normalized) face normal to point to the outside of the contour */
+            /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+
+            nx =  (vertices[next_i_around_ct]->y - vertices[i]->y);
+            ny = -(vertices[next_i_around_ct]->x - vertices[i]->x);
+            length = hypot (nx, ny);
+            nx /= length;
+            ny /= length;
+
+            if (invert_face_normals)
+              {
+                nx = -nx;
+                ny = -ny;
+              }
+
+            face3d_set_normal (faces[i], nx, ny, 0.);
+
+            /* Assign the appropriate vertex geometric data to each edge end */
+            ODATA (edges[              i]) = vertices[0 * npoints + i];
+            DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+            ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+            DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+            ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+            DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+
+            if (get_contour_edge_n_is_round (ct, offset_in_ct))
+              {
+                double cx;
+                double cy;
+                double radius;
+                double normal_z;
+                bool cw;
+
+                get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
+
+                face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
+                                                  0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
+                                                  radius);
+
+                /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
+                if (ct->Flags.orient == PLF_INV)
+                  face3d_set_surface_orientation_reversed (faces[i]);
+
+                face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                          /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
-      faces[npoints + 1] = make_face3d (); /* top_face */
 #ifdef REVERSED_PCB_CONTOURS
-      face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+                normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
-      face3d_set_normal (faces[npoints + 1], 0., 0., -1.);
+                normal_z = cw ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #endif
-      face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-      object3d_add_face (object, faces[npoints + 1]);
 
-      /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+                edge_info_set_round (UNDIR_DATA (edges[i]),
+                                     cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                                     0., 0., normal_z, /* Normal */ radius);
+                edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                     cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                                     0., 0., normal_z, /* Normal */ radius);
+                if (ct->is_round)
+                  edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+              }
+
+            /* NB: Contours are counter clockwise in XY plane.
+             *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+             *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+             *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+             */
+
+            RDATA (edges[              i]) = faces[i];
+            LDATA (edges[              i]) = faces[npoints];
+            RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+            LDATA (edges[1 * npoints + i]) = faces[i];
+            RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+            LDATA (edges[2 * npoints + i]) = faces[i];
+
+            /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+            splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+            splice (edges[2 * npoints + i], edges[i]);
+            /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+            splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+            splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+          }
+
+        if (0)
+          {
+            /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+            edge_ref cylinder_edges[3];
+            vertex3d *cylinder_vertices[2];
+            face3d *cylinder_faces[2];
+
+            /* Edge on top of board */
+            cylinder_edges[0] = make_edge ();
+            UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 #ifdef REVERSED_PCB_CONTOURS
-      face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                  0.,   0., 1., /* Normal */
+                                  5.);          /* Radius */
 #else
-      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                  0.,   0., 1., /* Normal */
+                                  5.);         /* Radius */
 #endif
-
+        object3d_add_edge (object, cylinder_edges[0]);
+
+        /* Edge on top of cylinder */
+        cylinder_edges[1] = make_edge ();
+        UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+        edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                              0.,   0., 1.,  /* Normal */
+                              5.);          /* Radius */
+        object3d_add_edge (object, cylinder_edges[1]);
+
+        /* Edge stitching cylinder */
+        cylinder_edges[2] = make_edge ();
+        UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+        edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+        object3d_add_edge (object, cylinder_edges[2]);
+
+        /* Vertex on board top surface */
+        cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+        object3d_add_vertex (object, cylinder_vertices[0]);
+
+        /* Vertex on cylinder top surface */
+        cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+        object3d_add_vertex (object, cylinder_vertices[1]);
+
+        /* Cylindrical face */
+        cylinder_faces[0] = make_face3d ();
+        face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,             /* Direction of the cylindrical axis */
+                                          5.);                   /* Radius of cylinder */
+        face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                     /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+        object3d_add_face (object, cylinder_faces[0]);
+        face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+        /* Top face of cylinder */
+        cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+        face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+        face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+        object3d_add_face (object, cylinder_faces[1]);
+        face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+        /* Splice onto board */
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+        /* Assign the appropriate vertex geometric data to each edge end */
+        ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+        DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+        ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+        DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+        ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+        DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+        LDATA (cylinder_edges[0]) = cylinder_faces[0];
+        RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+        LDATA (cylinder_edges[1]) = cylinder_faces[1];
+        RDATA (cylinder_edges[1]) = cylinder_faces[0];
+        LDATA (cylinder_edges[2]) = cylinder_faces[0];
+        RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+        /* Splice things together.... */
+
+        /* Link edges orbiting the cylinder bottom vertex */
+        splice (cylinder_edges[0], cylinder_edges[2]);
+        splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+        /* Link edges orbiting the cylinder top vertex */
+        splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+        splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+      }
+#ifndef NDEBUG
       ct = contour;
       start_of_ct = 0;
       offset_in_ct = 0;
@@ -427,208 +628,30 @@ object3d_from_contours (const POLYAREA *contours,
               offset_in_ct = 0;
               ct = ct->next;
               ct_npoints = get_contour_npoints (ct);
-
-              /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-#ifdef REVERSED_PCB_CONTOURS
-              face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
-              face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
-#else
-              face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-              face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-#endif
             }
 
           next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
           prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-          /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-          /* Define the (non-normalized) face normal to point to the outside of the contour */
-#if REVERSED_PCB_CONTOURS
-          /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
-          face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
-                                        (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-#else
-          face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                       -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-#endif
-
-          /* Assign the appropriate vertex geometric data to each edge end */
-          ODATA (edges[              i]) = vertices[0 * npoints + i];
-          DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-          ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-          DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-          ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-          DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-#if REVERSED_PCB_CONTOURS
-          RDATA (edges[              i]) = faces[i];
-          LDATA (edges[              i]) = faces[npoints];
-          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          LDATA (edges[1 * npoints + i]) = faces[i];
-          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          LDATA (edges[2 * npoints + i]) = faces[i];
-#else
-          LDATA (edges[              i]) = faces[i];
-          RDATA (edges[              i]) = faces[npoints];
-          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          RDATA (edges[1 * npoints + i]) = faces[i];
-          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          RDATA (edges[2 * npoints + i]) = faces[i];
-#endif
-
-          /* NB: Contours are counter clockwise in XY plane.
-           *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-           *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-           *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-           */
-
-#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], edges[i]);
-
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
-#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (edges[i], edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
-#endif
-
-          if (get_contour_edge_n_is_round (ct, offset_in_ct))
-            {
-              double cx;
-              double cy;
-              double radius;
-              double normal_z;
-              bool cw;
-
-              get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
-
-              face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
-                                                0., 0., 1., /* Direction of the cylindrical axis */
-                                                radius);
-
-              /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
-              if (ct->Flags.orient == PLF_INV)
-                face3d_set_surface_orientation_reversed (faces[i]);
-
-              face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                        /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-#ifdef REVERSED_PCB_CONTOURS
-              normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-#else
-              normal_z = cw ? -1. : 1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-#endif
-
-              edge_info_set_round (UNDIR_DATA (edges[i]),
-                                   cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
-                                   0., 0., normal_z, /* Normal */ radius);
-              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                                   cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
-                                   0., 0., normal_z, /* Normal */ radius);
-              if (ct->is_round)
-                edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-            }
-
+          g_assert (RDATA (edges[              i]) == faces[i]);
+          g_assert (LDATA (edges[              i]) == faces[npoints]);
+          g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+          g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+          g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+          g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+          g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+          g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+          g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+          g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+          g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+          g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+          g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+          g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+          g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
         }
-
-      if (0)
-        {
-          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
-
-          edge_ref cylinder_edges[3];
-          vertex3d *cylinder_vertices[2];
-          face3d *cylinder_faces[2];
-
-          /* Edge on top of board */
-          cylinder_edges[0] = make_edge ();
-          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
-#ifdef REVERSED_PCB_CONTOURS
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                0.,   0., 1., /* Normal */
-                                5.);          /* Radius */
-#else
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                0.,   0., 1., /* Normal */
-                                5.);         /* Radius */
 #endif
-          object3d_add_edge (object, cylinder_edges[0]);
-
-          /* Edge on top of cylinder */
-          cylinder_edges[1] = make_edge ();
-          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
-                                0.,   0., 1.,  /* Normal */
-                                5.);          /* Radius */
-          object3d_add_edge (object, cylinder_edges[1]);
-
-          /* Edge stitching cylinder */
-          cylinder_edges[2] = make_edge ();
-          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-          object3d_add_edge (object, cylinder_edges[2]);
-
-          /* Vertex on board top surface */
-          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-          object3d_add_vertex (object, cylinder_vertices[0]);
-
-          /* Vertex on cylinder top surface */
-          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-          object3d_add_vertex (object, cylinder_vertices[1]);
-
-          /* Cylindrical face */
-          cylinder_faces[0] = make_face3d ();
-          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1.,             /* Direction of the cylindrical axis */
-                                            5.);                   /* Radius of cylinder */
-          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-          object3d_add_face (object, cylinder_faces[0]);
-          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-          /* Top face of cylinder */
-          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-          object3d_add_face (object, cylinder_faces[1]);
-          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-          /* Splice onto board */
-          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-          /* Assign the appropriate vertex geometric data to each edge end */
-          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-          LDATA (cylinder_edges[0]) = cylinder_faces[0];
-          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-          LDATA (cylinder_edges[1]) = cylinder_faces[1];
-          RDATA (cylinder_edges[1]) = cylinder_faces[0];
-          LDATA (cylinder_edges[2]) = cylinder_faces[0];
-          RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-          /* Splice things together.... */
-
-          /* Link edges orbiting the cylinder bottom vertex */
-          splice (cylinder_edges[0], cylinder_edges[2]);
-          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-          /* Link edges orbiting the cylinder top vertex */
-          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-        }
 
       objects = g_list_append (objects, object);
 
@@ -657,19 +680,16 @@ object3d_from_board_outline (void)
   appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
 //  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (board_outline,
+#ifdef REVERSED_PCB_CONTOURS
                                     -HACK_BOARD_THICKNESS, /* Bottom */
                                     0                    ,  /* Top */
-                                    board_appearance,
-                                    top_bot_appearance);
 #else
-  objects = object3d_from_contours (board_outline,
                                      HACK_BOARD_THICKNESS / 2, /* Bottom */
                                     -HACK_BOARD_THICKNESS / 2, /* Top */
+#endif
                                     board_appearance,
                                     top_bot_appearance);
-#endif
 
   destroy_appearance (board_appearance);
   destroy_appearance (top_bot_appearance);
@@ -907,19 +927,16 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
   mask_appearance = make_appearance ();
   appearance_set_color (mask_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (info.poly,
+#ifdef REVERSED_PCB_CONTOURS
                                     (side == TOP_SIDE) ? 0                    : -HACK_BOARD_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
                                     (side == TOP_SIDE) ? HACK_MASK_THICKNESS  : -HACK_BOARD_THICKNESS,                       /* Top */
-                                    mask_appearance,
-                                    NULL);
 #else
-  objects = object3d_from_contours (info.poly,
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2                       : HACK_BOARD_THICKNESS / 2 + HACK_MASK_THICKNESS, /* Bottom */
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2, /* Top */
+#endif
                                     mask_appearance,
                                     NULL);
-#endif
 
   destroy_appearance (mask_appearance);
