Bottom: d9725a06a4707b39a781c6a6bca381ce55777062
Top:    e0acadc73798d505306470d1f10f15448da6bd3c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 23:07:45 +0000

Refresh of more-play-with-quad-edge-data

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 2f7eac2..2b61148 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -408,80 +408,80 @@ object3d_from_board_outline (void)
   ct_npoints = get_contour_npoints (ct);
 
   for (i = 0; i < npoints; i++, offset_in_ct++)
-  {
-    int next_i_around_ct;
-    int prev_i_around_ct;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints)
-      {
-        start_of_ct = i;
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-
-        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-      }
-
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-    /* Define the (non-normalized) face normal to point to the outside of the contour */
-    faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
-    faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
-    faces[i]->nz = 0.;
-
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[              i]) = vertices[0 * npoints + i];
-    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-    LDATA (edges[              i]) = faces[i];
-    RDATA (edges[              i]) = faces[npoints];
-    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-    RDATA (edges[1 * npoints + i]) = faces[i];
-    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-    RDATA (edges[2 * npoints + i]) = faces[i];
-
-    /* NB: Contours are counter clockwise in XY plane.
-     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-     */
-
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[2 * npoints + i]);
-    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-    if (ct->is_round)
-      {
-
-        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                          COORD_TO_MM (ct->radius));
-        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-      }
-
-  }
+    {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints)
+        {
+          start_of_ct = i;
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
+
+          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        }
+
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+      faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
+      faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
+      faces[i]->nz = 0.;
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+
+      if (ct->is_round)
+        {
+
+          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                            COORD_TO_MM (ct->radius));
+          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+        }
+
+    }
 
   poly_Free (&outline);
