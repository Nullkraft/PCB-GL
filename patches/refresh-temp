Bottom: f39a30bad6506e0164fe17a6f59b6a809cac62be
Top:    2efee406972982673daeaa8182f66569bd73d2dd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-20 03:19:14 +0000

Refresh of more-restructuring-on-3d-model

---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index ebcdc08..11b6579 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,9 +1,17 @@
 #include <glib.h>
+#include <stdint.h>
 #include <stdbool.h>
 
+#include <math.h>
+
 #include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
 #include "edge3d.h"
 
+#define CIRC_SEGS_D 64.0
+
+
 edge_info *
 make_edge_info (void)
 {
@@ -37,3 +45,240 @@ destroy_edge_info (edge_info *info)
 {
   g_slice_free (edge_info, info);
 }
+
+static void
+allocate_linearised_vertices (edge_ref e, int num_vertices)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->num_linearised_vertices = 0;
+  info->linearised_vertices = g_new0 (float, 3 * num_vertices);
+}
+
+static void
+add_vertex (edge_ref e, float x, float y, float z)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 0] = x;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 1] = y;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 2] = z;
+
+  info->num_linearised_vertices++;
+}
+
+#if 0
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+#endif
+
+static void
+sample_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+#if 0
+  for (i = 0; i < 20; i++)
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      add_vertex (x, y, z);
+    }
+#endif
+
+  allocate_linearised_vertices (e, info->num_control_points);
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++)
+    {
+      x = info->control_points[i * 3 + 0];
+      y = info->control_points[i * 3 + 1];
+      z = info->control_points[i * 3 + 2];
+
+      add_vertex (e, x, y, z);
+    }
+}
+
+static void
+sample_circle (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+  int i;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  double cx, cy, cz;
+  double nx, ny, nz;
+  double refx, refy, refz;
+  double endx, endy, endz;
+  double ortx, orty, ortz;
+  double cosa;
+  double sina;
+  double recip_length;
+  double da;
+  int segs;
+  double angle_step;
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  cx = ((edge_info *)UNDIR_DATA(e))->cx;
+  cy = ((edge_info *)UNDIR_DATA(e))->cy;
+  cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+  nx = ((edge_info *)UNDIR_DATA(e))->nx;
+  ny = ((edge_info *)UNDIR_DATA(e))->ny;
+  nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+  /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+   * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+   */
+  refx = x1 - cx;
+  refy = y1 - cy;
+  refz = z1 - cz;
+
+  /* Normalise refx */
+  recip_length = 1. / hypot (hypot (refx, refy), refz);
+  refx *= recip_length;
+  refy *= recip_length;
+  refz *= recip_length;
+
+  endx = x2 - cx;
+  endy = y2 - cy;
+  endz = z2 - cz;
+
+  /* Normalise endx */
+  recip_length = 1. / hypot (hypot (endx, endy), endz);
+  endx *= recip_length;
+  endy *= recip_length;
+  endz *= recip_length;
+
+  /* ref cross normal */
+  /* ort will be orthogonal to normal and ref vector */
+  ortx = ny * refz - nz * refy;
+  orty = nz * refx - nx * refz;
+  ortz = nx * refy - ny * refx;
+
+  /* Cosine is dot product of ref (normalised) and end (normalised) */
+  cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and end (normalised) */
+  sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+  if (x1 == x2 &&
+      y1 == y2 &&
+      z1 == z2)
+    {
+      da = 2.0 * M_PI;
+    }
+  else
+    {
+      /* Delta angled */
+      da = atan2 (sina, cosa);
+
+      if (da < 0.0)
+        da += 2.0 * M_PI;
+    }
+
+  /* Scale up ref and ort to the actual vector length */
+  refx *= info->radius;
+  refy *= info->radius;
+  refz *= info->radius;
+
+  ortx *= info->radius;
+  orty *= info->radius;
+  ortz *= info->radius;
+
+  segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+  segs = MAX(segs, 1);
+  angle_step = da / (double)segs;
+
+  allocate_linearised_vertices (e, segs + 1);
+
+  for (i = 0; i <= segs; i++)
+    {
+      cosa = cos (i * angle_step);
+      sina = sin (i * angle_step);
+      add_vertex (e, info->cx + refx * cosa + ortx * sina,
+                     info->cy + refy * cosa + orty * sina,
+                     info->cz + refz * cosa + ortz * sina);
+    }
+
+}
+
+static void
+sample_line (edge_ref e)
+{
+  double x, y, z;
+
+  allocate_linearised_vertices (e, 2);
+
+  x = ((vertex3d *)ODATA(e))->x;
+  y = ((vertex3d *)ODATA(e))->y;
+  z = ((vertex3d *)ODATA(e))->z;
+
+  add_vertex (e, x, y, z);
+
+  x = ((vertex3d *)DDATA(e))->x;
+  y = ((vertex3d *)DDATA(e))->y;
+  z = ((vertex3d *)DDATA(e))->z;
+
+  add_vertex (e, x, y, z);
+  /* Leave end-point */
+}
+
+void
+edge_ensure_linearised (edge_ref edge)
+{
+  edge_info *info;
+
+  /* Ensure we're looking at the forward edge */
+  edge &= (uintptr_t) ~3;
+
+  info = UNDIR_DATA(edge);
+
+  /* Already cached, nothing to do */
+  if (info->linearised_vertices != NULL)
+    return;
+
+  /* Can't do anything if we don't have the edge_info data */
+  if (info == NULL)
+    return;
+
+  if (info->is_bspline)
+    {
+      sample_bspline (edge);
+      return;
+    }
+
+  if (info->is_round)
+    {
+      sample_circle (edge);
+      return;
+    }
+
+  /* Must be linear */
+  sample_line (edge);
+}
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 7b26668..b77b835 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -30,9 +30,15 @@ typedef struct
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
   step_id edge_identifier;
+
+
+  /* Rendering data */
+  int num_linearised_vertices;
+  float *linearised_vertices; /* NB: Does not include the start_point */
 } edge_info;
 
 edge_info *make_edge_info (void);
 void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
+void edge_ensure_linearised (edge_ref edge);
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 770792f..f690587 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -8,6 +8,8 @@ typedef struct {
   GList *contours;
   char *name;
 
+  bool is_planar;
+
   /* For cylindrical surfaces */
   bool is_cylindrical;
   double cx, cy, cz; /* A point on the axis */
@@ -24,6 +26,7 @@ typedef struct {
   /* Rendering cache */
   int tristrip_num_vertices;
   float *tristrip_vertices;
+  bool triangulate_failed;
 } face3d;
 
 face3d *make_face3d (char *name);
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index 019304b..5b7f925 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -109,173 +109,69 @@ ensure_tristrip (face3d *face)
   VNODE *node;
   PLINE *p_contour = NULL;
   POLYAREA *poly;
+  PLINE *dummy_contour;
   borast_traps_t traps;
+  bool found_outer_contour = false;
 
   /* Nothing to do if vertices are already cached */
   if (face->tristrip_vertices != NULL)
     return;
 
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
   if (face->is_cylindrical)
     return;
 
 //  if (face->is_b_spline)
 //    return;
 
-  /* Outer contour */ /* XXX: NOT ALWAYS IT WOULD SEEM! */
-//  contour = &ace->contours->data;
-
   poly = poly_Create ();
   if (poly == NULL)
     return;
 
+  /* Create a dummy outer contour (so we don't have to worry about the order below..
+   * when we encounter the outer contour, we substitute this dummy one for it.
+   */
+  p_v[0] = 0;
+  p_v[1] = 0;
+  node = poly_CreateNode (p_v);
+  dummy_contour = poly_NewContour (node);
+  dummy_contour->Flags.orient = PLF_DIR;
+  poly_InclContour (poly, dummy_contour);
+
   for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
     {
       contour = c_iter->data;
-      bool hole = false; /* XXX ??? */
 
       e = contour->first_edge;
 
       do
         {
           edge_info *info = UNDIR_DATA (e);
-          double ex, ey, ez;
-          double x, y, z;
           float u, v;
+          bool backwards_edge;
 
-          ex = ((vertex3d *)DDATA(e))->x;
-          ey = ((vertex3d *)DDATA(e))->y;
-          ez = ((vertex3d *)DDATA(e))->z;
-
-          if (info->is_round)
-            {
-              int i;
-              double sx, sy, sz;
-              double cx, cy, cz;
-              double nx, ny, nz;
-              double refx, refy, refz;
-              double endx, endy, endz;
-              double ortx, orty, ortz;
-              double cosa, sina;
-              double recip_length;
-              double da;
-              int segs;
-              double angle_step;
-
-              sx = ((vertex3d *)ODATA(e))->x;
-              sy = ((vertex3d *)ODATA(e))->y;
-              sz = ((vertex3d *)ODATA(e))->z;
-
-              cx = ((edge_info *)UNDIR_DATA(e))->cx;
-              cy = ((edge_info *)UNDIR_DATA(e))->cy;
-              cz = ((edge_info *)UNDIR_DATA(e))->cz;
-
-              nx = ((edge_info *)UNDIR_DATA(e))->nx;
-              ny = ((edge_info *)UNDIR_DATA(e))->ny;
-              nz = ((edge_info *)UNDIR_DATA(e))->nz;
-
-              /* XXX: Do this without breaking abstraction? */
-              /* Detect SYM edges, reverse the circle normal */
-              if ((e & 2) == 2)
-                {
-                  nx = -nx;
-                  ny = -ny;
-                  nz = -nz;
-                }
-
-              /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
-               * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
-               */
-              refx = sx - cx;
-              refy = sy - cy;
-              refz = sz - cz;
-
-              /* Normalise refx */
-              recip_length = 1. / hypot (hypot (refx, refy), refz);
-              refx *= recip_length;
-              refy *= recip_length;
-              refz *= recip_length;
-
-              endx = ex - cx;
-              endy = ey - cy;
-              endz = ez - cz;
-
-              /* Normalise endx */
-              recip_length = 1. / hypot (hypot (endx, endy), endz);
-              endx *= recip_length;
-              endy *= recip_length;
-              endz *= recip_length;
-
-              /* ref cross normal */
-              /* ort will be orthogonal to normal and ref vector */
-              ortx = ny * refz - nz * refy;
-              orty = nz * refx - nx * refz;
-              ortz = nx * refy - ny * refx;
-
-              /* Cosine is dot product of ref (normalised) and end (normalised) */
-              cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
-              /* Sine is dot product of ort (normalised) and end (normalised) */
-              sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
-
-              if (sx == ex &&
-                  sy == ey &&
-                  sz == ez)
-                {
-                  da = 2.0 * M_PI;
-                }
-              else
-                {
-                  /* Delta angled */
-                  da = atan2 (sina, cosa);
-
-                  if (da < 0.0)
-                    da += 2.0 * M_PI;
-                }
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
 
-              /* Scale up ref and ort to the actual vector length */
-              refx *= info->radius;
-              refy *= info->radius;
-              refz *= info->radius;
+          edge_ensure_linearised (e);
 
-              ortx *= info->radius;
-              orty *= info->radius;
-              ortz *= info->radius;
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
 
-              segs = CIRC_SEGS_D * da / (2.0 * M_PI);
-              segs = MAX(segs, 1);
-              angle_step = da / (double)segs;
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
 
-              for (i = 0; i < segs; i++)
-                {
-                  cosa = cos ((i + 1) * angle_step);
-                  sina = sin ((i + 1) * angle_step);
-                  x = info->cx + refx * cosa + ortx * sina;
-                  y = info->cy + refy * cosa + orty * sina;
-                  z = info->cz + refz * cosa + ortz * sina;
-
-                  plane_xyz_to_uv (face, x, y, z, &u, &v);
-
-                  /* XXX: Arbitrary scaling from parameter space to coords, assuming parameter space approx mm (which is likely wrong */
-                  p_v[0] = MM_TO_COORD (u);
-                  p_v[1] = MM_TO_COORD (v);
-                  node = poly_CreateNode (p_v);
-
-                  if (p_contour == NULL)
-                    {
-                      if ((p_contour = poly_NewContour (node)) == NULL)
-                        return;
-                    }
-                  else
-                    {
-                      poly_InclVertex (p_contour->head.prev, node);
-                    }
-                }
-            }
-          else
-            {
-              /* Straight line case */
-              plane_xyz_to_uv (face, ex, ey, ez, &u, &v);
+              plane_xyz_to_uv (face,
+                               info->linearised_vertices[vertex_idx * 3 + 0],
+                               info->linearised_vertices[vertex_idx * 3 + 1],
+                               info->linearised_vertices[vertex_idx * 3 + 2],
+                               &u, &v);
 
-              /* XXX: Arbitrary scaling from parameter space to coords, assuming parameter space approx mm (which is likely wrong */
               p_v[0] = MM_TO_COORD (u);
               p_v[1] = MM_TO_COORD (v);
               node = poly_CreateNode (p_v);
@@ -290,20 +186,59 @@ ensure_tristrip (face3d *face)
                   poly_InclVertex (p_contour->head.prev, node);
                 }
             }
+
         }
       while ((e = LNEXT(e)) != contour->first_edge);
 
       poly_PreContour (p_contour, FALSE);
 
       /* make sure it is a positive contour (outer) or negative (hole) */
-      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
-        poly_InvContour (p_contour);
+//      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+//      poly_InvContour (p_contour);
 
-      poly_InclContour (poly, p_contour);
-      contour = NULL;
+      if (p_contour->Flags.orient == PLF_DIR)
+        {
+          PLINE *old_outer;
+
+          /* Found the outer contour */
+          if (found_outer_contour)
+            {
+              printf ("FOUND TWO OUTER CONTOURS FOR PLANAR FACE.. WILL END BADLY!\n");
+#if 1
+              face->triangulate_failed = true;
+              return;
+#endif
+            }
+
+          p_contour->next = poly->contours->next;
+          old_outer = poly->contours;
+          poly->contours = p_contour;
 
+          found_outer_contour = true;
+        }
+      else
+        {
+          if (!poly_InclContour (poly, p_contour))
+            {
+              printf ("Contour dropped - oops!\n");
+              poly_DelContour (&p_contour);
+            }
+        }
+      p_contour = NULL;
+
+      /* XXX: Assumption of outline first, holes second seems to be false! */
+//      hole = true;
     }
 
+  if (!found_outer_contour)
+    {
+      printf ("DID NOT FIND OUTER CONTOUR... BADNESS\n");
+      face->triangulate_failed = true;
+      return;
+    }
+
+  poly_DelContour (&dummy_contour);
+
   /* XXX: Need to tesselate the polygon */
   _borast_traps_init (&traps);
   bo_poly_to_traps_no_draw (poly, &traps);
@@ -326,12 +261,15 @@ ensure_tristrip (face3d *face)
     }
   }
 
+  poly_Free (&poly);
+
   if (num_uv_points == 0) {
 //    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
     return;
   }
 
-  printf ("Tesselated with %i uv points\n", num_uv_points);
+//  printf ("Tesselated with %i uv points\n", num_uv_points);
 
   uv_points = g_new0 (float, 2 * num_uv_points);
 
@@ -395,6 +333,8 @@ ensure_tristrip (face3d *face)
                       &face->tristrip_vertices[vertex_comp + 2]);
       vertex_comp += 3;
     }
+
+  g_free (uv_points);
 }
 
 void
@@ -408,13 +348,20 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
   int i;
   int vertex_comp;
 
+  /* We only know how to deal with planar faces for now */
+  if (!face->is_planar)
+    return;
+
   if (selected)
     hidgl_flush_triangles (hidgl);
 
   ensure_tristrip (face);
 
 //  glColor4f (1.0f, 0.0f, 0.0f, 0.3f);
-  glColor4f (1.0f, 0.0f, 0.0f, 1.0f);
+  if (selected)
+    glColor4f (0.0f, 1.0f, 1.0f, 1.0f);
+  else
+    glColor4f (0.8f, 0.8f, 0.8f, 1.0f);
 
   hidgl_ensure_vertex_space (gc, face->tristrip_num_vertices);
 
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
index 421cfb0..d350572 100644
--- a/src/hid/common/object3d_gl.c
+++ b/src/hid/common/object3d_gl.c
@@ -428,6 +428,7 @@ draw_face (face3d *face, void *data)
   struct draw_info *info = data;
 
   face3d_fill (info->gc, face, info->selected);
+//  face3d_fill (info->gc, face, (face_no == debug_integer));
 
 //  info->debug_face = (face_no == debug_integer);
 //
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 0e78d54..0816807 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2823,7 +2823,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
 //  glDisable (GL_DEPTH_TEST); /* TEST */
-//  glDepthMask (FALSE); /* TEST */
+  glDepthMask (FALSE); /* TEST */
 
   if (!global_view_2d)
     ghid_draw_packages (&region);
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 677483b..a70b7c2 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -97,8 +97,8 @@ typedef std::list<SdaiMapped_item *> mi_list;
 
 SdaiProduct_definition *
 read_model_from_file (Registry *registry,
-                        InstMgr *instance_list,
-                        const char *filename)
+                      InstMgr *instance_list,
+                      const char *filename)
 {
   STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
 
@@ -381,7 +381,7 @@ transform_vector (double m[4][4], double *x, double *y, double *z)
 static double
 distance (double a[3], double b[3])
 {
-  return hypot(hypot(a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
+  return hypot (hypot (a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
 }
 
 static void
@@ -1160,12 +1160,11 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
 
           /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
-          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          //SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
           /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
           SdaiFace_surface *fs = (SdaiFace_surface *) face;
 
           SdaiSurface *surface = fs->face_geometry_ ();
-
 #if 0
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
@@ -1196,9 +1195,35 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                                 &info->current_face->ry,
                                 &info->current_face->rz);
 
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_planar = true;
+
               info->current_face->nx = info->current_face->ax;
               info->current_face->ny = info->current_face->ay;
               info->current_face->nz = info->current_face->az;
+
+              if (!fs->same_sense_ ())
+                {
+                  info->current_face->nx = -info->current_face->nx;
+                  info->current_face->ny = -info->current_face->ny;
+                  info->current_face->nz = -info->current_face->nz;
+
+//                  printf ("Not same sense, flipping normal\n");
+                }
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
@@ -1216,6 +1241,7 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                                 &info->current_face->ry,
                                 &info->current_face->rz);
 
+              info->current_face->is_cylindrical = true;
               info->current_face->radius = cylinder->radius_ ();
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
