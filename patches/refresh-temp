Bottom: 244f3796c5143ad37b9b95e3537d6a3dca3a06e0
Top:    46a346c7c65f204e67ea776c8e0358d3f03cf22c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-05-05 18:47:45 +0100

Refresh of add-multi-clearance-drc-whilst

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 742c411..128d048 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -100,6 +100,8 @@ PCB_SRCS = \
 	mtspace.h \
 	mymem.c \
 	mymem.h \
+	netclass.c \
+	netclass.h \
 	netlist.c \
 	parse_l.h \
 	parse_l.l \
@@ -153,6 +155,8 @@ PCB_SRCS = \
 	hid/common/hidnogui.c \
 	hid/common/hidnogui.h \
 	hid/common/extents.c \
+	hid/common/draw_drc.c \
+	hid/common/draw_drc.h \
 	hid/common/draw_helpers.c \
 	hid/common/draw_helpers.h \
 	hid/common/hid_resource.c \
diff --git a/src/action.c b/src/action.c
index 7782164..a9f7972 100644
--- a/src/action.c
+++ b/src/action.c
@@ -73,6 +73,7 @@
 #include "rtree.h"
 #include "macro.h"
 #include "pcb-printf.h"
+#include "netclass.h"
 
 #include <assert.h>
 #include <stdlib.h> /* rand() */
@@ -890,13 +891,19 @@ NotifyLine (void)
 	  gui->beep ();
 	  break;
 	}
-      if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
+      if (Settings.Mode == LINE_MODE)
 	{
-	  type = SearchScreen (Crosshair.X, Crosshair.Y,
-			       PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
-			       &ptr3);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false);
-	  LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true);
+          if (TEST_FLAG (AUTODRCFLAG, PCB))
+            {
+              type = SearchScreen (Crosshair.X, Crosshair.Y,
+                                   PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
+                                   &ptr3);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, CONNECTEDFLAG, false, true);
+              LookupConnection (Crosshair.X, Crosshair.Y, true, 1, FOUNDFLAG, true, true);
+            }
+          /* XXX: NEED TO FIGURE OUT WHAT NET CLASS THIS IS, AND/OR STORE FOR USE WITH DRC */
+	  Crosshair.Netclass = get_netclass_at_xy (LAYER_ON_STACK(0), Crosshair.X, Crosshair.Y); /* XXX: Not sure about the layer! */
+	  PCB->Bloat = get_min_clearance_for_netclass (Crosshair.Netclass);
 	}
       if (type == PIN_TYPE || type == VIA_TYPE)
 	{
@@ -1343,7 +1350,7 @@ NotifyMode (void)
 		}
 	    }
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && !TEST_SILK_LAYER (CURRENT))
-	    LookupConnection (Note.X, Note.Y, true, 1, CONNECTEDFLAG, false);
+	    LookupConnection (Note.X, Note.Y, true, 1, CONNECTEDFLAG, false, true);
 	  Draw ();
 	}
       break;
@@ -2331,13 +2338,13 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	case F_Find:
 	  {
 	    gui->get_coords (_("Click on a connection"), &x, &y);
-	    LookupConnection (x, y, true, 1, CONNECTEDFLAG, false);
-	    LookupConnection (x, y, true, 1, FOUNDFLAG, true);
+	    LookupConnection (x, y, true, 1, CONNECTEDFLAG, false, true);
+	    LookupConnection (x, y, true, 1, FOUNDFLAG, true, true);
 	    break;
 	  }
 
 	case F_ResetLinesAndPolygons:
-	  if (ClearFlagOnLinesAndPolygons (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnLinesAndPolygons (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2345,7 +2352,7 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	  break;
 
 	case F_ResetPinsViasAndPads:
-	  if (ClearFlagOnPinsViasAndPads (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnPinsViasAndPads (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2353,7 +2360,7 @@ ActionConnection (int argc, char **argv, Coord x, Coord y)
 	  break;
 
 	case F_Reset:
-	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
@@ -2790,7 +2797,7 @@ ActionDisplay (int argc, char **argv, Coord childX, Coord childY)
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
-	      if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	      if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 		{
 		  IncrementUndoSerialNumber ();
 		  Draw ();
@@ -2799,10 +2806,10 @@ ActionDisplay (int argc, char **argv, Coord childX, Coord childY)
 		{
 		  LookupConnection (Crosshair.AttachedLine.Point1.X,
 		                    Crosshair.AttachedLine.Point1.Y,
-		                    true, 1, CONNECTEDFLAG, false);
+		                    true, 1, CONNECTEDFLAG, false, true);
 		  LookupConnection (Crosshair.AttachedLine.Point1.X,
 		                    Crosshair.AttachedLine.Point1.Y,
-		                    true, 1, FOUNDFLAG, true);
+		                    true, 1, FOUNDFLAG, true, true);
 		}
 	    }
 	  notify_crosshair_change (true);
diff --git a/src/create.c b/src/create.c
index 7d0a760..4b00197 100644
--- a/src/create.c
+++ b/src/create.c
@@ -997,7 +997,7 @@ CreateNewRubberbandEntry (LayerType *Layer,
  * \brief Add a new net to the netlist menu.
  */
 LibraryMenuType *
-CreateNewNet (LibraryType *lib, char *name, char *style)
+CreateNewNet (LibraryType *lib, char *name, char *style, char *class)
 {
   LibraryMenuType *menu;
   char temp[64];
@@ -1010,6 +1010,7 @@ CreateNewNet (LibraryType *lib, char *name, char *style)
     menu->Style = NULL;
   else
     menu->Style = strdup (style);
+  menu->Netclass = STRDUP (class);
   return (menu);
 }
 
diff --git a/src/create.h b/src/create.h
index aec69b8..82124bf 100644
--- a/src/create.h
+++ b/src/create.h
@@ -59,7 +59,7 @@ PadType * CreateNewPad (ElementType *, Coord, Coord, Coord, Coord, Coord, Coord,
 LineType * CreateNewLineInSymbol (SymbolType *, Coord, Coord, Coord, Coord, Coord);
 void CreateDefaultFont (PCBType *);
 RubberbandType * CreateNewRubberbandEntry (LayerType *, LineType *, PointType *, bool);
-LibraryMenuType * CreateNewNet (LibraryType *, char *, char *);
+LibraryMenuType * CreateNewNet (LibraryType *, char *, char *, char *);
 LibraryEntryType * CreateNewConnection (LibraryMenuType *, char *);
 AttributeType * CreateNewAttribute (AttributeListType *list, char *name, char *value);
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 1d20765..274ce69 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -1320,7 +1320,7 @@ common_tail:
 
   if (Settings.Mode == LINE_MODE
       && Crosshair.AttachedLine.State != STATE_FIRST
-      && TEST_FLAG (AUTODRCFLAG, PCB))
+     )//      && TEST_FLAG (AUTODRCFLAG, PCB))
     EnforceLineDRC ();
 
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_DO_NOTHING);
diff --git a/src/find.c b/src/find.c
index 2b6496f..655d227 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2939,7 +2939,7 @@ LookupElementConnections (ElementType *Element, FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   InitConnectionLookup ();
   PrintElementConnections (Element, FP, FOUNDFLAG, true);
   SetChangedFlag (true);
@@ -2959,7 +2959,7 @@ LookupConnectionsToAllElements (FILE * FP)
 {
   /* reset all currently marked connections */
   User = false;
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
@@ -2969,12 +2969,12 @@ LookupConnectionsToAllElements (FILE * FP)
       break;
     SEPARATE (FP);
     if (Settings.ResetAfterElement && n != 1)
-      ClearFlagOnAllObjects (false, FOUNDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   }
   END_LOOP;
   if (Settings.RingBellWhenFinished)
     gui->beep ();
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   FreeConnectionLookupMemory ();
   Redraw ();
 }
@@ -3055,7 +3055,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3, int flag)
  */
 void
 LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
-                  bool AndRats)
+                  bool AndRats, bool store_undo)
 {
   void *ptr1, *ptr2, *ptr3;
   char *name;
@@ -3088,7 +3088,7 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
   name = ConnectionName (type, ptr1, ptr2);
   hid_actionl ("NetlistShow", name, NULL);
 
-  User = AndDraw;
+  User = store_undo;
   InitConnectionLookup ();
 
   /* now add the object to the appropriate list and start scanning
@@ -3096,7 +3096,39 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
    */
   ListStart (type, ptr1, ptr2, ptr3, flag);
   DoIt (flag, AndRats, AndDraw);
+  if (store_undo)
+    IncrementUndoSerialNumber ();
+  User = false;
+
+  /* we are done */
   if (AndDraw)
+    Draw ();
+  if (AndDraw && Settings.RingBellWhenFinished)
+    gui->beep ();
+  FreeConnectionLookupMemory ();
+}
+
+/* ---------------------------------------------------------------------------
+ * looks up all connections from the object at the given coordinates
+ * the TheFlag (normally 'FOUNDFLAG') is set for all objects found
+ * the objects are re-drawn if AndDraw is true
+ * also the action is marked as undoable if AndDraw is true
+ */
+void
+LookupObject (int type, void *ptr1, void *ptr2, void *ptr3, bool AndDraw, int flag,
+                  bool AndRats, bool store_undo)
+{
+  reassign_no_drc_flags ();
+
+  User = store_undo;
+  InitConnectionLookup ();
+
+  /* now add the object to the appropriate list and start scanning
+   * This is step (1) from the description
+   */
+  ListStart (type, ptr1, ptr2, ptr3, flag);
+  DoIt (flag, AndRats, AndDraw);
+  if (store_undo)
     IncrementUndoSerialNumber ();
   User = false;
 
@@ -3131,7 +3163,7 @@ LookupUnusedPins (FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
@@ -3156,7 +3188,7 @@ LookupUnusedPins (FILE * FP)
  * resets all used flags of pins and vias
  */
 bool
-ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
+ClearFlagOnPinsViasAndPads (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
@@ -3164,7 +3196,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, via))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
         CLEAR_FLAG (flag, via);
         if (AndDraw)
@@ -3179,7 +3211,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
     {
       if (TEST_FLAG (flag, pin))
         {
-          if (AndDraw)
+          if (store_undo)
             AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
           CLEAR_FLAG (flag, pin);
           if (AndDraw)
@@ -3192,7 +3224,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
     {
       if (TEST_FLAG (flag, pad))
         {
-          if (AndDraw)
+          if (store_undo)
             AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
           CLEAR_FLAG (flag, pad);
           if (AndDraw)
@@ -3212,7 +3244,7 @@ ClearFlagOnPinsViasAndPads (bool AndDraw, int flag)
  * resets all used flags of LOs
  */
 bool
-ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
+ClearFlagOnLinesAndPolygons (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
@@ -3220,7 +3252,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, line))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (RATLINE_TYPE, line, line, line);
         CLEAR_FLAG (flag, line);
         if (AndDraw)
@@ -3233,7 +3265,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, line))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (LINE_TYPE, layer, line, line);
         CLEAR_FLAG (flag, line);
         if (AndDraw)
@@ -3246,7 +3278,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, arc))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (ARC_TYPE, layer, arc, arc);
         CLEAR_FLAG (flag, arc);
         if (AndDraw)
@@ -3259,7 +3291,7 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
   {
     if (TEST_FLAG (flag, polygon))
       {
-        if (AndDraw)
+        if (store_undo)
           AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
         CLEAR_FLAG (flag, polygon);
         if (AndDraw)
@@ -3277,12 +3309,12 @@ ClearFlagOnLinesAndPolygons (bool AndDraw, int flag)
  * resets all found connections
  */
 bool
-ClearFlagOnAllObjects (bool AndDraw, int flag)
+ClearFlagOnAllObjects (bool AndDraw, int flag, bool store_undo)
 {
   bool change = false;
 
-  change = ClearFlagOnPinsViasAndPads  (AndDraw, flag) || change;
-  change = ClearFlagOnLinesAndPolygons (AndDraw, flag) || change;
+  change = ClearFlagOnPinsViasAndPads  (AndDraw, flag, store_undo) || change;
+  change = ClearFlagOnLinesAndPolygons (AndDraw, flag, store_undo) || change;
 
   return change;
 }
@@ -3364,7 +3396,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
         {
           DumpList ();
           /* make the flag changes undoable */
-          ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+          ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
           User = true;
           start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, true, -PCB->Shrink, false);
           start_do_it_and_dump (What, ptr1, ptr2, ptr3, FOUNDFLAG, true, 0, true);
@@ -3397,7 +3429,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
       DumpList ();
     }
   /* now check the bloated condition */
-  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
   start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, false, 0, false);
   flag = FOUNDFLAG;
   ListStart (What, ptr1, ptr2, ptr3, flag);
@@ -3407,7 +3439,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
     {
       DumpList ();
       /* make the flag changes undoable */
-      ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
       User = true;
       start_do_it_and_dump (What, ptr1, ptr2, ptr3, SELECTEDFLAG, true, 0, false);
       start_do_it_and_dump (What, ptr1, ptr2, ptr3, FOUNDFLAG, true, PCB->Bloat, true);
@@ -3444,7 +3476,7 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
     }
   drc = false;
   DumpList ();
-  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG | SELECTEDFLAG, false);
   return (false);
 }
 
@@ -3580,7 +3612,7 @@ DRCAll (void)
   hid_action ("LayersChanged");
   InitConnectionLookup ();
 
-  if (ClearFlagOnAllObjects (true, FOUNDFLAG | DRCFLAG | SELECTEDFLAG))
+  if (ClearFlagOnAllObjects (true, FOUNDFLAG | DRCFLAG | SELECTEDFLAG, true))
     {
       IncrementUndoSerialNumber ();
       Draw ();
@@ -3633,7 +3665,7 @@ DRCAll (void)
   }
   END_LOOP;
 
-  ClearFlagOnAllObjects (false, IsBad ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG));
+  ClearFlagOnAllObjects (false, IsBad ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG), false);
   info.flag = SELECTEDFLAG;
   /* check minimum widths and polygon clearances */
   if (!IsBad)
diff --git a/src/find.h b/src/find.h
index 4cc68f8..3a9c7d9 100644
--- a/src/find.h
+++ b/src/find.h
@@ -50,11 +50,12 @@ bool LinePadIntersect (LineType *, PadType *);
 bool ArcPadIntersect (ArcType *, PadType *);
 void LookupElementConnections (ElementType *, FILE *);
 void LookupConnectionsToAllElements (FILE *);
-void LookupConnection (Coord, Coord, bool, Coord, int, bool AndRats);
+void LookupConnection (Coord, Coord, bool, Coord, int, bool AndRats, bool store_undo);
+void LookupObject (int, void *, void *, void *, bool, int, bool AndRats, bool store_undo);
 void LookupUnusedPins (FILE *);
-bool ClearFlagOnLinesAndPolygons (bool, int flag);
-bool ClearFlagOnPinsViasAndPads (bool, int flag);
-bool ClearFlagOnAllObjects (bool, int flag);
+bool ClearFlagOnLinesAndPolygons (bool, int flag, bool store_undo);
+bool ClearFlagOnPinsViasAndPads (bool, int flag, bool store_undo);
+bool ClearFlagOnAllObjects (bool, int flag, bool store_undo);
 void InitConnectionLookup (void);
 void FreeConnectionLookupMemory (void);
 void RatFindHook (int, void *, void *, void *, bool, int flag, bool);
diff --git a/src/global.h b/src/global.h
index a542ccf..d5d2f82 100644
--- a/src/global.h
+++ b/src/global.h
@@ -167,6 +167,7 @@ typedef struct
 	BoxType		BoundingBox;	\
 	long int	ID;		\
 	FlagType	Flags;		\
+	Coord		ExtraDrcClearance; \
 	//	struct LibraryEntryType *net
 
 /* Lines, pads, and rats all use this so they can be cross-cast.  */
@@ -459,7 +460,8 @@ typedef struct
 {
   char *Name,			/* name of the menu entry */
    *directory,			/* Directory name library elements are from */
-   *Style;			/* routing style */
+   *Style,			/* routing style */
+   *Netclass;			/* Net class */
   Cardinal EntryN,		/* number of objects */
     EntryMax;			/* number of reserved memory locations */
   LibraryEntryType *Entry;	/* the entries */
@@ -599,6 +601,7 @@ typedef struct			/* holds cursor information */
   PolygonType AttachedPolygon;
   AttachedObjectType AttachedObject;	/* data of attached objects */
   enum crosshair_shape shape; 	/* shape of crosshair */
+  char *Netclass;
 } CrosshairType;
 
 typedef struct
diff --git a/src/hid/common/draw_drc.c b/src/hid/common/draw_drc.c
index 3143bfd..f6f0fa3 100644
--- a/src/hid/common/draw_drc.c
+++ b/src/hid/common/draw_drc.c
@@ -2,720 +2,221 @@
 #include "hid.h"
 #include "hid_draw.h"
 #include "data.h" /* For global "PCB" variable */
+#include "misc.h" /* For GetArcEnds() */
 #include "rotate.h" /* For RotateLineLowLevel() */
 #include "polygon.h"
 #include "draw_helpers.h"
 
+/* Hacky chaining of functions */
+static HID_DRAW_CLASS orig_class;
 
-static void
-common_draw_pcb_line (hidGC gc, LineType *line)
-{
-  hid_draw_set_line_cap (gc, Trace_Cap);
-  if (TEST_FLAG (THINDRAWFLAG, PCB))
-    hid_draw_set_line_width (gc, 0);
-  else
-    hid_draw_set_line_width (gc, line->Thickness);
-
-  hid_draw_line (gc, line->Point1.X, line->Point1.Y,
-                     line->Point2.X, line->Point2.Y);
-}
-
-static void
-common_draw_pcb_arc (hidGC gc, ArcType *arc)
-{
-  if (!arc->Thickness)
-    return;
 
-  if (TEST_FLAG (THINDRAWFLAG, PCB))
-    hid_draw_set_line_width (gc, 0);
-  else
-    hid_draw_set_line_width (gc, arc->Thickness);
-  hid_draw_set_line_cap (gc, Trace_Cap);
-
-  hid_draw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta);
-}
-
-/* ---------------------------------------------------------------------------
- * drawing routine for text objects
+/*-----------------------------------------------------------
+ * Draws the outline of a line
  */
 static void
-common_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+thindraw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
 {
-  Coord x = 0;
-  unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
-  FontType *font = &PCB->Font;
+  Coord dx, dy, ox, oy;
+  double h;
 
-  while (string && *string)
+  dx = x2 - x1;
+  dy = y2 - y1;
+  if (dx != 0 || dy != 0)
+    h = 0.5 * thick / sqrt (SQUARE (dx) + SQUARE (dy));
+  else
+    h = 0.0;
+  ox = dy * h + 0.5 * SGN (dy);
+  oy = -(dx * h + 0.5 * SGN (dx));
+  hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+  if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
     {
-      /* draw lines if symbol is valid and data is present */
-      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
-        {
-          LineType *line = font->Symbol[*string].Line;
-          LineType newline;
-
-          for (n = font->Symbol[*string].LineN; n; n--, line++)
-            {
-              /* create one line, scale, move, rotate and swap it */
-              newline = *line;
-              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
-              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
-              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
-              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
-              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
-              if (newline.Thickness < min_line_width)
-                newline.Thickness = min_line_width;
-
-              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
-
-              /* the labels of SMD objects on the bottom
-               * side haven't been swapped yet, only their offset
-               */
-              if (TEST_FLAG (ONSOLDERFLAG, Text))
-                {
-                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
-                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
-                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
-                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
-                }
-              /* add offset and draw line */
-              newline.Point1.X += Text->X;
-              newline.Point1.Y += Text->Y;
-              newline.Point2.X += Text->X;
-              newline.Point2.Y += Text->Y;
-              hid_draw_pcb_line (gc, &newline);
-            }
-
-          /* move on to next cursor position */
-          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
-        }
-      else
-        {
-          /* the default symbol is a filled box */
-          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
-          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
-
-          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
-          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
-          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
-          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
-
-          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
-
-          /* add offset and draw box */
-          defaultsymbol.X1 += Text->X;
-          defaultsymbol.Y1 += Text->Y;
-          defaultsymbol.X2 += Text->X;
-          defaultsymbol.Y2 += Text->Y;
-          hid_draw_fill_rect (gc, defaultsymbol.X1, defaultsymbol.Y1,
-                                  defaultsymbol.X2, defaultsymbol.Y2);
-
-          /* move on to next cursor position */
-          x += size;
-        }
-      string++;
+      Angle angle = atan2 (dx, dy) * 57.295779;
+      hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+      hid_draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
+      hid_draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
     }
 }
 
+
+/*-----------------------------------------------------------
+ * Draws the outline of an arc
+ */
 static void
-fill_contour (hidGC gc, PLINE *pl)
+thindraw_arc (hidGC gc, Coord X, Coord Y, Coord wx, Coord wy, Angle sa, Angle dir, Coord thick)
 {
-  Coord *x, *y, n, i = 0;
-  VNODE *v;
+  ArcType arc;
+  BoxType *bx;
+  Coord wid = thick / 2;
 
-  n = pl->Count;
-  x = (Coord *)malloc (n * sizeof (*x));
-  y = (Coord *)malloc (n * sizeof (*y));
-
-  for (v = &pl->head; i < n; v = v->next)
-    {
-      x[i] = v->point[0];
-      y[i++] = v->point[1];
-    }
-
-  hid_draw_fill_polygon (gc, n, x, y);
-
-  free (x);
-  free (y);
+  arc.X = X;
+  arc.Y = Y;
+  arc.StartAngle = sa;
+  arc.Delta = dir;
+  arc.Width = wx;
+  arc.Height = wy;
+  bx = GetArcEnds (&arc);
+  /*  sa = sa - 180; */
+  hid_draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
+  hid_draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
+  hid_draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
+  hid_draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
 }
 
+
 static void
-thindraw_contour (hidGC gc, PLINE *pl)
+common_drc_draw_pcb_line (hidGC gc, LineType *line)
 {
-  VNODE *v;
-  Coord this_x, this_y;
-  Coord next_x, next_y;
-
-  hid_draw_set_line_width (gc, 0);
-  hid_draw_set_line_cap (gc, Round_Cap);
-
-#if 0
-  /* If the contour is round, use an arc drawing routine. */
-  if (pl->is_round)
-    {
-      hid_draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
-      return;
-    }
-#endif
+  orig_class.draw_pcb_line (gc, line);
 
-  /* Need at least two points in the contour */
-  if (pl->head.next == NULL)
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      line->ExtraDrcClearance == 0)
     return;
 
-  this_x = pl->head.point[0];
-  this_y = pl->head.point[1];
-  v = &pl->head;
-
-  do
-    {
-      next_x = v->next->point[0];
-      next_y = v->next->point[1];
-
-      if (v->is_round)
-        {
-          Angle start_angle, end_angle, delta_angle;
-
-          start_angle = TO_DEGREES (atan2 ((v->      point[1] - v->cy), -(v->      point[0] - v->cx)));
-          end_angle   = TO_DEGREES (atan2 ((v->next->point[1] - v->cy), -(v->next->point[0] - v->cx)));
-          delta_angle = end_angle - start_angle;
-
-          if (delta_angle > 180.) delta_angle -= 360.;
-          if (delta_angle < -180.) delta_angle += 360.;
-
-          hid_draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
-
-          /* Fill the head vertex */
-          if (v == &pl->head)
-            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
-          else
-            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
-        }
-      else
-        {
-          if (v == &pl->head)
-            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (1.5));
-          else
-            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (1.5), MIL_TO_COORD (1.5), 0, 360);
-          hid_draw_line (gc, this_x, this_y, next_x, next_y);
-        }
-
-      this_x = next_x;
-      this_y = next_y;
-    }
-  while ((v = v->next) != &pl->head);
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_line (gc, line->Point1.X, line->Point1.Y,
+                     line->Point2.X, line->Point2.Y,
+                     line->Thickness + line->ExtraDrcClearance * 2);
 }
 
 static void
-fill_contour_cb (PLINE *pl, void *user_data)
+common_drc_draw_pcb_arc (hidGC gc, ArcType *arc)
 {
-  hidGC gc = (hidGC)user_data;
-  PLINE *local_pl = pl;
-
-  fill_contour (gc, pl);
-  poly_FreeContours (&local_pl);
-}
+  orig_class.draw_pcb_arc (gc, arc);
 
-static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
-{
-  PLINE *pl_copy;
-  POLYAREA *clip_poly;
-  POLYAREA *piece_poly;
-  POLYAREA *clipped_pieces;
-  POLYAREA *draw_piece;
-  int x;
-
-  clip_poly = RectPoly (clip_box->X1, clip_box->X2,
-                        clip_box->Y1, clip_box->Y2);
-  poly_CopyContour (&pl_copy, pl);
-  piece_poly = poly_Create ();
-  poly_InclContour (piece_poly, pl_copy);
-  x = poly_Boolean_free (piece_poly, clip_poly,
-                         &clipped_pieces, PBO_ISECT);
-  if (x != err_ok || clipped_pieces == NULL)
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      arc->ExtraDrcClearance == 0)
     return;
 
-  draw_piece = clipped_pieces;
-  do
-    {
-      /* NB: The polygon won't have any holes in it */
-      fill_contour (gc, draw_piece->contours);
-    }
-  while ((draw_piece = draw_piece->f) != clipped_pieces);
-  poly_Free (&clipped_pieces);
+  hid_draw_set_color (gc, Settings.CrossColor);
+  hid_draw_set_line_width (gc, 0);
+  thindraw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta, arc->Thickness + arc->ExtraDrcClearance * 2);
 }
 
-/* If at least 50% of the bounding box of the polygon is on the screen,
- * lets compute the complete no-holes polygon.
+#if 0
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
  */
-#define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
-static int
-should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
+static void
+common_drc_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
 {
-  Coord x1, x2, y1, y2;
-  double poly_bounding_area;
-  double clipped_poly_area;
-
-  /* If there is no passed clip box, compute the whole thing */
-  if (clip_box == NULL)
-    return 1;
-
-  x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, clip_box->Y2);
-
-  /* Check if the polygon is outside the clip box */
-  if ((x2 <= x1) || (y2 <= y1))
-    return 0;
-
-  poly_bounding_area = (double)(poly->BoundingBox.X2 - poly->BoundingBox.X1) *
-                       (double)(poly->BoundingBox.Y2 - poly->BoundingBox.Y1);
-
-  clipped_poly_area = (double)(x2 - x1) * (double)(y2 - y1);
-
-  if (clipped_poly_area / poly_bounding_area >= BOUNDS_INSIDE_CLIP_THRESHOLD)
-    return 1;
-
-  return 0;
+  orig_class.draw_pcb_text (gc, Text, min_line_width);
 }
-#undef BOUNDS_INSIDE_CLIP_THRESHOLD
+#endif
 
 void
-common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+common_drc_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
 {
-  if (polygon->Clipped == NULL)
-    return;
-
-  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    hid_draw_thin_pcb_polygon (gc, polygon, clip_box);
-  else
-    hid_draw_fill_pcb_polygon (gc, polygon, clip_box);
-
-  /* If checking planes, thin-draw any pieces which have been clipped away */
-  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
-    {
-      PolygonType poly = *polygon;
-
-      for (poly.Clipped = polygon->Clipped->f;
-           poly.Clipped != polygon->Clipped;
-           poly.Clipped = poly.Clipped->f)
-        hid_draw_thin_pcb_polygon (gc, &poly, clip_box);
-    }
+  orig_class.draw_pcb_polygon (gc, polygon, clip_box);
 }
 
 void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
-{
-  if (poly->Clipped == NULL)
-    return;
-
-  if (!poly->NoHolesValid)
-    {
-      /* If enough of the polygon is on-screen, compute the entire
-       * NoHoles version and cache it for later rendering, otherwise
-       * just compute what we need to render now.
-       */
-      if (should_compute_no_holes (poly, clip_box))
-        ComputeNoHoles (poly);
-      else
-        NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
-    }
-  if (poly->NoHolesValid && poly->NoHoles)
-    {
-      PLINE *pl;
-
-      for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
-        {
-          if (clip_box == NULL)
-            fill_contour (gc, pl);
-          else
-            fill_clipped_contour (gc, pl, clip_box);
-        }
-    }
-
-  /* Draw other parts of the polygon if fullpoly flag is set */
-  /* NB: No "NoHoles" cache for these */
-  if (TEST_FLAG (FULLPOLYFLAG, poly))
-    {
-      PolygonType p = *poly;
-
-      for (p.Clipped = poly->Clipped->f;
-           p.Clipped != poly->Clipped;
-           p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
-    }
-}
-
-static int
-thindraw_hole_cb (PLINE *pl, void *user_data)
+common_drc_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
-  hidGC gc = (hidGC)user_data;
-  thindraw_contour (gc, pl);
-  return 0;
+  orig_class.fill_pcb_polygon (gc, poly, clip_box);
 }
 
 void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+common_drc_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
                              const BoxType *clip_box)
 {
-  if (poly->Clipped == NULL)
-    return;
-
-  thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
-
-  /* Draw other parts of the polygon if fullpoly flag is set */
-  if (TEST_FLAG (FULLPOLYFLAG, poly))
-    {
-      PolygonType p = *poly;
-
-      for (p.Clipped = poly->Clipped->f;
-           p.Clipped != poly->Clipped;
-           p.Clipped = p.Clipped->f)
-        {
-          thindraw_contour (gc, p.Clipped->contours);
-          PolygonHoles (&p, clip_box, thindraw_hole_cb, gc);
-        }
-    }
+  orig_class.thindraw_pcb_polygon (gc, poly, clip_box);
 }
 
 void
-common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
-{
-  Coord w = clear ? (mask ? pad->Mask
-                          : pad->Thickness + pad->Clearance)
-                  : pad->Thickness;
-  Coord x1, y1, x2, y2;
-  Coord t = w / 2;
-  x1 = pad->Point1.X;
-  y1 = pad->Point1.Y;
-  x2 = pad->Point2.X;
-  y2 = pad->Point2.Y;
-  if (x1 > x2 || y1 > y2)
-    {
-      Coord temp_x = x1;
-      Coord temp_y = y1;
-      x1 = x2; x2 = temp_x;
-      y1 = y2; y2 = temp_y;
-    }
-  hid_draw_set_line_cap (gc, Round_Cap);
-  hid_draw_set_line_width (gc, 0);
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      /* slanted square pad */
-      double tx, ty, theta;
-
-      if (x1 == x2 && y1 == y2)
-        theta = 0;
-      else
-        theta = atan2 (y2 - y1, x2 - x1);
-
-      /* T is a vector half a thickness long, in the direction of
-         one of the corners.  */
-      tx = t * cos (theta + M_PI / 4) * sqrt (2.0);
-      ty = t * sin (theta + M_PI / 4) * sqrt (2.0);
-
-      hid_draw_line (gc, x1 - tx, y1 - ty, x2 + ty, y2 - tx);
-      hid_draw_line (gc, x2 + ty, y2 - tx, x2 + tx, y2 + ty);
-      hid_draw_line (gc, x2 + tx, y2 + ty, x1 - ty, y1 + tx);
-      hid_draw_line (gc, x1 - ty, y1 + tx, x1 - tx, y1 - ty);
-    }
-  else if (x1 == x2 && y1 == y2)
-    {
-      hid_draw_arc (gc, x1, y1, t, t, 0, 360);
-    }
-  else
-    {
-      /* Slanted round-end pads.  */
-      Coord dx, dy, ox, oy;
-      double h;
-
-      dx = x2 - x1;
-      dy = y2 - y1;
-      h = t / sqrt (SQUARE (dx) + SQUARE (dy));
-      ox = dy * h + 0.5 * SGN (dy);
-      oy = -(dx * h + 0.5 * SGN (dx));
-
-      hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
-
-      if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
-        {
-          Angle angle = atan2 (dx, dy) * 57.295779;
-          hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-          hid_draw_arc (gc, x1, y1, t, t, angle - 180, 180);
-          hid_draw_arc (gc, x2, y2, t, t, angle, 180);
-        }
-    }
-}
-
-/* Computes the coordinates of the corners of a squared pad.  */
-static void
-common_get_pad_polygon(Coord x[4], Coord y[4], const PadType *l, int w)
+common_drc_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 {
-  Coord dX, dY;
-  double dwx, dwy;
-
-  dX = l->Point2.X - l->Point1.X;
-  dY = l->Point2.Y - l->Point1.Y;
-
-  if (dY == 0)
-    {
-      dwx = w / 2;
-      dwy = 0;
-    }
-  else if (dX == 0)
-    {
-      dwx = 0;
-      dwy = w / 2;
-    }
-  else
-    {
-      double r;
+  PadType drc_pad;
 
-      r = sqrt (dX * (double) dX + dY * (double) dY) * 2;
-      dwx = w / r * dX;
-      dwy =  w / r * dY;
-    }
+  orig_class.thindraw_pcb_pad (gc, pad, clear, mask);
 
-  x[0] = l->Point1.X - dwx + dwy;
-  y[0] = l->Point1.Y - dwy - dwx;
-
-  x[1] = l->Point1.X - dwx - dwy;
-  y[1] = l->Point1.Y - dwy + dwx;
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
 
-  x[2] = l->Point2.X + dwx - dwy;
-  y[2] = l->Point2.Y + dwy + dwx;
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
 
-  x[3] = l->Point2.X + dwx + dwy;
-  y[3] = l->Point2.Y + dwy - dwx;
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
 }
 
 void
-common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+common_drc_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 {
-  Coord w = clear ? (mask ? pad->Mask
-                          : pad->Thickness + pad->Clearance)
-                  : pad->Thickness;
-
-  if (pad->Point1.X == pad->Point2.X &&
-      pad->Point1.Y == pad->Point2.Y)
-    {
-      if (TEST_FLAG (SQUAREFLAG, pad))
-        {
-          Coord l, r, t, b;
-          l = pad->Point1.X - w / 2;
-          b = pad->Point1.Y - w / 2;
-          r = l + w;
-          t = b + w;
-          hid_draw_fill_rect (gc, l, b, r, t);
-        }
-      else
-        {
-          hid_draw_fill_circle (gc, pad->Point1.X, pad->Point1.Y, w / 2);
-        }
-    }
-  else
-    {
-      hid_draw_set_line_cap (gc, TEST_FLAG (SQUAREFLAG, pad) ? Square_Cap : Round_Cap);
-      hid_draw_set_line_width (gc, w);
-
-      if (TEST_FLAG (SQUAREFLAG, pad))
-        {
-          Coord x[4], y[4];
-          common_get_pad_polygon (x, y, pad, w);
-          hid_draw_fill_polygon (gc, 4, x, y);
-        }
-      else
-        hid_draw_line (gc, pad->Point1.X, pad->Point1.Y,
-                           pad->Point2.X, pad->Point2.Y);
-    }
-}
+  PadType drc_pad;
 
-/* ---------------------------------------------------------------------------
- * draws one polygon
- * x and y are already in display coordinates
- * the points are numbered:
- *
- *          5 --- 6
- *         /       \
- *        4         7
- *        |         |
- *        3         0
- *         \       /
- *          2 --- 1
- */
+  orig_class.fill_pcb_pad (gc, pad, clear, mask);
 
-typedef struct
-{
-  double X, Y;
-}
-FloatPolyType;
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pad->ExtraDrcClearance == 0)
+    return;
 
-static void
-draw_octagon_poly (hidGC gc, Coord X, Coord Y,
-                   Coord Thickness, bool thin_draw)
-{
-  static FloatPolyType p[8] = {
-    { 0.5,               -TAN_22_5_DEGREE_2},
-    { TAN_22_5_DEGREE_2, -0.5              },
-    {-TAN_22_5_DEGREE_2, -0.5              },
-    {-0.5,               -TAN_22_5_DEGREE_2},
-    {-0.5,                TAN_22_5_DEGREE_2},
-    {-TAN_22_5_DEGREE_2,  0.5              },
-    { TAN_22_5_DEGREE_2,  0.5              },
-    { 0.5,                TAN_22_5_DEGREE_2}
-  };
-  static int special_size = 0;
-  static int scaled_x[8];
-  static int scaled_y[8];
-  Coord polygon_x[9];
-  Coord polygon_y[9];
-  int i;
-
-  if (Thickness != special_size)
-    {
-      special_size = Thickness;
-      for (i = 0; i < 8; i++)
-        {
-          scaled_x[i] = p[i].X * special_size;
-          scaled_y[i] = p[i].Y * special_size;
-        }
-    }
-  /* add line offset */
-  for (i = 0; i < 8; i++)
-    {
-      polygon_x[i] = X + scaled_x[i];
-      polygon_y[i] = Y + scaled_y[i];
-    }
+  drc_pad = *pad;
+  drc_pad.Clearance = pad->ExtraDrcClearance * 2;
 
-  if (thin_draw)
-    {
-      int i;
-      hid_draw_set_line_cap (gc, Round_Cap);
-      hid_draw_set_line_width (gc, 0);
-      polygon_x[8] = X + scaled_x[0];
-      polygon_y[8] = Y + scaled_y[0];
-      for (i = 0; i < 8; i++)
-        hid_draw_line (gc, polygon_x[i    ], polygon_y[i    ],
-                           polygon_x[i + 1], polygon_y[i + 1]);
-    }
-  else
-    hid_draw_fill_polygon (gc, 8, polygon_x, polygon_y);
+  hid_draw_set_color (gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pad (gc, &drc_pad, true /*clear*/, false /*mask*/);
 }
 
 void
-common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+common_drc_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
 {
-  Coord w = mask ? pv->Mask : pv->Thickness;
-  Coord r = w / 2;
+  PinType drc_pv;
 
-  if (TEST_FLAG (HOLEFLAG, pv))
-    {
-      if (mask)
-	hid_draw_fill_circle (bg_gc, pv->X, pv->Y, r);
-      if (drawHole)
-        {
-          hid_draw_fill_circle (bg_gc, pv->X, pv->Y, r);
-          hid_draw_set_line_cap (fg_gc, Round_Cap);
-          hid_draw_set_line_width (fg_gc, 0);
-          hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
-        }
-      return;
-    }
+  orig_class.fill_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
 
-  if (TEST_FLAG (SQUAREFLAG, pv))
-    {
-      Coord l = pv->X - r;
-      Coord b = pv->Y - r;
-      Coord r = l + w;
-      Coord t = b + w;
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
 
-      hid_draw_fill_rect (fg_gc, l, b, r, t);
-    }
-  else if (TEST_FLAG (OCTAGONFLAG, pv))
-    draw_octagon_poly (fg_gc, pv->X, pv->Y, w, false);
-  else /* draw a round pin or via */
-    hid_draw_fill_circle (fg_gc, pv->X, pv->Y, r);
-
-  /* and the drilling hole  (which is always round) */
-  if (drawHole)
-    hid_draw_fill_circle (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
+  drc_pv = *pv;
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
 }
 
 void
-common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+common_drc_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
 {
-  Coord w = mask ? pv->Mask : pv->Thickness;
-  Coord r = w / 2;
+  PinType drc_pv;
 
-  if (TEST_FLAG (HOLEFLAG, pv))
-    {
-      if (mask)
-	hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
-      if (drawHole)
-        {
-	  r = pv->DrillingHole / 2;
-          hid_draw_set_line_cap (bg_gc, Round_Cap);
-          hid_draw_set_line_width (bg_gc, 0);
-          hid_draw_arc (bg_gc, pv->X, pv->Y, r, r, 0, 360);
-        }
-      return;
-    }
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, pv, drawHole, mask);
 
-  if (TEST_FLAG (SQUAREFLAG, pv))
-    {
-      Coord l = pv->X - r;
-      Coord b = pv->Y - r;
-      Coord r = l + w;
-      Coord t = b + w;
-
-      hid_draw_set_line_cap (fg_gc, Round_Cap);
-      hid_draw_set_line_width (fg_gc, 0);
-      hid_draw_line (fg_gc, r, t, r, b);
-      hid_draw_line (fg_gc, l, t, l, b);
-      hid_draw_line (fg_gc, r, t, l, t);
-      hid_draw_line (fg_gc, r, b, l, b);
+  if (!TEST_FLAG (SHOWDRCFLAG, PCB) ||
+      pv->ExtraDrcClearance == 0)
+    return;
 
-    }
-  else if (TEST_FLAG (OCTAGONFLAG, pv))
-    {
-      draw_octagon_poly (fg_gc, pv->X, pv->Y, w, true);
-    }
-  else /* draw a round pin or via */
-    {
-      hid_draw_set_line_cap (fg_gc, Round_Cap);
-      hid_draw_set_line_width (fg_gc, 0);
-      hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
-    }
+  drc_pv = *pv;
+  pcb_printf ("via clearance was %mn, extra %mn\n", drc_pv.Thickness, pv->ExtraDrcClearance);
+  drc_pv.Thickness += pv->ExtraDrcClearance * 2;
+  pcb_printf ("via clearance is now %mn\n", drc_pv.Thickness);
 
-  /* and the drilling hole  (which is always round */
-  if (drawHole)
-    {
-      hid_draw_set_line_cap (bg_gc, Round_Cap);
-      hid_draw_set_line_width (bg_gc, 0);
-      hid_draw_arc (bg_gc, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
-    }
+  hid_draw_set_color (fg_gc, Settings.CrossColor);
+  orig_class.thindraw_pcb_pv (fg_gc, bg_gc, &drc_pv, false /*drawHole*/, false /*mask*/);
 }
 
 void
-common_draw_helpers_class_init (HID_DRAW_CLASS *klass)
+common_draw_drc_class_init (HID_DRAW_CLASS *klass)
 {
-  klass->draw_pcb_line        = common_draw_pcb_line;
-  klass->draw_pcb_arc         = common_draw_pcb_arc;
-  klass->draw_pcb_text        = common_draw_pcb_text;
-  klass->draw_pcb_polygon     = common_fill_pcb_polygon; /* Default is the non-GUI case */
-
-  klass->fill_pcb_polygon     = common_fill_pcb_polygon;
-  klass->thindraw_pcb_polygon = common_thindraw_pcb_polygon;
-  klass->fill_pcb_pad         = common_fill_pcb_pad;
-  klass->thindraw_pcb_pad     = common_thindraw_pcb_pad;
-  klass->fill_pcb_pv          = common_fill_pcb_pv;
-  klass->thindraw_pcb_pv      = common_thindraw_pcb_pv;
+  orig_class = *klass; /* Copy function pointers from parent... allows chaining */
+
+  klass->draw_pcb_line        = common_drc_draw_pcb_line;
+  klass->draw_pcb_arc         = common_drc_draw_pcb_arc;
+  klass->draw_pcb_polygon     = common_drc_fill_pcb_polygon;
+//  klass->draw_pcb_text        = common_drc_fill_pcb_text;
+
+  klass->fill_pcb_polygon     = common_drc_fill_pcb_polygon;
+  klass->thindraw_pcb_polygon = common_drc_thindraw_pcb_polygon;
+  klass->fill_pcb_pad         = common_drc_fill_pcb_pad;
+  klass->thindraw_pcb_pad     = common_drc_thindraw_pcb_pad;
+  klass->fill_pcb_pv          = common_drc_fill_pcb_pv;
+  klass->thindraw_pcb_pv      = common_drc_thindraw_pcb_pv;
 }
 
 void
-common_draw_helpers_init (HID_DRAW *graphics)
+common_draw_drc_init (HID_DRAW *graphics)
 {
 }
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 763f493..488f530 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -17,6 +17,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "hid/common/hidnogui.h"
+#include "hid/common/draw_drc.h"
 #include "hid/common/draw_helpers.h"
 #include "pcb-printf.h"
 
@@ -2199,6 +2200,7 @@ hid_gtk_init ()
 
   common_nogui_graphics_class_init (&ghid_graphics_class);
   common_draw_helpers_class_init (&ghid_graphics_class);
+  common_draw_drc_class_init (&ghid_graphics_class); /* XXX: Some vfuncs are overridden below, and the drc helpers won't be drawn! */
 
   ghid_graphics_class.set_layer      = ghid_set_layer;
   ghid_graphics_class.make_gc        = ghid_make_gc;
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index 8f5a352..29232bb 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -101,7 +101,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   if (!gtk_tree_selection_get_selected (selection, &model, &iter))
     {
-      if (ClearFlagOnAllObjects (true, FOUNDFLAG))
+      if (ClearFlagOnAllObjects (true, FOUNDFLAG, true))
         {
           IncrementUndoSerialNumber ();
           Draw ();
@@ -115,7 +115,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   gtk_tree_model_get (model, &iter, DRC_VIOLATION_OBJ_COL, &violation, -1);
 
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
 
   if (violation == NULL)
     return;
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index 089aa7c..7be1188 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -536,14 +536,14 @@ netlist_select_cb (GtkWidget * widget, gpointer data)
     node_selected_net = NULL;
 
   InitConnectionLookup ();
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
 
   for (i = selected_net->EntryN, entry = selected_net->Entry; i; i--, entry++)
     if (SeekPad (entry, &conn, false))
       RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, true, FOUNDFLAG, true);
 
   SelectByFlag (FOUNDFLAG, select_flag);
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
   Draw ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 71327b4..1fed021 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -45,6 +45,7 @@
 #include "find.h"
 #include "search.h"
 #include "rats.h"
+#include "netclass.h"
 #include "snavi.h"
 #include "gui-trackball.h"
 
@@ -400,6 +401,7 @@ describe_location (Coord X, Coord Y)
   char *elename = "";
   char *pinname;
   char *netname = NULL;
+  char *netclass = NULL;
   char *description;
 
   /* check if there are any pins or pads at that position */
@@ -438,6 +440,7 @@ describe_location (Coord X, Coord Y)
         netname = g_strdup (menu->Name);
         /* For some reason, the netname has spaces in front of it, strip them */
         g_strstrip (netname);
+        netclass = menu->Netclass;
         break;
       }
     }
@@ -450,10 +453,12 @@ describe_location (Coord X, Coord Y)
 
   description = g_strdup_printf (_("Element name: %s\n"
                                  "Pinname : %s\n"
-                                 "Netname : %s"),
+                                 "Netname : %s\n"
+                                 "Netclass : %s\n"),
                                  elename,
                                  (pinname != NULL) ? pinname : _("--"),
-                                 (netname != NULL) ? netname : _("--"));
+                                 (netname != NULL) ? netname : _("--"),
+                                 (netclass != NULL) ? netclass : _("--"));
 
   g_free (netname);
 
diff --git a/src/line.c b/src/line.c
index 469f0f6..abad924 100644
--- a/src/line.c
+++ b/src/line.c
@@ -41,6 +41,8 @@
 #include "line.h"
 #include "misc.h"
 #include "rtree.h"
+#include "netclass.h"
+#include "draw.h" /* For Redraw */
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -231,6 +233,11 @@ struct drc_info
   bool bottom_side;
   bool top_side;
   jmp_buf env;
+  ElementType *element;
+  LayerType *layer;
+  char *drawn_line_netclass;
+  Coord drawn_line_clearance;
+  Coord max_clearance;
 };
 
 static int
@@ -238,9 +245,56 @@ drcVia_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
 
-  if (!TEST_FLAG (FOUNDFLAG, via) && PinLineIntersect (via, i->line))
-    longjmp (i->env, 1);
+  if (TEST_FLAG (FOUNDFLAG, via))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_via (via);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (via, i->line))
+    {
+      via->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", via->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
+  return 1;
+}
+
+static int
+drcPin_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, pin))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pin (pin);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (PinLineIntersect (pin, i->line))
+    {
+      pin->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pin->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -249,10 +303,27 @@ drcPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, pad) || TEST_FLAG (ONSOLDERFLAG, pad) != i->bottom_side)
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_pad (pad);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
 
-  if (TEST_FLAG (ONSOLDERFLAG, pad) == i->bottom_side &&
-      !TEST_FLAG (FOUNDFLAG, pad) && LinePadIntersect (i->line, pad))
-    longjmp (i->env, 1);
+  if (LinePadIntersect (i->line, pad))
+    {
+      pad->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", pad->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -261,9 +332,27 @@ drcLine_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, line))
+    return 1;
 
-  if (!TEST_FLAG (FOUNDFLAG, line) && LineLineIntersect (line, i->line))
-    longjmp (i->env, 1);
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_line (i->layer, line);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
+
+  if (LineLineIntersect (line, i->line))
+    {
+      line->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", line->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -272,9 +361,27 @@ drcArc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *) b;
   struct drc_info *i = (struct drc_info *) cl;
+  char *netclass;
+  Coord required_drc_clearance;
+  Coord tmp;
+
+  if (TEST_FLAG (FOUNDFLAG, arc))
+    return 1;
+
+  tmp = i->line->Thickness;
+  netclass = get_netclass_for_arc (i->layer, arc);
+  required_drc_clearance = get_clearance_between_netclasses (i->drawn_line_netclass, netclass);
+  i->line->Thickness = Settings.LineThickness + 2 * required_drc_clearance;
 
-  if (!TEST_FLAG (FOUNDFLAG, arc) && LineArcIntersect (i->line, arc))
-    longjmp (i->env, 1);
+  if (LineArcIntersect (i->line, arc))
+    {
+      arc->ExtraDrcClearance = required_drc_clearance - i->drawn_line_clearance;
+//      printf ("Setting ExtraDrcClearance on object to %li\n", arc->ExtraDrcClearance);
+      i->line->Thickness = tmp;
+      if (TEST_FLAG (AUTODRCFLAG, PCB))
+        longjmp (i->env, 1);
+    }
+  i->line->Thickness = tmp;
   return 1;
 }
 
@@ -300,11 +407,15 @@ drc_lines (PointType *end, bool way)
   bool two_lines, x_is_long, blocker;
   PointType ans;
 
+  info.drawn_line_netclass = Crosshair.Netclass;
+  info.drawn_line_clearance = PCB->Bloat; /* XXX: PICK THIS UP FROM MIN CLEARANCE IN line_netclass -> * */
+  info.max_clearance = get_max_clearance_for_netclass (info.drawn_line_netclass);
+
   f = 1.0;
   s = 0.5;
   last = -1;
   line1.Flags = line2.Flags = NoFlags ();
-  line1.Thickness = Settings.LineThickness + 2 * (PCB->Bloat + 1);
+  line1.Thickness = Settings.LineThickness + 2 * info.max_clearance;
   line2.Thickness = line1.Thickness;
   line1.Clearance = line2.Clearance = 0;
   line1.Point1.X = Crosshair.AttachedLine.Point1.X;
@@ -404,38 +515,29 @@ drc_lines (PointType *end, bool way)
 	  if (setjmp (info.env) == 0)
 	    {
 	      info.line = &line1;
-	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
-	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL,
-			drcVia_callback, &info);
+	      r_search (PCB->Data->via_tree, &line1.BoundingBox, NULL, drcVia_callback, &info);
+	      r_search (PCB->Data->pin_tree, &line1.BoundingBox, NULL, drcPin_callback, &info);
 	      if (info.bottom_side || info.top_side)
-		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL,
-			  drcPad_callback, &info);
+		r_search (PCB->Data->pad_tree, &line1.BoundingBox, NULL, drcPad_callback, &info);
 	      if (two_lines)
 		{
 		  info.line = &line2;
-		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
-		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL,
-			    drcVia_callback, &info);
+		  r_search (PCB->Data->via_tree, &line2.BoundingBox, NULL, drcVia_callback, &info);
+		  r_search (PCB->Data->pin_tree, &line2.BoundingBox, NULL, drcPin_callback, &info);
 		  if (info.bottom_side || info.top_side)
-		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL,
-			      drcPad_callback, &info);
+		    r_search (PCB->Data->pad_tree, &line2.BoundingBox, NULL, drcPad_callback, &info);
 		}
 	      GROUP_LOOP (PCB->Data, group);
 	      {
 		info.line = &line1;
-		r_search (layer->line_tree, &line1.BoundingBox, NULL,
-			  drcLine_callback, &info);
-		r_search (layer->arc_tree, &line1.BoundingBox, NULL,
-			  drcArc_callback, &info);
+		info.layer = layer;
+		r_search (layer->line_tree, &line1.BoundingBox, NULL, drcLine_callback, &info);
+		r_search (layer->arc_tree,  &line1.BoundingBox, NULL, drcArc_callback,  &info);
 		if (two_lines)
 		  {
 		    info.line = &line2;
-		    r_search (layer->line_tree, &line2.BoundingBox,
-			      NULL, drcLine_callback, &info);
-		    r_search (layer->arc_tree, &line2.BoundingBox,
-			      NULL, drcArc_callback, &info);
+		    r_search (layer->line_tree, &line2.BoundingBox, NULL, drcLine_callback, &info);
+		    r_search (layer->arc_tree,  &line2.BoundingBox, NULL, drcArc_callback,  &info);
 		  }
 	      }
 	      END_LOOP;
@@ -461,6 +563,11 @@ drc_lines (PointType *end, bool way)
 	    {
 	      /* bumped into something, back off */
 	      f2 -= s2;
+	      //SET_FLAG (WARNFLAG, info.object);
+//	      if (TEST_FLAG (AUTODRCFLAG, PCB))
+//	        info.object->ExtraDrcClearance = MM_TO_COORD (1.0);
+//	      Draw (type, info.ptr1, info.ptr2); /* XXX: Need info */
+//	      Redraw (); /* XXX: Sledgehammer */
 	    }
 	  s2 *= 0.5;
 	  length2 = MIN (f2 * temp2, temp2);
@@ -490,16 +597,75 @@ EnforceLineDRC (void)
   /* Silence a bogus compiler warning by storing this in a variable */
   int layer_idx = INDEXOFCURRENT;
 
+  if (!TEST_FLAG (AUTODRCFLAG, PCB) && !TEST_FLAG (SHOWDRCFLAG, PCB))
+    return;
+
   if ( gui->mod1_is_pressed() || gui->control_is_pressed () || PCB->RatDraw
       || layer_idx >= max_copper_layer)
     return;
 
+  /* Reset ExtraDrcClearance on all objects */
+  GROUP_LOOP (PCB->Data, GetLayerGroupNumberByNumber (INDEXOFCURRENT));
+    {
+      LINE_LOOP (layer);
+        {
+          line->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      ARC_LOOP (layer);
+        {
+          arc->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      POLYGON_LOOP (layer);
+        {
+          polygon->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      TEXT_LOOP (layer);
+        {
+          text->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          pin->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          pad->ExtraDrcClearance = 0;
+        }
+      END_LOOP;
+    }
+  END_LOOP;
+  VIA_LOOP (PCB->Data);
+    {
+      via->ExtraDrcClearance = 0;
+    }
+  END_LOOP;
+
   rs.X = r45.X = Crosshair.X;
   rs.Y = r45.Y = Crosshair.Y;
+
+  if (!TEST_FLAG (AUTODRCFLAG, PCB))
+    {
+      if (TEST_FLAG (ALLDIRECTIONFLAG, PCB)) /* We don't have code to handle this case! */
+        return;
+
+      drc_lines (&rs, (PCB->Clipping == 2) != gui->shift_is_pressed ());
+      return;
+    }
+
   /* first try starting straight */
-  r1 = drc_lines (&rs, false);
+  r1 = drc_lines (&rs, false);              /* XXX: This code doesn't cope well with all-direction lines (?) */
   /* then try starting at 45 */
-  r2 = drc_lines (&r45, true);
+  r2 = drc_lines (&r45, true);              /* XXX: This code doesn't cope well with all-direction lines (?) */
+
   shift = gui->shift_is_pressed ();
   if (XOR (r1 > r2, shift))
     {
diff --git a/src/netclass.c b/src/netclass.c
index 587ffb6..b81d0dc 100644
--- a/src/netclass.c
+++ b/src/netclass.c
@@ -2,20 +2,24 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>
-//#include <stdlib.h>
+//#include <stdio.h>
 #include <string.h>
-#include <assert.h>
+//#include <assert.h>
 
-#include "global.h"
+#include "data.h"
+#include "rats.h"
+#include "find.h"
+#include "undo.h"
+#include "pcb-printf.h"
 #include "netclass.h"
 
-static int num_netclass = 9;
+static int num_netclass = 10;
 
-static char *netclass_names[9] =
+static char *netclass_names[10] =
   {
     NULL,
     "PE",
+    "DC+",
     "BAT+",
     "PHASE1",
     "PHASE2",
@@ -25,17 +29,18 @@ static char *netclass_names[9] =
     "PHASE6"
   };
 
-static Coord clearances[9][9] =
+static Coord clearances[10][10] =
   {
-    {MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0)},
-    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2)}
+    {MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2), MM_TO_COORD (4.0)},
+    {MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (4.0), MM_TO_COORD (0.2)}
   };
 
 
@@ -71,36 +76,274 @@ clearance_between_netclasses (int a, int b)
 }
 
 Coord
+get_min_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord min_clearance = MAX_COORD;
+
+  for (i = 0; i < num_netclass; i++)
+    min_clearance = MIN (min_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up minimum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              min_clearance);
+#endif
+
+  return min_clearance;
+}
+
+Coord
+get_max_clearance_for_netclass (char *netclass)
+{
+  int netclass_i = netclass_index (netclass);
+  int i;
+  Coord max_clearance = 0;
+
+  for (i = 0; i < num_netclass; i++)
+    max_clearance = MAX (max_clearance, clearances[netclass_i][i]);
+
+#if 0
+  pcb_printf ("Looking up maximum clearance for netclass %s%s%s, found '%mn'\n",
+              netclass != NULL ? "'" : "",
+              netclass != NULL ? netclass : "(NULL)",
+              netclass != NULL ? "'" : "",
+              max_clearance);
+#endif
+
+  return max_clearance;
+}
+
+Coord
 get_clearance_between_netclasses (char *netclass_a, char *netclass_b)
 {
   int a = netclass_index (netclass_a);
   int b = netclass_index (netclass_b);
+  Coord clearance = clearance_between_netclasses (a, b);
+
+#if 0
+  pcb_printf ("Looking up clearance between netclass %s%s%s and %s%s%s, found '%mn'\n",
+              netclass_a != NULL ? "'" : "",
+              netclass_a != NULL ? netclass_a : "(NULL)",
+              netclass_a != NULL ? "'" : "",
+              netclass_b != NULL ? "'" : "",
+              netclass_b != NULL ? netclass_b : "(NULL)",
+              netclass_b != NULL ? "'" : "",
+              clearance);
+#endif
 
-  return clearance_between_netclasses (a, b);
+  return clearance;
 }
 
 char *
 get_netclass_for_netname (char *netname)
 {
+  char *menu_netname;
+
+//  g_return_val_if_fail (netname != NULL, NULL);
+  if (netname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      menu_netname = g_strdup (menu->Name);
+      /* For some reason, the netname has spaces in front of it, strip them */
+      g_strstrip (menu_netname);
+      if (strcmp (menu_netname, netname) == 0) {
+        g_free (menu_netname);
+        return menu->Netclass;
+      }
+      g_free (menu_netname);
+    }
+    END_LOOP;
+  }
+  END_LOOP;
+
   return NULL;
 }
 
+static char *
+g_strdup_netname_for_pinpad (int type, ElementType *ele, void *pinpad)
+{
+  char *pinname;
+  char *netname = NULL;
+
+  pinname = ConnectionName (type, ele, pinpad);
+
+  if (pinname == NULL)
+    return NULL;
+
+  /* Find netlist entry */
+  MENU_LOOP (&PCB->NetlistLib);
+  {
+    if (!menu->Name)
+    continue;
+
+    ENTRY_LOOP (menu);
+    {
+      if (!entry->ListEntry)
+        continue;
+
+      if (strcmp (entry->ListEntry, pinname) == 0) {
+        netname = g_strdup (menu->Name);
+        /* For some reason, the netname has spaces in front of it, strip them */
+        g_strstrip (netname);
+        break;
+      }
+    }
+    END_LOOP;
+
+    if (netname != NULL)
+      break;
+  }
+  END_LOOP;
+
+  return netname;
+}
+
 char *
-get_netclass_for_pin ()
+get_netclass_for_via (PinType *via)
 {
   char *netname = NULL;
+  char *netclass;
 
-//  netname = lookup_netname_for_pin (...);
+//  netname = g_strdup_netname_for_via (pin->Element, via);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pin (PinType *pin)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+//  printf ("Looking up netname for pin, found '%s'\n", netname);
+  netclass = get_netclass_for_netname (netname);
+//  printf ("Looking up netclass for netname, found '%s'\n", netclass);
+  g_free (netname);
+
+  return netclass;
+}
+
+char *
+get_netclass_for_pad (PadType *pad)
+{
+  char *netname = NULL;
+  char *netclass;
+
+  netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+  netclass = get_netclass_for_netname (netname);
+  g_free (netname);
+
+  return netclass;
+}
+
+static char *
+find_first_flagged_netname (int flag)
+{
+  char *netname = NULL;
+
+  ELEMENT_LOOP (PCB->Data);
+    {
+      PIN_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pin))
+            {
+              netname = g_strdup_netname_for_pinpad (PIN_TYPE, pin->Element, pin);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      PAD_LOOP (element);
+        {
+          if (TEST_FLAG (flag, pad))
+            {
+              netname = g_strdup_netname_for_pinpad (PAD_TYPE, pad->Element, pad);
+              if (netname != NULL)
+                break;
+            }
+        }
+      END_LOOP;
+      if (netname != NULL)
+        break;
+    }
+  END_LOOP;
+
+  return netname;
+}
+
+/* NB: THIS CALL IS EXPENSIVE!! */
+char *
+find_netname_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /* store_undo */);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupObject (type, ptr1, ptr2, ptr3, false /*AndDraw*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+static char *
+find_netname_at_xy (LayerType *layer, Coord x, Coord y)
+{
+  char *netname;
+  int flag = CONNECTEDFLAG;
+  ClearFlagOnAllObjects (false /*AndDraw*/, flag, true /*store_undo*/);
+  /* Find a pin / pad which is connected, and grab the netname from this */
+  LookupConnection (x, y, false /*AndDraw*/, 0 /*Range*/, flag, true /*AndRats*/, true /*store_undo*/);
+  netname = find_first_flagged_netname (flag);
+  Undo (true);
+  return netname;
+}
+
+char *
+get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3)
+{
+  char *netname = NULL;
+
+  netname = find_netname_for_object (type, ptr1, ptr2, ptr3);
 
   return get_netclass_for_netname (netname);
 }
 
 char *
+get_netclass_for_line (LayerType *layer, LineType *line)
+{
+  return get_netclass_for_object (LINE_TYPE, layer, line, NULL);
+}
+
+char *
+get_netclass_for_arc (LayerType *layer, ArcType *arc)
+{
+  return get_netclass_for_object (ARC_TYPE, layer, arc, NULL);
+}
+
+char *
 get_netclass_at_xy (LayerType *layer, Coord x, Coord y)
 {
   char *netname = NULL;
 
-//  netname = find_netname_at_xy (layer, x, y);
+  netname = find_netname_at_xy (layer, x, y);
 
   return get_netclass_for_netname (netname);
 }
diff --git a/src/netclass.h b/src/netclass.h
index 414b38b..bb6f51c 100644
--- a/src/netclass.h
+++ b/src/netclass.h
@@ -1,4 +1,11 @@
 
+Coord get_min_clearance_for_netclass (char *netclass);
+Coord get_max_clearance_for_netclass (char *netclass);
 Coord get_clearance_between_netclasses (char *netclass_a, char *netclass_b);
-char *get_netclass_for_pin ();
+char *get_netclass_for_object (int type, void *ptr1, void *ptr2, void *ptr3);
+char *get_netclass_for_via (PinType *via);
+char *get_netclass_for_pin (PinType *pin);
+char *get_netclass_for_pad (PadType *pad);
+char *get_netclass_for_line (LayerType *layer, LineType *line);
+char *get_netclass_for_arc (LayerType *layer, ArcType *arc);
 char *get_netclass_at_xy (LayerType *layer, Coord x, Coord y);
diff --git a/src/netlist.c b/src/netlist.c
index f420fac..7114ae0 100644
--- a/src/netlist.c
+++ b/src/netlist.c
@@ -163,7 +163,7 @@ netlist_find (LibraryMenuType * net, LibraryEntryType * pin)
   int x, y;
   if (pin_name_to_xy (net->Entry, &x, &y))
     return;
-  LookupConnection (x, y, 1, 1, FOUNDFLAG, true);
+  LookupConnection (x, y, 1, 1, FOUNDFLAG, true, true);
 }
 
 static void
@@ -172,7 +172,7 @@ netlist_select (LibraryMenuType * net, LibraryEntryType * pin)
   int x, y;
   if (pin_name_to_xy (net->Entry, &x, &y))
     return;
-  LookupConnection (x, y, 1, 1, SELECTEDFLAG, true);
+  LookupConnection (x, y, 1, 1, SELECTEDFLAG, true, true);
 }
 
 static void
@@ -241,10 +241,19 @@ netlist_style (LibraryMenuType *net, const char *style)
   net->Style = STRDUP ((char *)style);
 }
 
+#if 0
+static void
+netlist_netclass (LibraryMenuType *net, const char *netclass)
+{
+  free (net->Netclass);
+  net->Style = STRDUP ((char *)netclass);
+}
+#endif
+
 /* The primary purpose of this action is to rebuild a netlist from a
    script, in conjunction with the clear action above.  */
 static int
-netlist_add (const char *netname, const char *pinname)
+netlist_add (const char *netname, const char *pinname, const char *netclass)
 {
   int ni, pi;
   LibraryType *netlist = &PCB->NetlistLib;
@@ -259,7 +268,12 @@ netlist_add (const char *netname, const char *pinname)
       }
   if (net == NULL)
     {
-      net = CreateNewNet (netlist, (char *)netname, NULL);
+      net = CreateNewNet (netlist, (char *)netname, NULL, (char *)netclass); /* XXX: Only takes class from the first net */
+    }
+  else
+    {
+      if (strcmp (net->Netclass, netclass) != 0)
+        g_warning ("Netclass '%s' different to initial '%s'... being ignored", netclass, net->Netclass);
     }
 
   for (pi=0; pi<net->EntryN; pi++)
@@ -387,7 +401,7 @@ Netlist (int argc, char **argv, Coord x, Coord y)
   else if (strcasecmp (argv[0], "add") == 0)
     {
       /* Add is different, because the net/pin won't already exist.  */
-      return netlist_add (ARG(1), ARG(2));
+      return netlist_add (ARG(1), ARG(2), NULL); /* Net class? */
     }
   else if (strcasecmp (argv[0], "sort") == 0)
     {
diff --git a/src/parse_y.y b/src/parse_y.y
index 79dc75b..8c42d0f 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -1844,9 +1844,17 @@ The routing style that should be used when autorouting this net.
 
 net
 			/* name style pin pin ... */
-		: T_NET '(' STRING STRING ')' '('
+		: T_NET '(' STRING STRING STRING ')' '('
 			{
-				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4);
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, $5);
+				free ($3);
+				free ($4);
+				free ($5);
+			}
+		 connections ')'
+		| T_NET '(' STRING STRING ')' '('
+			{
+				Menu = CreateNewNet(&yyPCB->NetlistLib, $3, $4, NULL);
 				free ($3);
 				free ($4);
 			}
diff --git a/src/rats.c b/src/rats.c
index 5c48055..c35f515 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -458,7 +458,7 @@ GatherSubnets (NetListType *Netl, bool NoWarn, bool AndRats)
   for (m = 0; Netl->NetN > 0 && m < Netl->NetN; m++)
     {
       a = &Netl->Net[m];
-      ClearFlagOnAllObjects (false, DRCFLAG);
+      ClearFlagOnAllObjects (false, DRCFLAG, false);
       RatFindHook (a->Connection[0].type, a->Connection[0].ptr1,
                    a->Connection[0].ptr2, a->Connection[0].ptr2,
                    false, DRCFLAG, AndRats);
@@ -537,7 +537,7 @@ GatherSubnets (NetListType *Netl, bool NoWarn, bool AndRats)
       if (!NoWarn)
 	Warned |= CheckShorts (a->Connection[0].menu);
     }
-  ClearFlagOnAllObjects (false, DRCFLAG);
+  ClearFlagOnAllObjects (false, DRCFLAG, false);
   return (Warned);
 }
 
diff --git a/src/report.c b/src/report.c
index 1e49d9d..e9a1cba 100644
--- a/src/report.c
+++ b/src/report.c
@@ -569,7 +569,7 @@ XYtoNetLength (Coord x, Coord y, int *found)
   /* NB: The third argument here, 'false' ensures LookupConnection
    *     does not add its changes to the undo system.
    */
-  LookupConnection (x, y, false, PCB->Grid, FOUNDFLAG, true);
+  LookupConnection (x, y, false, PCB->Grid, FOUNDFLAG, true, false);
 
   ALLLINE_LOOP (PCB->Data);
   {
@@ -616,7 +616,7 @@ ReportAllNetLengths (int argc, char **argv, Coord x, Coord y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() at the end of the procedure.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   for (ni = 0; ni < PCB->NetlistLib.MenuN; ni++)
@@ -678,14 +678,14 @@ ReportAllNetLengths (int argc, char **argv, Coord x, Coord y)
           length = XYtoNetLength (x, y, &found);
 
           /* Reset connectors for the next lookup */
-          ClearFlagOnAllObjects (false, FOUNDFLAG);
+          ClearFlagOnAllObjects (false, FOUNDFLAG, false);
 
           pcb_snprintf(buf, sizeof (buf), _("%$m*"), units_name, length);
           gui->log(_("Net %s length %s\n"), netname, buf);
         }
     }
 
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
   return 0;
 }
@@ -707,14 +707,14 @@ ReportNetLength (int argc, char **argv, Coord x, Coord y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() at the end of the procedure.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   length = XYtoNetLength (x, y, &found);
 
   if (!found)
     {
-      ClearFlagOnAllObjects (false, FOUNDFLAG);
+      ClearFlagOnAllObjects (false, FOUNDFLAG, false);
       Undo (true);
       gui->log (_("No net under cursor.\n"));
       return 1;
@@ -776,7 +776,7 @@ ReportNetLength (int argc, char **argv, Coord x, Coord y)
   END_LOOP;
 
 got_net_name:
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
 
   {
@@ -913,13 +913,13 @@ ReportNetLengthByName (char *tofind, int x, int y)
    * by resetting the connections with ClearFlagOnAllObjects() before
    * calling Undo() when we are finished.
    */
-  ClearFlagOnAllObjects (true, FOUNDFLAG);
+  ClearFlagOnAllObjects (true, FOUNDFLAG, true);
   IncrementUndoSerialNumber ();
 
   length = XYtoNetLength (x, y, &found);
   netname = net->Name + 2;
 
-  ClearFlagOnAllObjects (false, FOUNDFLAG);
+  ClearFlagOnAllObjects (false, FOUNDFLAG, false);
   Undo (true);
 
   if (!found)
diff --git a/src/select.c b/src/select.c
index 3e231d0..2c49342 100644
--- a/src/select.c
+++ b/src/select.c
@@ -976,7 +976,7 @@ SelectObjectByName (int Type, char *Pattern, bool select)
   if (Type & NET_TYPE)
     {
       InitConnectionLookup ();
-      changed = ClearFlagOnAllObjects (true, FOUNDFLAG) || changed;
+      changed = ClearFlagOnAllObjects (true, FOUNDFLAG, true) || changed;
 
       MENU_LOOP (&PCB->NetlistLib);
       {
@@ -997,7 +997,7 @@ SelectObjectByName (int Type, char *Pattern, bool select)
       END_LOOP;
 
       changed = SelectByFlag (FOUNDFLAG, select) || changed;
-      changed = ClearFlagOnAllObjects (false, FOUNDFLAG) || changed;
+      changed = ClearFlagOnAllObjects (false, FOUNDFLAG, false) || changed;
       FreeConnectionLookupMemory ();
     }
 
diff --git a/src/set.c b/src/set.c
index 9bf64b8..03b452a 100644
--- a/src/set.c
+++ b/src/set.c
@@ -300,7 +300,7 @@ SetMode (int Mode)
       Crosshair.AttachedLine.State = STATE_FIRST;
       if (Mode == LINE_MODE && TEST_FLAG (AUTODRCFLAG, PCB))
 	{
-	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG))
+	  if (ClearFlagOnAllObjects (true, CONNECTEDFLAG | FOUNDFLAG, true))
 	    {
 	      IncrementUndoSerialNumber ();
 	      Draw ();
