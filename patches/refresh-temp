Bottom: 85e07ae84b10661f6c4c5279d4210e52d1ac5761
Top:    2dc0413d723630f43ba512d176eca5f287838dc6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:39:18 +0000

Refresh of fix-3d-contour-export-0

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index a64a451..2352729 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -25,7 +25,7 @@
 
 #define PERFECT_ROUND_CONTOURS
 
-//#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
 #undef REVERSED_PCB_CONTOURS
 
 #ifdef REVERSED_PCB_CONTOURS
@@ -294,6 +294,15 @@ object3d_from_contours (const POLYAREA *contours,
   int start_of_ct;
   int offset_in_ct;
   int ct_npoints;
+  bool invert_face_normals;
+  double length;
+  double nx, ny;
+
+#ifdef REVERSED_PCB_CONTOURS
+  invert_face_normals = true;
+#else
+  invert_face_normals = false;
+#endif
 
   if (contours == NULL)
     return NULL;
@@ -370,39 +379,29 @@ object3d_from_contours (const POLYAREA *contours,
 
       object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-#ifdef REVERSED_PCB_CONTOURS
       face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
-#else
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-#endif
     }
 
-    faces[npoints] = make_face3d (); /* bottom_face */
-#ifdef REVERSED_PCB_CONTOURS
-    face3d_set_normal (faces[npoints], 0., 0., -1.);
-#else
-    face3d_set_normal (faces[npoints], 0., 0., 1.); /* PCB bottom is at positive Z in this scheme */
-#endif
-    face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (object, faces[npoints]);
-
+    faces[npoints    ] = make_face3d (); /* bottom_face */
     faces[npoints + 1] = make_face3d (); /* top_face */
-#ifdef REVERSED_PCB_CONTOURS
-    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-#else
-    face3d_set_normal (faces[npoints + 1], 0., 0., -1.); /* PCB top is at negative Z in this scheme */
-#endif
+    if (invert_face_normals)
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0., -1.); /* bottom_face */
+        face3d_set_normal (faces[npoints + 1], 0., 0.,  1.); /* top_face */
+      }
+    else
+      {
+        face3d_set_normal (faces[npoints    ], 0., 0.,  1.); /* bottom_face */ /* PCB bottom is at positive Z in this scheme */
+        face3d_set_normal (faces[npoints + 1], 0., 0., -1.); /* top_face */    /* PCB top is at negative Z in this scheme */
+      }
+    face3d_set_appearance (faces[npoints    ], top_bot_appearance);
     face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (object, faces[npoints    ]);
     object3d_add_face (object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-#ifdef REVERSED_PCB_CONTOURS
-    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
     face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
-#else
-    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-#endif
 
     ct = contour;
     start_of_ct = 0;
@@ -421,13 +420,8 @@ object3d_from_contours (const POLYAREA *contours,
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-#ifdef REVERSED_PCB_CONTOURS
-        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
-#else
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-#endif
+      face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
       }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -435,14 +429,21 @@ object3d_from_contours (const POLYAREA *contours,
 
       /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
       /* Define the (non-normalized) face normal to point to the outside of the contour */
-#if REVERSED_PCB_CONTOURS
       /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
-      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
-                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-#else
-      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-#endif
+
+      nx =  (vertices[next_i_around_ct]->y - vertices[i]->y);
+      ny = -(vertices[next_i_around_ct]->x - vertices[i]->x);
+      length = hypot (nx, ny);
+      nx /= length;
+      ny /= length;
+
+      if (invert_face_normals)
+        {
+          nx = -nx;
+          ny = -ny;
+        }
+
+      face3d_set_normal (faces[i], nx, ny, 0.);
 
       /* Assign the appropriate vertex geometric data to each edge end */
       ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -451,45 +452,6 @@ object3d_from_contours (const POLYAREA *contours,
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-#if REVERSED_PCB_CONTOURS
-      RDATA (edges[              i]) = faces[i];
-      LDATA (edges[              i]) = faces[npoints];
-      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      LDATA (edges[1 * npoints + i]) = faces[i];
-      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      LDATA (edges[2 * npoints + i]) = faces[i];
-#else
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
-#endif
-
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
-
-#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], edges[i]);
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
-#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
-#endif
 
       if (get_contour_edge_n_is_round (ct, offset_in_ct))
         {
@@ -502,7 +464,7 @@ object3d_from_contours (const POLYAREA *contours,
           get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
 
           face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
-                                            0., 0., 1., /* Direction of the cylindrical axis */
+                                            0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
                                             radius);
 
           /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
@@ -528,6 +490,25 @@ object3d_from_contours (const POLYAREA *contours,
             edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
         }
 
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
     }
 
     if (0) {
@@ -620,6 +601,47 @@ object3d_from_contours (const POLYAREA *contours,
       splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
       splice (cylinder_edges[1], SYM(cylinder_edges[1]));
     }
+#ifndef NDEBUG
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+      }
+
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+      g_assert (RDATA (edges[              i]) == faces[i]);
+      g_assert (LDATA (edges[              i]) == faces[npoints]);
+      g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+      g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+      g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+      g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+      g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+      g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+      g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+      g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+      g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+      g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+      g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+      g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+      g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+    }
+#endif
 
     objects = g_list_append (objects, object);
 
@@ -647,19 +669,16 @@ object3d_from_board_outline (void)
   appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
 //  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (board_outline,
+#ifdef REVERSED_PCB_CONTOURS
                                     -HACK_BOARD_THICKNESS, /* Bottom */
                                     0                    ,  /* Top */
-                                    board_appearance,
-                                    top_bot_appearance);
 #else
-  objects = object3d_from_contours (board_outline,
                                      HACK_BOARD_THICKNESS / 2, /* Bottom */
                                     -HACK_BOARD_THICKNESS / 2, /* Top */
+#endif
                                     board_appearance,
                                     top_bot_appearance);
-#endif
 
   destroy_appearance (board_appearance);
   destroy_appearance (top_bot_appearance);
@@ -898,19 +917,16 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
   mask_appearance = make_appearance ();
   appearance_set_color (mask_appearance, 0.2, 0.8, 0.2);
 
-#ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (info.poly,
-                                    (side == TOP_SIDE) ? 0                   - HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
-                                    (side == TOP_SIDE) ? HACK_MASK_THICKNESS - HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS,                       /* Top */
-                                    mask_appearance,
-                                    NULL);
+#ifdef REVERSED_PCB_CONTOURS
+                                    (side == TOP_SIDE) ? 0                   + HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
+                                    (side == TOP_SIDE) ? HACK_MASK_THICKNESS + HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS,                       /* Top */
 #else
-  objects = object3d_from_contours (info.poly,
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS                       : HACK_BOARD_THICKNESS / 2 + HACK_COPPER_THICKNESS + HACK_MASK_THICKNESS, /* Bottom */
                                     (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2 + HACK_COPPER_THICKNESS, /* Top */
+#endif
                                     mask_appearance,
                                     NULL);
-#endif
 
   destroy_appearance (mask_appearance);
 
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 5b2cd40..93d7dcc 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -25,7 +25,7 @@
 #include "object3d_step.h"
 
 
-//#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
 #undef REVERSED_PCB_CONTOURS
 
 #define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
@@ -222,7 +222,7 @@ object3d_to_step_body_fragment (step_file *step,
       dir_y = dv->y - ov->y;
       dir_z = dv->z - ov->z;
 
-#if 1
+#if 0
       /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
       if (dir_x < EPSILON && -dir_x < EPSILON &&
           dir_y < EPSILON && -dir_y < EPSILON &&
@@ -280,9 +280,10 @@ object3d_to_step_body_fragment (step_file *step,
 
       edge = contour->first_edge;
       do {
-        edge_loop_edges = g_list_append (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
+        edge_loop_edges = g_list_prepend (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
       } while (edge = LNEXT (edge), edge != contour->first_edge);
 
+      edge_loop_edges = g_list_reverse (edge_loop_edges);
       edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
 
       if (outer_contour)
@@ -290,13 +291,16 @@ object3d_to_step_body_fragment (step_file *step,
       else
         contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
 
-      face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
+      face_contour_list = g_list_prepend (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
     }
 
+    face_contour_list = g_list_reverse (face_contour_list);
     face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
-    shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
+    shell_face_list = g_list_prepend (shell_face_list, GINT_TO_POINTER (face->face_identifier));
   }
 
+  shell_face_list = g_list_reverse (shell_face_list);
+
   /* Closed shell which bounds the brep solid */
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, body_name /* This is picked up as the solid body name by Solidworks */, pcb_shell_identifier);
