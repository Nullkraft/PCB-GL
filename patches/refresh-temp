Bottom: 254272370ce8472deba87c5f5bbc7cdfa4ab9bbc
Top:    66ec033ecac4dc478607879fe5f7b2cbe8022cdc
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 22:04:51 +0000

Refresh of extend-object3d_from_contours

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 5f221ba..ca175bd 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -412,8 +412,8 @@ object3d_from_contours (const POLYAREA *contours,
               offset_in_ct = 0;
               ct = ct->next;
               ct_npoints = get_contour_npoints (ct);
+
             }
-=======
       object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
       if (!extrude_inverted)
@@ -672,147 +672,148 @@ object3d_from_contours (const POLYAREA *contours,
             cylinder_edges[0] = make_edge ();
             UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 =======
-          edge_info_set_round (UNDIR_DATA (edges[i]),
-                               cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
-                               0., 0., normal_z, /* Normal */ radius);
-          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                               cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
-                               0., 0., normal_z, /* Normal */ radius);
-          if (ct->is_round)
-            edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-        }
+              edge_info_set_round (UNDIR_DATA (edges[i]),
+                                   cx, cy, COORD_TO_STEP_Z (PCB, zbot), /* Center of circle */ /* BOTTOM */
+                                   0., 0., normal_z, /* Normal */ radius);
+              edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                                   cx, cy, COORD_TO_STEP_Z (PCB, ztop), /* Center of circle */ /* TOP */
+                                   0., 0., normal_z, /* Normal */ radius);
+              if (ct->is_round)
+                edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+            }
 
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
+          /* NB: Contours are counter clockwise in XY plane.
+           *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+           *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+           *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+           */
 
-      if (extrude_inverted)
-        {
-          LDATA (edges[              i]) = faces[i];
-          RDATA (edges[              i]) = faces[npoints];
-          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          RDATA (edges[1 * npoints + i]) = faces[i];
-          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          RDATA (edges[2 * npoints + i]) = faces[i];
-
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (SYM(edges[prev_i_around_ct]), edges[i]);
-          splice (edges[i], edges[2 * npoints + i]);
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-        }
-      else
-        {
-          RDATA (edges[              i]) = faces[i];
-          LDATA (edges[              i]) = faces[npoints];
-          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-          LDATA (edges[1 * npoints + i]) = faces[i];
-          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-          LDATA (edges[2 * npoints + i]) = faces[i];
-
-          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-          splice (edges[2 * npoints + i], edges[i]);
-          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+          if (extrude_inverted)
+            {
+              LDATA (edges[              i]) = faces[i];
+              RDATA (edges[              i]) = faces[npoints];
+              LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+              RDATA (edges[1 * npoints + i]) = faces[i];
+              LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+              RDATA (edges[2 * npoints + i]) = faces[i];
+
+              /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+              splice (SYM(edges[prev_i_around_ct]), edges[i]);
+              splice (edges[i], edges[2 * npoints + i]);
+              /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+              splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+              splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+            }
+          else
+            {
+              RDATA (edges[              i]) = faces[i];
+              LDATA (edges[              i]) = faces[npoints];
+              RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+              LDATA (edges[1 * npoints + i]) = faces[i];
+              RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+              LDATA (edges[2 * npoints + i]) = faces[i];
+
+              /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+              splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+              splice (edges[2 * npoints + i], edges[i]);
+              /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+              splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+              splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+            }
         }
-    }
 
-    if (0) {
-      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+      if (0)
+        {
+          /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
-      edge_ref cylinder_edges[3];
-      vertex3d *cylinder_vertices[2];
-      face3d *cylinder_faces[2];
+          edge_ref cylinder_edges[3];
+          vertex3d *cylinder_vertices[2];
+          face3d *cylinder_faces[2];
 
-      /* Edge on top of board */
-      cylinder_edges[0] = make_edge ();
-      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
->>>>>>> patched
+          /* Edge on top of board */
+          cylinder_edges[0] = make_edge ();
+          UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 #ifdef REVERSED_PCB_CONTOURS
-            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                  0.,   0., 1., /* Normal */
-                                  5.);          /* Radius */
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);          /* Radius */
 #else
-            edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                                 COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                                  0.,   0., 1., /* Normal */
-                                  5.);         /* Radius */
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                                0.,   0., 1., /* Normal */
+                                5.);         /* Radius */
 #endif
-        object3d_add_edge (object, cylinder_edges[0]);
-
-        /* Edge on top of cylinder */
-        cylinder_edges[1] = make_edge ();
-        UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-        edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
-                              0.,   0., 1.,  /* Normal */
-                              5.);          /* Radius */
-        object3d_add_edge (object, cylinder_edges[1]);
-
-        /* Edge stitching cylinder */
-        cylinder_edges[2] = make_edge ();
-        UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-        edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-        object3d_add_edge (object, cylinder_edges[2]);
-
-        /* Vertex on board top surface */
-        cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-        object3d_add_vertex (object, cylinder_vertices[0]);
-
-        /* Vertex on cylinder top surface */
-        cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-        object3d_add_vertex (object, cylinder_vertices[1]);
-
-        /* Cylindrical face */
-        cylinder_faces[0] = make_face3d ();
-        face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,             /* Direction of the cylindrical axis */
-                                          5.);                   /* Radius of cylinder */
-        face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                     /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-        object3d_add_face (object, cylinder_faces[0]);
-        face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-        /* Top face of cylinder */
-        cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-        face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-        face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-        object3d_add_face (object, cylinder_faces[1]);
-        face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-        /* Splice onto board */
-        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-        /* Assign the appropriate vertex geometric data to each edge end */
-        ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-        DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-        ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-        DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-        ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-        DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-        LDATA (cylinder_edges[0]) = cylinder_faces[0];
-        RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-        LDATA (cylinder_edges[1]) = cylinder_faces[1];
-        RDATA (cylinder_edges[1]) = cylinder_faces[0];
-        LDATA (cylinder_edges[2]) = cylinder_faces[0];
-        RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-        /* Splice things together.... */
-
-        /* Link edges orbiting the cylinder bottom vertex */
-        splice (cylinder_edges[0], cylinder_edges[2]);
-        splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-        /* Link edges orbiting the cylinder top vertex */
-        splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-        splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-      }
+          object3d_add_edge (object, cylinder_edges[0]);
+
+          /* Edge on top of cylinder */
+          cylinder_edges[1] = make_edge ();
+          UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+          edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                               COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                                0.,   0., 1.,  /* Normal */
+                                5.);          /* Radius */
+          object3d_add_edge (object, cylinder_edges[1]);
+
+          /* Edge stitching cylinder */
+          cylinder_edges[2] = make_edge ();
+          UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+          edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+          object3d_add_edge (object, cylinder_edges[2]);
+
+          /* Vertex on board top surface */
+          cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+          object3d_add_vertex (object, cylinder_vertices[0]);
+
+          /* Vertex on cylinder top surface */
+          cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+          object3d_add_vertex (object, cylinder_vertices[1]);
+
+          /* Cylindrical face */
+          cylinder_faces[0] = make_face3d ();
+          face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,             /* Direction of the cylindrical axis */
+                                            5.);                   /* Radius of cylinder */
+          face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                       /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+          object3d_add_face (object, cylinder_faces[0]);
+          face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+          /* Top face of cylinder */
+          cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+          face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+          face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+          object3d_add_face (object, cylinder_faces[1]);
+          face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+          /* Splice onto board */
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+          /* Assign the appropriate vertex geometric data to each edge end */
+          ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+          ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+          DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+          ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+          DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+          LDATA (cylinder_edges[0]) = cylinder_faces[0];
+          RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+          LDATA (cylinder_edges[1]) = cylinder_faces[1];
+          RDATA (cylinder_edges[1]) = cylinder_faces[0];
+          LDATA (cylinder_edges[2]) = cylinder_faces[0];
+          RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+          /* Splice things together.... */
+
+          /* Link edges orbiting the cylinder bottom vertex */
+          splice (cylinder_edges[0], cylinder_edges[2]);
+          splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+          /* Link edges orbiting the cylinder top vertex */
+          splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+          splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+        }
+
 #ifndef NDEBUG
       ct = contour;
       start_of_ct = 0;
@@ -824,7 +825,6 @@ object3d_from_contours (const POLYAREA *contours,
           int next_i_around_ct;
           int prev_i_around_ct;
 
-<<<<<<< current
           /* Update which contour we're looking at */
           if (offset_in_ct == ct_npoints)
             {
@@ -834,7 +834,6 @@ object3d_from_contours (const POLYAREA *contours,
               ct_npoints = get_contour_npoints (ct);
             }
 
-=======
           next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
           prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
