Bottom: 4ff96c389e61cf12dc75174cb117cc27df207a4a
Top:    05826333d3a88d5e00bd733048092c680b3fca1f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-23 17:14:30 +0000

Refresh of more-restructuring-on-3d-model

---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index c973860..97f564d 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,6 +1,7 @@
 #include <glib.h>
 #include <stdint.h>
 #include <stdbool.h>
+#include <stdio.h>
 
 #include <math.h>
 
@@ -248,22 +249,42 @@ sample_circle (edge_ref e)
 static void
 sample_line (edge_ref e)
 {
+  edge_info *info = UNDIR_DATA(e);
   double x, y, z;
 
   allocate_linearised_vertices (e, 2);
 
-  x = ((vertex3d *)ODATA(e))->x;
-  y = ((vertex3d *)ODATA(e))->y;
-  z = ((vertex3d *)ODATA(e))->z;
+  if (info->same_sense)
+    {
+      x = ((vertex3d *)ODATA(e))->x;
+      y = ((vertex3d *)ODATA(e))->y;
+      z = ((vertex3d *)ODATA(e))->z;
+
+      add_vertex (e, x, y, z);
+
+      x = ((vertex3d *)DDATA(e))->x;
+      y = ((vertex3d *)DDATA(e))->y;
+      z = ((vertex3d *)DDATA(e))->z;
+
+      add_vertex (e, x, y, z);
+    }
+  else
+    {
+      /* Unusual, but somtimes occurs */
+      //printf ("****************************************************\n");
+
+      x = ((vertex3d *)DDATA(e))->x;
+      y = ((vertex3d *)DDATA(e))->y;
+      z = ((vertex3d *)DDATA(e))->z;
 
-  add_vertex (e, x, y, z);
+      add_vertex (e, x, y, z);
 
-  x = ((vertex3d *)DDATA(e))->x;
-  y = ((vertex3d *)DDATA(e))->y;
-  z = ((vertex3d *)DDATA(e))->z;
+      x = ((vertex3d *)ODATA(e))->x;
+      y = ((vertex3d *)ODATA(e))->y;
+      z = ((vertex3d *)ODATA(e))->z;
 
-  add_vertex (e, x, y, z);
-  /* Leave end-point */
+      add_vertex (e, x, y, z);
+    }
 }
 
 void
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index 1bb3a11..3f8f936 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -62,6 +62,495 @@
 
 #define CIRC_SEGS_D 64.0
 
+
+#define BUFFER_STRIDE 6 /* 3x vertex + 3x normal */
+
+static void
+emit_tristrip (face3d *face)
+{
+  GLfloat *data_pointer = NULL;
+
+  int count;
+
+//  CHECK_IS_IN_CONTEXT ();
+
+  if (face->tristrip_num_vertices == 0)
+    return;
+
+//  if (priv->buffer.use_vbo) {
+//    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+
+//    if (priv->buffer.use_map) {
+//      glUnmapBuffer (GL_ARRAY_BUFFER);
+//      priv->buffer.triangle_array = NULL;
+//    } else {
+//      glBufferData (GL_ARRAY_BUFFER,
+//                    BUFFER_STRIDE * priv->buffer.vertex_count,
+//                    priv->buffer.triangle_array,
+//                    GL_STREAM_DRAW);
+//    }
+//  } else {
+    data_pointer = face->tristrip_vertices;
+//  }
+
+  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
+  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
+//  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_NORMAL_ARRAY);
+//  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  glTexCoord2f (0.0f, 0.0f);
+
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, face->tristrip_num_vertices);
+#if 0
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glDrawArrays (GL_LINE_STRIP, 0, priv->buffer.vertex_count);
+  glPopAttrib ();
+#endif
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_NORMAL_ARRAY);
+//  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+}
+
+static void
+cylinder_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double refx, refy, refz;
+  double ortx, orty, ortz;
+  double vx, vy, vz;
+  double recip_length;
+  double cosa, sina;
+
+  refx = face->rx;
+  refy = face->ry;
+  refz = face->rz;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  /* v is dot product of vector from surface origin to point, and the axis direction */
+  *v = (x - face->ox) * face->ax +
+       (y - face->oy) * face->ay +
+       (z - face->oz) * face->az;
+
+  /* Find the vector to x,y,z in the plane of the cylinder slice at *v */
+  vx = x - face->ox - *v * face->ax;
+  vy = y - face->oy - *v * face->ay;
+  vz = z - face->oz - *v * face->az;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (vx, vy), vz);
+  vx *= recip_length;
+  vy *= recip_length;
+  vz *= recip_length;
+
+  /* Cosine is dot product of ref (normalised) and v (normalised) */
+  cosa = refx * vx + refy * vy + refz * vz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and v (normalised) */
+  sina = ortx * vx + orty * vy + ortz * vz; // sin (phi) = cos (phi - 90)
+
+  /* U is the angle */
+  *u = atan2 (sina, cosa);
+
+  if (*u < 0.0)
+    *u += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *u *= 180. / M_PI;
+}
+
+static void
+cylinder_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z,
+                               float *nx, float *ny, float *nz)
+{
+  float ortx, orty, ortz;
+  double cosu, sinu;
+  double rcosu, rsinu;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  cosu = cos(u / 180. * M_PI);
+  sinu = sin(u / 180. * M_PI);
+
+  rcosu = face->radius * cosu;
+  rsinu = face->radius * sinu;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + rcosu * face->rx + rsinu * ortx + v * face->ax);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + rcosu * face->ry + rsinu * orty + v * face->ay);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + rcosu * face->rz + rsinu * ortz + v * face->az);
+
+  if (face->surface_orientation_reversed)
+    {
+      *nx = -(cosu * face->rx + sinu * ortx);
+      *ny = cosu * face->ry + sinu * orty; /* XXX: Note this is not negated, presumably due to PCB's coordinate space */
+      *nz = -(cosu * face->rz + sinu * ortz);
+    }
+  else
+    {
+      *nx = cosu * face->rx + sinu * ortx;
+      *ny = -(cosu * face->ry + sinu * orty); /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+      *nz = cosu * face->rz + sinu * ortz;
+    }
+}
+
+static void
+cylinder_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  Vector p_v;
+  VNODE *node;
+  PLINE *p_contour = NULL;
+  POLYAREA *poly;
+  PLINE *dummy_contour;
+  borast_traps_t traps;
+  bool found_outer_contour = false;
+  float u, v;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_cylindrical)
+    return;
+
+  poly = poly_Create ();
+  if (poly == NULL)
+    return;
+
+#if 1
+  /* Create a dummy outer contour (so we don't have to worry about the order below..
+   * when we encounter the outer contour, we substitute this dummy one for it.
+   */
+  p_v[0] = 0;
+  p_v[1] = 0;
+  node = poly_CreateNode (p_v);
+  dummy_contour = poly_NewContour (node);
+  dummy_contour->Flags.orient = PLF_DIR;
+  poly_InclContour (poly, dummy_contour);
+
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      float lost_phase = 0.0;
+      bool first_iteration = true;
+
+      int wobble = 0;
+
+      contour = c_iter->data;
+
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          float lu, lv;
+          float u, v;
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              cylinder_xyz_to_uv (face,
+                                  info->linearised_vertices[vertex_idx * 3 + 0],
+                                  info->linearised_vertices[vertex_idx * 3 + 1],
+                                  info->linearised_vertices[vertex_idx * 3 + 2],
+                                  &u, &v);
+
+              /* Add back on any wrapped phase */
+              u += lost_phase;
+
+              if (!first_iteration)
+                {
+//                  printf ("u = %f, delta since last u = %f\n", (double)u, (double)(u - lu));
+
+                  if (fabs (u - lu) > fabs (u + 360.0f - lu))
+                    {
+//                      printf ("Adding 360 degrees to lost phase\n");
+                      lost_phase += 360.0f;
+                      u += 360.0f;
+                    }
+                  else if (fabs (u - lu) > fabs (u - 360.0f - lu))
+                    {
+//                      printf ("Subtracting 360 degrees to lost phase\n");
+                      lost_phase -= 360.0f;
+                      u -= 360.0f;
+                    }
+                }
+
+
+              wobble = 10 - wobble;
+
+              p_v[0] = MM_TO_COORD (v) + wobble;
+              p_v[1] = MM_TO_COORD (u);
+              node = poly_CreateNode (p_v);
+
+              if (p_contour == NULL)
+                {
+                  if ((p_contour = poly_NewContour (node)) == NULL)
+                    return;
+                }
+              else
+                {
+                  poly_InclVertex (p_contour->head.prev, node);
+                }
+
+              lu = u;
+              lv = v;
+              first_iteration = false;
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      poly_PreContour (p_contour, FALSE);
+
+      /* make sure it is a positive contour (outer) or negative (hole) */
+//      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+
+
+//      if (p_contour->Flags.orient != PLF_DIR)
+      if (!face->surface_orientation_reversed)
+        poly_InvContour (p_contour);
+
+      if (p_contour->Flags.orient == PLF_DIR)
+        {
+          PLINE *old_outer;
+
+          /* Found the outer contour */
+          if (found_outer_contour)
+            {
+              printf ("FOUND TWO OUTER CONTOURS FOR CYLINDRICAL.. NEED TO HANDLE THIS..!\n");
+#if 1
+              face->triangulate_failed = true;
+              return;
+#endif
+            }
+
+          p_contour->next = poly->contours->next;
+          old_outer = poly->contours;
+          poly->contours = p_contour;
+
+          found_outer_contour = true;
+        }
+      else
+        {
+          if (!poly_InclContour (poly, p_contour))
+            {
+              printf ("Contour dropped - oops!\n");
+              poly_DelContour (&p_contour);
+            }
+        }
+      p_contour = NULL;
+
+      /* XXX: Assumption of outline first, holes second seems to be false! */
+//      hole = true;
+    }
+
+  if (!found_outer_contour)
+    {
+      printf ("DID NOT FIND OUTER CONTOUR... BADNESS\n");
+      face->triangulate_failed = true;
+      return;
+    }
+
+  poly_DelContour (&dummy_contour);
+#endif
+
+#if 0
+  v = 0.0;
+  for (i = 0; i <= 360; i+= 10)
+    {
+      u = i;
+      p_v[0] = MM_TO_COORD (v) + i; /* + i is a hack to keep the tesselator from combining strips across y */
+      p_v[1] = MM_TO_COORD (u);
+      node = poly_CreateNode (p_v);
+
+      if (p_contour == NULL)
+        {
+          if ((p_contour = poly_NewContour (node)) == NULL)
+            return;
+        }
+      else
+        {
+          poly_InclVertex (p_contour->head.prev, node);
+        }
+    }
+
+  v = -10.0;
+  for (i = 360; i >= 0; i-= 10)
+    {
+      u = i;
+      p_v[0] = MM_TO_COORD (v); // + i; /* + i is a hack to keep the tesselator from combining strips across y */
+      p_v[1] = MM_TO_COORD (u);
+      node = poly_CreateNode (p_v);
+      poly_InclVertex (p_contour->head.prev, node);
+    }
+
+    poly_PreContour (p_contour, FALSE);
+    if (!poly_InclContour (poly, p_contour))
+      {
+        printf ("Contour dropped - oops!\n");
+        poly_DelContour (&p_contour);
+      }
+#endif
+
+  /* XXX: Need to tesselate the polygon */
+  _borast_traps_init (&traps);
+  bo_poly_to_traps_no_draw (poly, &traps);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  poly_Free (&poly);
+
+  if (num_uv_points == 0) {
+    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+//  printf ("Tesselated with %i uv points\n", num_uv_points);
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    if (face->surface_orientation_reversed)
+      {
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top) - COORD_TO_MM(y_top); /* Subtract of COORD_TO_MM(y_top) undoes hack above which kept the tesselator from combining strips across y */
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top) - COORD_TO_MM(y_top);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot) - COORD_TO_MM(y_bot);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot) - COORD_TO_MM(y_bot);
+      }
+    else
+      {
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top) - COORD_TO_MM(y_top); /* Subtract of COORD_TO_MM(y_top) undoes hack above which kept the tesselator from combining strips across y */
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top) - COORD_TO_MM(y_top);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot) - COORD_TO_MM(y_bot);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot) - COORD_TO_MM(y_bot);
+      }
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      cylinder_uv_to_xyz_and_normal(face,
+                                    /* uv */
+                                    COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                                    COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                                    /* xyz */
+                                    &face->tristrip_vertices[vertex_comp + 0],
+                                    &face->tristrip_vertices[vertex_comp + 1],
+                                    &face->tristrip_vertices[vertex_comp + 2],
+                                    /* Vertex normal */
+                                    &face->tristrip_vertices[vertex_comp + 3],
+                                    &face->tristrip_vertices[vertex_comp + 4],
+                                    &face->tristrip_vertices[vertex_comp + 5]);
+
+#if 0
+      printf ("%f, %f  ->  %f, %f, %f\n",
+                         COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                         COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                         (double)face->tristrip_vertices[vertex_comp + 0],
+                         (double)face->tristrip_vertices[vertex_comp + 1],
+                         (double)face->tristrip_vertices[vertex_comp + 2]);
+#endif
+      vertex_comp += BUFFER_STRIDE;
+    }
+
+  g_free (uv_points);
+}
+
 static void
 plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
 {
@@ -95,7 +584,7 @@ plane_uv_to_xyz (face3d *face, float u, float v, float *x, float *y, float *z)
 }
 
 static void
-ensure_tristrip (face3d *face)
+plane_ensure_tristrip (face3d *face)
 {
   GList *c_iter;
   int num_uv_points;
@@ -121,12 +610,9 @@ ensure_tristrip (face3d *face)
   if (face->triangulate_failed)
     return;
 
-  if (face->is_cylindrical)
+  if (!face->is_planar)
     return;
 
-//  if (face->is_b_spline)
-//    return;
-
   poly = poly_Create ();
   if (poly == NULL)
     return;
@@ -186,7 +672,6 @@ ensure_tristrip (face3d *face)
                   poly_InclVertex (p_contour->head.prev, node);
                 }
             }
-
         }
       while ((e = LNEXT(e)) != contour->first_edge);
 
@@ -328,7 +813,7 @@ ensure_tristrip (face3d *face)
    */
 
   face->tristrip_num_vertices = num_uv_points;
-  face->tristrip_vertices = g_new0 (float, 3 * num_uv_points);
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
 
   vertex_comp = 0;
   for (i = 0; i < num_uv_points; i++)
@@ -339,7 +824,13 @@ ensure_tristrip (face3d *face)
                       &face->tristrip_vertices[vertex_comp + 0],
                       &face->tristrip_vertices[vertex_comp + 1],
                       &face->tristrip_vertices[vertex_comp + 2]);
-      vertex_comp += 3;
+
+      /* Vertex normal */
+      face->tristrip_vertices[vertex_comp + 3] = face->nx;
+      face->tristrip_vertices[vertex_comp + 4] = -face->ny; /* XXX: -ny */
+      face->tristrip_vertices[vertex_comp + 5] = face->nz;
+
+      vertex_comp += BUFFER_STRIDE;
     }
 
   g_free (uv_points);
@@ -356,23 +847,32 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
   int i;
   int vertex_comp;
 
-  /* We only know how to deal with planar faces for now */
-  if (!face->is_planar)
-    return;
-
   hidgl_flush_triangles (hidgl);
 
-  ensure_tristrip (face);
-
-  glNormal3f (face->nx, -face->ny, face->nz); /* XXX: Note the -ny */
+  if (face->is_planar)
+    {
+      plane_ensure_tristrip (face);
+    }
+  else if (face->is_cylindrical)
+    {
+      cylinder_ensure_tristrip (face);
+    }
+  else
+    {
+      /* We only know how to deal with planar and cylindrical faces for now */
+      return;
+    }
 
   if (face->is_debug)
     glColor4f (1.0f, 0.0f, 0.0f, 0.5f);
   else if (selected)
     glColor4f (0.0f, 1.0f, 1.0f, 0.5f);
+//  else if (face->is_cylindrical)
+//    glColor4f (0.0f, 1.0f, 0.0f, 0.5f);
   else
-    glColor4f (0.8f, 0.8f, 0.8f, 0.5f);
+    glColor4f (0.8f, 0.8f, 0.8f, 1.0f);
 
+#if 0
   hidgl_ensure_vertex_space (gc, face->tristrip_num_vertices);
 
 #ifdef MEMCPY_VERTEX_DATA
@@ -392,8 +892,10 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
     hidgl_add_vertex_3D_tex (gc, x, y, z, 0.0, 0.0);
   }
 #endif
+#endif
 
-  hidgl_flush_triangles (hidgl);
+//  hidgl_flush_triangles (hidgl);
+  emit_tristrip (face);
 
-  glDisable(GL_AUTO_NORMAL); /* Quick hack test */
+//  glDisable(GL_AUTO_NORMAL); /* Quick hack test */
 }
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
index ceb12da..c2c25a6 100644
--- a/src/hid/common/object3d_gl.c
+++ b/src/hid/common/object3d_gl.c
@@ -365,7 +365,7 @@ draw_quad_edge (edge_ref e, void *data)
 
           glEnd ();
 
-          glDepthMask (FALSE);
+//          glDepthMask (FALSE);
           return;
         }
     }
@@ -379,7 +379,7 @@ draw_quad_edge (edge_ref e, void *data)
               STEP_Y_TO_COORD (PCB, y2),
               STEP_X_TO_COORD (PCB, z2));
   glEnd ();
-  glDepthMask (FALSE);
+//  glDepthMask (FALSE);
 }
 
 static void
@@ -464,9 +464,13 @@ object3d_draw (hidGC gc, object3d *object, bool selected)
 
 //  printf ("\nDrawing object\n");
 
+  glDisable(GL_LIGHTING); /* XXX: HACK */
+
   face_no = 0;
   g_list_foreach (object->faces, (GFunc)draw_face_edges, &info);
 
+  glEnable(GL_LIGHTING); /* XXX: HACK */
+
   face_no = 0;
   g_list_foreach (object->faces, (GFunc)draw_face, &info);
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 32d5d2f..5529f5b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2829,7 +2829,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
 //  glDisable (GL_DEPTH_TEST); /* TEST */
-  glDepthMask (FALSE); /* TEST */
+//  glDepthMask (FALSE); /* TEST */
 
   if (!global_view_2d)
     ghid_draw_packages (&region);
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index a293067..c543c57 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -874,6 +874,44 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
           DDATA(our_edge) = vertex;
 
         }
+      else if (strcmp (curve->EntityName (), "Ellipse") == 0)
+        {
+          SdaiEllipse *ellipse = (SdaiEllipse *)curve;
+          double cx = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+          double cy = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+          double cz = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          double nx = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+          double ny = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          double nz = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+          our_edge_info->is_placeholder = true;
+#if 0 /* NOT YET IMPLEMENTED */
+          double radius = circle->radius_();
+
+          transform_vertex (info->current_transform, &cx, &cy, &cz);
+
+          transform_vector (info->current_transform, &nx, &ny, &nz);
+
+          if (orientation) // NOT REQUIRED, SINCE WE ADDED same_sense to the edge info ----> (orientation == same_sense)
+            {
+              edge_info_set_round (our_edge_info, cx, cy, cz, nx, ny, nz, radius);
+            }
+          else
+            {
+              edge_info_set_round (our_edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
+            }
+#endif
+
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
+        }
       else if (curve->IsComplex() || /* This is a guess - assuming complex curves are likely to be B_SPLINE_* complexes */
                strcmp (curve->EntityName (), "B_Spline_Curve_With_Knots") == 0)
         {
@@ -901,6 +939,18 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
           // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
           // XXX: Various derived types of the above, e.g.:
           //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+          our_edge_info->is_placeholder = true;
+
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
           return;
         }
 
@@ -1241,8 +1291,11 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                   info->current_face->ny = -info->current_face->ny;
                   info->current_face->nz = -info->current_face->nz;
 
+                  /* XXX: Could use face->surface_orientation_reversed ? */
 //                  printf ("Not same sense, flipping normal\n");
                 }
+
+              info->current_face->surface_orientation_reversed = false;
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
@@ -1260,8 +1313,33 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                                 &info->current_face->ry,
                                 &info->current_face->rz);
 
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
               info->current_face->is_cylindrical = true;
               info->current_face->radius = cylinder->radius_ ();
+
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
+                {
+                  info->current_face->surface_orientation_reversed = true;
+                }
+
             }
           else if (strcmp (surface->EntityName (), "Conical_Surface") == 0)
             {
