Bottom: 83b7c564e0a8d55055703f0d39e27f828f5ac2b2
Top:    faa491a920ef22dc2ffef60934478357b012ebed
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-10 20:59:23 +0000

Refresh of mess-of-attempts-to-debug-and

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 82fb9c4..a89d4c4 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2629,6 +2629,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   if (ghidgui->debugged_polyarea != NULL) {
     PolygonType dummy_poly;
     dummy_poly.Clipped = ghidgui->debugged_polyarea;
+    dummy_poly.Flags = NoFlags ();
+    SET_FLAG (FULLPOLYFLAG, &dummy_poly);
 
     common_thindraw_pcb_polygon (Output.fgGC, &dummy_poly, &region);
     hidgl_flush_triangles (priv->hidgl);
diff --git a/src/misc.c b/src/misc.c
index b4babfd..79416c8 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -362,10 +362,12 @@ SetLineBoundingBox (LineType *Line)
  */
 void
 calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle,
-                                         Coord *cx, Coord *cy, Coord *radius,
+                                         double *cx, double *cy, double *radius,
+//                                         Coord *cx, Coord *cy, Coord *radius,
                                          Angle *start_angle, Angle *delta_angle)
 {
-  Coord hx, hy;
+  double hx, hy;
+//  Coord hx, hy;
   double p_to_h_dist;
   double c_to_h_dist;
   double unit_hcx, unit_hcy;
@@ -434,7 +436,8 @@ SetPolygonBoundingBox (PolygonType *Polygon)
     if (point->included_angle != 0)
       {
         BoxType arc_bound;
-        Coord cx, cy, radius;
+        double cx, cy, radius;
+//        Coord cx, cy, radius;
         Angle start_angle, delta_angle;
         PointType *next_point;
 
diff --git a/src/misc.h b/src/misc.h
index 84f62ed..ded72f6 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -53,7 +53,8 @@ void SetArcEndpoints (ArcType *);
 void SetPointBoundingBox (PointType *);
 void SetPinBoundingBox (PinType *);
 void SetPadBoundingBox (PadType *);
-void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, Coord *cx, Coord *cy, Coord *radius, Angle *start_angle, Angle *delta_angle);
+void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, double *cx, double *cy, double *radius, Angle *start_angle, Angle *delta_angle);
+//void calc_arc_from_points_and_included_angle (PointType *p1, PointType *p2, Angle included_angle, Coord *cx, Coord *cy, Coord *radius, Angle *start_angle, Angle *delta_angle);
 void SetPolygonBoundingBox (PolygonType *);
 void SetElementBoundingBox (DataType *, ElementType *, FontType *);
 bool IsDataEmpty (DataType *);
diff --git a/src/polyarea.h b/src/polyarea.h
index c892307..199bc59 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -94,8 +94,10 @@ struct VNODE
     double p0; /* Smaller parameter along curve, 0-1 */
     double p1; /* Larger  parameter along curve, 0-1 */
     bool is_round;
-    Coord cx, cy;
-    Coord radius;
+    double cx, cy;
+    double radius;
+//    Coord cx, cy;
+//    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -130,7 +132,8 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
-VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
+VNODE *poly_CreateNodeArcApproximation(Vector v, double cx, double cy, double radius);
+//VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index 432a169..895014b 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -136,7 +136,7 @@ polygon_init (void)
 
   /* DEBUG - AVOID PCB running the system out of memory! */
   getrlimit (RLIMIT_AS, &limit);
-  limit.rlim_cur = MIN (limit.rlim_cur, 2000 * 1024 * 1024 /* 2000 GiB limit to virtual memory size */);
+  limit.rlim_cur = MIN (limit.rlim_cur, 7000 * 1024 * 1024 /* 2000 GiB limit to virtual memory size */);
   setrlimit (RLIMIT_AS, &limit);
 
 }
@@ -293,7 +293,8 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
+//degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
+degree_circle (PLINE * c, double X, double Y /* <- Center */, double radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -393,8 +394,10 @@ original_poly (PolygonType * p)
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
-          Coord cx, cy;
-          Coord radius;
+          double cx, cy;
+          double radius;
+//          Coord cx, cy;
+//          Coord radius;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -2362,6 +2365,12 @@ delete_piece_cb (gpointer data, gpointer userdata)
   piece->f->b = piece->b;
   piece->f = piece->b = piece;
 
+  /* Detach the parentage information, so we don't free it.. copies still belong to the M_POLYAREA we are taking this piece from */
+  piece->parentage.immaculate_conception = true;
+  piece->parentage.action = PBO_NONE;
+  piece->parentage.a = NULL;
+  piece->parentage.b = NULL;
+
   poly_Free (&piece);
 }
 
@@ -2454,6 +2463,12 @@ POLYAREA *board_outline_poly (bool include_holes)
   return clipped;
 #endif
 
+  if (clipped == NULL)
+    {
+      fprintf (stderr, "clipped == NULL in board_outline_poly\n");
+      return clipped;
+    }
+
   /* Now we just need to work out which pieces of polygon are inside
      and outside the board! */
 
diff --git a/src/polygon1.c b/src/polygon1.c
index ac4de07..1264fa8 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -159,7 +159,7 @@ pline_dump (VNODE * v)
   do
     {
       n = NEXT_VERTEX(v);
-      pcb_fprintf (stderr, "Line [%#mS %#mS %#mS %#mS 10 10 \"%s\"]\n",
+      pcb_fprintf (stderr, "Line [%#$mn %#$mn %#$mn %#$mn 10 10 \"%s\"]\n",
 	       v->point[0], v->point[1],
 	       n->point[0], n->point[1], theState (v));
     }
@@ -188,7 +188,8 @@ poly_dump (POLYAREA * p)
 #endif
 
 static VNODE *
-poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+poly_CreateNodeFull (Vector v, bool is_round, double cx, double cy, double radius)
+//poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
 {
   VNODE *res;
   Coord *c;
@@ -198,6 +199,29 @@ poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
   if (res == NULL)
     return NULL;
   // bzero (res, sizeof (VNODE) - sizeof(Vector));
+
+#if 0
+  if (is_round)
+    {
+      Angle start_angle;
+//      Angle end_angle;
+      Coord check_x, check_y;
+
+      start_angle = atan2 ((v[1] - cy), -(v[0] - cx)) / M180;
+
+      check_x = cx + radius * -cos (start_angle * M180);
+      check_y = cy + radius *  sin (start_angle * M180);
+
+      if (check_x != v[0] || check_y != v[1])
+        {
+          fprintf (stderr, "poly_CreateNodeFull() Tweaking from vertex location to match angle calculation\n");
+          pcb_fprintf (stderr, "Moving from (%$mn, %$mn) to (%$mn, %$mn)\n", v[0], v[1], check_x, check_y);
+          v[0] = check_x;
+          v[1] = check_y;
+        }
+    }
+#endif
+
   c = res->point;
   *c++ = *v++;
   *c = *v;
@@ -222,7 +246,8 @@ poly_CreateNode (Vector v)
 }
 
 VNODE *
-poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+//poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+poly_CreateNodeArcApproximation (Vector v, double cx, double cy, double radius)
 {
 //  return poly_CreateNodeFull (v, false /*true*/, cx, cy, radius);
   return poly_CreateNodeFull (v, true, cx, cy, radius);
@@ -641,7 +666,16 @@ edge_label (VNODE * pn)
        */
       if (l->poly == l->next->poly &&
           l->side != l->next->side && /* <-- PCJC: Not sure if this is required, including for sanity */
-          l->angle == l->next->angle)
+          l->angle == l->next->angle &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->is_round ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->is_round &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->radius ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->radius &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->cx ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->cx &&
+          ((l->side       = 'P') ? VERTEX_BACKWARD_EDGE (l->parent      ) : VERTEX_FORWARD_EDGE (l->parent      ))->cy ==
+          ((l->next->side = 'P') ? VERTEX_BACKWARD_EDGE (l->next->parent) : VERTEX_FORWARD_EDGE (l->next->parent))->cy)
+
         l = l->next->next;
     }
   assert (l->poly != this_poly);
@@ -717,6 +751,34 @@ edge_label (VNODE * pn)
   return region;
 }				/* edge_label */
 
+static void
+cvc_list_dump (CVCList *list)
+{
+  VNODE *node = list->parent;
+  CVCList *iter;
+
+  /* Only print for the vertex we're interested in at the moment */
+  if (!(
+      (node->point[0] == 69088001 || node->point[0] == 69088000 || node->point[0] == 69087998) &&
+      node->point[1] == 29336999))
+    return;
+
+  pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
+
+  iter = list;
+  do {
+    pcb_fprintf (stderr, "angle = %f, poly = %c, side = %c, (%mm, %mm)-(%mm, %mm)\n",
+                 iter->angle,
+                 iter->poly,
+                 iter->side,
+                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
+                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1],
+                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
+                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1]);
+  } while ((iter = iter->next) != list);
+
+}
+
 /*
  add_descriptors
  (C) 2006 harry eaton
@@ -735,9 +797,11 @@ add_descriptors (PLINE * pl, char poly, CVCList * list)
 	  list = node->cvc_prev = insert_descriptor (node, poly, 'P', list);
 	  if (!node->cvc_prev)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	  list = node->cvc_next = insert_descriptor (node, poly, 'N', list);
 	  if (!node->cvc_next)
 	    return NULL;
+	   cvc_list_dump (node->cvc_prev);
 	}
     }
   while ((node = NEXT_VERTEX(node)) != &pl->head);
@@ -1113,6 +1177,7 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
   printf ("  Intersect count is %i\n", cnt);
 
+#if 0
   if (cnt == 0)
     {
       printf ("Trying with a perturbation\n");
@@ -1127,6 +1192,10 @@ seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
 
       printf ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<<<<\n");
     }
+#endif
+
+  if (cnt == 0)
+    return 0;
 
   if (cnt == 2)
     {
@@ -2497,8 +2566,8 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
           VERTEX_FORWARD_EDGE (newn)->orig_point0[1] = VERTEX_BACKWARD_EDGE (curv)->orig_point1[1];
           VERTEX_FORWARD_EDGE (newn)->orig_point1[0] = VERTEX_BACKWARD_EDGE (curv)->orig_point0[0];
           VERTEX_FORWARD_EDGE (newn)->orig_point1[1] = VERTEX_BACKWARD_EDGE (curv)->orig_point0[1];
-          VERTEX_FORWARD_EDGE (newn)->p0 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->prev->p1;
-          VERTEX_FORWARD_EDGE (newn)->p1 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->prev->p0;
+          VERTEX_FORWARD_EDGE (newn)->p0 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->/*prev->*/p1;
+          VERTEX_FORWARD_EDGE (newn)->p1 = 1.0 - VERTEX_BACKWARD_EDGE (curv)->/*prev->*/p0;
           if (VERTEX_FORWARD_EDGE (newn)->p1 < VERTEX_FORWARD_EDGE (newn)->p0)
             {
               printf ("!FORW: OH DEAR, p0=%f, p1=%f\n", newn->p0, newn->p1);
@@ -3634,6 +3703,8 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               Angle end_angle;
               Angle delta_angle;
               BoxType arc_bound;
+              Coord p_check_x, p_check_y;
+              Coord c_check_x, c_check_y;
 
               start_angle = atan2 ((p->point[1] - p->cy), -(p->point[0] - p->cx)) / M180;
               end_angle   = atan2 ((c->point[1] - p->cy), -(c->point[0] - p->cx)) / M180;
@@ -3644,6 +3715,34 @@ poly_PreContour (PLINE * C, BOOLp optimize)
               if (delta_angle > 180.) delta_angle -= 360.;
               if (delta_angle < -180.) delta_angle += 360.;
 
+              p_check_x = p->cx + p->radius * -cos (start_angle * M180);
+              p_check_y = p->cy + p->radius *  sin (start_angle * M180);
+              c_check_x = p->cx + p->radius * -cos (end_angle * M180);
+              c_check_y = p->cy + p->radius *  sin (end_angle * M180);
+
+              if (p_check_x != p->point[0] || p_check_y != p->point[1] ||
+                  c_check_x != c->point[0] || c_check_y != c->point[1])
+                {
+                  fprintf (stderr, "Oh dear, arc start point doesn't land correctly\n");
+                  pcb_fprintf (stderr, "p = (%$mn, %$mn), c = (%$mn, %$mn) (by endpoint)\n",
+                               p->point[0], p->point[1], c->point[0], c->point[1]);
+                  pcb_fprintf (stderr, "! = (%$mn, %$mn), ! = (%$mn, %$mn) (by angles, center and radius)\n",
+                               p_check_x, p_check_y, c_check_x, c_check_y);
+                  fprintf (stderr, "Error distances are %fnm %fnm\n",
+                           hypot (p->point[0] - p_check_x, p->point[1] - p_check_y),
+                           hypot (c->point[0] - c_check_x, c->point[1] - c_check_y));
+                  fprintf (stderr, "\n");
+                  //*(char *)0 = 0;
+                  p->point[0] = p_check_x;
+                  p->point[1] = p_check_y;
+                  c->point[0] = c_check_x;
+                  c->point[1] = c_check_y;
+                }
+              else
+                {
+                  fprintf (stderr, "angles ok\n");
+                }
+
               arc_bound = calc_thin_arc_bounds (p->cx, p->cy, p->radius, p->radius, start_angle, delta_angle);
 
               C->xmin = min (C->xmin, arc_bound.X1);
