Bottom: 76cdd0e9552a923cbae25271c5115c5cca4a5306
Top:    49786ccb18954b6acbd29f84b6a66885f68047a4
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-18 16:46:31 +0000

Refresh of alternative-more-thorough-step

---

diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index 245abca..23e335e 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,25 +1,41 @@
 #include <stdbool.h>
 #include <stdlib.h>
+#include <stdio.h>
+#include <glib.h>
 
+#include "step_id.h"
 #include "edge3d.h"
 
 edge_info *
-make_edge_info (bool is_stitch, bool is_round, float cx, float cy, float radius)
+make_edge_info (void)
 {
   edge_info *info;
 
-  info = malloc (sizeof(edge_info));
-  info->is_stitch = is_stitch;
-  info->is_round = is_round;
+  info = g_new0 (edge_info, 1);
+
+  return info;
+}
+
+void
+edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius)
+{
+  info->is_round = true;
   info->cx = cx;
   info->cy = cy;
+  info->cz = cz;
+  info->nx = nx;
+  info->ny = ny;
+  info->nz = nz;
   info->radius = radius;
+}
 
-  return info;
+void edge_info_set_stitch (edge_info *info)
+{
+  info->is_stitch = true;
 }
 
 void
 destroy_edge_info (edge_info *info)
 {
-  free (info);
+  g_free (info);
 }
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index e67cdb3..38fd6c1 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -1,11 +1,24 @@
 typedef struct
 {
-  bool is_stitch;
+  /* For edge curves */
+  bool is_stitch; /* Allows us to identify the stitch edge along the side of a cylinder */
+
+  /* For circular curves */
   bool is_round;
-  float cx;
-  float cy;
-  float radius;
+  double cx;
+  double cy;
+  double cz;
+  double nx;
+  double ny;
+  double nz;
+  double radius;
+
+  /* STEP crap - to hell with encapsulation */
+  step_id infinite_line_identifier;
+  step_id edge_identifier;
 } edge_info;
 
-edge_info *make_edge_info (bool is_stitch, bool is_round, float cx, float cy, float radius);
+edge_info *make_edge_info (void);
+void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
+void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index ddcf35e..2da2c5c 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -3,14 +3,41 @@
 #include <assert.h>
 #include <stdbool.h>
 
+#include <glib.h>
+
+#include "step_id.h"
 #include "quad.h"
 #include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
 #include "face3d.h"
 #include "edge3d.h"
 #include "object3d.h"
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
 
 
 #ifndef WIN32
@@ -31,44 +58,23 @@
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
 
-static object3d *object3d_test_object = NULL;
-
-static void
-print_edge_id (edge_ref e)
-{
-  printf ("ID %i.%i", ID(e), (unsigned int)e & 3u);
-}
-
-static void
-debug_print_edge (edge_ref e, void *data)
-{
-  printf ("Edge ID %i.%i\n", ID(e), (int)e & 3u);
-
-  printf ("Edge ONEXT is "); print_edge_id (ONEXT(e)); printf ("\n");
-  printf ("Edge OPREV is "); print_edge_id (OPREV(e)); printf ("\n");
-  printf ("Edge DNEXT is "); print_edge_id (DNEXT(e)); printf ("\n");
-  printf ("Edge DPREV is "); print_edge_id (DPREV(e)); printf ("\n");
-  printf ("Edge RNEXT is "); print_edge_id (RNEXT(e)); printf ("\n");
-  printf ("Edge RPREV is "); print_edge_id (RPREV(e)); printf ("\n");
-  printf ("Edge LNEXT is "); print_edge_id (LNEXT(e)); printf ("\n");
-  printf ("Edge LPREV is "); print_edge_id (LPREV(e)); printf ("\n");
-}
+static GList *object3d_test_objects = NULL;
 
 void
 object3d_test_init (void)
 {
-  //object3d_test_object = object3d_create_test_cube ();
-  object3d_test_object = object3d_from_board_outline ();
+  object3d_test_objects = object3d_from_board_outline ();
 }
 
 object3d *
-make_object3d ()
+make_object3d (char *name)
 {
   static int object3d_count = 0;
   object3d *object;
 
-  object = malloc (sizeof (object3d));
+  object = g_new0 (object3d, 1);
   object->id = object3d_count++;
+  name = g_strdup (name);
 
   return object;
 }
@@ -76,70 +82,39 @@ make_object3d ()
 void
 destroy_object3d (object3d *object)
 {
-  /* XXX: LEAK GEOMETERY AND TOPOLOGY */
-  free (object);
+  g_list_free_full (object->vertices, (GDestroyNotify)destroy_vertex3d);
+  g_list_free_full (object->edges, (GDestroyNotify)destroy_edge);
+  g_list_free_full (object->faces, (GDestroyNotify)destroy_face3d);
+  g_free (object->name);
+  g_free (object);
 }
 
-#define XOFFSET 50
-#define YOFFSET 50
-#define ZOFFSET 0
-#define SCALE  10
-object3d *
-object3d_create_test_cube (void)
+void
+object3d_set_appearance (object3d *object, appearance *appear)
 {
-  object3d *object;
-  vertex3d *cube_vertices[8];
-  edge_ref cube_edges[12];
-  int i;
-
-  cube_vertices[0] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 0., ZOFFSET + SCALE *  0.);
-  cube_vertices[1] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 0., ZOFFSET + SCALE *  0.);
-  cube_vertices[2] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 0., ZOFFSET + SCALE * -1.);
-  cube_vertices[3] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 0., ZOFFSET + SCALE * -1.);
-  cube_vertices[4] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 1., ZOFFSET + SCALE *  0.);
-  cube_vertices[5] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 1., ZOFFSET + SCALE *  0.);
-  cube_vertices[6] = make_vertex3d (XOFFSET + SCALE * 1., YOFFSET + SCALE * 1., ZOFFSET + SCALE * -1.);
-  cube_vertices[7] = make_vertex3d (XOFFSET + SCALE * 0., YOFFSET + SCALE * 1., ZOFFSET + SCALE * -1.);
-
-  for (i = 0; i < 12; i++)
-    cube_edges[i] = make_edge ();
-
-  for (i = 0; i < 4; i++) {
-    int next_vertex = (i + 1) % 4;
-    int prev_vertex = (i + 3) % 4;
-
-    /* Assign bottom edge endpoints */
-    ODATA (cube_edges[i]) = cube_vertices[i];
-    DDATA (cube_edges[i]) = cube_vertices[next_vertex];
-
-    /* Assign top edge endpoints */
-    ODATA (cube_edges[4 + i]) = cube_vertices[4 + i];
-    DDATA (cube_edges[4 + i]) = cube_vertices[4 + next_vertex];
-
-    /* Assign side edge endpoints */
-    ODATA (cube_edges[8 + i]) = cube_vertices[i];
-    DDATA (cube_edges[8 + i]) = cube_vertices[4 + i];
-
-    /* Link up edges orbiting around each bottom vertex */
-    splice (cube_edges[i], cube_edges[8 + i]);
-    splice (cube_edges[8 + i], SYM(cube_edges[prev_vertex]));
-
-    /* Link up edges orbiting around each bottom top */
-    splice (cube_edges[4 + i], SYM(cube_edges[4 + prev_vertex]));
-    splice (SYM(cube_edges[4 + prev_vertex]), SYM(cube_edges[8 + i]));
-
-  }
+  object->appear = appear;
+}
 
-  quad_enum (cube_edges[0], debug_print_edge, NULL);
+void
+object3d_add_edge (object3d *object, edge_ref edge)
+{
+  object->edges = g_list_append (object->edges, (void *)edge);
+}
 
-  object = make_object3d ();
-  object->first_edge = cube_edges[0];
+void
+object3d_add_vertex (object3d *object, vertex3d *vertex)
+{
+  object->vertices = g_list_append (object->vertices, vertex);
+}
 
-  return object;
+void
+object3d_add_face (object3d *object, face3d *face)
+{
+  object->faces = g_list_append (object->faces, face);
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -168,18 +143,19 @@ draw_quad_edge (edge_ref e, void *data)
 
   if (UNDIR_DATA(e) != NULL) {
     edge_info *info = UNDIR_DATA(e);
-    if (info->is_stitch)
-      return;
+//    if (info->is_stitch)
+//      return;
     if (info->is_round) {
       int i;
       glBegin (GL_LINES);
       for (i = 0; i < CIRC_SEGS; i++) {
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (((vertex3d *)ODATA(e))->z));
+        /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
       }
       glEnd ();
       return;
@@ -187,15 +163,28 @@ draw_quad_edge (edge_ref e, void *data)
   }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  g_return_if_fail (object->edges != NULL);
+
+//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+}
+
 void
 object3d_draw_debug (void)
 {
-  quad_enum (object3d_test_object->first_edge, draw_quad_edge, NULL);
+  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, NULL);
 }
 
 /*********************************************************************************************************/
@@ -211,7 +200,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -223,8 +212,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -234,682 +223,336 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
     n--;
   }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
-void
-object3d_export_to_step (object3d *object, char *filename)
-{
-  FILE *f;
-  time_t currenttime;
-  struct tm utc;
-  //int next_step_identifier;
 
-  f = fopen (filename, "w");
-  if (f == NULL)
-    {
-      perror (filename);
-      return;
-    }
-
-  currenttime = time (NULL);
-  gmtime_r (&currenttime, &utc);
-
-  fprintf (f, "ISO-10303-21;\n");
-  fprintf (f, "HEADER;\n");
-  fprintf (f, "FILE_DESCRIPTION (\n"
-              "/* description */ ('STEP AP214 export of circuit board'),\n"
-              "/* implementation level */ '1');\n");
-  fprintf (f, "FILE_NAME (/* name */ '%s',\n"
-              "/* time_stamp */ '%.4d-%.2d-%.2dT%.2d:%.2d:%.2d',\n"
-              "/* author */ ( '' ),\n"
-              "/* organisation */ ( '' ),\n"
-              "/* preprocessor_version */ 'PCB STEP EXPORT',\n"
-              "/* originating system */ '%s " VERSION "',\n"
-              "/* authorisation */ '' );\n",
-           filename,
-           1900 + utc.tm_year, 1 + utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec,
-           Progname);
-  fprintf (f, "FILE_SCHEMA (( 'AUTOMOTIVE_DESIGN' ));\n");
-  fprintf (f, "ENDSEC;\n");
-  fprintf (f, "\n");
-  fprintf (f, "DATA;\n");
-
-  /* TEST */
-
-  /* Setup the context of the "product" we are defining", and that it is a 'part' */
-
-  fprintf (f, "#1 = APPLICATION_CONTEXT ( 'automotive_design' ) ;\n"
-              "#2 = APPLICATION_PROTOCOL_DEFINITION ( 'draft international standard', 'automotive_design', 1998, #1 );\n"
-              "#3 = PRODUCT_CONTEXT ( 'NONE', #1, 'mechanical' ) ;\n"
-              "#4 = PRODUCT ('%s', '%s', '%s', (#3)) ;\n"
-              "#5 = PRODUCT_RELATED_PRODUCT_CATEGORY ('part', $, (#4)) ;\n",
-              "test_pcb_id", "test_pcb_name", "test_pcb_description");
-
-  /* Setup the specific definition of the product we are defining */
-  fprintf (f, "#6 = PRODUCT_DEFINITION_CONTEXT ( 'detailed design', #1, 'design' ) ;\n"
-              "#7 = PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE ( 'ANY', '', #4, .NOT_KNOWN. ) ;\n"
-              "#8 = PRODUCT_DEFINITION ( 'UNKNOWN', '', #7, #6 ) ;\n"
-              "#9 = PRODUCT_DEFINITION_SHAPE ( 'NONE', 'NONE',  #8 ) ;\n");
-
-  /* Need an anchor in 3D space to orient the shape */
-  fprintf (f, "#10 =    CARTESIAN_POINT ( 'NONE',  ( 0.0, 0.0, 0.0 ) ) ;\n"
-              "#11 =          DIRECTION ( 'NONE',  ( 0.0, 0.0, 1.0 ) ) ;\n"
-              "#12 =          DIRECTION ( 'NONE',  ( 1.0, 0.0, 0.0 ) ) ;\n"
-              "#13 = AXIS2_PLACEMENT_3D ( 'NONE', #10, #11, #12 ) ;\n");
-
-  /* Grr.. more boilerplate - this time unit definitions */
-
-  fprintf (f, "#14 = UNCERTAINTY_MEASURE_WITH_UNIT (LENGTH_MEASURE( 1.0E-005 ), #15, 'distance_accuracy_value', 'NONE');\n"
-              "#15 =( LENGTH_UNIT ( ) NAMED_UNIT ( * ) SI_UNIT ( .MILLI., .METRE. ) );\n"
-              "#16 =( NAMED_UNIT ( * ) PLANE_ANGLE_UNIT ( ) SI_UNIT ( $, .RADIAN. ) );\n"
-              "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
-              "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
-
-  /* BREP STUFF FROM #21 onwards say? */
-  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( /* Manifold_solid_brep */ #21, #13 ), #18 ) ;\n"
-              "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
-              "test_pcb_absr_name");
-
-  //next_step_identifier = 21;
-
-  /* TODO.. EXPORT FROM A QUAD DATA-STRUCTURE */
-#if 0
-#define FWD 1
-#define REV 2
-static void
-quad_emit_board_contour_step (FILE *f, PLINE *contour)
+GList *
+object3d_from_board_outline (void)
 {
+  GList *board_objects = NULL;
+  object3d *board_object;
+  appearance *board_appearance;
+  appearance *top_bot_appearance;
+  POLYAREA *board_outline;
+  POLYAREA *pa;
+  PLINE *contour;
+  PLINE *ct;
   int ncontours;
   int npoints;
-
-  int brep_identifier;
-
-  int bottom_plane_identifier;
-  int top_plane_identifier;
-  int *side_plane_identifier;
-
-  int *bottom_infinite_line_identifier;
-  int *top_infinite_line_identifier;
-  int *side_infinite_line_identifier;
-
-  int *bottom_vertex_identifier;
-  int *top_vertex_identifier;
-
-  int *bottom_edge_identifier;
-  int *top_edge_identifier;
-  int *side_edge_identifier;
-
-  int *bottom_face_bound_identifier;
-  int *top_face_bound_identifier;
-
-  int bottom_face_identifier;
-  int top_face_identifier;
-  int *side_face_identifier;
-
-  int pcb_shell_identifier;
-
   int i;
+  vertex3d **vertices;
+  edge_ref *edges;
+  face3d **faces;
+  int start_of_ct;
+  int offset_in_ct;
+  int ct_npoints;
 
-  PLINE *ct;
-
-  ncontours = 0;
-  npoints = 0;
-  ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
-
-  /* TODO: Avoid needing to store these identifiers by nailing down our usage pattern of identifiers */
-  /* Allocate some storage for identifiers */
-
-            side_plane_identifier = malloc (sizeof (int) * npoints);
-  bottom_infinite_line_identifier = malloc (sizeof (int) * npoints);
-     top_infinite_line_identifier = malloc (sizeof (int) * npoints);
-    side_infinite_line_identifier = malloc (sizeof (int) * npoints);
-         bottom_vertex_identifier = malloc (sizeof (int) * npoints);
-            top_vertex_identifier = malloc (sizeof (int) * npoints);
-           bottom_edge_identifier = malloc (sizeof (int) * npoints);
-              top_edge_identifier = malloc (sizeof (int) * npoints);
-             side_edge_identifier = malloc (sizeof (int) * npoints);
-             side_face_identifier = malloc (sizeof (int) * npoints);
-
-     bottom_face_bound_identifier = malloc (sizeof (int) * ncontours);
-        top_face_bound_identifier = malloc (sizeof (int) * ncontours);
-
-  /* For a n-sided outline, we need: */
-
-  // PLANES:               2 + n
-  // 2 bottom + top planes
-  // n side planes
-
-  // INFINITE LINES:       3n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-  // n for the sides (joining the top + bottom vertex of the extruded shape (n sided outline = n vertices)
-
-  // VERTICES:             2n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-
-  // EDGES:                3n          (6n oriented edges)
-  // n for the bottom
-  // n for the top
-  // n for the sides
-
-  // FACES:                2 + n
-  // 2 bottom + top faces
-  // n side faces
-
-  // A consistent numbering scheme will avoid needing complex data-structures here!
-
-  /* Save a place for the brep identifier */
-  brep_identifier = next_step_identifier++;
-
-  /* Define the bottom and top planes */
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0,  1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', (  1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           next_step_identifier, 0.0, 0.0, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           next_step_identifier + 1,
-           next_step_identifier + 2,
-           next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-           next_step_identifier + 4, next_step_identifier + 3);
-  bottom_plane_identifier = next_step_identifier + 4;
-  next_step_identifier = next_step_identifier + 5;
-
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0, -1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', ( -1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           next_step_identifier, 0.0, 0.0, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           next_step_identifier + 1,
-           next_step_identifier + 2,
-           next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-           next_step_identifier + 4, next_step_identifier + 3);
-  top_plane_identifier = next_step_identifier + 4;
-  next_step_identifier = next_step_identifier + 5;
-
-  /* Define the side planes */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Surface edges bounded by a cylindrical surface, not n-planes) */
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
-                 next_step_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
-                 next_step_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-
-        side_plane_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-    else
-      {
-        get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-        get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-                 next_step_identifier,     /* A point on the plane                      */ x1, y1, 0.0,
-                 next_step_identifier + 1, /* An axis direction pointing into the shape */ -(y2 - y1), (x2 - x1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* A reference direction pointing.. "meh"?   */ 0.0, 0.0, 1.0,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3);
-        side_plane_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-  }
+  board_outline = board_outline_poly (true);
 
-  /* Define the infinite lines */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
+  /* Loop over all board outline pieces */
+  pa = board_outline;
+  do {
 
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
+    contour = pa->contours;
+    ncontours = 0;
+    npoints = 0;
 
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
+    ct = contour;
+    while (ct != NULL) {
+      ncontours ++;
+      npoints += get_contour_npoints (ct);
       ct = ct->next;
     }
 
-    get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-    get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Top and bottom faces bounded a circular contour, not n-lines) */
-
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-        bottom_infinite_line_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 next_step_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                 next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-        top_infinite_line_identifier[i] = next_step_identifier + 4;
-        next_step_identifier = next_step_identifier + 5;
-      }
-    else
-      {
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 next_step_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, next_step_identifier + 1,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-        bottom_infinite_line_identifier[i] = next_step_identifier + 3;
-        next_step_identifier = next_step_identifier + 4;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 next_step_identifier,     /* A point on the line         */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 next_step_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 next_step_identifier + 2, next_step_identifier + 1,
-                 next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-        top_infinite_line_identifier[i] = next_step_identifier + 3;
-        next_step_identifier = next_step_identifier + 4;
-      }
+    board_object = make_object3d (PCB->Name);
+    board_appearance = make_appearance ();
+    top_bot_appearance = make_appearance ();
+    appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+    appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-    /* Side */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-             next_step_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, /* A direction along the line  */ 0.0, 0.0, 1.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-             next_step_identifier + 2, next_step_identifier + 1,
-             next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-    side_infinite_line_identifier[i] = next_step_identifier + 3;
-    next_step_identifier = next_step_identifier + 4;
-  }
+    object3d_set_appearance (board_object, board_appearance);
 
-  /* Define the vertices */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1;
+    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
+    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
+    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
 
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
+    /* Define the vertices */
+    ct = contour;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
 
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
-    }
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      double x1, y1;
 
-    get_contour_coord_n_in_mm (ct, adjusted_i, &x1, &y1);
-
-    /* Bottom */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             next_step_identifier,     /* Vertex coordinate  */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, next_step_identifier);
-    bottom_vertex_identifier[i] = next_step_identifier + 1;
-    next_step_identifier = next_step_identifier + 2;
-
-    /* Top */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             next_step_identifier,     /* Vertex coordinate  */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             next_step_identifier + 1, next_step_identifier);
-    top_vertex_identifier[i] = next_step_identifier + 1;
-    next_step_identifier = next_step_identifier + 2;
-  }
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+      }
 
-  /* Define the Edges */
-  for (i = 0; i < npoints; i++) {
+      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
 
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
+      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
+      object3d_add_vertex (board_object, vertices[i]);
+      object3d_add_vertex (board_object, vertices[npoints + i]);
     }
 
-    /* Due to the way the index wrapping works, this works for circular cutouts as well as n-sided */
-
-    /* Bottom */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, bottom_vertex_identifier[i], bottom_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], bottom_infinite_line_identifier[i],      // <-- MIGHT NEED TO REVERSE THIS???
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    bottom_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-
-    /* Top */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, top_vertex_identifier[i], top_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], top_infinite_line_identifier[i],                 // <-- MIGHT NEED TO REVERSE THIS???
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    top_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-
-    /* Side */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             next_step_identifier, bottom_vertex_identifier[i], top_vertex_identifier[i], side_infinite_line_identifier[i],
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier);
-    side_edge_identifier[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    next_step_identifier = next_step_identifier + 3;
-  }
-
-  /* Define the faces */
-
-  /* Bottom */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               next_step_identifier);
-      for (i = start_i + get_contour_npoints (ct) - 1; i > start_i; i--)
-        fprintf (f, "#%i, ", bottom_edge_identifier[i] + FWD);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               bottom_edge_identifier[start_i] + FWD,
-               next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-      bottom_face_bound_identifier[icont] = next_step_identifier + 1;
-      next_step_identifier = next_step_identifier + 2;
+    /* Define the edges */
+    for (i = 0; i < 3 * npoints; i++) {
+      edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
+      object3d_add_edge (board_object, edges[i]);
     }
 
-    fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ( ",
-             next_step_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               bottom_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             bottom_face_bound_identifier[ncontours - 1], bottom_plane_identifier);
-    bottom_face_identifier = next_step_identifier;
-    next_step_identifier = next_step_identifier + 1;
-  }
+    /* Define the faces */
+    for (i = 0; i < npoints; i++) {
+      faces[i] = make_face3d ();
 
-  /* Top */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               next_step_identifier);
-      for (i = start_i; i < start_i + get_contour_npoints (ct) - 1; i++)
-        fprintf (f, "#%i, ", top_edge_identifier[i] + REV);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               top_edge_identifier[start_i + get_contour_npoints (ct) - 1] + REV,
-               next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-      top_face_bound_identifier[icont] = next_step_identifier + 1;
-      next_step_identifier = next_step_identifier + 2;
+      object3d_add_face (board_object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+#else
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+#endif
     }
 
-    fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ( ",
-             next_step_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               top_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             top_face_bound_identifier[ncontours - 1], top_plane_identifier);
-    top_face_identifier = next_step_identifier;
-    next_step_identifier = next_step_identifier + 1;
-  }
+    faces[npoints] = make_face3d (); /* bottom_face */
+    face3d_set_normal (faces[npoints], 0., 0., -1.);
+    face3d_set_appearance (faces[npoints], top_bot_appearance);
+    object3d_add_face (board_object, faces[npoints]);
 
-  /* Sides */
-  for (i = 0; i < npoints; i++) {
+    faces[npoints + 1] = make_face3d (); /* top_face */
+    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+    object3d_add_face (board_object, faces[npoints + 1]);
 
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( #%i, #%i, #%i, #%i ) ) ; "
-                "#%i = FACE_OUTER_BOUND ( 'NONE', #%i, .T. ) ; "
-                "#%i = ADVANCED_FACE ( 'NONE', ( #%i ), #%i, .F. ) ;\n",
-             next_step_identifier, side_edge_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)] + REV, top_edge_identifier[i] + FWD, side_edge_identifier[i] + FWD, bottom_edge_identifier[i] + REV,
-             next_step_identifier + 1, next_step_identifier,
-             next_step_identifier + 2, next_step_identifier + 1, side_plane_identifier[i]);
-    side_face_identifier[i] = next_step_identifier + 2;
-    next_step_identifier = next_step_identifier + 3;
-  }
-
-  /* Closed shell which bounds the brep solid */
-  pcb_shell_identifier = next_step_identifier;
-  next_step_identifier++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ( #%i, #%i, ", pcb_shell_identifier, bottom_face_identifier, top_face_identifier);
-  for (i = 0; i < npoints - 1; i++) {
-    fprintf (f, "#%i, ", side_face_identifier[i]);
-  }
-  fprintf (f, "#%i) ) ;\n",
-           side_face_identifier[npoints - 1]);
-
-  /* Finally emit the brep solid definition */
-  fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
-
-  free (side_plane_identifier);
-  free (bottom_infinite_line_identifier);
-  free (top_infinite_line_identifier);
-  free (side_infinite_line_identifier);
-  free (bottom_vertex_identifier);
-  free (top_vertex_identifier);
-  free (bottom_edge_identifier);
-  free (top_edge_identifier);
-  free (side_edge_identifier);
-  free (side_face_identifier);
-  free (bottom_face_bound_identifier);
-  free (top_face_bound_identifier);
-}
-#undef FWD
-#undef REV
+    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#ifdef REVERSED_PCB_CONTOURS
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#else
+    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
 #endif
 
-  fprintf (f, "ENDSEC;\n" );
-  fprintf (f, "END-ISO-10303-21;\n" );
-
-  fclose (f);
-}
-
-object3d *
-object3d_from_board_outline (void)
-{
-  object3d *object;
-  POLYAREA *outline;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  outline = board_outline_poly (true);
-  //outline = board_outline_poly (false); /* (FOR NOW - just the outline, no holes) */
-  ncontours = 0;
-  npoints = 0;
-
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
+    ct = contour;
+    start_of_ct = 0;
+    offset_in_ct = 0;
+    ct_npoints = get_contour_npoints (ct);
+
+    for (i = 0; i < npoints; i++, offset_in_ct++) {
+      int next_i_around_ct;
+      int prev_i_around_ct;
+
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints) {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#ifdef REVERSED_PCB_CONTOURS
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#else
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
+      }
 
-  ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
+      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-  /* We know how many edges and vertices we need now...
-   *
-   * let n = npoints
-   * bodies = 1             (FOR NOW - just the first board outline)
-   * vertices = 2n          (n-top, n-bottom)
-   * edges = 3n             (n-top, n-bottom, n-sides)
-   * faces = 2 + n          (1-top, 1-bottom, n-sides)
-   *
-   * holes = 0              (FOR NOW - just the outline, no holes)
-   * holes = ncontours - 1  (LATER)
-   */
-
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    double x1, y1;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
-    }
-
-    get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-    vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-    vertices[npoints + i] = make_vertex3d (x1, y1, 0); /* Top */
-  }
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+#if REVERSED_PCB_CONTOURS
+      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#else
+      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
-  /* Define the edges */
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if REVERSED_PCB_CONTOURS
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#else
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
+      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      RDATA (edges[1 * npoints + i]) = faces[i];
+      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
-  for (i = 0; i < 3 * npoints; i++)
-    edges[i] = make_edge ();
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
 
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
+#ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[i]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+#else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
 
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    int next_i_around_ct;
+      if (ct->is_round) {
+
+        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
+                                          COORD_TO_MM (ct->radius));
+        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+#ifdef REVERSED_PCB_CONTOURS
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#else
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+      }
 
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      start_of_ct = i;
-      printf ("start_of_ct = %i\n", start_of_ct);
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
     }
 
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[0 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[0 * npoints + i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[next_i_around_ct]));
-
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (edges[npoints + i], SYM(edges[npoints + next_i_around_ct]));
-    splice (SYM(edges[npoints + next_i_around_ct]), SYM(edges[2 * npoints + i]));
-
-    /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
-    /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
-    if (ct->is_round) {
-      UNDIR_DATA (edges[0 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-      UNDIR_DATA (edges[1 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-      UNDIR_DATA (edges[2 * npoints + i]) = make_edge_info (true,  true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+    if (0) {
+      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+      edge_ref cylinder_edges[3];
+      vertex3d *cylinder_vertices[2];
+      face3d *cylinder_faces[2];
+
+      /* Edge on top of board */
+      cylinder_edges[0] = make_edge ();
+      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#ifdef REVERSED_PCB_CONTOURS
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
+#else
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
+                            5.);         /* Radius */
+#endif
+      object3d_add_edge (board_object, cylinder_edges[0]);
+
+      /* Edge on top of cylinder */
+      cylinder_edges[1] = make_edge ();
+      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
+                            5.);          /* Radius */
+      object3d_add_edge (board_object, cylinder_edges[1]);
+
+      /* Edge stitching cylinder */
+      cylinder_edges[2] = make_edge ();
+      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+      object3d_add_edge (board_object, cylinder_edges[2]);
+
+      /* Vertex on board top surface */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+      object3d_add_vertex (board_object, cylinder_vertices[0]);
+
+      /* Vertex on cylinder top surface */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+      object3d_add_vertex (board_object, cylinder_vertices[1]);
+
+      /* Cylindrical face */
+      cylinder_faces[0] = make_face3d ();
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
+                                        5.);                   /* Radius of cylinder */
+      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+      object3d_add_face (board_object, cylinder_faces[0]);
+      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+      /* Top face of cylinder */
+      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+      object3d_add_face (board_object, cylinder_faces[1]);
+      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+      /* Splice onto board */
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+      /* Assign the appropriate vertex geometric data to each edge end */
+      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+      LDATA (cylinder_edges[0]) = cylinder_faces[0];
+      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+      LDATA (cylinder_edges[1]) = cylinder_faces[1];
+      RDATA (cylinder_edges[1]) = cylinder_faces[0];
+      LDATA (cylinder_edges[2]) = cylinder_faces[0];
+      RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+      /* Splice things together.... */
+
+      /* Link edges orbiting the cylinder bottom vertex */
+      splice (cylinder_edges[0], cylinder_edges[2]);
+      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+      /* Link edges orbiting the cylinder top vertex */
+      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
     }
 
-  }
+    board_objects = g_list_append (board_objects, board_object);
 
-  poly_Free (&outline);
+  } while (pa = pa->f, pa != board_outline);
 
-  object = make_object3d ();
-  object->first_edge = edges[0]; /* edges[34] */
-
-  return object;
-}
-
-void
-object3d_test_board_outline (void)
-{
-  object3d *board_outline;
+  poly_Free (&board_outline);
 
-  board_outline = object3d_from_board_outline ();
-  object3d_export_to_step (board_outline, "object3d_test.step");
-  destroy_object3d (board_outline);
+  return board_objects;
 }
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index a7bae87..e8c26e2 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -1,12 +1,18 @@
 typedef struct {
-  edge_ref first_edge;
   int id;
+  char *name;
+  appearance *appear;
+  GList *edges;
+  GList *vertices;
+  GList *faces;
 } object3d;
 
 void object3d_test_init (void);
 void object3d_draw_debug (void);
-object3d *make_object3d (void);
+object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
-object3d *object3d_create_test_cube (void);
-object3d *object3d_from_board_outline (void);
-void object3d_test_board_outline (void);
+void object3d_set_appearance (object3d *object, appearance *appear);
+void object3d_add_edge (object3d *object, edge_ref edge);
+void object3d_add_vertex (object3d *object, vertex3d *vertex);
+void object3d_add_face (object3d *object, face3d *face);
+GList *object3d_from_board_outline (void);
diff --git a/src/hid/common/vertex3d.h b/src/hid/common/vertex3d.h
index bac7e89..cad586d 100644
--- a/src/hid/common/vertex3d.h
+++ b/src/hid/common/vertex3d.h
@@ -1,10 +1,13 @@
 typedef struct
 {
-  float x;
-  float y;
-  float z;
+  double x;
+  double y;
+  double z;
   int id;
+
+  /* STEP crap - to hell with encapsulation */
+  step_id vertex_identifier;
 } vertex3d;
 
-vertex3d *make_vertex3d (float x, float y, float z);
+vertex3d *make_vertex3d (double x, double y, double z);
 void destroy_vertex3d (vertex3d *v);
