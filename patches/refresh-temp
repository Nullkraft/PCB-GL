Bottom: 995179a1ee50dde515cff6dedae8a4018572f557
Top:    bdc5df037d0f4b3b21c8af730e640aa7cdb0f78f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-05-02 03:07:46 +0100

Refresh of extend-board-export

---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 1f8d97b..c4de6b7 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -16,6 +16,9 @@
 #include "object3d.h"
 #include "polygon.h"
 
+#include "rtree.h"
+#include "rotate.h"
+
 #include "pcb-printf.h"
 
 #define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
@@ -238,8 +241,8 @@ object3d_from_contours (const POLYAREA *contours,
 {
   GList *objects = NULL;
   object3d *object;
-  appearance *object_appearance;
-  appearance *top_bot_appearance;
+  appearance *object_appearance = NULL;
+  appearance *top_bot_appearance = NULL;
   const POLYAREA *pa;
   PLINE *contour;
   PLINE *ct;
@@ -269,10 +272,18 @@ object3d_from_contours (const POLYAREA *contours,
     }
 
     object = make_object3d (PCB->Name);
-    object_appearance = make_appearance ();
-    top_bot_appearance = make_appearance ();
-    appearance_set_appearance (object_appearance, master_object_appearance);
-    appearance_set_appearance (top_bot_appearance, master_top_bot_appearance);
+
+    if (master_object_appearance != NULL)
+      {
+        object_appearance = make_appearance ();
+        appearance_set_appearance (object_appearance, master_object_appearance);
+      }
+
+    if (master_top_bot_appearance != NULL)
+      {
+        top_bot_appearance = make_appearance ();
+        appearance_set_appearance (top_bot_appearance, master_top_bot_appearance);
+      }
 
     object3d_set_appearance (object, object_appearance);
 
@@ -561,25 +572,31 @@ GList *
 object3d_from_board_outline (void)
 {
   POLYAREA *board_outline = board_outline_poly (true);
+
+#if 0
+  return object3d_from_soldermask_within_area (board_outline, TOP_SIDE);
+#else
+
   appearance *board_appearance;
   appearance *top_bot_appearance;
   GList *objects;
 
   board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
+  top_bot_appearance = NULL;
+//  top_bot_appearance = make_appearance ();
   appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+//  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
 #ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (board_outline,
-                                    -HACK_BOARD_THICKNESS, /* Bottom */
-                                    0,                     /* Top */
+                                    -HACK_BOARD_THICKNESS + HACK_MASK_THICKNESS, /* Bottom */
+                                    0                     -HACK_MASK_THICKNESS,  /* Top */
                                     board_appearance,
                                     top_bot_appearance);
 #else
   objects = object3d_from_contours (board_outline,
-                                     HACK_BOARD_THICKNESS / 2, /* Bottom */
-                                    -HACK_BOARD_THICKNESS / 2, /* Top */
+                                     HACK_BOARD_THICKNESS / 2 - HACK_MASK_THICKNESS, /* Bottom */
+                                    -HACK_BOARD_THICKNESS / 2 + HACK_MASK_THICKNESS, /* Top */
                                     board_appearance,
                                     top_bot_appearance);
 #endif
@@ -590,29 +607,229 @@ object3d_from_board_outline (void)
   poly_Free (&board_outline);
 
   return objects;
+#endif
+}
+
+struct mask_info {
+  POLYAREA *poly;
+  int side;
+};
+
+static POLYAREA *
+TextToPoly (TextType *Text, Coord min_line_width)
+{
+  POLYAREA *np, *res;
+  Coord x = 0;
+  unsigned char *string = (unsigned char *) Text->TextString;
+  Cardinal n;
+  FontType *font = &PCB->Font;
+
+  res = NULL;
+
+  while (string && *string)
+    {
+      /* draw lines if symbol is valid and data is present */
+      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
+        {
+          LineType *line = font->Symbol[*string].Line;
+          LineType newline;
+
+          for (n = font->Symbol[*string].LineN; n; n--, line++)
+            {
+              /* create one line, scale, move, rotate and swap it */
+              newline = *line;
+              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
+              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
+              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
+              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
+              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
+              if (newline.Thickness < min_line_width)
+                newline.Thickness = min_line_width;
+
+              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
+
+              /* the labels of SMD objects on the bottom
+               * side haven't been swapped yet, only their offset
+               */
+              if (TEST_FLAG (ONSOLDERFLAG, Text))
+                {
+                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
+                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
+                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
+                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
+                }
+              /* add offset and draw line */
+              newline.Point1.X += Text->X;
+              newline.Point1.Y += Text->Y;
+              newline.Point2.X += Text->X;
+              newline.Point2.Y += Text->Y;
+
+              np = LinePoly (&newline, newline.Thickness, NULL);
+              poly_Boolean_free (res, np, &res, PBO_UNITE);
+            }
+
+          /* move on to next cursor position */
+          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
+        }
+      else
+        {
+          /* the default symbol is a filled box */
+          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
+          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
+
+          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
+          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
+          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
+          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
+
+          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
+
+          /* add offset and draw box */
+          defaultsymbol.X1 += Text->X;
+          defaultsymbol.Y1 += Text->Y;
+          defaultsymbol.X2 += Text->X;
+          defaultsymbol.Y2 += Text->Y;
+
+          np = RectPoly (defaultsymbol.X1, defaultsymbol.X2,
+                         defaultsymbol.Y1, defaultsymbol.Y2);
+          poly_Boolean_free (res, np, &res, PBO_UNITE);
+
+          /* move on to next cursor position */
+          x += size;
+        }
+      string++;
+    }
+
+  return res;
+}
+
+static int
+line_mask_callback (const BoxType * b, void *cl)
+{
+  LineType *line = (LineType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = LinePoly (line, line->Thickness, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+arc_mask_callback (const BoxType * b, void *cl)
+{
+  ArcType *arc = (ArcType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = ArcPoly (arc, arc->Thickness, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+
+static int
+text_mask_callback (const BoxType * b, void *cl)
+{
+  TextType *text = (TextType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = TextToPoly (text, PCB->minWid))) /* XXX: Min mask cutout width should be separate */
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+polygon_mask_callback (const BoxType * b, void *cl)
+{
+  PolygonType *poly = (PolygonType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (!(np = PolygonToPoly (poly)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+pad_mask_callback (const BoxType * b, void *cl)
+{
+  PadType *pad = (PadType *) b;
+  struct mask_info *info = (struct mask_info *) cl;
+  POLYAREA *np, *res;
+
+  if (pad->Mask == 0)
+    return 0;
+
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), (info->side == BOTTOM_SIDE)))
+    return 0;
+
+  if (!(np = PadPoly (pad, pad->Mask)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+pv_mask_callback (const BoxType * b, void *cl)
+{
+  PinType *pv = (PinType *)b;
+  struct mask_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = CirclePoly (pv->X, pv->Y, pv->Mask / 2, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
 }
 
 
 GList *
-object3d_from_board_soldermask_within_area (POLYAREA *area, int side)
+object3d_from_soldermask_within_area (POLYAREA *area, int side)
 {
   appearance *mask_appearance;
   GList *objects;
-  struct mask_poly_info info;
-  BoxType *bounds;
+  struct mask_info info;
+  BoxType bounds;
+  LayerType *layer;
 
-  info.poly = area;
+  poly_Copy0 (&info.poly, area);
   info.side = side;
 
-  bounds.X1 = area->contours.xmin;
-  bounds.X2 = area->contours.xmax;
-  bounds.Y1 = area->contours.ymin;
-  bounds.Y2 = area->contours.ymax;
+  bounds.X1 = area->contours->xmin;
+  bounds.X2 = area->contours->xmax;
+  bounds.Y1 = area->contours->ymin;
+  bounds.Y2 = area->contours->ymax;
+
+  layer = LAYER_PTR ((side == TOP_SIDE) ? top_soldermask_layer : bottom_soldermask_layer);
 
-  r_search (Layer->line_tree, &bounds, NULL, line_mask_callback, &info);
-  r_search (Layer->arc_tree,  &bounds, NULL, arc_mask_callback, &info);
-  r_search (Layer->text_tree, &bounds, NULL, text_masK_callback, &info);
-  r_search (Layer->polygon_tree, &bounds, NULL, polygon_mask_callback, &info);
+  r_search (layer->line_tree, &bounds, NULL, line_mask_callback, &info);
+  r_search (layer->arc_tree,  &bounds, NULL, arc_mask_callback, &info);
+  r_search (layer->text_tree, &bounds, NULL, text_mask_callback, &info);
+  r_search (layer->polygon_tree, &bounds, NULL, polygon_mask_callback, &info);
   r_search (PCB->Data->pad_tree, &bounds, NULL, pad_mask_callback, &info);
   r_search (PCB->Data->pin_tree, &bounds, NULL, pv_mask_callback, &info);
   r_search (PCB->Data->via_tree, &bounds, NULL, pv_mask_callback, &info);
@@ -622,14 +839,14 @@ object3d_from_board_soldermask_within_area (POLYAREA *area, int side)
 
 #ifdef REVERSED_PCB_CONTOURS
   objects = object3d_from_contours (info.poly,
-                                    -HACK_BOARD_THICKNESS / 2, /* Bottom */
-                                    -HACK_BOARD_THICKNESS + HACK_MASK_THICKNESS, /* Top */
+                                    (side == TOP_SIDE) ? -HACK_MASK_THICKNESS : -HACK_BOARD_THICKNESS,                       /* Bottom */
+                                    (side == TOP_SIDE) ? 0                    : -HACK_BOARD_THICKNESS + HACK_MASK_THICKNESS, /* Top */
                                     mask_appearance,
                                     NULL);
 #else
   objects = object3d_from_contours (info.poly,
-                                    -HACK_BOARD_THICKNESS / 2 + HACK_MASK_THICKNESS, /* Bottom */
-                                    -HACK_BOARD_THICKNESS / 2, /* Top */
+                                    (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2 + HACK_MASK_THICKNESS : HACK_BOARD_THICKNESS / 2,                       /* Bottom */
+                                    (side == TOP_SIDE) ? -HACK_BOARD_THICKNESS / 2                       : HACK_BOARD_THICKNESS / 2 - HACK_MASK_THICKNESS, /* Top */
                                     mask_appearance,
                                     NULL);
 #endif
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 167a586..8a999f5 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -100,6 +100,256 @@ finish_ap214_file (step_file *step)
 }
 
 static void
+step_product_fragment (step_file *step, char *part_id, char *part_name, char *part_description,
+                              step_id *shape_representation, step_id *placement_axis)
+{
+  step_id application_context_identifier;
+  step_id product_identifier;
+  step_id product_definition_identifier;
+  step_id product_definition_shape_identifier;
+  step_id geometric_representation_context_identifier;
+  step_id shape_representation_identifier;
+  step_id brep_identifier;
+  step_id anchor_axis_identifier;
+  step_id pcb_shell_identifier;
+  step_id brep_style_identifier;
+  step_id shape_definition_representation_identifier;
+  GList *styled_item_identifiers = NULL;
+
+  /* Setup the context of the "product" we are defining", and that it is a 'part' */
+  application_context_identifier = step_application_context (step, "automotive_design");
+  step_application_protocol_definition (step, "draft international standard", "automotive_design", "1998", application_context_identifier);
+  product_identifier = step_product (step, part_id, part_name /* This one is picked up by freecad */, part_description,
+                                     make_step_id_list (1, step_product_context (step, "NONE", application_context_identifier, "mechanical")));
+  step_product_related_product_category (step, "part", NULL, make_step_id_list (1, product_identifier));
+
+  /* Setup the specific definition of the product we are defining */
+  product_definition_identifier = step_product_definition (step, "UNKNOWN", "",
+                                                           step_product_definition_formation (step, "any", "", product_identifier), /* Versioning for the product */
+                                                           step_product_definition_context (step, "detailed design", application_context_identifier, "design"));
+  product_definition_shape_identifier = step_product_definition_shape (step, "NONE", "NONE", product_definition_identifier);
+
+  geometric_representation_context_identifier = make_3d_metric_step_geometric_representation_context (step);
+
+  /* Need an anchor in 3D space to orient the shape */
+  anchor_axis_identifier = step_axis2_placement_3d (step, "NONE",
+                                                    step_cartesian_point (step, "NONE", 0.0, 0.0, 0.0),
+                                                          step_direction (step, "NONE", 0.0, 0.0, 1.0),
+                                                          step_direction (step, "NONE", 1.0, 0.0, 0.0)),
+
+  shape_representation_identifier =
+    step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
+                                             make_step_id_list (2, brep_identifier, anchor_axis_identifier), geometric_representation_context_identifier);
+
+  shape_definition_representation_identifier =
+  step_shape_definition_representation (step, product_definition_shape_identifier, shape_representation_identifier);
+
+//  if (shape_definition_representation != NULL)
+//    *shape_definition_representation = shape_definition_representation_identifier;
+
+  if (placement_axis != NULL)
+    *placement_axis = anchor_axis_identifier;
+}
+
+static void
+object3d_to_step_body_fragment (step_file *step, object3d *object, char *part_id, char *part_name, char *part_description, char *body_name,
+                                step_id *shape_definition_representation, step_id *brep)
+{
+  step_id brep_identifier;
+  step_id pcb_shell_identifier;
+  step_id brep_style_identifier;
+  GList *styled_item_identifiers = NULL;
+  GList *shell_face_list = NULL;
+  GList *face_iter;
+  GList *edge_iter;
+  GList *vertex_iter;
+  GList *contour_iter;
+
+#define FWD 1
+#define REV 2
+#define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
+
+  /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+
+    if (face->is_cylindrical) {
+      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+       */
+      face->surface_identifier =
+        step_cylindrical_surface (step, "NONE",
+                                  step_axis2_placement_3d (step, "NONE",
+                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                  face->radius);
+    } else {
+      contour3d *outer_contour = face->contours->data;
+      vertex3d *ov = ODATA (outer_contour->first_edge);
+      vertex3d *dv = DDATA (outer_contour->first_edge);
+
+      double rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
+      face->surface_identifier =
+        step_plane (step, "NONE",
+                    step_axis2_placement_3d (step, "NONE",
+                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */ 
+                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
+                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
+    }
+  }
+
+  /* Define the infinite lines corresponding to every edge (either lines or circles)*/
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+
+    if (info->is_round) {
+      info->infinite_line_identifier =
+        step_circle (step, "NONE",
+                     step_axis2_placement_3d (step, "NONE",
+                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                    info->radius);
+    } else {
+      vertex3d *ov = ODATA (edge);
+      vertex3d *dv = DDATA (edge);
+
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
+      info->infinite_line_identifier =
+        step_line (step, "NONE",
+                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                   step_vector (step, "NONE",
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
+                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
+    }
+  }
+
+  /* Define the vertices */
+  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter)) {
+    vertex3d *vertex = vertex_iter->data;
+
+    vertex->vertex_identifier =
+      step_vertex_point (step, "NONE", step_cartesian_point (step, "NONE", vertex->x, vertex->y, vertex->z));
+  }
+
+  /* Define the Edges */
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+    step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
+    step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
+
+    /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
+    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+    step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
+    step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
+  }
+
+  /* Define the faces */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+    bool outer_contour = true;
+    step_id_list face_contour_list = NULL;
+
+    for (contour_iter = face->contours;
+         contour_iter != NULL;
+         contour_iter = g_list_next (contour_iter), outer_contour = false) {
+      contour3d *contour = contour_iter->data;
+      edge_ref edge;
+      step_id edge_loop;
+      step_id_list edge_loop_edges = NULL;
+
+      edge = contour->first_edge;
+      do {
+        edge_loop_edges = g_list_append (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
+      } while (edge = LNEXT (edge), edge != contour->first_edge);
+
+      edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
+
+      if (outer_contour)
+        contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, true);
+      else
+        contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
+
+      face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
+    }
+
+    face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
+    shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
+  }
+
+  /* Closed shell which bounds the brep solid */
+  pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
+  brep_identifier = step_manifold_solid_brep (step, body_name /* This is picked up as the solid body name by Solidworks */, pcb_shell_identifier);
+
+#if 1
+  /* Body style */
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
+
+  /* Face styles */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+
+    if (face->appear != NULL) {
+      step_id orsi = step_over_riding_styled_item (step, "NONE",
+                                                   presentation_style_assignments_from_appearance (step, face->appear),
+                                                   face->face_identifier, brep_style_identifier);
+      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+    }
+  }
+
+  /* Emit references to the styled and over_ridden styled items */
+// XXX: step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
+
+  if (brep != NULL)
+    *brep = brep_identifier;
+
+#undef ORIENTED_EDGE_IDENTIFIER
+#undef FWD
+#undef REV
+}
+
+static void
 object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, char *part_name, char *part_description, char *body_name,
                            step_id *shape_definition_representation, step_id *placement_axis)
 {
@@ -337,6 +587,55 @@ object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, cha
 }
 
 void
+object3d_list_export_to_step_part (GList *objects, const char *filename)
+{
+  step_file *step;
+  step_id product_definition_shape;
+  step_id comp_shape_representation;
+  step_id comp_shape_definition_representation;
+  step_id comp_placement_axis;
+  step_id comp_brep;
+  GList *object_iter;
+  int part;
+  bool multiple_bodies;
+  GString *part_id;
+  GString *part_name;
+
+  multiple_bodies = (g_list_next (objects) != NULL);
+
+  part_id   = g_string_new ("part id");
+  part_name = g_string_new ("part name");
+
+  step = start_ap214_file (filename);
+
+  step_product_fragment (step, part_id->str, part_name->str, "PCB model", &comp_shape_representation, &comp_placement_axis);
+
+  for (object_iter = objects, part = 1;
+       object_iter != NULL;
+       object_iter = g_list_next (object_iter), part++) {
+
+    object3d *object = object_iter->data;
+    GString *body_name;
+
+    body_name = g_string_new ("part body");
+    if (multiple_bodies)
+      g_string_append_printf (body_name, " - %i", part);
+
+    object3d_to_step_body_fragment (step, object, part_id->str, part_name->str, "PCB model", body_name->str,
+                                    &comp_shape_definition_representation, &comp_brep);
+
+    g_string_free (body_name, true);
+
+    /* XXX: Append brep identifier onto a list for later use in forming the product's shape_representation */
+  }
+
+  g_string_free (part_id, true);
+  g_string_free (part_name, true);
+
+  finish_ap214_file (step);
+}
+
+void
 object3d_list_export_to_step_assy (GList *objects, const char *filename)
 {
   step_file *step;
diff --git a/src/hid/step/object3d_step.h b/src/hid/step/object3d_step.h
index 5dc6f4d..2860d9b 100644
--- a/src/hid/step/object3d_step.h
+++ b/src/hid/step/object3d_step.h
@@ -1,2 +1,3 @@
+void object3d_list_export_to_step_part (GList *objects, const char *filename);
 void object3d_list_export_to_step_assy (GList *objects, const char *filename);
 void object3d_export_to_step (object3d *object, const char *filename);
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 2e2e86d..e360435 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -136,6 +136,8 @@ step_do_export (HID_Attr_Val * options)
   const char *filename;
   const char *temp_pcb_filename = "_pcb.step";
   GList *board_outline_list;
+  POLYAREA *board_outline;
+  POLYAREA *piece;
 
   if (!options)
     {
@@ -150,6 +152,21 @@ step_do_export (HID_Attr_Val * options)
     filename = "pcb-out.step";
 
   board_outline_list = object3d_from_board_outline ();
+
+  board_outline = board_outline_poly (false);
+  piece = board_outline;
+  do {
+    GList *mask_objects;
+
+    mask_objects = object3d_from_soldermask_within_area (piece, TOP_SIDE);
+    board_outline_list = g_list_concat (board_outline_list, mask_objects);
+
+    mask_objects = object3d_from_soldermask_within_area (piece, BOTTOM_SIDE);
+    board_outline_list = g_list_concat (board_outline_list, mask_objects);
+
+  } while ((piece = piece->f) != board_outline);
+  poly_Free (&board_outline);
+
   object3d_list_export_to_step_assy (board_outline_list, temp_pcb_filename);
   g_list_free_full (board_outline_list, (GDestroyNotify)destroy_object3d);
 
diff --git a/src/polygon.c b/src/polygon.c
index 8834733..667895b 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -687,14 +687,72 @@ LinePoly (LineType * L, Coord thick, char *name)
   return np;
 }
 
-/* make a rounded-corner rectangle */
-POLYAREA *
+/* make a rectangle pad (clear is applied square, not rounded) */
+static POLYAREA *
 SquarePadPoly (PadType * pad, Coord clear)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
   double d;
+  double cx, cy;
+  PadType _c=*pad,*c=&_c;
+  int halfclear = (clear + 1) / 2;
+
+  d =
+    sqrt (SQUARE (pad->Point1.X - pad->Point2.X) +
+          SQUARE (pad->Point1.Y - pad->Point2.Y));
+  if (d != 0)
+    {
+      double a = halfclear / d;
+      cx = (c->Point1.Y - c->Point2.Y) * a;
+      cy = (c->Point2.X - c->Point1.X) * a;
+
+      c->Point1.X -= cy;
+      c->Point1.Y += cx;
+      c->Point2.X += cy;
+      c->Point2.Y -= cx;
+    }
+  else
+    {
+      cx = halfclear;
+      cy = 0;
+
+      c->Point1.Y += cx;
+      c->Point2.Y -= cx;
+    }
+
+  v[0] = c->Point1.X + cx;
+  v[1] = c->Point1.Y + cy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
+
+  v[0] = c->Point1.X - cx;
+  v[1] = c->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  v[0] = c->Point2.X - cx;
+  v[1] = c->Point2.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  v[0] = c->Point2.X + cx;
+  v[1] = c->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  /* now we have the line contour */
+  if (!(np = ContourToPoly (contour)))
+    return NULL;
+  return np;
+}
+
+/* make a rounded-corner rectangle */
+static POLYAREA *
+SquarePadClearPoly (PadType * pad, Coord clear)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Vector v;
+  double d;
   double tx, ty;
   double cx, cy;
   PadType _t=*pad,*t=&_t;
@@ -835,6 +893,24 @@ BoxPolyBloated (BoxType *box, Coord bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
+POLYAREA *
+PadPoly (PadType *pad, Coord size)
+{
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    return SquarePadPoly (pad, size);
+  else
+    return LinePoly ((LineType *) pad, size, NULL);
+}
+
+static POLYAREA *
+PadClearPoly (PadType *pad, Coord size)
+{
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    return SquarePadClearPoly (pad, size);
+  else
+    return LinePoly ((LineType *) pad, size, NULL);
+}
+
 /* remove the pin clearance from the polygon */
 static int
 SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
@@ -905,18 +981,8 @@ SubtractPad (PadType * pad, PolygonType * p)
 
   if (pad->Clearance == 0)
     return 0;
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance, NULL)))
-        return -1;
-    }
+  if (!(np = PadClearPoly (pad, pad->Thickness + pad->Clearance)))
+    return -1;
   return Subtract (np, p, true);
 }
 
diff --git a/src/polygon.h b/src/polygon.h
index 3737f35..e86059e 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -75,6 +75,7 @@ POLYAREA * LinePoly(LineType *l, Coord thick, char *name);
 POLYAREA * ArcPoly(ArcType *l, Coord thick, char *name);
 POLYAREA * PinPoly(PinType *l, Coord thick, Coord clear);
 POLYAREA * BoxPolyBloated (BoxType *box, Coord radius);
+POLYAREA * PadPoly (PadType *pad, Coord size);
 void frac_circle (PLINE *, Coord, Coord, Vector, int);
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
