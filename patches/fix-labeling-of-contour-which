Bottom: 0e5daf8cdc3e52d373e98398cbd8398b7164c046
Top:    9c4f920e4ee2f17e534fb1320892ec096ed0f842
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-21 20:04:32 +0000

Fix labeling of contour which ends up as all SHARED / SHARED2, or all UNKNKWN

SHARED / SHARED2 labelling does not propagate, so if this occurs for an entire
contour, the labelling code would loop forever. (Same as if no cross-connected
vertex with definitive INSIDE / OUTSIDE information was found).

Catch when we wrap around the edge list and then decide how to classify the
whole contour. If it is all UNKNWN, we re-classify it as not intersected. The
cntr_label_POLYAREA() routine is adjusted to handle the possibility that the
label_contour() routine for ISECTED contours changes the contour status back
back to UNKNWN.

If the whole contour is SHARED or SHARED2, we leave it as ISECTED, since there
is no handling of that condition for an entire contour. (It will either be
dropped, or re-constructed, depending on the boolean operation being performed).


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 670c1df..546bf45 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -1504,7 +1504,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   /* DEBUG */
   poly_M_Copy0 (&PCB->Data->outline, info.poly);
   PCB->Data->outline_valid = true;
-  gui->invalidate_all ();
+//  gui->invalidate_all ();
 
   poly_Free (&info.poly);
 
diff --git a/src/polygon.h b/src/polygon.h
index aabc096..1343d03 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,7 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 10 //40
+#define POLY_CIRC_SEGS 8 //10 //40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index e8db54f..1164e9d 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1218,7 +1218,26 @@ label_contour (PLINE * a)
       assert (label == INSIDE || label == OUTSIDE);
       LABEL_EDGE (cure, label);
     }
-  while ((cure = NEXT_EDGE (cure)) != first_labelled);
+  while ((cure = NEXT_EDGE (cure)) != first_labelled && (first_labelled != NULL || cure != &a->head));
+
+  if (first_labelled == NULL)
+    {
+//      g_warning ("Walked entire contour and couldn't find anything we could label - is it INSIDE or OUTSIDE??  SHARED OR SHARED2??");
+
+      if (EDGE_LABEL (&a->head) == UNKNWN)
+        {
+          g_warning ("Walked entire contour and couldn't find anything we could label - it is either all INSIDE or OUTSIDE");
+          /* Mark the contour as NOT intersected, so it can be treated separately below. */
+          /* XXX: Does this work with separated out intersected contours? */
+          a->Flags.status = UNKNWN;
+        }
+      else
+        {
+          g_warning ("Walked entire contour and couldn't find anything we could label - it is either all SHARED OR SHARED2");
+          /* Head was marked, so presumably the entire contour is either SHARED or SHARED2 */
+        }
+    }
+
 #warning The above loop could run forever if we encounter a contour where the only intersection gets nuked due to shared edges
 #ifdef DEBUG_ALL_LABELS
   print_labels (a);
@@ -1235,7 +1254,12 @@ cntr_label_POLYAREA (PLINE * poly, POLYAREA * ppl, BOOLp test)
     {
       label_contour (poly);	/* should never get here when BOOLp is true */
     }
-  else if (cntr_in_M_POLYAREA (poly, ppl, test))
+
+  /* label_contour may decide the contour is NOT intersected, and we must fall through to the tests below */
+  if (poly->Flags.status == ISECTED)
+    return false;
+
+  if (cntr_in_M_POLYAREA (poly, ppl, test))
     {
       if (test)
 	return TRUE;
@@ -2328,6 +2352,7 @@ M_POLYAREA_Collect_separated (jmp_buf * e, PLINE * afst, POLYAREA ** contours,
       if (cntr_Collect (e, cur, contours, holes, action, NULL, NULL, NULL))
 	next = cur;
     }
+  /* XXX: What about rogue contours we re-labelled as INSIDE or OUTSIDE - ARE THEY DEALT WITH OK? */
 }
 
 static void
