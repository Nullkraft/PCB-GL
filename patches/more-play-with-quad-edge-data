Bottom: 919e8b28ff69f069f4d92811dc167b986d0d73df
Top:    a365a32d95f0a33b2bff8db2699286f3f75947f3
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:25:59 +0000

More play with quad edge data-structures and STEP export


---

diff --git a/src/Makefile.am b/src/Makefile.am
index df1ea37..35d6178 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -159,6 +159,8 @@ PCB_SRCS = \
 	hid/common/hid_resource.h \
 	hid/common/appearance.c \
 	hid/common/appearance.h \
+	hid/common/contour3d.c \
+	hid/common/contour3d.h \
 	hid/common/edge3d.c \
 	hid/common/edge3d.h \
 	hid/common/face3d.c \
diff --git a/src/hid/common/contour3d.c b/src/hid/common/contour3d.c
new file mode 100644
index 0000000..6aa3189
--- /dev/null
+++ b/src/hid/common/contour3d.c
@@ -0,0 +1,22 @@
+#include <glib.h>
+#include <stdbool.h>
+
+#include "quad.h"
+#include "contour3d.h"
+
+contour3d *
+make_contour3d (edge_ref first_edge)
+{
+  contour3d *contour;
+
+  contour = g_new0 (contour3d, 1);
+  contour->first_edge = first_edge;
+
+  return contour;
+}
+
+void
+destroy_contour3d (contour3d *contour)
+{
+  g_free (contour);
+}
diff --git a/src/hid/common/contour3d.h b/src/hid/common/contour3d.h
new file mode 100644
index 0000000..7723f31
--- /dev/null
+++ b/src/hid/common/contour3d.h
@@ -0,0 +1,7 @@
+typedef struct {
+  edge_ref first_edge;
+
+} contour3d;
+
+contour3d *make_contour3d (edge_ref first_edge);
+void destroy_contour3d (contour3d *contour);
diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index 3f08003..263f986 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,25 +1,39 @@
 #include <stdbool.h>
 #include <stdlib.h>
+#include <glib.h>
 
 #include "edge3d.h"
 
 edge_info *
-make_edge_info (bool is_stitch, bool is_round, double cx, double cy, double radius)
+make_edge_info (void)
 {
   edge_info *info;
 
-  info = malloc (sizeof(edge_info));
-  info->is_stitch = is_stitch;
-  info->is_round = is_round;
+  info = g_new0 (edge_info, 1);
+
+  return info;
+}
+
+void
+edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius)
+{
+  info->is_round = true;
   info->cx = cx;
   info->cy = cy;
+  info->cz = cz;
+  info->nx = nx;
+  info->ny = ny;
+  info->nz = nz;
   info->radius = radius;
+}
 
-  return info;
+void edge_info_set_stitch (edge_info *info)
+{
+  info->is_stitch = true;
 }
 
 void
 destroy_edge_info (edge_info *info)
 {
-  free (info);
+  g_free (info);
 }
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 22e783f..060c7b2 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -1,11 +1,20 @@
 typedef struct
 {
-  bool is_stitch;
+  /* For edge curves */
+  bool is_stitch; /* Allows us to identify the stitch edge along the side of a cylinder */
+
+  /* For circular curves */
   bool is_round;
   double cx;
   double cy;
+  double cz;
+  double nx;
+  double ny;
+  double nz;
   double radius;
 } edge_info;
 
-edge_info *make_edge_info (bool is_stitch, bool is_round, double cx, double cy, double radius);
+edge_info *make_edge_info (void);
+void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
+void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index 1a8c8c3..8791abf 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -1,6 +1,9 @@
 #include <glib.h>
+#include <stdbool.h>
 
 #include "quad.h"
+#include "contour3d.h"
+#include "appearance.h"
 #include "face3d.h"
 
 face3d *
@@ -16,12 +19,39 @@ make_face3d (void)
 void
 destroy_face3d (face3d *face)
 {
-  g_list_free (face->contours);
+  g_list_free_full (face->contours, (GDestroyNotify)destroy_contour3d);
   g_free (face);
 }
 
 void
-face3d_add_contour (face3d *face, edge_ref contour)
+face3d_add_contour (face3d *face, contour3d *contour)
 {
-  face->contours = g_list_append (face->contours, (void *)contour);
+  face->contours = g_list_append (face->contours, contour);
+}
+
+void
+face3d_set_appearance (face3d *face, appearance *appear)
+{
+  face->appear = appear;
+}
+
+void
+face3d_set_normal (face3d *face, double nx, double ny, double nz)
+{
+  face->nx = nx;
+  face->ny = ny;
+  face->nz = nz;
+}
+
+void
+face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius)
+{
+  face->is_cylindrical = true;
+  face->cx = cx;
+  face->cy = cy;
+  face->cz = cz;
+  face->ax = ax;
+  face->ay = ay;
+  face->az = az;
+  face->radius = radius;
 }
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 42154df..4838c43 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,8 +1,19 @@
 typedef struct {
   double nx, ny, nz; /* Face normal?*/
   GList *contours;
+
+  /* For cylindrical surfaces */
+  bool is_cylindrical;
+  double cx, cy, cz; /* A point on the axis */
+  double ax, ay, az; /* Direction of the axis */
+  double radius;
+
+  appearance *appear;
 } face3d;
 
 face3d *make_face3d (void);
 void destroy_face3d (face3d *face);
-void face3d_add_contour (face3d *face, edge_ref contour);
+void face3d_add_contour (face3d *face, contour3d *contour);
+void face3d_set_appearance (face3d *face, appearance *appear);
+void face3d_set_normal (face3d *face, double nx, double ny, double nz);
+void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index f89c15c..79fdfe8 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -7,9 +7,10 @@
 
 #include "quad.h"
 #include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
 #include "face3d.h"
 #include "edge3d.h"
-#include "appearance.h"
 #include "object3d.h"
 #include "polygon.h"
 #include "data.h"
@@ -70,7 +71,7 @@ make_object3d (char *name)
   static int object3d_count = 0;
   object3d *object;
 
-  object = g_new (object3d, 1);
+  object = g_new0 (object3d, 1);
   object->id = object3d_count++;
   name = g_strdup (name);
 
@@ -141,12 +142,15 @@ object3d_create_test_cube (void)
   for (i = 0; i < 12; i++)
     {
       cube_edges[i] = make_edge ();
+      UNDIR_DATA (cube_edges[i]) = make_edge_info ();
       object3d_add_edge (object, cube_edges[i]);
     }
 
   for (i = 0; i < 6; i++)
     {
       faces[i] = make_face3d ();
+      /* XXX: Face normal */
+      /* XXX: Face contours */
       object3d_add_face (object, faces[i]);
     }
 
@@ -222,12 +226,13 @@ draw_quad_edge (edge_ref e, void *data)
           glBegin (GL_LINES);
           for (i = 0; i < CIRC_SEGS; i++)
             {
+              /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
               glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
                           MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (((vertex3d *)ODATA(e))->z));
+                          MM_TO_COORD (info->cz));
               glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
                           MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          MM_TO_COORD (((vertex3d *)ODATA(e))->z));
+                          MM_TO_COORD (info->cz));
             }
           glEnd ();
           return;
@@ -289,250 +294,229 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
   *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
 }
 
-#if 0
-static void
-fprint_idlist (FILE *f, int *ids, int num_ids)
+object3d *
+object3d_from_board_outline (void)
 {
+  object3d *object;
+  appearance *board_appearance;
+  appearance *top_bot_appearance;
+  POLYAREA *outline;
+  PLINE *contour;
+  PLINE *ct;
+  int ncontours;
+  int npoints;
   int i;
-  fprintf (f, "(");
-  for (i = 0; i < num_ids - 1; i++)
-    fprintf (f, "#%i, ", ids[i]);
-  fprintf (f, "#%i) ) ;\n", ids[i]);
-}
+  vertex3d **vertices;
+  edge_ref *edges;
+  face3d **faces;
+  int start_of_ct;
+  int offset_in_ct;
+  int ct_npoints;
 
-void
-object3d_export_to_step (object3d *object, const char *filename)
-{
-  FILE *f;
-  time_t currenttime;
-  struct tm utc;
-  int next_step_identifier;
-  int brep_identifier;
-  int pcb_shell_identifier;
-
-  f = fopen (filename, "w");
-  if (f == NULL)
-    {
-      perror (filename);
-      return;
-    }
+  outline = board_outline_poly (true);
+  //outline = board_outline_poly (false); /* (FOR NOW - just the outline, no holes) */
+  ncontours = 0;
+  npoints = 0;
 
-  currenttime = time (NULL);
-  gmtime_r (&currenttime, &utc);
-
-  fprintf (f, "ISO-10303-21;\n");
-  fprintf (f, "HEADER;\n");
-  fprintf (f, "FILE_DESCRIPTION (\n"
-              "/* description */ ('STEP AP214 export of circuit board'),\n"
-              "/* implementation level */ '1');\n");
-  fprintf (f, "FILE_NAME (/* name */ '%s',\n"
-              "/* time_stamp */ '%.4d-%.2d-%.2dT%.2d:%.2d:%.2d',\n"
-              "/* author */ ( '' ),\n"
-              "/* organisation */ ( '' ),\n"
-              "/* preprocessor_version */ 'PCB STEP EXPORT',\n"
-              "/* originating system */ '%s " VERSION "',\n"
-              "/* authorisation */ '' );\n",
-           filename,
-           1900 + utc.tm_year, 1 + utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec,
-           Progname);
-  fprintf (f, "FILE_SCHEMA (( 'AUTOMOTIVE_DESIGN' ));\n");
-  fprintf (f, "ENDSEC;\n");
-  fprintf (f, "\n");
-  fprintf (f, "DATA;\n");
-
-  /* TEST */
-
-  /* Setup the context of the "product" we are defining", and that it is a 'part' */
-
-  fprintf (f, "#1 = APPLICATION_CONTEXT ( 'automotive_design' ) ;\n"
-              "#2 = APPLICATION_PROTOCOL_DEFINITION ( 'draft international standard', 'automotive_design', 1998, #1 );\n"
-              "#3 = PRODUCT_CONTEXT ( 'NONE', #1, 'mechanical' ) ;\n"
-              "#4 = PRODUCT ('%s', '%s', '%s', (#3)) ;\n"
-              "#5 = PRODUCT_RELATED_PRODUCT_CATEGORY ('part', $, (#4)) ;\n",
-              "test_pcb_id", "test_pcb_name", "test_pcb_description");
-
-  /* Setup the specific definition of the product we are defining */
-  fprintf (f, "#6 = PRODUCT_DEFINITION_CONTEXT ( 'detailed design', #1, 'design' ) ;\n"
-              "#7 = PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE ( 'ANY', '', #4, .NOT_KNOWN. ) ;\n"
-              "#8 = PRODUCT_DEFINITION ( 'UNKNOWN', '', #7, #6 ) ;\n"
-              "#9 = PRODUCT_DEFINITION_SHAPE ( 'NONE', 'NONE',  #8 ) ;\n");
-
-  /* Need an anchor in 3D space to orient the shape */
-  fprintf (f, "#10 =    CARTESIAN_POINT ( 'NONE',  ( 0.0, 0.0, 0.0 ) ) ;\n"
-              "#11 =          DIRECTION ( 'NONE',  ( 0.0, 0.0, 1.0 ) ) ;\n"
-              "#12 =          DIRECTION ( 'NONE',  ( 1.0, 0.0, 0.0 ) ) ;\n"
-              "#13 = AXIS2_PLACEMENT_3D ( 'NONE', #10, #11, #12 ) ;\n");
-
-  /* Grr.. more boilerplate - this time unit definitions */
-
-  fprintf (f, "#14 = UNCERTAINTY_MEASURE_WITH_UNIT (LENGTH_MEASURE( 1.0E-005 ), #15, 'distance_accuracy_value', 'NONE');\n"
-              "#15 =( LENGTH_UNIT ( ) NAMED_UNIT ( * ) SI_UNIT ( .MILLI., .METRE. ) );\n"
-              "#16 =( NAMED_UNIT ( * ) PLANE_ANGLE_UNIT ( ) SI_UNIT ( $, .RADIAN. ) );\n"
-              "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
-              "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
-
-  /* BREP STUFF FROM #21 onwards say? */
-  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( /* Manifold_solid_brep */ #21, #13 ), #18 ) ;\n"
-              "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
-              "test_pcb_absr_name");
-
-  next_step_identifier = 21;
-
-  /* TODO.. EXPORT FROM A QUAD DATA-STRUCTURE */
-#if 1
-#define FWD 1
-#define REV 2
-
-  /* Save a place for the brep identifier */
-  brep_identifier = next_step_identifier++;
-
-  /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
+  contour = outline->contours;
+
+  ct = contour;
+  while (ct != NULL)
     {
-      if (ct->is_round)
-        {
-          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
-           * BECAUSE OUR ROUND CONTOURS ARE (CURRENTLY) ALWAYS HOLES IN THE SOLID,
-           * THIS MEANS THE CYLINDER NORMAL POINTS INTO THE OBJECT
-           */
-          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                      "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
-                   next_step_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
-                   next_step_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
-                   next_step_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                   next_step_identifier + 4, next_step_identifier + 3, COORD_TO_MM (ct->radius));
-
-          plane_identifiers[i] = next_step_identifier + 4;
-          next_step_identifier = next_step_identifier + 5;
-        }
-      else
-        {
-          /* FOR CONSISTENCY WITH ABOVE, DEFINE PLANE NORMAL TO BE POINTING INSIDE THE SHAPE.
-           * THIS ALLOWS TO FLIP THE ORIENTATION OF THE UNDERLYING SURFACE WHEN DEFINING EVERY ADVANCED_FACE
-           */
-          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier, x1, y1, 0.0);    // <-- A locating point on the plane. Forms 0,0 of its parameterised coords.
-          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 1,  -(y2 - y1), (x2 - x1), 0.0);  /* An axis direction pointing into the shape */ // <-- Or is this the z-axis of the coordinate placement -> plane normal?
-          fprintf (f, "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier + 2, 0.0, 0.0, 1.0);          // <-- Reference x-axis, should be orthogonal to the z-axis above.
-          fprintf (f, "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2);
-          fprintf (f, "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-                   next_step_identifier + 4, next_step_identifier + 3);
-          plane_identifiers[i] = next_step_identifier + 4;
-          next_step_identifier = next_step_identifier + 5;
-        }
+      ncontours ++;
+      npoints += get_contour_npoints (ct);
+      ct = ct->next;
     }
 
-  /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  /* We know how many edges and vertices we need now...
+   *
+   * let n = npoints
+   * bodies = 1             (FOR NOW - just the first board outline)
+   * vertices = 2n          (n-top, n-bottom)
+   * edges = 3n             (n-top, n-bottom, n-sides)
+   * faces = 2 + n          (1-top, 1-bottom, n-sides)
+   *
+   * holes = 0              (FOR NOW - just the outline, no holes)
+   * holes = ncontours - 1  (LATER)
+   */
+
+  object = make_object3d (PCB->Name);
+  board_appearance = make_appearance ();
+  top_bot_appearance = make_appearance ();
+  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+
+  object3d_set_appearance (object, board_appearance);
+
+  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
+  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
+  faces    = malloc (sizeof (face3d *) * (2 + npoints));
+
+  /* Define the vertices */
+  ct = contour;
+  start_of_ct = 0;
+  offset_in_ct = 0;
+  ct_npoints = get_contour_npoints (ct);
+
+  for (i = 0; i < npoints; i++, offset_in_ct++)
     {
+      double x1, y1;
 
-      if (ct->is_round)
-        {
-          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                      "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                   next_step_identifier,     /* Center of the circle   */ edge_info->cx, edge_info->cy, edge_info->cz, // <--- Center of coordinate placement
-                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
-                   next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
-                   next_step_identifier + 4, next_step_identifier + 3, edge_info->radius);
-          infinite_line_identifiers[i] = next_step_identifier + 4;
-          next_step_identifier = next_step_identifier + 5;
-        }
-      else
+      /* Update which contour we're looking at */
+      if (offset_in_ct == ct_npoints)
         {
-          double dx, dy, dz;
-
-          dx = end_v->x - start_v->x;
-          dy = end_v->y - start_v->y;
-          dz = end_v->z - start_v->z;
-
-          fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                      "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                      "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                   next_step_identifier,     /* A point on the line         */ start_v->x, start_v->y, start_v->z,
-                   next_step_identifier + 1, /* A direction along the line  */ dx, dy, dz,
-                   next_step_identifier + 2, next_step_identifier + 1,
-                   next_step_identifier + 3, next_step_identifier, next_step_identifier + 2);
-          infinite_line_identifiers[i] = next_step_identifier + 3;
-          next_step_identifier = next_step_identifier + 4;
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
         }
-    }
 
-  /* Define the vertices */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
-    {
-      fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; ", next_step_identifier,     /* Vertex coordinate  */ x, y, z);
-      fprintf (f, "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",             next_step_identifier + 1, next_step_identifier);
-      vertex_identifiers[i] = next_step_identifier + 1;
-      next_step_identifier = next_step_identifier + 2;
+      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
+      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
     }
 
-  /* Define the Edges */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE */
-  for (;;)
+  /* Define the edges */
+  for (i = 0; i < 3 * npoints; i++)
     {
-      fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; ", next_step_identifier, start_vertex_identifiers[i], end_vertex_identifiers[i], infinite_line_identifier[i]);
-      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; ",    next_step_identifier + 1, next_step_identifier);
-      fprintf (f, "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",   next_step_identifier + 2, next_step_identifier);
-      edge_identifiers[i] = next_step_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-      next_step_identifier = next_step_identifier + 3;
+      edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
+      object3d_add_edge (object, edges[i]);
     }
 
   /* Define the faces */
-  /* XXX: ENUMERATE OVER SPATIAL DATA-STRUCTURE (ESPECIALLY FOR CORRECT ORDERING!)*/
-  for (;;)
+  for (i = 0; i < npoints; i++)
     {
-      start_i = 0;
-      for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next)
-        {
-
-          /* XXX: FWD / BWD NEEDS TO BE FUDGED IN HERE PERHAPS? */ 
-          fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_edge_identifiers[i], face_contour_npoints[i]); fprintf (f, " ) ; ");
-          fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n", next_step_identifier + 1, icont > 0 ? "" : "OUTER_", next_step_identifier);
-          face_bound_identifiers[icont] = next_step_identifier + 1;
-          next_step_identifier = next_step_identifier + 2;
-        }
+      faces[i] = make_face3d ();
 
-      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", next_step_identifier); fprint_idlist (f, face_bound_identifiers, ncontours);  fprintf (f, ", #%i, .F. ) ;\n", plane_identifiers[i]);
-      face_identifiers[i] = next_step_identifier;
-      next_step_identifier = next_step_identifier + 1;
+      object3d_add_face (object, faces[i]);
+      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
     }
 
-  /* Closed shell which bounds the brep solid */
-  pcb_shell_identifier = next_step_identifier;
-  next_step_identifier++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ", pcb_shell_identifier); fprint_idlist (f, face_identifiers, nfaces); fprintf (f, " ) ;\n");
+  faces[npoints] = make_face3d (); /* bottom_face */
+  faces[npoints]->nx =  0.;
+  faces[npoints]->ny =  0.;
+  faces[npoints]->nz = -1.;
+  face3d_set_appearance (faces[npoints], top_bot_appearance);
+  object3d_add_face (object, faces[npoints]);
 
-  /* Finally emit the brep solid definition */
-  fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
+  faces[npoints + 1] = make_face3d (); /* top_face */
+  faces[npoints + 1]->nx = 0.;
+  faces[npoints + 1]->ny = 0.;
+  faces[npoints + 1]->nz = 1.;
+  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+  object3d_add_face (object, faces[npoints + 1]);
 
-#undef FWD
-#undef REV
-#endif
+  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+
+  ct = contour;
+  start_of_ct = 0;
+  offset_in_ct = 0;
+  ct_npoints = get_contour_npoints (ct);
 
-  fprintf (f, "ENDSEC;\n" );
-  fprintf (f, "END-ISO-10303-21;\n" );
+  for (i = 0; i < npoints; i++, offset_in_ct++)
+  {
+    int next_i_around_ct;
+    int prev_i_around_ct;
+
+    /* Update which contour we're looking at */
+    if (offset_in_ct == ct_npoints)
+      {
+        start_of_ct = i;
+        offset_in_ct = 0;
+        ct = ct->next;
+        ct_npoints = get_contour_npoints (ct);
+
+        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+      }
+
+    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+    /* Define the (non-normalized) face normal to point to the outside of the contour */
+    faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
+    faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
+    faces[i]->nz = 0.;
+
+    /* Assign the appropriate vertex geometric data to each edge end */
+    ODATA (edges[              i]) = vertices[0 * npoints + i];
+    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+    LDATA (edges[              i]) = faces[i];
+    RDATA (edges[              i]) = faces[npoints];
+    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+    RDATA (edges[1 * npoints + i]) = faces[i];
+    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+    RDATA (edges[2 * npoints + i]) = faces[i];
+
+    /* NB: Contours are counter clockwise in XY plane.
+     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+     */
+
+    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+    splice (edges[i], edges[2 * npoints + i]);
+    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+
+    if (ct->is_round)
+      {
+
+        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                          COORD_TO_MM (ct->radius));
+        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
+        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+      }
+
+  }
 
-  fclose (f);
+  poly_Free (&outline);
+
+  return object;
+}
+
+void
+object3d_test_board_outline (void)
+{
+  object3d *board_outline;
+
+  board_outline = object3d_from_board_outline ();
+  object3d_export_to_step (board_outline, "object3d_test.step");
+  destroy_object3d (board_outline);
 }
-#endif
 
 object3d *
-object3d_from_board_outline (void)
+object3d_from_tracking (void)
 {
   object3d *object;
   appearance *board_appearance;
+  appearance *top_bot_appearance;
   POLYAREA *outline;
   PLINE *contour;
   PLINE *ct;
@@ -547,7 +531,6 @@ object3d_from_board_outline (void)
   int ct_npoints;
 
   outline = board_outline_poly (true);
-  //outline = board_outline_poly (false); /* (FOR NOW - just the outline, no holes) */
   ncontours = 0;
   npoints = 0;
 
@@ -562,21 +545,11 @@ object3d_from_board_outline (void)
       ct = ct->next;
     }
 
-  /* We know how many edges and vertices we need now...
-   *
-   * let n = npoints
-   * bodies = 1             (FOR NOW - just the first board outline)
-   * vertices = 2n          (n-top, n-bottom)
-   * edges = 3n             (n-top, n-bottom, n-sides)
-   * faces = 2 + n          (1-top, 1-bottom, n-sides)
-   *
-   * holes = 0              (FOR NOW - just the outline, no holes)
-   * holes = ncontours - 1  (LATER)
-   */
-
   object = make_object3d (PCB->Name);
   board_appearance = make_appearance ();
-  appearance_set_color (board_appearance, 1., 1., 0.);
+  top_bot_appearance = make_appearance ();
+  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
   object3d_set_appearance (object, board_appearance);
 
@@ -604,7 +577,7 @@ object3d_from_board_outline (void)
 
       get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
       vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0); /* Top */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
 
       object3d_add_vertex (object, vertices[i]);
       object3d_add_vertex (object, vertices[npoints + i]);
@@ -614,6 +587,7 @@ object3d_from_board_outline (void)
   for (i = 0; i < 3 * npoints; i++)
     {
       edges[i] = make_edge ();
+      UNDIR_DATA (edges[i]) = make_edge_info ();
       object3d_add_edge (object, edges[i]);
     }
 
@@ -621,15 +595,25 @@ object3d_from_board_outline (void)
   for (i = 0; i < npoints; i++)
     {
       faces[i] = make_face3d ();
+
+      object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], edges[2 * npoints + i]);
+      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
     }
-  faces[npoints]     = make_face3d (); /* bottom_face */
+
+  faces[npoints] = make_face3d (); /* bottom_face */
+  face3d_set_normal (faces[npoints], 0., 0., -1.);
+  face3d_set_appearance (faces[npoints], top_bot_appearance);
+  object3d_add_face (object, faces[npoints]);
+
   faces[npoints + 1] = make_face3d (); /* top_face */
+  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+  object3d_add_face (object, faces[npoints + 1]);
 
-  /* Pick the first bottom / top edge which within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], edges[0]);
-  face3d_add_contour (faces[npoints + 1], edges[npoints]);
+  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
 
   ct = contour;
   start_of_ct = 0;
@@ -645,62 +629,72 @@ object3d_from_board_outline (void)
       if (offset_in_ct == ct_npoints)
         {
           start_of_ct = i;
-          printf ("start_of_ct = %i\n", start_of_ct);
           offset_in_ct = 0;
           ct = ct->next;
           ct_npoints = get_contour_npoints (ct);
 
           /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-          face3d_add_contour (faces[npoints], edges[i]);
-          face3d_add_contour (faces[npoints + 1], edges[npoints + i]);
+          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
         }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
       prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
+      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+      /* Define the (non-normalized) face normal to point to the outside of the contour */
+      face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                  -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+
       /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[0 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[0 * npoints + i]) = vertices[0 * npoints + next_i_around_ct];
+      ODATA (edges[              i]) = vertices[0 * npoints + i];
+      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
       ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-      LDATA (edges[0 * npoints + i]) = faces[i];
-      RDATA (edges[0 * npoints + i]) = faces[npoints];
+      LDATA (edges[              i]) = faces[i];
+      RDATA (edges[              i]) = faces[npoints];
       LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
       RDATA (edges[1 * npoints + i]) = faces[i];
       LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
       RDATA (edges[2 * npoints + i]) = faces[i];
 
+      /* NB: Contours are counter clockwise in XY plane.
+       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+       */
+
       /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[npoints + i]);
-      splice (edges[npoints + i], SYM(edges[next_i_around_ct]));
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
       /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (edges[npoints + i], SYM(edges[npoints + next_i_around_ct]));
-      splice (SYM(edges[npoints + next_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+      splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
 
-      /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
-      /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
       if (ct->is_round)
         {
-          UNDIR_DATA (edges[0 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-          UNDIR_DATA (edges[1 * npoints + i]) = make_edge_info (false, true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
-          UNDIR_DATA (edges[2 * npoints + i]) = make_edge_info (true,  true, COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (ct->radius));
+
+          face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,                                     /* Direction of the cylindrical axis */
+                                            COORD_TO_MM (ct->radius));
+          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
         }
+
     }
 
   poly_Free (&outline);
 
   return object;
 }
-
-void
-object3d_test_board_outline (void)
-{
-  object3d *board_outline;
-
-  board_outline = object3d_from_board_outline ();
-  object3d_export_to_step (board_outline, "object3d_test.step");
-  destroy_object3d (board_outline);
-}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index b9830b8..015d575 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -17,8 +17,9 @@
 
 #include "hid/common/quad.h"
 #include "hid/common/vertex3d.h"
-#include "hid/common/face3d.h"
+#include "hid/common/contour3d.h"
 #include "hid/common/appearance.h"
+#include "hid/common/face3d.h"
 #include "hid/common/object3d.h"
 
 #ifndef WIN32
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 24082a4..449d44a 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -1,11 +1,12 @@
 #include <stdio.h>
 //#include <stdlib.h>
-//#include <stdbool.h>
+#include <stdbool.h>
 
 #include <glib.h>
 
 #include "hid/common/quad.h"
 #include "hid/common/vertex3d.h"
+#include "hid/common/contour3d.h"
 #include "hid/common/appearance.h"
 #include "hid/common/face3d.h"
 //#include "hid/common/edge3d.h"
