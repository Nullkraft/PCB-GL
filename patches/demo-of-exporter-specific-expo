Bottom: 579d204f62c545b7a932bacff5630ff9a4c3807b
Top:    c1bab5bdb1302af9b5ab03b813db13b0c904d8c5
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2014-07-10 19:01:20 +0100

Demo of exporter specific export routine


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 685b614..b2e3ff0 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -5,6 +5,11 @@
 #include "rotate.h" /* For RotateLineLowLevel() */
 #include "polygon.h"
 #include "draw_helpers.h"
+#include "rtree.h"
+#include "misc.h"
+#include "print.h" /* FIXME */
+#include "data.h" /* FIXME */
+#include "draw.h" /* FIXME */
 
 
 static void
@@ -641,3 +646,225 @@ common_draw_helpers_init (HID_DRAW *graphics)
   graphics->fill_pcb_pv          = common_fill_pcb_pv;
   graphics->thindraw_pcb_pv      = common_thindraw_pcb_pv;
 }
+
+
+struct pin_info
+{
+  bool arg;
+  LayerType *Layer;
+};
+
+/* ---------------------------------------------------------------------------
+ * draws one non-copper layer
+ */
+#if 0
+void
+DrawLayerCommon (LayerType *Layer, const BoxType * screen, bool clear_pins)
+{
+  struct pin_info info;
+
+  /* print the non-clearing polys */
+  info.Layer = Layer;
+  info.arg = clear_pins;
+
+  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+
+  if (clear_pins && TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  /* draw all visible lines this layer */
+  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
+
+  /* draw the layer arcs on screen */
+  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
+
+  /* draw the layer text on screen */
+  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+
+  /* We should check for gui->gui here, but it's kinda cool seeing the
+     auto-outline magically disappear when you first add something to
+     the "outline" layer.  */
+  if (IsLayerEmpty (Layer) && (strcmp (Layer->Name, "outline") == 0 ||
+                               strcmp (Layer->Name, "route") == 0))
+    {
+      gui->set_color (Output.fgGC, Layer->Color);
+      gui->set_line_width (Output.fgGC, PCB->minWid);
+      gui->draw_rect (Output.fgGC,
+                      0, 0,
+                      PCB->MaxWidth, PCB->MaxHeight);
+    }
+}
+#endif
+
+/* ---------------------------------------------------------------------------
+ * draws one layer group.  Returns non-zero if pins and pads should be
+ * drawn with this group.
+ */
+#if 0
+static int
+DrawLayerGroup (int group, const BoxType * screen)
+{
+  int i, rv = 1;
+  int layernum;
+  LayerType *Layer;
+  int n_entries = PCB->LayerGroups.Number[group];
+  Cardinal *layers = PCB->LayerGroups.Entries[group];
+
+  for (i = n_entries - 1; i >= 0; i--)
+    {
+      layernum = layers[i];
+      Layer = PCB->Data->Layer + layers[i];
+      if (strcmp (Layer->Name, "outline") == 0 ||
+          strcmp (Layer->Name, "route") == 0)
+        rv = 0;
+      if (layernum < max_copper_layer)
+        DrawLayerCommon (Layer, screen, true);
+    }
+  if (n_entries > 1)
+    rv = 1;
+  return rv;
+}
+#endif
+
+typedef struct
+{
+  int nplated;
+  int nunplated;
+} HoleCountStruct;
+
+static int
+hole_counting_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  HoleCountStruct *hcs = cl;
+  if (TEST_FLAG (HOLEFLAG, pin))
+    hcs->nunplated++;
+  else
+    hcs->nplated++;
+  return 1;
+}
+
+static void
+count_holes (BoxType *region, int *plated, int *unplated)
+{
+  HoleCountStruct hcs;
+  hcs.nplated = hcs.nunplated = 0;
+  r_search (PCB->Data->pin_tree, region, NULL, hole_counting_callback, &hcs);
+  r_search (PCB->Data->via_tree, region, NULL, hole_counting_callback, &hcs);
+  if (plated != NULL) *plated = hcs.nplated;
+  if (unplated != NULL) *unplated = hcs.nunplated;
+}
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  int plated = cl ? *(int *) cl : -1;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+    return 1;
+
+  //DrawHole ((PinType *) b);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  //DrawPlainPin ((PinType *) b, false);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  //PadType *pad = (PadType *) b;
+  //if (FRONT (pad))
+    //DrawPad (pad, 0);
+  return 1;
+}
+
+void
+common_export_region (HID *hid, BoxType *region)
+{
+  int plated;
+  int nplated;
+  int nunplated;
+  int component_group;
+  int solder_group;
+  int group;
+  int save_swap = SWAP_IDENT;
+  bool paste_empty;
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  /* draw all copper layer groups in group order */
+  for (group = 0; group < max_copper_layer; group++)
+    {
+      if (gui->set_layer (0, group, 0))
+        {
+          if (DrawLayerGroup (group, region))
+            {
+              r_search (PCB->Data->via_tree, region, NULL, pin_callback, NULL);
+              r_search (PCB->Data->pin_tree, region, NULL, pin_callback, NULL);
+
+              if (group == component_group || group == solder_group)
+                {
+                  SWAP_IDENT = (group == solder_group);
+                  r_search (PCB->Data->pad_tree, region, NULL, pad_callback, NULL);
+                  SWAP_IDENT = save_swap;
+                }
+            }
+        }
+    }
+
+  count_holes (region, &nplated, &nunplated);
+
+  if (nplated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
+    {
+      plated = 1;
+      r_search (PCB->Data->pin_tree, region, NULL, hole_callback, &plated);
+      r_search (PCB->Data->via_tree, region, NULL, hole_callback, &plated);
+    }
+
+  if (nunplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+    {
+      plated = 0;
+      r_search (PCB->Data->pin_tree, region, NULL, hole_callback, &plated);
+      r_search (PCB->Data->via_tree, region, NULL, hole_callback, &plated);
+    }
+
+  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
+    DrawMask (COMPONENT_LAYER, region);
+
+  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    DrawMask (SOLDER_LAYER, region);
+
+  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
+    DrawSilk (COMPONENT_LAYER, region);
+
+  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    DrawSilk (SOLDER_LAYER, region);
+
+  paste_empty = IsPasteEmpty (COMPONENT_LAYER);
+  if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+    DrawPaste (COMPONENT_LAYER, region);
+
+  paste_empty = IsPasteEmpty (SOLDER_LAYER);
+  if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+    DrawPaste (SOLDER_LAYER, region);
+
+  //if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
+    //PrintAssembly (region, component_group, 0);
+
+  //if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+    //PrintAssembly (region, solder_group, 1);
+
+  if (gui->set_layer ("fab", SL (FAB, 0), 0))
+    PrintFab (Output.fgGC);
+}
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 52d29c8..068c8bf 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -23,9 +23,11 @@
 #include "data.h"
 #include "misc.h"
 #include "error.h"
+#include "rtree.h"
 #include "draw.h"
 #include "pcb-printf.h"
 #include "draw_funcs.h"
+#include "print.h"
 
 #include "hid.h"
 #include "hid_draw.h"
@@ -47,7 +49,7 @@
 static HID_Attribute * gerber_get_export_options (int *n);
 static void gerber_do_export (HID_Attr_Val * options);
 static void gerber_parse_arguments (int *argc, char ***argv);
-static int gerber_set_layer (const char *name, int group, int empty);
+static int set_layer (const char *name, int group, int empty);
 static hidGC gerber_make_gc (void);
 static void gerber_destroy_gc (hidGC gc);
 static void gerber_use_mask (enum mask_mode mode);
@@ -411,20 +413,6 @@ gerber_get_export_options (int *n)
   return gerber_options;
 }
 
-static int
-layer_stack_sort (const void *va, const void *vb)
-{
-  int a_layer = *(int *) va;
-  int b_layer = *(int *) vb;
-  int a_group = GetLayerGroupNumberByNumber (a_layer);
-  int b_group = GetLayerGroupNumberByNumber (b_layer);
-
-  if (b_group != a_group)
-    return b_group - a_group;
-
-  return b_layer - a_layer;
-}
-
 static void
 maybe_close_f (FILE *f)
 {
@@ -582,13 +570,140 @@ assign_file_suffix (char *dest, int idx)
   strcat (dest, sext);
 }
 
+typedef struct
+{
+  int nplated;
+  int nunplated;
+} HoleCountStruct;
+
+static int
+hole_counting_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  HoleCountStruct *hcs = cl;
+  if (TEST_FLAG (HOLEFLAG, pin))
+    hcs->nunplated++;
+  else
+    hcs->nplated++;
+  return 1;
+}
+
+static void
+count_holes (BoxType *region, int *plated, int *unplated)
+{
+  HoleCountStruct hcs;
+  hcs.nplated = hcs.nunplated = 0;
+  r_search (PCB->Data->pin_tree, region, NULL, hole_counting_callback, &hcs);
+  r_search (PCB->Data->via_tree, region, NULL, hole_counting_callback, &hcs);
+  if (plated != NULL) *plated = hcs.nplated;
+  if (unplated != NULL) *unplated = hcs.nunplated;
+}
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  bool plated = *(bool *)cl;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+    return 1;
+
+  gui->graphics->fill_circle (Output.bgGC, pin->X, pin->Y, pin->DrillingHole / 2);
+  return 1;
+}
+
+static void
+DrawHoles (bool plated, BoxType *drawn_area)
+{
+  r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, &plated);
+  r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, &plated);
+}
+
+static void
+gerber_expose (HID * hid, BoxType *drawn_area, void *item)
+{
+  int i;
+  int group;
+  int nplated, nunplated;
+
+  HID *old_gui = gui;
+  hidGC savebg = Output.bgGC;
+  hidGC savefg = Output.fgGC;
+  hidGC savepm = Output.pmGC;
+
+  gui = hid;
+  Output.fgGC = gui->graphics->make_gc ();
+  Output.bgGC = gui->graphics->make_gc ();
+  Output.pmGC = gui->graphics->make_gc ();
+
+  hid->graphics->set_color (Output.pmGC, "erase");
+  hid->graphics->set_color (Output.bgGC, "drill");
+
+  memset (print_group, 0, sizeof (print_group));
+  for (i = 0; i < max_copper_layer; i++)
+    {
+      LayerType *layer = PCB->Data->Layer + i;
+      print_group[GetLayerGroupNumberByNumber (i)] = all_layers || !IsLayerEmpty (layer);
+    }
+
+  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
+
+  /* draw all copper layer groups in group order */
+  for (group = 0; group < max_copper_layer; group++)
+    {
+      if (!print_group[group])
+        continue;
+
+      if (set_layer (0, group, 0))
+        if (DrawLayerGroup (group, drawn_area))
+          DrawPPV (group, drawn_area);
+    }
+
+  count_holes (drawn_area, &nplated, &nunplated);
+
+  if (nplated && set_layer ("plated-drill", SL (PDRILL, 0), 0))
+    DrawHoles (true, drawn_area);
+
+  if (nunplated && set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+    DrawHoles (false, drawn_area);
+
+  if (set_layer ("componentmask", SL (MASK, TOP), 0))
+    DrawMask (TOP_SIDE, drawn_area);
+
+  if (set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    DrawMask (BOTTOM_SIDE, drawn_area);
+
+  if (set_layer ("topsilk", SL (SILK, TOP), 0))
+    DrawSilk (TOP_SIDE, drawn_area);
+
+  if (set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    DrawSilk (BOTTOM_SIDE, drawn_area);
+
+  if (set_layer ("toppaste", SL (PASTE, TOP), 0))
+    DrawPaste (TOP_SIDE, drawn_area);
+
+  if (set_layer ("bottompaste", SL (PASTE, BOTTOM), 0))
+    DrawPaste (BOTTOM_SIDE, drawn_area);
+
+  if (set_layer ("fab", SL (FAB, 0), 0))
+    PrintFab (Output.fgGC);
+
+  gui->graphics->destroy_gc (Output.fgGC);
+  gui->graphics->destroy_gc (Output.bgGC);
+  gui->graphics->destroy_gc (Output.pmGC);
+  gui = old_gui;
+  Output.fgGC = savefg;
+  Output.bgGC = savebg;
+  Output.pmGC = savepm;
+}
+
 static void
 gerber_do_export (HID_Attr_Val * options)
 {
   const char *fnbase;
   int i;
-  static int saved_layer_stack[MAX_LAYER];
-  int save_ons[MAX_LAYER + EXTRA_LAYERS];
   FlagType save_thindraw;
 
   save_thindraw = PCB->Flags;
@@ -648,24 +763,20 @@ gerber_do_export (HID_Attr_Val * options)
   else
     {
       memset (print_group, 0, sizeof (print_group));
-      memset (print_layer, 0, sizeof (print_layer));
-    }
+      for (i = 0; i < max_copper_layer; i++)
+        {
+          LayerType *layer = PCB->Data->Layer + i;
+          print_group[GetLayerGroupNumberByNumber (i)] = !IsLayerEmpty (layer);
+        }
+      print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+      print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
 
-  hid_save_and_show_layer_ons (save_ons);
-  for (i = 0; i < max_copper_layer; i++)
-    {
-      LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
-	print_group[GetLayerGroupNumberByNumber (i)] = 1;
+      memset (print_layer, 0, sizeof (print_layer));
+      for (i = 0; i < max_copper_layer; i++)
+        if (print_group[GetLayerGroupNumberByNumber (i)])
+          print_layer[i] = 1;
     }
-  print_group[GetLayerGroupNumberBySide (BOTTOM_SIDE)] = 1;
-  print_group[GetLayerGroupNumberBySide (TOP_SIDE)] = 1;
-  for (i = 0; i < max_copper_layer; i++)
-    if (print_group[GetLayerGroupNumberByNumber (i)])
-      print_layer[i] = 1;
 
-  memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_stack_sort);
   linewidth = -1;
   lastcap = -1;
   lastgroup = -1;
@@ -681,17 +792,14 @@ gerber_do_export (HID_Attr_Val * options)
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  gerber_expose (&gerber_hid, &region, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
-
-  memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
+  gerber_expose (&gerber_hid, &region, 0);
 
   maybe_close_f (f);
   f = NULL;
-  hid_restore_layer_ons (save_ons);
   PCB->Flags = save_thindraw;
 }
 
@@ -715,25 +823,17 @@ drill_sort (const void *va, const void *vb)
 }
 
 static int
-gerber_set_layer (const char *name, int group, int empty)
+set_layer (const char *name, int group, int empty)
 {
   int want_outline;
   char *cp;
   int idx = (group >= 0
-	     && group <
-	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+             && group <
+             max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (name == NULL)
     name = PCB->Data->Layer[idx].Name;
 
-  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
-    return 0;
-
-  if (strcmp (name, "invisible") == 0)
-    return 0;
-  if (SL_TYPE (idx) == SL_ASSY)
-    return 0;
-
   flash_drills = 0;
   if (strcmp (name, "outline") == 0 ||
       strcmp (name, "route") == 0)
@@ -744,18 +844,18 @@ gerber_set_layer (const char *name, int group, int empty)
       int i;
       /* dump pending drills in sequence */
       qsort (pending_drills, n_pending_drills, sizeof (pending_drills[0]),
-	     drill_sort);
+             drill_sort);
       for (i = 0; i < n_pending_drills; i++)
-	{
-	  if (i == 0 || pending_drills[i].diam != pending_drills[i - 1].diam)
-	    {
-	      Aperture *ap = findAperture (curr_aptr_list, pending_drills[i].diam, ROUND);
-	      fprintf (f, "T%02d\r\n", ap->dCode);
-	    }
-	  pcb_fprintf (f, metric ? "X%06.0muY%06.0mu\r\n" : "X%06.0mtY%06.0mt\r\n",
-		   gerberDrX (PCB, pending_drills[i].x),
-		   gerberDrY (PCB, pending_drills[i].y));
-	}
+        {
+          if (i == 0 || pending_drills[i].diam != pending_drills[i - 1].diam)
+            {
+              Aperture *ap = findAperture (curr_aptr_list, pending_drills[i].diam, ROUND);
+              fprintf (f, "T%02d\r\n", ap->dCode);
+            }
+          pcb_fprintf (f, metric ? "X%06.0muY%06.0mu\r\n" : "X%06.0mtY%06.0mt\r\n",
+                       gerberDrX (PCB, pending_drills[i].x),
+                       gerberDrY (PCB, pending_drills[i].y));
+        }
       free (pending_drills);
       n_pending_drills = max_pending_drills = 0;
       pending_drills = NULL;
@@ -766,7 +866,7 @@ gerber_set_layer (const char *name, int group, int empty)
   current_mask = HID_MASK_OFF;
 #if 0
   printf ("Layer %s group %d drill %d mask %d\n", name, group, is_drill,
-	  is_mask);
+          is_mask);
 #endif
 
   if (group < 0 || group != lastgroup)
@@ -788,10 +888,10 @@ gerber_set_layer (const char *name, int group, int empty)
       aptr_list = setLayerApertureList (layer_list_idx++);
 
       if (finding_apertures)
-	goto emit_outline;
+        goto emit_outline;
 
       if (aptr_list->count == 0 && !all_layers)
-	return 0;
+        return 0;
 
       maybe_close_f (f);
       f = NULL;
@@ -800,46 +900,46 @@ gerber_set_layer (const char *name, int group, int empty)
       assign_file_suffix (filesuff, idx);
       f = fopen (filename, "wb");   /* Binary needed to force CR-LF */
       if (f == NULL) 
-	{
-	  Message ( "Error:  Could not open %s for writing.\n", filename);
-	  return 1;
-	}
+        {
+          Message ( "Error:  Could not open %s for writing.\n", filename);
+          return 1;
+        }
 
       was_drill = is_drill;
 
       if (verbose)
-	{
-	  int c = aptr_list->count;
-	  printf ("Gerber: %d aperture%s in %s\n", c,
-		  c == 1 ? "" : "s", filename);
-	}
+        {
+          int c = aptr_list->count;
+          printf ("Gerber: %d aperture%s in %s\n", c,
+                  c == 1 ? "" : "s", filename);
+        }
 
       if (is_drill)
-	{
-	  /* We omit the ,TZ here because we are not omitting trailing zeros.  Our format is
-	     always six-digit 0.1 mil or µm resolution (i.e. 001100 = 0.11" or 1.1mm)*/
-	  fprintf (f, "M48\r\n");
-	  fprintf (f, metric ? "METRIC,000.000\r\n" : "INCH\r\n");
-	  for (search = aptr_list->data; search; search = search->next)
-		  pcb_fprintf (f, metric ? "T%02dC%.3`mm\r\n" : "T%02dC%.3`mi\r\n", search->dCode, search->width);
-	  fprintf (f, "%%\r\n");
-	  /* FIXME */
-	  return 1;
-	}
+        {
+          /* We omit the ,TZ here because we are not omitting trailing zeros.  Our format is
+             always six-digit 0.1 mil or µm resolution (i.e. 001100 = 0.11" or 1.1mm)*/
+          fprintf (f, "M48\r\n");
+          fprintf (f, metric ? "METRIC,000.000\r\n" : "INCH\r\n");
+          for (search = aptr_list->data; search; search = search->next)
+                  pcb_fprintf (f, metric ? "T%02dC%.3`mm\r\n" : "T%02dC%.3`mi\r\n", search->dCode, search->width);
+          fprintf (f, "%%\r\n");
+          /* FIXME */
+          return 1;
+        }
 
       fprintf (f, "G04 start of page %d for group %d idx %d *\r\n",
-	       pagecount, group, idx);
+               pagecount, group, idx);
 
       /* Create a portable timestamp. */
       currenttime = time (NULL);
       {
-	/* avoid gcc complaints */
-	const char *fmt = "%c UTC";
-	strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
+        /* avoid gcc complaints */
+        const char *fmt = "%c UTC";
+        strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
       }
       /* Print a cute file header at the beginning of each file. */
       fprintf (f, "G04 Title: %s, %s *\r\n", UNKNOWN (PCB->Name),
-	       UNKNOWN (name));
+               UNKNOWN (name));
       fprintf (f, "G04 Creator: %s " VERSION " *\r\n", Progname);
       fprintf (f, "G04 CreationDate: %s *\r\n", utcTime);
 
@@ -851,8 +951,8 @@ gerber_set_layer (const char *name, int group, int empty)
 
       fprintf (f, "G04 Format: Gerber/RS-274X *\r\n");
       pcb_fprintf (f, metric ? "G04 PCB-Dimensions (mm): %.2mm %.2mm *\r\n" :
-	       "G04 PCB-Dimensions (mil): %.2ml %.2ml *\r\n",
-	       PCB->MaxWidth, PCB->MaxHeight);
+               "G04 PCB-Dimensions (mil): %.2ml %.2ml *\r\n",
+               PCB->MaxWidth, PCB->MaxHeight);
       fprintf (f, "G04 PCB-Coordinate-Origin: lower left *\r\n");
 
       /* Signal data in inches. */
@@ -863,27 +963,27 @@ gerber_set_layer (const char *name, int group, int empty)
 
       /* build a legal identifier. */
       if (layername)
-	free (layername);
+        free (layername);
       layername = strdup (filesuff);
       if (strrchr (layername, '.'))
-	* strrchr (layername, '.') = 0;
+        * strrchr (layername, '.') = 0;
 
       for (cp=layername; *cp; cp++)
-	{
-	  if (isalnum((int) *cp))
-	    *cp = toupper((int) *cp);
-	  else
-	    *cp = '_';
-	}
+        {
+          if (isalnum((int) *cp))
+            *cp = toupper((int) *cp);
+          else
+            *cp = '_';
+        }
       fprintf (f, "%%LN%s*%%\r\n", layername);
       lncount = 1;
 
       for (search = aptr_list->data; search; search = search->next)
         fprintAperture(f, search);
       if (aptr_list->count == 0)
-	/* We need to put *something* in the file to make it be parsed
-	   as RS-274X instead of RS-274D. */
-	fprintf (f, "%%ADD11C,0.0100*%%\r\n");
+        /* We need to put *something* in the file to make it be parsed
+           as RS-274X instead of RS-274D. */
+        fprintf (f, "%%ADD11C,0.0100*%%\r\n");
     }
 
  emit_outline:
@@ -899,10 +999,10 @@ gerber_set_layer (const char *name, int group, int empty)
     want_outline = 1;
   if (copy_outline_mode == COPY_OUTLINE_ALL
       && (SL_TYPE (idx) == SL_SILK
-	  || SL_TYPE (idx) == SL_MASK
-	  || SL_TYPE (idx) == SL_FAB
-	  || SL_TYPE (idx) == SL_ASSY
-	  || SL_TYPE (idx) == 0))
+          || SL_TYPE (idx) == SL_MASK
+          || SL_TYPE (idx) == SL_FAB
+          || SL_TYPE (idx) == SL_ASSY
+          || SL_TYPE (idx) == 0))
     want_outline = 1;
 
   if (want_outline
@@ -910,24 +1010,24 @@ gerber_set_layer (const char *name, int group, int empty)
       && strcmp (name, "route"))
     {
       if (outline_layer
-	  && outline_layer != PCB->Data->Layer+idx)
-	dapi->draw_layer (outline_layer, &region, NULL);
+          && outline_layer != PCB->Data->Layer+idx)
+        dapi->draw_layer (outline_layer, &region, NULL);
       else if (!outline_layer)
-	{
-	  hidGC gc = gui->graphics->make_gc ();
-	  printf("name %s idx %d\n", name, idx);
-	  if (SL_TYPE (idx) == SL_SILK)
-	    gui->graphics->set_line_width (gc, PCB->minSlk);
-	  else if (group >= 0)
-	    gui->graphics->set_line_width (gc, PCB->minWid);
-	  else
-	    gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
-	  gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-	  gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->destroy_gc (gc);
-	}
+        {
+          hidGC gc = gui->graphics->make_gc ();
+          printf("name %s idx %d\n", name, idx);
+          if (SL_TYPE (idx) == SL_SILK)
+            gui->graphics->set_line_width (gc, PCB->minSlk);
+          else if (group >= 0)
+            gui->graphics->set_line_width (gc, PCB->minWid);
+          else
+            gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
+          gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
+          gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
+          gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+          gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
+          gui->graphics->destroy_gc (gc);
+        }
     }
 
   return 1;
@@ -1335,7 +1435,6 @@ hid_gerber_init ()
   gerber_hid.get_export_options  = gerber_get_export_options;
   gerber_hid.do_export           = gerber_do_export;
   gerber_hid.parse_arguments     = gerber_parse_arguments;
-  gerber_hid.set_layer           = gerber_set_layer;
   gerber_hid.calibrate           = gerber_calibrate;
   gerber_hid.set_crosshair       = gerber_set_crosshair;
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 9b4c6dd..bc3baa7 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -9,6 +9,9 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "gui-pinout-preview.h"
+#include "draw.h"
+#include "draw_funcs.h"
+#include "rtree.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
@@ -126,8 +129,8 @@ end_subcomposite (void)
 }
 
 
-int
-ghid_set_layer (const char *name, int group, int empty)
+static int
+set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   int idx = group;
@@ -855,6 +858,137 @@ ghid_screen_update (void)
 {
 }
 
+static void
+ghid_expose (const BoxType *drawn_area)
+{
+  int i, ngroups, side;
+  int component, solder;
+  /* This is the list of layer groups we will draw.  */
+  int do_group[MAX_LAYER];
+  /* This is the reverse of the order in which we draw them.  */
+  int drawn_groups[MAX_LAYER];
+  int plated, unplated;
+  bool paste_empty;
+  HID *old_gui = gui;
+
+  gui = &ghid_hid;
+  Output.fgGC = gui->graphics->make_gc ();
+  Output.bgGC = gui->graphics->make_gc ();
+  Output.pmGC = gui->graphics->make_gc ();
+
+  gui->graphics->set_color (Output.pmGC, "erase");
+  gui->graphics->set_color (Output.bgGC, "drill");
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  memset (do_group, 0, sizeof (do_group));
+  for (ngroups = 0, i = 0; i < max_copper_layer; i++)
+    {
+      LayerType *l = LAYER_ON_STACK (i);
+      int group = GetLayerGroupNumberByNumber (LayerStack[i]);
+      if (l->On && !do_group[group])
+	{
+	  do_group[group] = 1;
+	  drawn_groups[ngroups++] = group;
+	}
+    }
+
+  component = GetLayerGroupNumberByNumber (component_silk_layer);
+  solder = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  /*
+   * first draw all 'invisible' stuff
+   */
+  if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
+      && set_layer ("invisible", SL (INVISIBLE, 0), 0))
+    {
+      side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+      if (PCB->ElementOn)
+	{
+	  r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+	  dapi->draw_layer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area, NULL);
+	}
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      gui->end_layer ();
+    }
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--)
+    {
+      int group = drawn_groups[i];
+
+      if (set_layer (0, group, 0))
+        {
+          DrawLayerGroup (group, drawn_area);
+          gui->end_layer ();
+        }
+    }
+
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
+    return;
+
+  /* Draw pins, pads, vias below silk */
+  DrawPPV (SWAP_IDENT ? solder : component, drawn_area);
+
+  /* Draw the solder mask if turned on */
+  if (set_layer ("componentmask", SL (MASK, TOP), 0))
+    {
+      DrawMask (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  if (set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    {
+      DrawMask (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  if (set_layer ("topsilk", SL (SILK, TOP), 0))
+    {
+      DrawSilk (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  if (set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    {
+      DrawSilk (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  /* Draw element Marks */
+  if (PCB->PinOn)
+    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
+              NULL);
+
+  /* Draw rat lines on top */
+  if (set_layer ("rats", SL (RATS, 0), 0))
+    {
+      DrawRats(drawn_area);
+      gui->end_layer ();
+    }
+
+  paste_empty = IsPasteEmpty (COMPONENT_LAYER);
+  if (set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+    {
+      DrawPaste (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  paste_empty = IsPasteEmpty (SOLDER_LAYER);
+  if (set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+    {
+      DrawPaste (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
+  gui->graphics->destroy_gc (Output.fgGC);
+  gui->graphics->destroy_gc (Output.bgGC);
+  gui->graphics->destroy_gc (Output.pmGC);
+  gui = old_gui;
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -1001,7 +1135,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_draw_bg_image ();
 
   ghid_invalidate_current_gc ();
-  hid_expose_callback (&ghid_hid, &region, 0);
+  ghid_expose (&region);
   hidgl_flush_triangles (&buffer);
 
   ghid_draw_grid (&region);
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 37425e5..29fba1e 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -32,7 +32,7 @@
 
 #define CRASH fprintf(stderr, "HID error: pcb called unimplemented PS function %s.\n", __FUNCTION__); abort()
 
-static int ps_set_layer (const char *name, int group, int empty);
+static int set_layer (const char *name, int group, int empty);
 static void use_gc (hidGC gc);
 
 typedef struct hid_gc_struct
@@ -370,7 +370,6 @@ static struct {
   int pagecount;
   Coord linewidth;
   bool print_group[MAX_GROUP];
-  bool print_layer[MAX_LAYER];
   double fade_ratio;
   bool multi_file;
   Coord media_width, media_height, ps_width, ps_height;
@@ -394,8 +393,6 @@ static struct {
 
   double scale_factor;
 
-  BoxType region;
-
   HID_Attr_Val ps_values[NUM_OPTIONS];
 
   bool is_mask;
@@ -417,20 +414,6 @@ ps_get_export_options (int *n)
   return ps_attribute_list;
 }
 
-static int
-layer_stack_sort (const void *va, const void *vb)
-{
-  int a_layer = *(int *) va;
-  int b_layer = *(int *) vb;
-  int a_group = GetLayerGroupNumberByNumber (a_layer);
-  int b_group = GetLayerGroupNumberByNumber (b_layer);
-
-  if (b_group != a_group)
-    return b_group - a_group;
-
-  return b_layer - a_layer;
-}
-
 void
 ps_start_file (FILE *f)
 {
@@ -585,6 +568,83 @@ psopen (const char *base, const char *which)
   return ps_open_file;
 }
 
+void
+ps_expose (void)
+{
+  HID *old_gui = gui;
+  int group;
+  int nplated, nunplated;
+  bool paste_empty;
+
+  gui = &ps_hid;
+  Output.fgGC = gui->graphics->make_gc ();
+  Output.bgGC = gui->graphics->make_gc ();
+  Output.pmGC = gui->graphics->make_gc ();
+
+  gui->graphics->set_color (Output.pmGC, "erase");
+  gui->graphics->set_color (Output.bgGC, "drill");
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  /* draw all copper layers in group order */
+  for (group = 0; group < max_copper_layer; group++)
+    {
+      if (!global.print_group[group])
+        continue;
+
+      if (set_layer (0, group, 0))
+        if (DrawLayerGroup (group, NULL))
+          DrawPPV (group, NULL);
+    }
+
+  CountHoles (&nplated, &nunplated, NULL);
+
+  if (nplated && set_layer ("plated-drill", SL (PDRILL, 0), 0))
+    DrawHoles (true, false, NULL);
+
+  if (nunplated && set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+    DrawHoles (false, true, NULL);
+
+  if (set_layer ("componentmask", SL (MASK, TOP), 0))
+    DrawMask (COMPONENT_LAYER, NULL);
+
+  if (set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    DrawMask (SOLDER_LAYER, NULL);
+
+  if (set_layer ("topsilk", SL (SILK, TOP), 0))
+    DrawSilk (COMPONENT_LAYER, NULL);
+
+  if (set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    DrawSilk (SOLDER_LAYER, NULL);
+
+  paste_empty = IsPasteEmpty (COMPONENT_LAYER);
+  if (set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+    DrawPaste (COMPONENT_LAYER, NULL);
+
+  paste_empty = IsPasteEmpty (SOLDER_LAYER);
+  if (set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+    DrawPaste (SOLDER_LAYER, NULL);
+
+  doing_assy = true;
+
+  if (set_layer ("topassembly", SL (ASSY, TOP), 0))
+    PrintAssembly (COMPONENT_LAYER, NULL);
+
+  if (set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+    PrintAssembly (SOLDER_LAYER, NULL);
+
+  doing_assy = false;
+
+  if (set_layer ("fab", SL (FAB, 0), 0))
+    PrintFab (Output.fgGC);
+
+  gui->graphics->destroy_gc (Output.fgGC);
+  gui->graphics->destroy_gc (Output.bgGC);
+  gui->graphics->destroy_gc (Output.pmGC);
+  gui = old_gui;
+}
+
 /* This is used by other HIDs that use a postscript format, like lpr
    or eps.  */
 void
@@ -643,41 +703,24 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
     }
 
   memset (global.print_group, 0, sizeof (global.print_group));
-  memset (global.print_layer, 0, sizeof (global.print_layer));
-
   global.outline_layer = NULL;
-
   for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
-	global.print_group[GetLayerGroupNumberByNumber (i)] = 1;
+      global.print_group[GetLayerGroupNumberByNumber (i)] = !IsLayerEmpty (layer);
 
       if (strcmp (layer->Name, "outline") == 0 ||
-	  strcmp (layer->Name, "route") == 0)
-	{
-	  global.outline_layer = layer;
-	}
+          strcmp (layer->Name, "route") == 0)
+        global.outline_layer = layer;
     }
   global.print_group[GetLayerGroupNumberBySide (BOTTOM_SIDE)] = 1;
   global.print_group[GetLayerGroupNumberBySide (TOP_SIDE)] = 1;
-  for (i = 0; i < max_copper_layer; i++)
-    if (global.print_group[GetLayerGroupNumberByNumber (i)])
-      global.print_layer[i] = 1;
-
-  memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_stack_sort);
 
   global.linewidth = -1;
   /* reset static vars */
-  ps_set_layer (NULL, 0, -1);
+  set_layer (NULL, 0, -1);
   use_gc (NULL);
 
-  global.region.X1 = 0;
-  global.region.Y1 = 0;
-  global.region.X2 = PCB->MaxWidth;
-  global.region.Y2 = PCB->MaxHeight;
-
   if (!global.multi_file)
     {
       /* %%Page DSC requires both a label and an ordinal */
@@ -689,13 +732,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+      ps_expose ();
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
-  ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+  set_layer (NULL, 0, -1);  /* reset static vars */
+  ps_expose ();
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -781,7 +824,7 @@ corner (FILE *fh, Coord x, Coord y, int dx, int dy)
 }
 
 static int
-ps_set_layer (const char *name, int group, int empty)
+set_layer (const char *name, int group, int empty)
 {
   static int lastgroup = -1;
   time_t currenttime;
@@ -796,21 +839,11 @@ ps_set_layer (const char *name, int group, int empty)
   if (empty)
     return 0;
 
-  if (idx >= 0 && idx < max_copper_layer && !global.print_layer[idx])
-    return 0;
-
-  if (strcmp (name, "invisible") == 0)
-    return 0;
-
   global.is_drill = (SL_TYPE (idx) == SL_PDRILL || SL_TYPE (idx) == SL_UDRILL);
   global.is_mask  = (SL_TYPE (idx) == SL_MASK);
   global.is_assy  = (SL_TYPE (idx) == SL_ASSY);
   global.is_copper = (SL_TYPE (idx) == 0);
   global.is_paste  = (SL_TYPE (idx) == SL_PASTE);
-#if 0
-  printf ("Layer %s group %d drill %d mask %d\n", name, group, global.is_drill,
-	  global.is_mask);
-#endif
 
   if (global.doing_toc)
     {
@@ -1003,7 +1036,7 @@ ps_set_layer (const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, &global.region, NULL);
+      dapi->draw_layer (global.outline_layer, NULL, NULL);
     }
 
   return 1;
@@ -1509,7 +1542,6 @@ void ps_ps_init (HID *hid)
   hid->get_export_options = ps_get_export_options;
   hid->do_export          = ps_do_export;
   hid->parse_arguments    = ps_parse_arguments;
-  hid->set_layer          = ps_set_layer;
   hid->calibrate          = ps_calibrate;
   hid->set_crosshair      = ps_set_crosshair;
 }
