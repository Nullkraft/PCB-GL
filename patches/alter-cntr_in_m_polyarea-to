Bottom: 7b9931f8442f8dfcbebda65370df11206d54409c
Top:    ce6017b2f60365052191ac589e4828db32292c8f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 12:30:34 +0000

Alter cntr_in_M_POLYAREA() to return which POLYAREA which the passed PLINE was found inside.

In the case which previously returned FALSE, where the PLINE was not found
inside any of the linked POLYAREA, the funciton returns NULL.


---

diff --git a/src/polyarea.h b/src/polyarea.h
index 1e3c629..76b724a 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -177,6 +177,9 @@ BOOLp poly_ChkContour(PLINE * a);
 BOOLp poly_CheckInside(POLYAREA * c, Vector v0);
 BOOLp Touching(POLYAREA *p1, POLYAREA *p2);
 
+/* Call with test = false if wanting to test the whole polygon */
+POLYAREA *cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test);
+
 /**********************************************************************/
 
 /* tools for clipping */
diff --git a/src/polygon1.c b/src/polygon1.c
index 493618a..8b99dac 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1219,7 +1219,7 @@ count_contours_i_am_inside (const BoxType * b, void *cl)
 
 /* cntr_in_M_POLYAREA
 returns poly is inside outfst ? TRUE : FALSE */
-static int
+POLYAREA *
 cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
 {
   POLYAREA *outer = outfst;
@@ -1253,10 +1253,10 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
 	  break;
 	case 1:		/* Found we are inside this piece, and not any of its holes */
 	  heap_destroy (&heap);
-	  return TRUE;
+	  return outer;
 	case 2:		/* Found inside a hole in the smallest polygon so far. No need to check the other polygons */
 	  heap_destroy (&heap);
-	  return FALSE;
+	  return NULL;
 	default:
 	  printf ("Something strange here\n");
 	  break;
@@ -1264,7 +1264,7 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
     }
   while (1);
   heap_destroy (&heap);
-  return FALSE;
+  return NULL;
 }				/* cntr_in_M_POLYAREA */
 
 static char *
@@ -1380,7 +1380,7 @@ cntr_label_POLYAREA (PLINE * poly, POLYAREA * ppl, BOOLp test)
   if (poly->Flags.status == ISECTED)
     return false;
 
-  if (cntr_in_M_POLYAREA (poly, ppl, test))
+  if (cntr_in_M_POLYAREA (poly, ppl, test) != NULL)
     {
       if (test)
 	return TRUE;
@@ -2266,7 +2266,7 @@ find_inside_m_pa (const BoxType * b, void *cl)
   /* Don't look at contours marked as being intersected */
   if (check->Flags.status == ISECTED)
     return 0;
-  if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE))
+  if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE) != NULL)
     {
       info->result = check;
       longjmp (info->jb, 1);
@@ -2335,7 +2335,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 	       && (a->contours->xmax <= box.X2)
 	       && (a->contours->ymax <= box.Y2)) &&
 	      /* Then test properly */
-	      cntr_in_M_POLYAREA (a->contours, bpa, FALSE))
+	      cntr_in_M_POLYAREA (a->contours, bpa, FALSE) != NULL)
 	    {
 
 	      /* Delete this contour, all children -> holes queue */
@@ -2435,7 +2435,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 
 	  if (del_outside)
 	    del_contour = curc->Flags.status != ISECTED &&
-	      !cntr_in_M_POLYAREA (curc, bpa, FALSE);
+	      cntr_in_M_POLYAREA (curc, bpa, FALSE) == NULL;
 
 	  /* Skip intersected contours */
 	  if (curc->Flags.status == ISECTED)
