Bottom: 7d484dd6c10a05a0cb96cc68e5068ba31f66fbf7
Top:    e2e328780484bb0a8a042a4edc5641601df66f03
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-27 17:22:36 +0100

hid/gtk: Move viewport view data into renderer specific code.

As the different renderers may do different things with the board view,
it is not possible to save the flip state in the PCB settings any more.

---

diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index f28edff..6cf7f19 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -172,8 +172,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=10mil)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 507ad16..ea43664 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -20,9 +20,30 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
 static enum mask_mode cur_mask = HID_MASK_OFF;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  double coord_per_px;
+
+  Coord x0;
+  Coord y0;
+  Coord width;
+  Coord height;
+
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -33,6 +54,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -58,6 +80,58 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (Coord x)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+  else
+    return (x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vy (Coord y)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+  else
+    return (y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -166,11 +240,11 @@ ghid_draw_grid (void)
       gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
       set_clip (priv, priv->grid_gc);
     }
-  x1 = GridFit (SIDE_X (gport->view.x0), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (SIDE_Y (gport->view.y0), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (SIDE_X (gport->view.x0 + gport->view.width - 1),
+  x1 = GridFit (SIDE_X (priv->view.x0), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (SIDE_Y (priv->view.y0), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (SIDE_X (priv->view.x0 + priv->view.width - 1),
                 PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (SIDE_Y (gport->view.y0 + gport->view.height - 1),
+  y2 = GridFit (SIDE_Y (priv->view.y0 + priv->view.height - 1),
                 PCB->Grid, PCB->GridOffsetY);
   if (x1 > x2)
     {
@@ -188,9 +262,9 @@ ghid_draw_grid (void)
     x1 += PCB->Grid;
   if (Vy (y1) < 0)
     y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
+  if (Vx (x2) >= priv->view.width)
     x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
+  if (Vy (y2) >= priv->view.height)
     y2 -= PCB->Grid;
   n = (x2 - x1) / PCB->Grid + 1;
   if (n > npoints)
@@ -227,10 +301,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->view.coord_per_px;
-  h = PCB->MaxHeight / gport->view.coord_per_px;
-  x = gport->view.x0 / gport->view.coord_per_px;
-  y = gport->view.y0 / gport->view.coord_per_px;
+  w = PCB->MaxWidth / priv->view.coord_per_px;
+  h = PCB->MaxHeight / priv->view.coord_per_px;
+  x = priv->view.x0 / priv->view.coord_per_px;
+  y = priv->view.y0 / priv->view.coord_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -281,7 +355,7 @@ ghid_use_mask (enum mask_mode mode)
 
     case HID_MASK_CLEAR:
       if (!gport->mask)
-	gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
+	gport->mask = gdk_pixmap_new (0, priv->view.width, priv->view.height, 1);
       gport->drawable = gport->mask;
       mask_seq = 0;
       if (!priv->mask_gc)
@@ -293,7 +367,7 @@ ghid_use_mask (enum mask_mode mode)
       color.pixel = 1;
       gdk_gc_set_foreground (priv->mask_gc, &color);
       gdk_draw_rectangle (gport->drawable, priv->mask_gc, TRUE, 0, 0,
-			  gport->width, gport->height);
+			  priv->view.width, priv->view.height);
       color.pixel = 0;
       gdk_gc_set_foreground (priv->mask_gc, &color);
       break;
@@ -523,8 +597,8 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dx2 = Vx ((double) x2);
   dy2 = Vy ((double) y2);
 
-  if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
+  if (!ClipLine (0, 0, priv->view.width, priv->view.height,
+		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -539,25 +613,25 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (gport->view.flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (gport->view.flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -578,17 +652,17 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -621,12 +695,12 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
@@ -664,17 +738,17 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -717,8 +791,8 @@ redraw_region (GdkRectangle *rect)
     {
       priv->clip_rect.x = 0;
       priv->clip_rect.y = 0;
-      priv->clip_rect.width = gport->width;
-      priv->clip_rect.height = gport->height;
+      priv->clip_rect.width = priv->view.width;
+      priv->clip_rect.height = priv->view.height;
       priv->clip = false;
     }
 
@@ -760,25 +834,25 @@ redraw_region (GdkRectangle *rect)
 
   if (eleft > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-                        1, 0, 0, eleft, gport->height);
+                        1, 0, 0, eleft, priv->view.height);
   else
     eleft = 0;
-  if (eright < gport->width)
+  if (eright < priv->view.width)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-                        1, eright, 0, gport->width - eright, gport->height);
+                        1, eright, 0, priv->view.width - eright, priv->view.height);
   else
-    eright = gport->width;
+    eright = priv->view.width;
   if (etop > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
                         1, eleft, 0, eright - eleft + 1, etop);
   else
     etop = 0;
-  if (ebottom < gport->height)
+  if (ebottom < priv->view.height)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
                         1, eleft, ebottom, eright - eleft + 1,
-                        gport->height - ebottom);
+                        priv->view.height - ebottom);
   else
-    ebottom = gport->height;
+    ebottom = priv->view.height;
 
   gdk_draw_rectangle (gport->drawable, priv->bg_gc, 1,
                       eleft, etop, eright - eleft + 1, ebottom - etop + 1);
@@ -917,84 +991,87 @@ ghid_notify_mark_change (bool changes_complete)
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
 
-  gdk_draw_line (window, xor_gc, x, 0, x, gport->height);
-  gdk_draw_line (window, xor_gc, 0, y, gport->width, y);
+  gdk_draw_line (window, xor_gc, x, 0, x, priv->view.height);
+  gdk_draw_line (window, xor_gc, 0, y, priv->view.width, y);
 }
 
 static void
 draw_slanted_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
   gint x0, y0, x1, y1;
 
-  x0 = x + (gport->height - y);
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y);
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x);
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x);
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y);
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y);
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x);
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x);
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 }
 
 static void
 draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
   gint x0, y0, x1, y1;
   gdouble tan60 = sqrt (3);
 
-  x0 = x + (gport->height - y) / tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y) / tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y / tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x) * tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x) * tan60;
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x * tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x + (gport->height - y) * tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y) * tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y * tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x) / tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x) / tan60;
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x / tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y) / tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y) / tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y / tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x * tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x) * tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x) * tan60;
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y) * tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y) * tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y * tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x / tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x) / tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x) / tan60;
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 }
 
@@ -1074,7 +1151,7 @@ ghid_drawing_area_configure_hook (GHidPort *port)
   if (port->mask)
     {
       gdk_pixmap_unref (port->mask);
-      port->mask = gdk_pixmap_new (0, port->width, port->height, 1);
+      port->mask = gdk_pixmap_new (0, priv->view.width, priv->view.height, 1);
     }
 }
 
@@ -1088,7 +1165,7 @@ ghid_screen_update (void)
     return;
 
   gdk_draw_drawable (window, priv->bg_gc, gport->pixmap,
-                     0, 0, 0, 0, gport->width, gport->height);
+                     0, 0, 0, 0, priv->view.width, priv->view.height);
   draw_crosshair (priv);
 }
 
@@ -1120,37 +1197,34 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   GdkWindow *window = gtk_widget_get_window (widget);
   GdkDrawable *save_drawable;
   GtkAllocation allocation;
-  view_data save_view;
-  int save_width, save_height;
   Coord save_max_width;
   Coord save_max_height;
+  view_data save_view;
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
   /* Setup drawable and zoom factor for drawing routines
    */
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
   save_max_width = PCB->MaxWidth;
   save_max_height = PCB->MaxHeight;
+  save_view = priv->view;
 
   gtk_widget_get_allocation (widget, &allocation);
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
-
-  gport->drawable = window;
-  gport->width = allocation.width;
-  gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+    priv->view.coord_per_px = yz;
+
+  gport->drawable = widget->window;
+  priv->view.width = allocation.width;
+  priv->view.height = allocation.height;
+  priv->view.width = allocation.width * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
   PCB->MaxWidth =  pinout->x_max;
   PCB->MaxHeight = pinout->y_max;
 
@@ -1162,9 +1236,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
   PCB->MaxWidth = save_max_width;
   PCB->MaxHeight = save_max_height;
 
@@ -1177,14 +1249,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   GdkPixmap *pixmap;
   GdkDrawable *save_drawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
 
@@ -1192,24 +1261,24 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width  / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width;
+  priv->view.height = height;
+  priv->view.width = width * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* clear background */
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(Px(0), Px(priv->view.width + 1));
+  region.Y1 = MIN(Py(0), Py(priv->view.height + 1));
+  region.X2 = MAX(Px(0), Px(priv->view.width + 1));
+  region.Y2 = MAX(Py(0), Py(priv->view.height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1219,9 +1288,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1252,6 +1319,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1261,6 +1330,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1270,6 +1341,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 static void
 pan_common (GHidPort *port)
 {
+  render_priv *priv = gport->render_priv;
   int event_x, event_y;
 
   /* We need to fix up the PCB coordinates corresponding to the last
@@ -1277,10 +1349,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1289,8 +1361,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1299,8 +1371,10 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
   pan_common (gport);
 }
@@ -1308,24 +1382,27 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
   pan_common (gport);
 }
 
 
-/* gport->view.coord_per_px:
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view_width and priv->view_height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1334,22 +1411,22 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / priv->view.width,
+                  PCB->MaxHeight / priv->view.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
   pan_common (gport);
 
@@ -1359,28 +1436,32 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
 ghid_zoom_view_fit (void)
 {
+  render_priv *priv = gport->render_priv;
   ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
   ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
+                      MAX (PCB->MaxWidth  / priv->view.width,
+                           PCB->MaxHeight / priv->view.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d2a6a49..8bdb9da 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -42,6 +42,19 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define FLIP_X(x)         ((priv->view.flip_x ? -(x) : (x)))
+#define FLIP_Y(y)         ((priv->view.flip_y ? -(y) : (y)))
+
+#define SIDE_X(x)         ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)         ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
+
 static enum mask_mode cur_mask = HID_MASK_OFF;
 static GLfloat view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
                                     {0.0, 1.0, 0.0, 0.0},
@@ -53,6 +66,21 @@ static GLfloat last_modelview_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
                                               {0.0, 0.0, 0.0, 1.0}};
 static int global_view_2d = 1;
 
+typedef struct view_data {
+  double coord_per_px;
+  Coord center_x;
+  Coord center_y;
+
+  Coord x0; /* XXX */
+  Coord y0; /* XXX */
+  Coord width;  /* XXX */
+  Coord height; /* XXX */
+
+  bool flip_x;
+  bool flip_y;
+  /* TODO: Rotation matrix ? */
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -62,6 +90,8 @@ typedef struct render_priv {
   double current_alpha_mult;
   GTimer *time_since_expose;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -88,6 +118,36 @@ hid_gc_struct;
 static void draw_lead_user (render_priv *priv);
 static void ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -534,19 +594,21 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, priv->view.coord_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
                          Angle start_angle, Angle delta_angle)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->view.coord_per_px);
+                  start_angle, delta_angle, priv->view.coord_per_px);
 }
 
 void
@@ -561,9 +623,10 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 void
 ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (cx, cy, radius, priv->view.coord_per_px);
 }
 
 
@@ -578,9 +641,10 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 static void
 _fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
+  hidgl_fill_pcb_polygon (poly, clip_box, priv->view.coord_per_px);
 }
 
 static void
@@ -838,6 +902,11 @@ ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 void
 ghid_drawing_area_configure_hook (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+  GtkWidget *widget = port->drawing_area;
+
+  priv->view.width =  widget->allocation.width  * priv->view.coord_per_px;
+  priv->view.height = widget->allocation.height * priv->view.coord_per_px;
 }
 
 gboolean
@@ -922,13 +991,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
   glMultMatrixf ((GLfloat *)view_matrix);
   glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
-  glTranslatef (port->view.flip_x ?  port->view.x0 - PCB->MaxWidth  :
-                                    -port->view.x0,
-                port->view.flip_y ?  port->view.y0 - PCB->MaxHeight :
-                                    -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ?  priv->view.x0 - PCB->MaxWidth  :
+                                    -priv->view.x0,
+                priv->view.flip_y ?  priv->view.y0 - PCB->MaxHeight :
+                                    -priv->view.y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
   glEnable (GL_STENCIL_TEST);
@@ -1070,21 +1139,19 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
   GtkAllocation allocation;
   view_data save_view;
-  int save_width, save_height;
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
   save_max_width = PCB->MaxWidth;
   save_max_height = PCB->MaxHeight;
+  save_view = priv->view;
 
   /* Setup zoom factor for drawing routines */
 
@@ -1092,16 +1159,14 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
-
-  gport->width = allocation.width;
-  gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+    priv->view.coord_per_px = yz;
+
+  priv->view.width = allocation.width  * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
   PCB->MaxWidth = pinout->x_max;
   PCB->MaxHeight = pinout->y_max;
 
@@ -1141,14 +1206,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   /* call the drawing routine */
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1164,9 +1228,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
   PCB->MaxWidth = save_max_width;
   PCB->MaxHeight = save_max_height;
 
@@ -1177,18 +1239,16 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
   GdkGLContext* glcontext;
   GdkGLDrawable* gldrawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   /* Setup rendering context for drawing routines
    */
@@ -1204,15 +1264,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width   * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
@@ -1248,18 +1306,18 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   /* call the drawing routine */
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
+
+  region.X1 = MIN (Px(0), Px(width + 1));
+  region.Y1 = MIN (Py(0), Py(height + 1));
+  region.X2 = MAX (Px(0), Px(width + 1));
+  region.Y2 = MAX (Py(0), Py(height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1283,9 +1341,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1294,6 +1350,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -1317,13 +1374,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((gport->view.flip_x == port->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   return &ghid_hid;
 }
@@ -1545,7 +1602,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 }
 
 static void
-pan_common (GHidPort *port)
+pan_common (render_priv *priv)
 {
   int event_x, event_y;
 
@@ -1554,10 +1611,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1566,8 +1623,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1576,33 +1633,49 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
 
-  pan_common (gport);
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
+
+  pan_common (priv);
 }
 
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
-  pan_common (gport);
+  pan_common (priv);
 }
 
+void
+ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = MAX (0, priv->view.x0 + FLIP_X (priv->view.width)  * fraction_x);
+  priv->view.y0 = MAX (0, priv->view.y0 + FLIP_Y (priv->view.height) * fraction_y);
+
+  pan_common (priv);
+}
 
-/* gport->view.coord_per_px:
+
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view.width and priv->view.height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1611,24 +1684,24 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                  PCB->MaxHeight / gport->drawing_area->allocation.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
-  pan_common (gport);
+  pan_common (priv);
 
   ghid_set_status_line_label ();
 }
@@ -1636,28 +1709,32 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
 ghid_zoom_view_fit (void)
 {
+  render_priv *priv = gport->render_priv;
   ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
   ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
+                      MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                           PCB->MaxHeight / gport->drawing_area->allocation.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
@@ -1731,7 +1808,7 @@ draw_lead_user (render_priv *priv)
 
       /* Draw an arc at radius */
       hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
-                      radius, radius, 0, 360, gport->view.coord_per_px);
+                      radius, radius, 0, 360, priv->view.coord_per_px);
     }
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 425ca06..8174497 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1473,8 +1473,8 @@ Center(int argc, char **argv, Coord pcb_x, Coord pcb_y)
     AFAIL (center);
 
   /* Aim to put the given x, y PCB coordinates in the center of the widget */
-  widget_x = gport->width / 2;
-  widget_y = gport->height / 2;
+  widget_x = gport->drawing_area->allocation.width / 2;
+  widget_y = gport->drawing_area->allocation.height / 2;
 
   ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
@@ -1545,13 +1545,13 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.width, UNIT_PERCENT },
+//    { "view",  gport->view_width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.height, UNIT_PERCENT },
+//    { "view",  gport->view_height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1569,11 +1569,12 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (gport->view.flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!gport->view.flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (gport->view.flip_x) dx = -dx;
+  if (gport->view.flip_x) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -1727,8 +1728,9 @@ default is given, div=40.
 static int
 ScrollAction (int argc, char **argv, Coord x, Coord y)
 {
-  gdouble dx = 0.0, dy = 0.0;
-  int div = 40;
+  double dx = 0.;
+  double dy = 0.;
+  double fraction = 1. / 40.;
 
   if (!ghidgui)
     return 0;
@@ -1737,20 +1739,20 @@ ScrollAction (int argc, char **argv, Coord x, Coord y)
     AFAIL (scroll);
 
   if (argc == 2)
-    div = atoi(argv[1]);
+    fraction = 1. / (double) atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -gport->view.height / div;
-  else if (strcasecmp (argv[0], "down") == 0)
-    dy = gport->view.height / div;
+    dy = -fraction;
+  else if (strcasecmp (argv[0], "down")  == 0)
+    dy =  fraction;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = gport->view.width / div;
-  else if (strcasecmp (argv[0], "left") == 0)
-    dx = -gport->view.width / div;
+    dx =  fraction;
+  else if (strcasecmp (argv[0], "left")  == 0)
+    dx = -fraction;
   else
     AFAIL (scroll);
 
-  ghid_pan_view_rel (dx, dy);
+  ghid_pan_view_rel_to_visible (dx, dy);
 
   return 0;
 }
@@ -1935,25 +1937,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (void *data)
-{
-  return gport->view.flip_x;
-}
-
-static int
-flag_flipy (void *data)
-{
-  return gport->view.flip_y;
-}
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, NULL},
-  {"flip_y", flag_flipy, NULL}
-};
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 2ca39de..8c4a2a8 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -55,12 +55,14 @@
 void
 ghid_port_ranges_changed (void)
 {
+#if 0
   GtkAdjustment *h_adj, *v_adj;
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view.x0 = gtk_adjustment_get_value (h_adj);
   gport->view.y0 = gtk_adjustment_get_value (v_adj);
+#endif
 
   ghid_invalidate_all ();
 }
@@ -71,6 +73,7 @@ ghid_port_ranges_changed (void)
 void
 ghid_port_ranges_scale (void)
 {
+#if 0
   GtkAdjustment *adj;
   gdouble page_size;
 
@@ -100,6 +103,7 @@ ghid_port_ranges_scale (void)
                             page_size / 100.0,              /* step_increment */
                             page_size / 10.0,               /* page_increment */
                             page_size);                     /* page_size      */
+#endif
 }
 
 
@@ -352,14 +356,11 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  gport->width = ev->width;
-  gport->height = ev->height;
-
   if (gport->pixmap)
     gdk_pixmap_unref (gport->pixmap);
 
   gport->pixmap = gdk_pixmap_new (gtk_widget_get_window (widget),
-				  gport->width, gport->height, -1);
+				  ev->width, ev->height, -1);
   gport->drawable = gport->pixmap;
 
   if (!first_time_done)
@@ -507,24 +508,20 @@ gint
 ghid_port_window_motion_cb (GtkWidget * widget,
 			    GdkEventMotion * ev, GHidPort * out)
 {
-  gdouble dx, dy;
-  static gint x_prev = -1, y_prev = -1;
-
   gdk_event_request_motions (ev);
 
   if (out->panning)
     {
-      dx = gport->view.coord_per_px * (x_prev - ev->x);
-      dy = gport->view.coord_per_px * (y_prev - ev->y);
-      if (x_prev > 0)
-        ghid_pan_view_rel (dx, dy);
-      x_prev = ev->x;
-      y_prev = ev->y;
+      /* gport->pcb_x and gport->pcb_y will correspond to where the user
+       * grabbed the board. Move the board so that location lands where
+       * the mouse pointer now is, as indicated by the event.
+       */
+      ghid_pan_view_abs (gport->pcb_x, gport->pcb_y, ev->x, ev->y);
+
       return FALSE;
     }
-  x_prev = y_prev = -1;
-  ghid_note_event_location ((GdkEventButton *)ev);
 
+  ghid_note_event_location ((GdkEventButton *)ev);
   queue_tooltip_update (out);
 
   return FALSE;
@@ -577,9 +574,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
    */
 
   if(ev->mode != GDK_CROSSING_NORMAL)
-    {
-      return FALSE;
-    }
+    return FALSE;
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index cd571c7..ee953da 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1833,7 +1833,6 @@ ghid_parse_arguments (int *argc, char ***argv)
   gdk_window_add_filter (NULL, &event_filter, NULL);
 
   gport = &ghid_port;
-  gport->view.coord_per_px = 300.0;
   pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 91b1831..810096a 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -62,15 +62,6 @@
 #define	FROM_PCB_UNITS(v)	coord_to_unit (Settings.grid_unit, v)
 #define	TO_PCB_UNITS(v)		unit_to_coord (Settings.grid_unit, v)
 
-#define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
-
-#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
-#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
-
-#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
-#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -154,20 +145,6 @@ GhidGui;
 
 extern GhidGui _ghidgui, *ghidgui;
 
-typedef struct
-{
-  double coord_per_px; /* Zoom level described as PCB units per screen pixel */
-
-  Coord x0;
-  Coord y0;
-  Coord width;
-  Coord height;
-
-  bool flip_x;
-  bool flip_y;
-
-} view_data;
-
   /* The output viewport
    */
 typedef struct
@@ -176,7 +153,6 @@ typedef struct
    *drawing_area;		/* and its drawing area */
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
-  gint width, height;
 
   struct render_priv *render_priv;
 
@@ -190,7 +166,6 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-  view_data view;
   Coord pcb_x, pcb_y;             /* PCB coordinates of the mouse pointer */
   Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair     */
 }
@@ -506,6 +481,7 @@ void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y);
 void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
 void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_zoom_view_fit (void);
@@ -529,58 +505,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (Coord x)
-{
-  int rv;
-  if (gport->view.flip_x)
-    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (Coord y)
-{
-  int rv;
-  if (gport->view.flip_y)
-    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (Coord z)
-{
-  return z / gport->view.coord_per_px + 0.5;
-}
-
-static inline Coord
-Px (int x)
-{
-  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
-  if (gport->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
-  return  rv;
-}
-
-static inline Coord
-Py (int y)
-{
-  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
-  if (gport->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
-  return  rv;
-}
-
-static inline Coord
-Pz (int z)
-{
-  return (z * gport->view.coord_per_px);
-}
-
 #endif /* PCB_HID_GTK_GHID_H */
