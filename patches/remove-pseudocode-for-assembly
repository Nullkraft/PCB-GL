Bottom: 2a23764067a946d6e13f6e540b0d0fa50f27f29e
Top:    d5480a66653084d9bf01b3034ceb7b1f5ea575ed
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:26:00 +0000

Remove pseudocode for assembly emission


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 4553186..8d01245 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -231,8 +231,8 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 GList *
 object3d_from_board_outline (void)
 {
-  GList *board_objects = NULL;
-  object3d *board_object;
+  GList *objects = NULL;
+  object3d *object;
   appearance *board_appearance;
   appearance *top_bot_appearance;
   POLYAREA *board_outline;
@@ -269,13 +269,13 @@ object3d_from_board_outline (void)
       ct = ct->next;
     }
 
-    board_object = make_object3d (PCB->Name);
+    object = make_object3d (PCB->Name);
     board_appearance = make_appearance ();
     top_bot_appearance = make_appearance ();
     appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
     appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-    object3d_set_appearance (board_object, board_appearance);
+    object3d_set_appearance (object, board_appearance);
 
     vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
     edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
@@ -301,22 +301,22 @@ object3d_from_board_outline (void)
       vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
       vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
-      object3d_add_vertex (board_object, vertices[i]);
-      object3d_add_vertex (board_object, vertices[npoints + i]);
+      object3d_add_vertex (object, vertices[i]);
+      object3d_add_vertex (object, vertices[npoints + i]);
     }
 
     /* Define the edges */
     for (i = 0; i < 3 * npoints; i++) {
       edges[i] = make_edge ();
       UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (board_object, edges[i]);
+      object3d_add_edge (object, edges[i]);
     }
 
     /* Define the faces */
     for (i = 0; i < npoints; i++) {
       faces[i] = make_face3d ();
 
-      object3d_add_face (board_object, faces[i]);
+      object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
       face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
@@ -328,12 +328,12 @@ object3d_from_board_outline (void)
     faces[npoints] = make_face3d (); /* bottom_face */
     face3d_set_normal (faces[npoints], 0., 0., -1.);
     face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (board_object, faces[npoints]);
+    object3d_add_face (object, faces[npoints]);
 
     faces[npoints + 1] = make_face3d (); /* top_face */
     face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
     face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-    object3d_add_face (board_object, faces[npoints + 1]);
+    object3d_add_face (object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
@@ -481,7 +481,7 @@ object3d_from_board_outline (void)
                             0.,   0., 1., /* Normal */
                             5.);         /* Radius */
 #endif
-      object3d_add_edge (board_object, cylinder_edges[0]);
+      object3d_add_edge (object, cylinder_edges[0]);
 
       /* Edge on top of cylinder */
       cylinder_edges[1] = make_edge ();
@@ -490,21 +490,21 @@ object3d_from_board_outline (void)
                            COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
                             0.,   0., 1.,  /* Normal */
                             5.);          /* Radius */
-      object3d_add_edge (board_object, cylinder_edges[1]);
+      object3d_add_edge (object, cylinder_edges[1]);
 
       /* Edge stitching cylinder */
       cylinder_edges[2] = make_edge ();
       UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
       edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-      object3d_add_edge (board_object, cylinder_edges[2]);
+      object3d_add_edge (object, cylinder_edges[2]);
 
       /* Vertex on board top surface */
       cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-      object3d_add_vertex (board_object, cylinder_vertices[0]);
+      object3d_add_vertex (object, cylinder_vertices[0]);
 
       /* Vertex on cylinder top surface */
       cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-      object3d_add_vertex (board_object, cylinder_vertices[1]);
+      object3d_add_vertex (object, cylinder_vertices[1]);
 
       /* Cylindrical face */
       cylinder_faces[0] = make_face3d ();
@@ -513,14 +513,14 @@ object3d_from_board_outline (void)
                                         5.);                   /* Radius of cylinder */
       face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-      object3d_add_face (board_object, cylinder_faces[0]);
+      object3d_add_face (object, cylinder_faces[0]);
       face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
 
       /* Top face of cylinder */
       cylinder_faces[1] = make_face3d (); /* top face of cylinder */
       face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
       face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-      object3d_add_face (board_object, cylinder_faces[1]);
+      object3d_add_face (object, cylinder_faces[1]);
       face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
 
       /* Splice onto board */
@@ -551,13 +551,13 @@ object3d_from_board_outline (void)
       splice (cylinder_edges[1], SYM(cylinder_edges[1]));
     }
 
-    board_objects = g_list_append (board_objects, board_object);
+    objects = g_list_append (objects, object);
 
   } while (pa = pa->f, pa != board_outline);
 
   poly_Free (&board_outline);
 
-  return board_objects;
+  return objects;
 }
 
 void
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index ad297ce..8748f51 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -378,175 +378,6 @@ object3d_list_export_to_step_assy (GList *objects, const char *filename)
   finish_ap214_file (step);
 
   /* XXX: TODO: MAKE AN ASSEMBLY PRODUCT AND GATHER THE ABOVE PIECES INSIDE IT */
-#if 0
-    // RELATE THE PRODUCT STRUCTURE --------------------
-    // Find the product definitions by following the definition
-    // attribute of the shape definition representations.
-    stp_product_definition * asm_pd =  get_property_pdef (asm_sdr);
-    stp_product_definition * comp_pd = get_property_pdef (comp_sdr);
-
-    // Create the association between the configuration management
-    // description of the assembly and component.
-    //
-    stp_next_assembly_usage_occurrence* nauo = createCMAsm(
-	"unique ID",    // any unique id string
-	"left tire",    // something that identifies the usage.
-	"",		// description, "" is fine.
-	0,     		// Optional reference_designator string used
-			// to separate multiple uses of a component.
-	asm_pd, comp_pd
-	);
-
-
-    // RELATE THE GEOMETRY --------------------
-    // We need locations for the assembly and the component, so we
-    // create some example axis2_placements
-    //
-    stp_cartesian_point* p1 = pnew stp_cartesian_point;
-    p1-> name("");
-    p1-> coordinates()->add(0);
-    p1-> coordinates()->add(0);
-    p1-> coordinates()->add(0);
-    stp_axis2_placement_3d* asmAxis = pnew stp_axis2_placement_3d("", p1, 0, 0);
-
-    stp_cartesian_point* p2 = pnew stp_cartesian_point;
-    p2-> name("");
-    p2-> coordinates()->add(0);
-    p2-> coordinates()->add(0);
-    p2-> coordinates()->add(0);
-    stp_axis2_placement_3d* compAxis = pnew stp_axis2_placement_3d("", p2, 0, 0);
-
-    // Create the association between the geometry description of the
-    // assembly and component.  There are two distinct ways to relate
-    // the geometry.
-    //
-    if (useMappedItem) {
-	createGeomAsmMI(
-	    asm_sdr->used_representation(), asmAxis,
-	    comp_sdr->used_representation(), compAxis, 
-	    nauo);
-    } else {
-	createGeomAsmCDSR(
-	    asm_sdr->used_representation(), asmAxis,
-	    comp_sdr->used_representation(), compAxis, 
-	    nauo);
-    }
-
-
-  // Given two product_definitions this creates an assembly between them.
-  stp_next_assembly_usage_occurrence* createCMAsm(
-      const char* asm_id,
-      const char* asm_usage,
-      const char* asm_desc,
-      const char* ref_desig, 
-      stp_product_definition* asm_pdef, 
-      stp_product_definition* comp_pdef
-      )
-  {
-      // Create a next_assembly_usage occurrence to link the two.
-      stp_next_assembly_usage_occurrence* nauo = 
-          pnew stp_next_assembly_usage_occurrence();
-
-      // The id has no standard mapping, but it should be unique.
-      nauo->id (asm_id);
-
-      // The name should contain something that identifies the usage.
-      nauo->name (asm_usage);
-
-      // There's no mapping for the description, "" is fine..
-      nauo->description (asm_desc);
-
-      // The reference_designator is optional.  When specified, it
-      // should contain a unique location for the assembly.
-      nauo->reference_designator (ref_desig);
-
-      // The relating_product_definition is the assembly.
-      nauo->relating_product_definition (asm_pdef);
-
-      // The related_product_definition is the component.
-      nauo->related_product_definition (comp_pdef);
-
-      return nauo;
-  }
-
-
-  // This method should be used if the shape types are different.  Given
-  // two shape_representations and their axis2_placements, this creates
-  // the geometric portion of the assembly using a
-  // context_dependent_shape_representation.
-  //
-  void createGeomAsmCDSR(
-      stp_representation* asmSR, 
-      stp_representation_item* asmAxis,
-      stp_representation* compSR,
-      stp_representation_item* compAxis,
-      stp_next_assembly_usage_occurrence* nauo
-      )
-  {
-      /* We pass in representations to avoid having to do casts,
-       * but this should only be used to relate instances of the
-       * shape representation subtype.
-       */
-      if (!asmSR->  isa (ROSE_DOMAIN(stp_shape_representation)) ||
-          !compSR-> isa (ROSE_DOMAIN(stp_shape_representation)))
-      {
-          printf ("createGeomAsmCDSR: representations must be instances of");
-          printf ("  the shape representation subtype");
-          return;
-      }
-
-      // Create a product_definition_shape to link the cdsr to the nauo
-      stp_product_definition_shape* pds = pnew stp_product_definition_shape();
-
-      // There's no standard mapping for the name or description.
-      pds->name("");
-      pds->description("");
-
-      // The definition should point to next_assembly_usage_occurrence.
-      stp_characterized_definition* cd = pnew stp_characterized_definition();
-      stp_characterized_product_definition* cpd = 
-          pnew stp_characterized_product_definition();
-      cd->_characterized_product_definition(cpd);
-      cpd->_product_definition_relationship(nauo);
-      pds->definition(cd);
-
-      // Create a context_dependent_shape_representation.
-      stp_context_dependent_shape_representation* cdsr = 
-          pnew stp_context_dependent_shape_representation();
-
-      // The represented_product_relation is the pds.
-      cdsr->represented_product_relation(pds);
-
-      // A complex entity is used for the shape_representation_relationship.
-      stp_representation_relationship_with_transformation_and_shape_representation_relationship * repRel = 
-          pnew stp_representation_relationship_with_transformation_and_shape_representation_relationship();
-      cdsr->representation_relation(repRel);
-
-      // The name and description attributes have no standard mapping
-      repRel->name("");
-      repRel->description("");
-
-      // rep_1 is the assembly shape and rep_2 is the component.
-      repRel->rep_1(asmSR);
-      repRel->rep_2(compSR);
-
-      // The transformation_operator should be an item_defined_transform.
-      stp_item_defined_transformation* xform = pnew stp_item_defined_transformation();
-      stp_transformation* trans = pnew stp_transformation();
-      trans->_item_defined_transformation(xform);
-      repRel->transformation_operator(trans);
-
-      // The name and description fields have no standard mapping.
-      xform->name("");
-      xform->description("");
-
-      // The first transform_item is the axis of the assembly and the second is
-      // the component.
-      xform->transform_item_1(asmAxis);
-      xform->transform_item_2(compAxis);
-  }
-#endif
-
 }
 
 void
