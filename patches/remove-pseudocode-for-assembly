Bottom: 187883ca48622849d77972e6d72d80e255968fd6
Top:    99296e80530a374ca2f38550e756412b78b6b407
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 16:26:00 +0000

Remove pseudocode for assembly emission


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 92e9d87..1f890ce 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -222,10 +222,11 @@ get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
       return;
     }
 
-  while (n > 0) {
-    vertex = vertex->next; /* The VNODE structure is circularly linked, so wrapping is OK */
-    n--;
-  }
+  while (n > 0)
+    {
+      vertex = vertex->next; /* The VNODE structure is circularly linked, so wrapping is OK */
+      n--;
+    }
 
   *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
   *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
@@ -259,304 +260,308 @@ object3d_from_board_outline (void)
 
   /* Loop over all board outline pieces */
   pa = board_outline;
-  do {
+  do
+    {
 
-    contour = pa->contours;
-    ncontours = 0;
-    npoints = 0;
+      contour = pa->contours;
+      ncontours = 0;
+      npoints = 0;
 
-    ct = contour;
-    while (ct != NULL) {
-      ncontours ++;
-      npoints += get_contour_npoints (ct);
-      ct = ct->next;
-    }
+      ct = contour;
+      while (ct != NULL)
+        {
+          ncontours ++;
+          npoints += get_contour_npoints (ct);
+          ct = ct->next;
+        }
 
-    object = make_object3d (PCB->Name);
-    board_appearance = make_appearance ();
-    top_bot_appearance = make_appearance ();
-    appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-    appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+      object = make_object3d (PCB->Name);
+      board_appearance = make_appearance ();
+      top_bot_appearance = make_appearance ();
+      appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+      appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
 
-    object3d_set_appearance (object, board_appearance);
+      object3d_set_appearance (object, board_appearance);
 
-    vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
-    edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
-    faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
+      vertices = malloc (sizeof (vertex3d *) * 2 * npoints); /* (n-bottom, n-top) */
+      edges    = malloc (sizeof (edge_ref  ) * 3 * npoints); /* (n-bottom, n-top, n-sides) */
+      faces    = malloc (sizeof (face3d *) * (npoints + 2)); /* (n-sides, 1-bottom, 1-top */
 
-    /* Define the vertices */
-    ct = contour;
-    offset_in_ct = 0;
-    ct_npoints = get_contour_npoints (ct);
+      /* Define the vertices */
+      ct = contour;
+      offset_in_ct = 0;
+      ct_npoints = get_contour_npoints (ct);
 
-    for (i = 0; i < npoints; i++, offset_in_ct++) {
-      double x1, y1;
+      for (i = 0; i < npoints; i++, offset_in_ct++)
+        {
+          double x1, y1;
 
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints) {
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
-      }
+          /* Update which contour we're looking at */
+          if (offset_in_ct == ct_npoints) {
+            offset_in_ct = 0;
+            ct = ct->next;
+            ct_npoints = get_contour_npoints (ct);
+          }
 
-      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+        get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
 
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
+        vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+        vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
-      object3d_add_vertex (object, vertices[i]);
-      object3d_add_vertex (object, vertices[npoints + i]);
-    }
+        object3d_add_vertex (object, vertices[i]);
+        object3d_add_vertex (object, vertices[npoints + i]);
+      }
 
-    /* Define the edges */
-    for (i = 0; i < 3 * npoints; i++) {
-      edges[i] = make_edge ();
-      UNDIR_DATA (edges[i]) = make_edge_info ();
-      object3d_add_edge (object, edges[i]);
-    }
+      /* Define the edges */
+      for (i = 0; i < 3 * npoints; i++) {
+        edges[i] = make_edge ();
+        UNDIR_DATA (edges[i]) = make_edge_info ();
+        object3d_add_edge (object, edges[i]);
+      }
 
-    /* Define the faces */
-    for (i = 0; i < npoints; i++) {
-      faces[i] = make_face3d ();
+      /* Define the faces */
+      for (i = 0; i < npoints; i++) {
+        faces[i] = make_face3d ();
 
-      object3d_add_face (object, faces[i]);
-      /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+        object3d_add_face (object, faces[i]);
+        /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
-      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+        face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
 #else
-      face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+        face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
 #endif
-    }
+      }
 
-    faces[npoints] = make_face3d (); /* bottom_face */
-    face3d_set_normal (faces[npoints], 0., 0., -1.);
-    face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (object, faces[npoints]);
+      faces[npoints] = make_face3d (); /* bottom_face */
+      face3d_set_normal (faces[npoints], 0., 0., -1.);
+      face3d_set_appearance (faces[npoints], top_bot_appearance);
+      object3d_add_face (object, faces[npoints]);
 
-    faces[npoints + 1] = make_face3d (); /* top_face */
-    face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-    face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-    object3d_add_face (object, faces[npoints + 1]);
+      faces[npoints + 1] = make_face3d (); /* top_face */
+      face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
+      face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+      object3d_add_face (object, faces[npoints + 1]);
 
-    /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+      /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
 #ifdef REVERSED_PCB_CONTOURS
-    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+      face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
 #else
-    face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
 #endif
 
-    ct = contour;
-    start_of_ct = 0;
-    offset_in_ct = 0;
-    ct_npoints = get_contour_npoints (ct);
+      ct = contour;
+      start_of_ct = 0;
+      offset_in_ct = 0;
+      ct_npoints = get_contour_npoints (ct);
 
-    for (i = 0; i < npoints; i++, offset_in_ct++) {
-      int next_i_around_ct;
-      int prev_i_around_ct;
+      for (i = 0; i < npoints; i++, offset_in_ct++) {
+        int next_i_around_ct;
+        int prev_i_around_ct;
 
-      /* Update which contour we're looking at */
-      if (offset_in_ct == ct_npoints) {
-        start_of_ct = i;
-        offset_in_ct = 0;
-        ct = ct->next;
-        ct_npoints = get_contour_npoints (ct);
+        /* Update which contour we're looking at */
+        if (offset_in_ct == ct_npoints) {
+          start_of_ct = i;
+          offset_in_ct = 0;
+          ct = ct->next;
+          ct_npoints = get_contour_npoints (ct);
 
-        /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+          /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
 #ifdef REVERSED_PCB_CONTOURS
-        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+          face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
 #else
-        face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+          face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
 #endif
-      }
+        }
 
-      next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-      prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+        next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+        prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-      /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-      /* Define the (non-normalized) face normal to point to the outside of the contour */
+        /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+        /* Define the (non-normalized) face normal to point to the outside of the contour */
 #if REVERSED_PCB_CONTOURS
-      /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
-      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
-                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+        /* Vertex ordering of the edge we're finding the normal to is reversed in this case */
+        face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                      (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
 #else
-      face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+        face3d_set_normal (faces[i],  (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                     -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
 #endif
 
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (edges[              i]) = vertices[0 * npoints + i];
-      DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-      ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-      DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-      ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-      DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+        /* Assign the appropriate vertex geometric data to each edge end */
+        ODATA (edges[              i]) = vertices[0 * npoints + i];
+        DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+        ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+        DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+        ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+        DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
 #if REVERSED_PCB_CONTOURS
-      RDATA (edges[              i]) = faces[i];
-      LDATA (edges[              i]) = faces[npoints];
-      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      LDATA (edges[1 * npoints + i]) = faces[i];
-      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      LDATA (edges[2 * npoints + i]) = faces[i];
+        RDATA (edges[              i]) = faces[i];
+        LDATA (edges[              i]) = faces[npoints];
+        RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+        LDATA (edges[1 * npoints + i]) = faces[i];
+        RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+        LDATA (edges[2 * npoints + i]) = faces[i];
 #else
-      LDATA (edges[              i]) = faces[i];
-      RDATA (edges[              i]) = faces[npoints];
-      LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      RDATA (edges[1 * npoints + i]) = faces[i];
-      LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      RDATA (edges[2 * npoints + i]) = faces[i];
+        LDATA (edges[              i]) = faces[i];
+        RDATA (edges[              i]) = faces[npoints];
+        LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+        RDATA (edges[1 * npoints + i]) = faces[i];
+        LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+        RDATA (edges[2 * npoints + i]) = faces[i];
 #endif
 
-      /* NB: Contours are counter clockwise in XY plane.
-       *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-       *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-       *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-       */
+        /* NB: Contours are counter clockwise in XY plane.
+         *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+         *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+         *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+         */
 
 #ifdef REVERSED_PCB_CONTOURS  /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW FOR INNER - E.g. PCB's polygons when translated into STEP coordinates */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], edges[i]);
+        /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+        splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+        splice (edges[2 * npoints + i], edges[i]);
 
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+        /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+        splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+        splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
 #else /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW FOR INNER. E.g. PCB's raw coordinates in X, Y */
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (edges[i], edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+        /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+        splice (edges[i], edges[2 * npoints + i]);
+        splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
 
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+        /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+        splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+        splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
 #endif
 
-      if (ct->is_round) {
+        if (ct->is_round) {
 
-        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
-                                          COORD_TO_MM (ct->radius));
-        face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
-        face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                  /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+          face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                            0., 0., 1.,                                                       /* Direction of the cylindrical axis */
+                                            COORD_TO_MM (ct->radius));
+          face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
+          face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
+                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
 #ifdef REVERSED_PCB_CONTOURS
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
-                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                               0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
-        edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
-        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
-                             0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+          edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                               COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                               0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #endif
-        edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-      }
+          edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
+        }
 
-    }
+      }
 
-    if (0) {
-      /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+      if (0) {
+        /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
-      edge_ref cylinder_edges[3];
-      vertex3d *cylinder_vertices[2];
-      face3d *cylinder_faces[2];
+        edge_ref cylinder_edges[3];
+        vertex3d *cylinder_vertices[2];
+        face3d *cylinder_faces[2];
 
-      /* Edge on top of board */
-      cylinder_edges[0] = make_edge ();
-      UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+        /* Edge on top of board */
+        cylinder_edges[0] = make_edge ();
+        UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
 #ifdef REVERSED_PCB_CONTOURS
-      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                            0.,   0., 1., /* Normal */
-                            5.);          /* Radius */
+        edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                              0.,   0., 1., /* Normal */
+                              5.);          /* Radius */
 #else
-      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                            0.,   0., 1., /* Normal */
-                            5.);         /* Radius */
+        edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                              0.,   0., 1., /* Normal */
+                              5.);         /* Radius */
 #endif
-      object3d_add_edge (object, cylinder_edges[0]);
-
-      /* Edge on top of cylinder */
-      cylinder_edges[1] = make_edge ();
-      UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
-      edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
-                            0.,   0., 1.,  /* Normal */
-                            5.);          /* Radius */
-      object3d_add_edge (object, cylinder_edges[1]);
-
-      /* Edge stitching cylinder */
-      cylinder_edges[2] = make_edge ();
-      UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
-      edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
-      object3d_add_edge (object, cylinder_edges[2]);
-
-      /* Vertex on board top surface */
-      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
-      object3d_add_vertex (object, cylinder_vertices[0]);
-
-      /* Vertex on cylinder top surface */
-      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
-      object3d_add_vertex (object, cylinder_vertices[1]);
-
-      /* Cylindrical face */
-      cylinder_faces[0] = make_face3d ();
-      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,             /* Direction of the cylindrical axis */
-                                        5.);                   /* Radius of cylinder */
-      face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
-                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-      object3d_add_face (object, cylinder_faces[0]);
-      face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
-
-      /* Top face of cylinder */
-      cylinder_faces[1] = make_face3d (); /* top face of cylinder */
-      face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
-      face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
-      object3d_add_face (object, cylinder_faces[1]);
-      face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
-
-      /* Splice onto board */
-      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
-
-      /* Assign the appropriate vertex geometric data to each edge end */
-      ODATA (cylinder_edges[0]) = cylinder_vertices[0];
-      DDATA (cylinder_edges[0]) = cylinder_vertices[0];
-      ODATA (cylinder_edges[1]) = cylinder_vertices[1];
-      DDATA (cylinder_edges[1]) = cylinder_vertices[1];
-      ODATA (cylinder_edges[2]) = cylinder_vertices[0];
-      DDATA (cylinder_edges[2]) = cylinder_vertices[1];
-      LDATA (cylinder_edges[0]) = cylinder_faces[0];
-      RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
-      LDATA (cylinder_edges[1]) = cylinder_faces[1];
-      RDATA (cylinder_edges[1]) = cylinder_faces[0];
-      LDATA (cylinder_edges[2]) = cylinder_faces[0];
-      RDATA (cylinder_edges[2]) = cylinder_faces[0];
-
-      /* Splice things together.... */
-
-      /* Link edges orbiting the cylinder bottom vertex */
-      splice (cylinder_edges[0], cylinder_edges[2]);
-      splice (cylinder_edges[2], SYM(cylinder_edges[0]));
-
-      /* Link edges orbiting the cylinder top vertex */
-      splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
-      splice (cylinder_edges[1], SYM(cylinder_edges[1]));
-    }
+        object3d_add_edge (object, cylinder_edges[0]);
+
+        /* Edge on top of cylinder */
+        cylinder_edges[1] = make_edge ();
+        UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+        edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                             COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                              0.,   0., 1.,  /* Normal */
+                              5.);          /* Radius */
+        object3d_add_edge (object, cylinder_edges[1]);
+
+        /* Edge stitching cylinder */
+        cylinder_edges[2] = make_edge ();
+        UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+        edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+        object3d_add_edge (object, cylinder_edges[2]);
+
+        /* Vertex on board top surface */
+        cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
+        object3d_add_vertex (object, cylinder_vertices[0]);
+
+        /* Vertex on cylinder top surface */
+        cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
+        object3d_add_vertex (object, cylinder_vertices[1]);
+
+        /* Cylindrical face */
+        cylinder_faces[0] = make_face3d ();
+        face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,             /* Direction of the cylindrical axis */
+                                          5.);                   /* Radius of cylinder */
+        face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                     /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+        object3d_add_face (object, cylinder_faces[0]);
+        face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+        /* Top face of cylinder */
+        cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+        face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+        face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+        object3d_add_face (object, cylinder_faces[1]);
+        face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+        /* Splice onto board */
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+        /* Assign the appropriate vertex geometric data to each edge end */
+        ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+        DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+        ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+        DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+        ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+        DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+        LDATA (cylinder_edges[0]) = cylinder_faces[0];
+        RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+        LDATA (cylinder_edges[1]) = cylinder_faces[1];
+        RDATA (cylinder_edges[1]) = cylinder_faces[0];
+        LDATA (cylinder_edges[2]) = cylinder_faces[0];
+        RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+        /* Splice things together.... */
+
+        /* Link edges orbiting the cylinder bottom vertex */
+        splice (cylinder_edges[0], cylinder_edges[2]);
+        splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+        /* Link edges orbiting the cylinder top vertex */
+        splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+        splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+      }
 
-    objects = g_list_append (objects, object);
+      objects = g_list_append (objects, object);
 
-  } while (pa = pa->f, pa != board_outline);
+    }
+  while (pa = pa->f, pa != board_outline);
 
   poly_Free (&board_outline);
 
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index ad297ce..8748f51 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -378,175 +378,6 @@ object3d_list_export_to_step_assy (GList *objects, const char *filename)
   finish_ap214_file (step);
 
   /* XXX: TODO: MAKE AN ASSEMBLY PRODUCT AND GATHER THE ABOVE PIECES INSIDE IT */
-#if 0
-    // RELATE THE PRODUCT STRUCTURE --------------------
-    // Find the product definitions by following the definition
-    // attribute of the shape definition representations.
-    stp_product_definition * asm_pd =  get_property_pdef (asm_sdr);
-    stp_product_definition * comp_pd = get_property_pdef (comp_sdr);
-
-    // Create the association between the configuration management
-    // description of the assembly and component.
-    //
-    stp_next_assembly_usage_occurrence* nauo = createCMAsm(
-	"unique ID",    // any unique id string
-	"left tire",    // something that identifies the usage.
-	"",		// description, "" is fine.
-	0,     		// Optional reference_designator string used
-			// to separate multiple uses of a component.
-	asm_pd, comp_pd
-	);
-
-
-    // RELATE THE GEOMETRY --------------------
-    // We need locations for the assembly and the component, so we
-    // create some example axis2_placements
-    //
-    stp_cartesian_point* p1 = pnew stp_cartesian_point;
-    p1-> name("");
-    p1-> coordinates()->add(0);
-    p1-> coordinates()->add(0);
-    p1-> coordinates()->add(0);
-    stp_axis2_placement_3d* asmAxis = pnew stp_axis2_placement_3d("", p1, 0, 0);
-
-    stp_cartesian_point* p2 = pnew stp_cartesian_point;
-    p2-> name("");
-    p2-> coordinates()->add(0);
-    p2-> coordinates()->add(0);
-    p2-> coordinates()->add(0);
-    stp_axis2_placement_3d* compAxis = pnew stp_axis2_placement_3d("", p2, 0, 0);
-
-    // Create the association between the geometry description of the
-    // assembly and component.  There are two distinct ways to relate
-    // the geometry.
-    //
-    if (useMappedItem) {
-	createGeomAsmMI(
-	    asm_sdr->used_representation(), asmAxis,
-	    comp_sdr->used_representation(), compAxis, 
-	    nauo);
-    } else {
-	createGeomAsmCDSR(
-	    asm_sdr->used_representation(), asmAxis,
-	    comp_sdr->used_representation(), compAxis, 
-	    nauo);
-    }
-
-
-  // Given two product_definitions this creates an assembly between them.
-  stp_next_assembly_usage_occurrence* createCMAsm(
-      const char* asm_id,
-      const char* asm_usage,
-      const char* asm_desc,
-      const char* ref_desig, 
-      stp_product_definition* asm_pdef, 
-      stp_product_definition* comp_pdef
-      )
-  {
-      // Create a next_assembly_usage occurrence to link the two.
-      stp_next_assembly_usage_occurrence* nauo = 
-          pnew stp_next_assembly_usage_occurrence();
-
-      // The id has no standard mapping, but it should be unique.
-      nauo->id (asm_id);
-
-      // The name should contain something that identifies the usage.
-      nauo->name (asm_usage);
-
-      // There's no mapping for the description, "" is fine..
-      nauo->description (asm_desc);
-
-      // The reference_designator is optional.  When specified, it
-      // should contain a unique location for the assembly.
-      nauo->reference_designator (ref_desig);
-
-      // The relating_product_definition is the assembly.
-      nauo->relating_product_definition (asm_pdef);
-
-      // The related_product_definition is the component.
-      nauo->related_product_definition (comp_pdef);
-
-      return nauo;
-  }
-
-
-  // This method should be used if the shape types are different.  Given
-  // two shape_representations and their axis2_placements, this creates
-  // the geometric portion of the assembly using a
-  // context_dependent_shape_representation.
-  //
-  void createGeomAsmCDSR(
-      stp_representation* asmSR, 
-      stp_representation_item* asmAxis,
-      stp_representation* compSR,
-      stp_representation_item* compAxis,
-      stp_next_assembly_usage_occurrence* nauo
-      )
-  {
-      /* We pass in representations to avoid having to do casts,
-       * but this should only be used to relate instances of the
-       * shape representation subtype.
-       */
-      if (!asmSR->  isa (ROSE_DOMAIN(stp_shape_representation)) ||
-          !compSR-> isa (ROSE_DOMAIN(stp_shape_representation)))
-      {
-          printf ("createGeomAsmCDSR: representations must be instances of");
-          printf ("  the shape representation subtype");
-          return;
-      }
-
-      // Create a product_definition_shape to link the cdsr to the nauo
-      stp_product_definition_shape* pds = pnew stp_product_definition_shape();
-
-      // There's no standard mapping for the name or description.
-      pds->name("");
-      pds->description("");
-
-      // The definition should point to next_assembly_usage_occurrence.
-      stp_characterized_definition* cd = pnew stp_characterized_definition();
-      stp_characterized_product_definition* cpd = 
-          pnew stp_characterized_product_definition();
-      cd->_characterized_product_definition(cpd);
-      cpd->_product_definition_relationship(nauo);
-      pds->definition(cd);
-
-      // Create a context_dependent_shape_representation.
-      stp_context_dependent_shape_representation* cdsr = 
-          pnew stp_context_dependent_shape_representation();
-
-      // The represented_product_relation is the pds.
-      cdsr->represented_product_relation(pds);
-
-      // A complex entity is used for the shape_representation_relationship.
-      stp_representation_relationship_with_transformation_and_shape_representation_relationship * repRel = 
-          pnew stp_representation_relationship_with_transformation_and_shape_representation_relationship();
-      cdsr->representation_relation(repRel);
-
-      // The name and description attributes have no standard mapping
-      repRel->name("");
-      repRel->description("");
-
-      // rep_1 is the assembly shape and rep_2 is the component.
-      repRel->rep_1(asmSR);
-      repRel->rep_2(compSR);
-
-      // The transformation_operator should be an item_defined_transform.
-      stp_item_defined_transformation* xform = pnew stp_item_defined_transformation();
-      stp_transformation* trans = pnew stp_transformation();
-      trans->_item_defined_transformation(xform);
-      repRel->transformation_operator(trans);
-
-      // The name and description fields have no standard mapping.
-      xform->name("");
-      xform->description("");
-
-      // The first transform_item is the axis of the assembly and the second is
-      // the component.
-      xform->transform_item_1(asmAxis);
-      xform->transform_item_2(compAxis);
-  }
-#endif
-
 }
 
 void
