Bottom: f5f63a7026941acaba21fc78534eae2038092d23
Top:    f63938ae13ec16ded5059773c3e861afce779945
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-17 19:56:41 +0000

Attempt to splice in edge_label routine from later in patch series...

This corrects the bogus fix for hairline edges in the previous patch,
simplifying edge_label, but it DOES NOT address how to deal with these
hairline edge pairs.

With debugging on the test-cases causing problem will fail.

With arc radius compensation disabled in polygon.h, the following will
produce hairline edge pairs, and cause problems..



Via[8475.00mil 5575.00mil 40.00mil 30.00mil 0.0000 20.00mil "" ""]

Layer(1 "component")
(
)
Layer(2 "solder")
(
  Line[8425.00mil 6250.00mil 8425.00mil 4475.00mil 25.00mil 30.00mil "clearline"]
  Line[8475.00mil 5575.00mil 8475.00mil 4425.00mil 15.00mil 30.00mil "clearline"]
  Polygon("clearpoly")
  (
    [6350.00mil 6650.00mil] [6350.00mil 4150.00mil] [9050.00mil 4150.00mil] [9050.00mil 6650.00mil]
  )
)

The diff for polygon.h:


diff --git a/src/polygon.h b/src/polygon.h
index a369096..0cba2bf 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -37,11 +37,28 @@
 #define POLY_CIRC_SEGS 8//40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)

+#if 0
+/* THIS IS BROKEN:
+ *
+ * IT BREAKS THE CIRCULARITY OF CIRULAR CONTORS, AS THE FIRST
+ * FIRST VERTEX ADDED BY CirclePoly IS NOT RADIUS ADJUSTED.
+ *
+ * IT BREAKS CIRCULARITY OF ALIGMENT BETWEEN A LINE AND ITS END-CAPS,
+ * LEADING TO MORE COMPLEX CONTOURS FOR COMMON LINE-LINE INTERSECTIONS,
+ * SUCH AS 90 AND 45 DEGREE ANGLES
+ *
+ * IT WAS INTENDED TO AVOID DRC ERRORS WITH "TOO-CLOSE" FEATURES,
+ * BUT COULD OTHERWISE CAUSE THEM FOR "TOO THIN" FEATURES - INSIDE/OUTSIDE
+ * CONTOUR APPROXIMATION NEEDS TO BE CONTROLED DEPENDING ON THE REQUIREMENT
+ */
 /* adjustment to make the segments outline the circle rather than connect
  * points on the circle: 1 - cos (\alpha / 2) < (\alpha / 2) ^ 2 / 2
  */
 #define POLY_CIRC_RADIUS_ADJ (1.0 + M_PI / POLY_CIRC_SEGS_F * \
                                     M_PI / POLY_CIRC_SEGS_F / 2.0)
+#else
+#define POLY_CIRC_RADIUS_ADJ 1.0
+#endif

 /* polygon diverges from modelled arc no more than MAX_ARC_DEVIATION * thick */
 #define POLY_ARC_MAX_DEVIATION 0.02




---

diff --git a/src/polygon1.c b/src/polygon1.c
index 140ea70..b44f814 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -276,6 +276,24 @@ new_descriptor (VNODE * a, char poly, char side)
 }
 
 /*
+ * Compare the edge angles (and curvatures) to determine
+ * the ordering of two edges around a vertex.
+ *
+ * Returns <0 (ie -1) for a < b
+ * Returns =0         for a = b
+ * Returns >1 (ie +1) for a > b
+ */
+static int compare_cvc_nodes (CVCList *a, CVCList *b)
+{
+  if (a->angle < b->angle)
+    return -1;
+  else if (a->angle > b->angle)
+    return 1;
+  else
+    return 0;
+}
+
+/*
 insert_descriptor
   (C) 2006 harry eaton
 
@@ -330,12 +348,13 @@ insert_descriptor (VNODE * a, char poly, char side, CVCList * start)
   l = big = small = start;
   do
     {
-      if (l->next->angle < l->angle)	/* find start/end of list */
+      if (compare_cvc_nodes (l->next, l) < 0)
 	{
 	  small = l->next;
 	  big = l;
 	}
-      else if (newone->angle >= l->angle && newone->angle <= l->next->angle)
+      else if (compare_cvc_nodes (newone, l) >= 0 &&
+               compare_cvc_nodes (newone, l->next) <= 0)
 	{
 	  /* insert new cvc if it lies between existing points */
 	  newone->prev = l;
@@ -346,6 +365,11 @@ insert_descriptor (VNODE * a, char poly, char side, CVCList * start)
     }
   while ((l = l->next) != start);
   /* didn't find it between points, it must go on an end */
+
+#if 0
+  /* XXX: DUH.. BOTH OF THESE CODE-PATHS BELOW ARE EQUIVELANT.. INSERT AFTER big, or BEFORE small.
+   *      The list rolls around, so big->next == small.
+   */
   if (big->angle <= newone->angle)
     {
       newone->prev = big;
@@ -354,6 +378,7 @@ insert_descriptor (VNODE * a, char poly, char side, CVCList * start)
       return newone;
     }
   assert (small->angle >= newone->angle);
+#endif
   newone->next = small;
   newone->prev = small->prev;
   small->prev = small->prev->next = newone;
@@ -391,86 +416,97 @@ node_add_single_point (VNODE * a, Vector p)
 /*
 edge_label
  (C) 2006 harry eaton
+ (C) 2016 Peter Clifton
 */
-/* pn is considered an edge (?) */
+/* pn is considered an edge */
 static unsigned int
 edge_label (VNODE * pn)
 {
   CVCList *first_l, *l;
   char this_poly;
-  int region = UNKNWN;
+  int region;
+  bool shared_edge_case = false;
 
-  assert (pn);
-  assert (pn->cvc_next);
-  this_poly = pn->cvc_next->poly;
   /* search counter-clockwise in the cross vertex connectivity (CVC) list
    *
    * check for shared edges (that could be prev or next in the list since the angles are equal)
    * and check if this edge (pn -> pn->next) is found between the other poly's entry and exit
    */
 
-  if (pn->cvc_next->angle == pn->cvc_next->prev->angle)
-    l = pn->cvc_next->prev;
-  else
-    l = pn->cvc_next;
+  /* Start with l pointing to the CVCNode corresponding to this edge leaving its from vertex */
+  assert (pn);
+  l = EDGE_BACKWARD_VERTEX (pn)->cvc_next;
+
+  assert (l);
+  this_poly = l->poly;
 
-  first_l = l;
-  while ((l->poly == this_poly) && (l != first_l->prev))
+  /* Shared edges can be sorted in either order, so need to check l->prev as well */
+  if (compare_cvc_nodes (l, l->prev) == 0)
     {
-      l = l->next;
+      shared_edge_case = true;
+      l = l->prev;
+    }
+  else
+    {
+      if (compare_cvc_nodes (l, l->next) == 0)
+        shared_edge_case = true;
 
-      /* Skip over hairline pairs of edges from the other polygon, as they are not necessarily
-       * sorted in the correct order, and thus can mislead as to whether we are inside or outside
-       */
-      if (l->poly == l->next->poly &&
-          l->side != l->next->side && /* <-- PCJC: Not sure if this is required, including for sanity */
-          l->angle == l->next->angle)
-        l = l->next->next;
+      /* Both the shared with next, or general non-shared cases need l = l->next */
+      l = l->next;
     }
-  assert (l->poly != this_poly);
 
-  assert (l && l->angle >= 0 && l->angle <= 4.0);
-  if (l->poly != this_poly)
+  if (shared_edge_case)
     {
-      if (l->side == 'P')
-	{
-	  if (EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (l->parent))->point[0] == EDGE_FORWARD_VERTEX (pn)->point[0] &&
-	      EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (l->parent))->point[1] == EDGE_FORWARD_VERTEX (pn)->point[1])
-	    {
-	      region = SHARED2;
-	      pn->shared = VERTEX_BACKWARD_EDGE (l->parent);
-	    }
-	  else
-	    region = INSIDE;
-	}
-      else
-	{
-	  if (l->angle == pn->cvc_next->angle)
-	    {
-	      assert (EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (l->parent))->point[0] == EDGE_FORWARD_VERTEX (pn)->point[0] &&
-	              EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (l->parent))->point[1] == EDGE_FORWARD_VERTEX (pn)->point[1]);
-	      region = SHARED;
-	      pn->shared = VERTEX_FORWARD_EDGE (l->parent);
-	    }
-	  else
-	    region = OUTSIDE;
-	}
+      /* Should be the shared edge case.. but we will make a few checks to be sure! */
+
+      /* If this fires, we found a hairline edge pair within our own polygon, as no edge
+       * from the same polygon should compare identically in the CVCList
+       */
+      assert (l->poly != this_poly);
+
+      /* If this fires, we found two geometrically distinct edges which for some reason compare as equal in our cvc_list.
+       * Shared edges should be geometrically identical (but may be in opposite directions).
+       */
+      assert (EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->parent, l->side), l->side)->point[0] == EDGE_FORWARD_VERTEX (pn)->point[0] &&
+              EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (l->parent, l->side), l->side)->point[1] == EDGE_FORWARD_VERTEX (pn)->point[1]);
+
+      /* SHARED is the same direction case,
+       * SHARED2 is the opposite direction case.
+       */
+      region = (l->side == 'P') ? SHARED2 : SHARED;
+      pn->shared = VERTEX_SIDE_DIR_EDGE (l->parent, l->side);
     }
-  if (region == UNKNWN)
+  else
     {
-      for (l = l->next; l != pn->cvc_next; l = l->next)
-	{
-	  if (l->poly != this_poly)
-	    {
-	      if (l->side == 'P')
-		region = INSIDE;
-	      else
-		region = OUTSIDE;
-	      break;
-	    }
-	}
+      first_l = l;
+      /* Skip edges unil we find one from the next polygon */
+      while ((l->poly == this_poly) && (l != first_l->prev))
+        {
+          /* Check for hairline pairs of edges in the CVCList, they may be sorted in incorrect order,
+           * and would thus mislead as to whether we are inside or outside a given contour. It is a
+           * bug if such edges are present, so test for it here where we may detect it. We compare
+           * l->prev and l, as we know both are still in this_poly.. l->next may not be.
+           */
+          assert (compare_cvc_nodes (l->prev, l) != 0);
+
+          l = l->next;
+        }
+
+      /* If this fires, we must have wrapped around the entire CVCList wihthout finding any edges from
+       * the other polygon.
+       */
+      assert (l->poly != this_poly);
+
+      /* Check the other polygon edge we landed on in the CVCList is not a hairline edge pair
+       * from the same polygon. If so, they may be sorted in incorrect order and would thus
+       * mislead as to whether we are inside or outside that contour. It is a bug if such edges
+       * are present.
+       */
+      assert (l->poly != l->next->poly || compare_cvc_nodes (l, l->next) != 0);
+
+      region = (l->side == 'P') ? INSIDE : OUTSIDE;
     }
-  assert (region != UNKNWN);
+
   assert (EDGE_LABEL (pn) == UNKNWN || EDGE_LABEL (pn) == region);
   LABEL_EDGE (pn, region);
   if (region == SHARED || region == SHARED2)
