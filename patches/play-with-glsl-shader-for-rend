Bottom: 396ab9a496814b0a19290fdcfd511ca8549588a8
Top:    520605bfc247d1ed32b82a41e0afa5a54cf10d04
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-12-04 19:24:09 +0000

Play with GLSL shader for rendering line caps and circles

And of course.. typically, a million other little fixes:

 - Primitive rendering object changed from GL_TRIANGLES to GL_TRIANGLE_STRIP
 - Cache of tristrip data per contour (HACK: in the core)
 - Rendering using mapped VBOs rather than just arrays
 - Updated layer depth code, so we render with "z" in world coordinates
 - Space navigator joystick support fixes against later kernels

Bugs:
 - Layer depths will be wrong for reversed layer group numbering
 - Pixel shader ought to be switched off for polygon fill?
 - hidgl_draw_rect stubbed out (for benchmarking)
 - Draw Element mark stubbed out (for benchmarking)
 - Draw crosshair stubbed out (for benchmarking)
 - Draw crosshair not updated to render in world coordinates

Notes:
 - Apparently it can be better to do glVertexPointer last (so we do):
    From: http://sdickinson.com/wordpress/?p=122
    ""
    Make sure you put glVertexPointer at the end as there is a lot of work that
    goes on behind the scenes with it, and if it's set at the start, it has to
    do all that work for each gl*Pointer call, rather than once at the end.
    ""

 - We set up the array pointers before calling glEnableClientState():
    I'm not sure, but if we do this the other way around, it might cause
    the driver to hang onto our old buffers longer, or perform state setup,
    only to have to discard that work shortly after.

 - DARN: Seems that using VBOs is not a win, even on Intel 965:
    Certainly seems to fail miserably (v. low FPS) on my NVidia card.

    On Intel, sysprof shows a huge amount of time spent clflushing
    buffers, or copying to the graphics card (uncached).

    Set to use glBufferSubData by default for now.


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 64bbdb1..e297169 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -177,6 +177,8 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_shaders.c \
+	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
 	hid/common/trackball.h \
 	borast/borast-minimal.h \
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 01a4479..c4e07ec 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -74,6 +74,7 @@
 #include <dmalloc.h>
 #endif
 
+hidgl_shader *circular_program = NULL;
 
 static bool in_context = false;
 
@@ -87,41 +88,137 @@ static bool in_context = false;
   } while (0)
 
 
+#define BUFFER_STRIDE (5 * sizeof (GLfloat))
+#define BUFFER_SIZE (BUFFER_STRIDE * 3 * TRIANGLE_ARRAY_SIZE)
+
+/* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
 hidgl_reset_triangle_array (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
 
+  if (priv->buffer.use_map) {
+    /* Hint to the driver that we're done with the previous buffer contents */
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+    /* Map the new memory to upload vertices into. */
+    priv->buffer.triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
+
+  /* If mapping the VBO fails (or if we aren't using VBOs) fall back to
+   * local storage.
+   */
+  if (priv->buffer.triangle_array == NULL) {
+    priv->buffer.triangle_array = malloc (BUFFER_SIZE);
+    priv->buffer.use_map = false;
+  }
+
+  /* Don't want this bound for now */
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
+
   priv->buffer.triangle_count = 0;
   priv->buffer.coord_comp_count = 0;
+  priv->buffer.vertex_count = 0;
 }
 
 static void
 hidgl_init_triangle_array (hidgl_instance *hidgl)
 {
+  hidgl_priv *priv = hidgl->priv;
+
+  CHECK_IS_IN_CONTEXT ();
+
+  priv->buffer.use_vbo = true;
+  // priv->buffer.use_vbo = false;
+
+  if (priv->buffer.use_vbo) {
+    glGenBuffers (1, &priv->buffer.vbo_id);
+    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+  }
+
+  if (priv->buffer.vbo_id == 0)
+    priv->buffer.use_vbo = false;
+
+  priv->buffer.use_map = priv->buffer.use_vbo;
+
+  /* NB: Mapping the whole buffer can be expensive since we ask the driver
+   *     to discard previous data and give us a "new" buffer to write into
+   *     each time. If it is still rendering from previous buffer, we end
+   *     up causing a lot of unnecessary allocation in the driver this way.
+   *
+   *     On intel drivers at least, glBufferSubData does not block. It uploads
+   *     into a temporary buffer and queues a GPU copy of the uploaded data
+   *     for when the "main" buffer has finished rendering.
+   */
+  priv->buffer.use_map = false;
+
+  /* If using VBOs (but not mapping), we only need to this once */
+  if (priv->buffer.use_vbo && !priv->buffer.use_map)
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+
+  priv->buffer.triangle_array = NULL;
   hidgl_reset_triangle_array (hidgl);
 }
 
+static void
+hidgl_finish_triangle_array (hidgl_instance *hidgl)
+{
+  hidgl_priv *priv = hidgl->priv;
+
+  if (priv->buffer.use_map) {
+    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+    glBindBuffer (GL_ARRAY_BUFFER, 0);
+  } else {
+    free (priv->buffer.triangle_array);
+  }
+
+  if (priv->buffer.use_vbo) {
+    glDeleteBuffers (1, &priv->buffer.vbo_id);
+    priv->buffer.vbo_id = 0;
+  }
+}
+
 void
 hidgl_flush_triangles (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
+  GLfloat *data_pointer = NULL;
 
   CHECK_IS_IN_CONTEXT ();
 
-  if (priv->buffer.triangle_count == 0)
+  if (priv->buffer.vertex_count == 0)
     return;
 
+  if (priv->buffer.use_vbo) {
+    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+
+    if (priv->buffer.use_map) {
+      glUnmapBuffer (GL_ARRAY_BUFFER);
+      priv->buffer.triangle_array = NULL;
+    } else {
+      /* NB: We only upload the portion of the buffer we've used */
+      glBufferSubData (GL_ARRAY_BUFFER, 0,
+                       BUFFER_STRIDE * priv->buffer.vertex_count,
+                       priv->buffer.triangle_array);
+    }
+  } else {
+    data_pointer = priv->buffer.triangle_array;
+  }
+
+  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+  glVertexPointer   (3, GL_FLOAT, BUFFER_STRIDE, data_pointer + 0);
+
+  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer   (3, GL_FLOAT, 0, priv->buffer.triangle_array);
-  glDrawArrays (GL_TRIANGLES, 0, priv->buffer.triangle_count * 3);
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, priv->buffer.vertex_count);
   glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
   hidgl_reset_triangle_array (hidgl);
 }
 
 void
-hidgl_ensure_triangle_space (hidGC gc, int count)
+hidgl_ensure_vertex_space (hidGC gc, int count)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
   hidgl_instance *hidgl = hidgl_gc->hidgl;
@@ -129,18 +226,27 @@ hidgl_ensure_triangle_space (hidGC gc, int count)
 
   CHECK_IS_IN_CONTEXT ();
 
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
-      fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+      fprintf (stderr, "Requested %i vertices, %i available\n",
+                       count, 3 * TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - priv->buffer.triangle_count)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE - priv->buffer.vertex_count)
     hidgl_flush_triangles (hidgl);
 }
 
 void
+hidgl_ensure_triangle_space (hidGC gc, int count)
+{
+  CHECK_IS_IN_CONTEXT ();
+
+  /* NB: 5 = 3 + 2 extra vertices to separate from other triangle strips */
+  hidgl_ensure_vertex_space (gc, count * 5);
+}
+
+void
 hidgl_set_depth (hidGC gc, float depth)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
@@ -220,42 +326,34 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (hidGC gc, Coord width, Coord x, Coord y, Angle angle, double scale)
+static void draw_cap (hidGC gc, Coord width, Coord x, Coord y, Angle angle)
 {
-  float last_capx, last_capy;
-  float capx, capy;
   float radius = width / 2.;
-  int slices = calc_slices (radius / scale, M_PI);
-  int i;
 
   CHECK_IS_IN_CONTEXT ();
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-  hidgl_ensure_triangle_space (gc, slices);
-
-  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
-  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
-  for (i = 0; i < slices; i++) {
-    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
-    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (gc, last_capx, last_capy, capx, capy, x, y);
-    last_capx = capx;
-    last_capy = capy;
-  }
+
+  hidgl_ensure_vertex_space (gc, 6);
+
+  /* FIXME: Should draw an offset rectangle at the appropriate angle,
+   *        avoiding relying on the subcompositing between layers to
+   *        stop us creating an artaefact by drawing a full circle.
+   */
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 void
 hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale)
 {
-  double angle;
   double deltax, deltay, length;
   float wdx, wdy;
+  float cosine, sine;
   int circular_caps = 0;
   int hairline = 0;
 
@@ -268,22 +366,19 @@ hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, C
 
   deltax = x2 - x1;
   deltay = y2 - y1;
-
   length = sqrt (deltax * deltax + deltay * deltay);
 
   if (length == 0) {
     /* Assume the orientation of the line is horizontal */
-    wdx = -width / 2.;
-    wdy = 0;
-    length = 1.;
-    deltax = 1.;
-    deltay = 0.;
+    cosine = 1.0;
+    sine   = 0.0;
   } else {
-    wdy = deltax * width / 2. / length;
-    wdx = -deltay * width / 2. / length;
+    cosine = deltax / length;
+    sine   = deltay / length;
   }
 
-  angle = -180. / M_PI * atan2 (deltay, deltax);
+  wdy =  width / 2. * cosine;
+  wdx = -width / 2. * sine;
 
   switch (cap) {
     case Trace_Cap:
@@ -293,26 +388,50 @@ hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, C
 
     case Square_Cap:
     case Beveled_Cap:
-      x1 -= deltax * width / 2. / length;
-      y1 -= deltay * width / 2. / length;
-      x2 += deltax * width / 2. / length;
-      y2 += deltay * width / 2. / length;
+      /* Use wdx and wdy (which already have the correct numbers), just in
+       * case the compiler doesn't spot it can avoid recomputing these. */
+      x1 -= wdy; /* x1 -= width / 2. * cosine;   */
+      y1 += wdx; /* y1 -= width / 2. * sine;     */
+      x2 += wdy; /* x2 += width / 2. * cosine;   */
+      y2 -= wdx; /* y2 += width / 2. / sine;     */
       break;
   }
 
-  hidgl_ensure_triangle_space (gc, 2);
-  hidgl_add_triangle (gc, x1 - wdx, y1 - wdy,
-                          x2 - wdx, y2 - wdy,
-                          x2 + wdx, y2 + wdy);
-  hidgl_add_triangle (gc, x1 - wdx, y1 - wdy,
-                          x2 + wdx, y2 + wdy,
-                          x1 + wdx, y1 + wdy);
-
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (gc, width, x1, y1, angle + 90., scale);
-      draw_cap (gc, width, x2, y2, angle - 90., scale);
+      float capx = deltax * width / 2. / length;
+      float capy = deltay * width / 2. / length;
+
+      hidgl_ensure_vertex_space (gc, 10);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (gc, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
+      hidgl_add_vertex_tex (gc, x1 - wdx,        y1 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 + wdx,        y1 + wdy,         0.0,  1.0);
+
+      hidgl_add_vertex_tex (gc, x2 - wdx,        y2 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx,        y2 + wdy,         0.0,  1.0);
+      hidgl_add_vertex_tex (gc, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  else
+    {
+      hidgl_ensure_vertex_space (gc, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (gc, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 + wdx, y1 + wdy, 0.0,  1.0);
+
+      hidgl_add_vertex_tex (gc, x2 - wdx, y2 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 }
 
@@ -391,10 +510,10 @@ hidgl_draw_arc (hidGC gc, Coord width, Coord x, Coord y, Coord rx, Coord ry,
 
   draw_cap (gc, width, x + rx * -cosf (start_angle_rad),
                        y + rx *  sinf (start_angle_rad),
-                       start_angle, scale);
+                       start_angle);
   draw_cap (gc, width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
                        y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                       start_angle + delta_angle + 180., scale);
+                       start_angle + delta_angle + 180.);
 }
 
 void
@@ -414,37 +533,20 @@ hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 
 
 void
-hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr, double scale)
+hidgl_fill_circle (hidGC gc, Coord x, Coord y, Coord radius)
 {
-#define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 360
-  float last_x, last_y;
-  float radius = vr;
-  int slices;
-  int i;
-
   CHECK_IS_IN_CONTEXT ();
-  slices = calc_slices (vr / scale, 2 * M_PI);
-
-  if (slices < MIN_TRIANGLES_PER_CIRCLE)
-    slices = MIN_TRIANGLES_PER_CIRCLE;
 
-  if (slices > MAX_TRIANGLES_PER_CIRCLE)
-    slices = MAX_TRIANGLES_PER_CIRCLE;
+  hidgl_ensure_vertex_space (gc, 6);
 
-  hidgl_ensure_triangle_space (gc, slices);
-
-  last_x = vx + vr;
-  last_y = vy;
-
-  for (i = 0; i < slices; i++) {
-    float x, y;
-    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (gc, vx, vy, last_x, last_y, x, y);
-    last_x = x;
-    last_y = y;
-  }
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 #define MAX_COMBINED_MALLOCS 2500
@@ -504,7 +606,6 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
-static double global_scale;
 static hidGC tesselator_gc = NULL;
 
 static void CALLBACK
@@ -609,20 +710,14 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-fill_contour (hidGC gc, PLINE *contour, double scale)
+fill_contour (hidGC gc, PLINE *contour)
 {
   borast_traps_t traps;
 
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
-   * hidgl_fill_circle to draw this contour.
-   */
+  /* If the contour is round, then call hidgl_fill_circle to draw it. */
   if (contour->is_round) {
-    double slices = calc_slices (contour->radius / scale, 2 * M_PI);
-    if (slices < contour->Count) {
-      hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius, scale);
-      return;
-    }
+    hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius);
+    return;
   }
 
   _borast_traps_init (&traps);
@@ -630,44 +725,34 @@ fill_contour (hidGC gc, PLINE *contour, double scale)
   _borast_traps_fini (&traps);
 }
 
-struct do_hole_info {
-  hidGC gc;
-  double scale;
-};
-
 static int
 do_hole (const BoxType *b, void *cl)
 {
-  struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
+  hidGC gc = (hidGC)cl;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
 
-  fill_contour (info->gc, curc, info->scale);
+  fill_contour (gc, curc);
   return 1;
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
+fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
   hidgl_instance *hidgl = hidgl_gc->hidgl;
   hidgl_priv *priv = hidgl->priv;
-  struct do_hole_info info;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
 
-  info.gc = gc;
-  info.scale = scale;
-  global_scale = scale;
-
   /* Special case non-holed polygons which don't require a stencil bit */
   if (pa->contour_tree->size == 1) {
-    fill_contour (gc, pa->contours, scale);
+    fill_contour (gc, pa->contours);
     return;
   }
 
@@ -695,7 +780,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, &info);
+  r_search (pa->contour_tree, clip_box, NULL, do_hole, gc);
   hidgl_flush_triangles (hidgl);
 
   glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
@@ -713,7 +798,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
   /* Draw the polygon outer */
-  fill_contour (gc, pa->contours, scale);
+  fill_contour (gc, pa->contours);
   hidgl_flush_triangles (hidgl);
 
   /* Unassign our stencil buffer bit */
@@ -723,19 +808,19 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
 }
 
 void
-hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   if (poly->Clipped == NULL)
     return;
 
-  fill_polyarea (gc, poly->Clipped, clip_box, scale);
+  fill_polyarea (gc, poly->Clipped, clip_box);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box, scale);
+        fill_polyarea (gc, pa, clip_box);
     }
 }
 
@@ -744,9 +829,32 @@ hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_ensure_triangle_space (gc, 2);
-  hidgl_add_triangle (gc, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (gc, x2, y1, x2, y2, x1, y1);
+  hidgl_ensure_vertex_space (gc, 6);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (gc, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x1, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+}
+
+static void
+load_built_in_shaders (void)
+{
+  char *circular_fs_source =
+          "void main()\n"
+          "{\n"
+          "  float sqdist;\n"
+          "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+          "  if (sqdist > 1.0)\n"
+          "    discard;\n"
+          "  gl_FragColor = gl_Color;\n"
+          "}\n";
+
+  /*priv->*/circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
 }
 
 void
@@ -762,6 +870,13 @@ hidgl_init (void)
 
   /* Any one-time (hopefully!) hidgl setup goes in here */
 
+#if 0 /* Need to initialise shaders with a current GL context */
+  if (hidgl_shader_init_shaders ())
+    load_built_in_shaders ();
+  else
+    printf ("Failed to initialise shader support\n");
+#endif
+
   called = true;
 }
 
@@ -793,7 +908,7 @@ hidgl_new_instance (void)
 
   hidgl_reset_stencil_usage (hidgl);
 #endif
-  hidgl_init_triangle_array (hidgl);
+//  hidgl_init_triangle_array (hidgl);
 
   return hidgl;
 }
@@ -825,6 +940,7 @@ void
 hidgl_start_render (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
+  static bool called = false;
 
   if (in_context)
     fprintf (stderr, "hidgl: hidgl_start_render() - Already in rendering context!\n");
@@ -847,8 +963,19 @@ hidgl_start_render (hidgl_instance *hidgl)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_reset_stencil_usage (hidgl);
+#if 1 /* Need to initialise shaders with a current GL context */
+  if (!called)
+    {
+      if (hidgl_shader_init_shaders ())
+        load_built_in_shaders ();
+      else
+        printf ("Failed to initialise shader support\n");
+      called = true;
+    }
+#endif
+
   hidgl_init_triangle_array (hidgl);
+  hidgl_shader_activate (/*priv->*/circular_program);
 }
 
 void
@@ -857,6 +984,8 @@ hidgl_finish_render (hidgl_instance *hidgl)
   if (!in_context)
     fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
 
+  hidgl_finish_triangle_array (hidgl);
+  hidgl_shader_activate (NULL);
   in_context = false;
 }
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 4b80714..484614c 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,12 +23,18 @@
 #ifndef PCB_HID_COMMON_HIDGL_H
 #define PCB_HID_COMMON_HIDGL_H
 
+#include "hidgl_shaders.h"
+
 /* NB: triangle_buffer is a private type, only defined here to enable inlining of geometry creation */
-#define TRIANGLE_ARRAY_SIZE 5461
+#define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  unsigned int vertex_count;
+  GLuint vbo_id;
+  bool use_vbo;
+  bool use_map;
 } triangle_buffer;
 
 /* NB: hidgl_priv is a private type, only defined here to enable inlining of geometry creation */
@@ -41,6 +47,9 @@ typedef struct {
   int dirty_bits;
   int assigned_bits;
 
+  /* Shaders */
+//  hidgl_shader *circular_program;
+
 } hidgl_priv;
 
 /* NB: hidgl_instance is a public type, intended to be used as an opaque pointer */
@@ -59,30 +68,77 @@ typedef struct hidgl_gc_struct {
 
 } *hidglGC;
 
+extern hidgl_shader *circular_program;
+
 void hidgl_flush_triangles (hidgl_instance *hidgl);
+void hidgl_ensure_vertex_space (hidGC gc, int count);
 void hidgl_ensure_triangle_space (hidGC gc, int count);
 
 
 static inline void
+hidgl_add_vertex_3D_tex (hidGC gc,
+                         GLfloat x, GLfloat y, GLfloat z,
+                         GLfloat s, GLfloat t)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+  hidgl_priv *priv = hidgl->priv;
+
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = s;
+  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = t;
+  priv->buffer.vertex_count++;
+}
+
+static inline void
+hidgl_add_vertex_tex (hidGC gc,
+                      GLfloat x, GLfloat y,
+                      GLfloat s, GLfloat t)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_add_vertex_3D_tex (gc, x, y, hidgl_gc->depth, s, t);
+}
+
+static inline void
+hidgl_add_triangle_3D_tex (hidGC gc,
+                           GLfloat x1, GLfloat y1, GLfloat z1, GLfloat s1, GLfloat t1,
+                           GLfloat x2, GLfloat y2, GLfloat z2, GLfloat s2, GLfloat t2,
+                           GLfloat x3, GLfloat y3, GLfloat z3, GLfloat s3, GLfloat t3)
+{
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (gc, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (gc, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (gc, x2, y2, z2, s2, t2);
+  hidgl_add_vertex_3D_tex (gc, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (gc, x3, y3, z3, s3, t3);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+}
+
+static inline void
 hidgl_add_triangle_3D (hidGC gc,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
+  hidgl_add_triangle_3D_tex (gc, x1, y1, z1, 0., 0.,
+                                 x2, y2, z2, 0., 0.,
+                                 x3, y3, z3, 0., 0.);
+}
+
+static inline void
+hidgl_add_triangle_tex (hidGC gc,
+                        GLfloat x1, GLfloat y1, GLfloat s1, GLfloat t1,
+                        GLfloat x2, GLfloat y2, GLfloat s2, GLfloat t2,
+                        GLfloat x3, GLfloat y3, GLfloat s3, GLfloat t3)
+{
   hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
 
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x1;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y1;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z1;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x2;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y2;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z2;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x3;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y3;
-  priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = z3;
-  priv->buffer.triangle_count++;
+  hidgl_add_triangle_3D_tex (gc, x1, y1, hidgl_gc->depth, s1, t1,
+                                 x2, y2, hidgl_gc->depth, s2, t2,
+                                 x3, y3, hidgl_gc->depth, s3, t3);
 }
 
 static inline void
@@ -103,9 +159,9 @@ void hidgl_set_depth (hidGC gc, float depth);
 void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
 void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
 void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
-void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr, double scale);
+void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr);
 void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
diff --git a/src/hid/common/hidgl_shaders.c b/src/hid/common/hidgl_shaders.c
new file mode 100644
index 0000000..fcf8c26
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.c
@@ -0,0 +1,178 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifndef WIN32
+    /* The Linux OpenGL ABI 1.0 spec requires that we define
+     * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+     * in order to get prototypes:
+     *   http://www.opengl.org/registry/ABI/
+     */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#ifdef HAVE_OPENGL_GLU_H
+#   include <OpenGL/glu.h>
+#else
+#   include <GL/glu.h>
+#endif
+
+#include "hidgl_shaders.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* Opaque data-structure keeping a shader object */
+struct _hidgl_shader {
+  char *name;
+  GLuint program;
+  GLuint vs;
+  GLuint fs;
+};
+
+bool
+hidgl_shader_init_shaders (void)
+{
+  /* XXX: Check for required functionality in the GL driver */
+  return true;
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+print_log (GLuint obj)
+{
+  int infologLength = 0;
+  int maxLength;
+  char *infoLog;
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  infoLog = malloc (maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+
+  free (infoLog);
+}
+
+
+/* If either vs or fs is NULL, used the fixed function pipeline for that */
+hidgl_shader *
+hidgl_shader_new (char *name, char *vs_source, char *fs_source)
+{
+  hidgl_shader *shader;
+  const char *source;
+  int source_len;
+
+  shader = malloc (sizeof (hidgl_shader));
+
+  if (shader == NULL)
+    return NULL;
+
+  shader->name = strdup (name);
+  shader->program = 0;
+  shader->vs = 0;
+  shader->fs = 0;
+
+  if (fs_source == NULL && vs_source == NULL)
+    return shader;
+
+  shader->program = glCreateProgram ();
+
+  if (vs_source != NULL) {
+    source = vs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->vs = glCreateShader (GL_VERTEX_SHADER);
+    glShaderSource (shader->vs, 1, &source, &source_len);
+    glCompileShader (shader->vs);
+    print_log (shader->vs);
+    glAttachShader (shader->program, shader->vs);
+  }
+
+  if (fs_source != NULL) {
+    source = fs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->fs = glCreateShader (GL_FRAGMENT_SHADER);
+    glShaderSource (shader->fs, 1, &source, &source_len);
+    glCompileShader (shader->fs);
+    print_log (shader->fs);
+    glAttachShader (shader->program, shader->fs);
+  }
+
+  glLinkProgram (shader->program);
+  print_log (shader->program);
+  return shader;
+}
+
+
+GLuint
+hidgl_shader_get_program (hidgl_shader *shader)
+{
+  return shader->program;
+}
+
+
+/* Delete the passed shader. */
+void
+hidgl_shader_free (hidgl_shader *shader)
+{
+  /* NB: These calls all silently ignore 0 or NULL arguments */
+  glDeleteShader (shader->vs);
+  glDeleteShader (shader->fs);
+  glDeleteProgram (shader->program);
+  free (shader->name);
+  free (shader);
+}
+
+
+/* Activate the given shader program, or deactivate if NULL passed */
+void
+hidgl_shader_activate (hidgl_shader *shader)
+{
+  if (shader == NULL)
+    glUseProgram (0);
+  else
+    glUseProgram (shader->program);
+}
diff --git a/src/hid/common/hidgl_shaders.h b/src/hid/common/hidgl_shaders.h
new file mode 100644
index 0000000..9812b4b
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.h
@@ -0,0 +1,35 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_SHADERS_INCLUDED__
+#define __HIDGL_SHADERS_INCLUDED__
+
+typedef struct _hidgl_shader hidgl_shader;
+
+bool hidgl_shader_init_shaders (void);
+
+hidgl_shader *hidgl_shader_new (char *name, char *vs_source, char *fs_source);
+GLuint hidgl_shader_get_program (hidgl_shader *shader);
+void hidgl_shader_free (hidgl_shader *shader);
+void hidgl_shader_activate (hidgl_shader *shader);
+
+#endif /* __HIDGL_SHADERS_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 158c37e..9b23144 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -14,13 +14,15 @@
 #include "polygon.h"
 #include "gui-pinout-preview.h"
 
+#ifndef WIN32
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
  * in order to get prototypes:
  *   http://www.opengl.org/registry/ABI/
  */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
 
-#define GL_GLEXT_PROTOTYPES 1
 #ifdef HAVE_OPENGL_GL_H
 #   include <OpenGL/gl.h>
 #else
@@ -347,6 +349,8 @@ ghid_draw_grid (hidGC gc, BoxType *drawn_area)
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
+  glTexCoord2f (0., 0.);
+
   glDisable (GL_STENCIL_TEST);
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
@@ -365,10 +369,14 @@ static void
 ghid_draw_bg_image (void)
 {
   static GLuint texture_handle = 0;
+  GLuint current_program;
 
   if (!ghidgui->bg_pixbuf)
     return;
 
+  glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&current_program);
+  glUseProgram (0);
+
   if (texture_handle == 0)
     {
       int width =             gdk_pixbuf_get_width (ghidgui->bg_pixbuf);
@@ -416,6 +424,8 @@ ghid_draw_bg_image (void)
   glEnd ();
 
   glDisable (GL_TEXTURE_2D);
+
+  glUseProgram (current_program);
 }
 
 void
@@ -713,7 +723,7 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (gc, cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (gc, cx, cy, radius);
 }
 
 
@@ -730,7 +740,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (gc, poly, clip_box, gport->view.coord_per_px);
+  hidgl_fill_pcb_polygon (gc, poly, clip_box);
 }
 
 void
@@ -970,10 +980,19 @@ void
 ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 {
   render_priv *priv = port->render_priv;
+  GdkGLContext *drawarea_glcontext;
+
+  /* NB: We share with the main rendering context so we can use the
+   *     same pixel shader etc..
+   */
+  if (widget == gport->drawing_area)
+    drawarea_glcontext = NULL;
+  else
+    drawarea_glcontext = gtk_widget_get_gl_context (gport->drawing_area);
 
   gtk_widget_set_gl_capability (widget,
                                 priv->glconfig,
-                                NULL,
+                                drawarea_glcontext,
                                 TRUE,
                                 GDK_GL_RGBA_TYPE);
 }
@@ -1570,9 +1589,7 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
 #define MIN_FACES_PER_CYL 6
 #define MAX_FACES_PER_CYL 360
   float radius = vr;
-  float x1, y1;
-  float x2, y2;
-  float z1, z2;
+  float x, y, z1, z2;
   int i;
   int slices;
 
@@ -1587,19 +1604,27 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
   z1 = compute_depth (from_layer);
   z2 = compute_depth (to_layer);
 
-  x1 = vx + vr;
-  y1 = vy;
+  x = vx + vr;
+  y = vy;
+
+  hidgl_ensure_vertex_space (gc, 2 * slices + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 
-  hidgl_ensure_triangle_space (gc, 2 * slices);
   for (i = 0; i < slices; i++)
     {
-      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-      hidgl_add_triangle_3D (gc, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
-      hidgl_add_triangle_3D (gc, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
-      x1 = x2;
-      y1 = y2;
+      x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+
+      hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
     }
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 }
 
 struct cyl_info {
@@ -2185,6 +2210,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
+  GdkGLContext *drawarea_glcontext;
   GdkGLContext* glcontext;
   GdkGLDrawable* gldrawable;
   view_data save_view;
@@ -2198,6 +2224,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   /* Setup rendering context for drawing routines
    */
 
+  /* NB: We share with the main rendering context so we can use the
+   *     same pixel shader etc..
+   */
+  drawarea_glcontext = gtk_widget_get_gl_context (gport->drawing_area);
+
   glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGB     |
                                         GDK_GL_MODE_STENCIL |
                                         GDK_GL_MODE_SINGLE);
@@ -2205,7 +2236,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
   glpixmap = gdk_pixmap_set_gl_capability (pixmap, glconfig, NULL);
   gldrawable = GDK_GL_DRAWABLE (glpixmap);
-  glcontext = gdk_gl_context_new (gldrawable, NULL, TRUE, GDK_GL_RGBA_TYPE);
+  glcontext = gdk_gl_context_new (gldrawable, drawarea_glcontext,
+                                  TRUE, GDK_GL_RGBA_TYPE);
 
   /* Setup zoom factor for drawing routines */
