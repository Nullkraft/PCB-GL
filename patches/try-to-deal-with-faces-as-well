Bottom: 6eb0ffe1f9ccd21bca0eb1d0496b94a915924f08
Top:    8650f4763da9678f45ed3863879e1b4497004405
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-17 18:49:04 +0000

Try to deal with faces as well as edges


---

diff --git a/src/data.h b/src/data.h
index 1006a61..b2acc2c 100644
--- a/src/data.h
+++ b/src/data.h
@@ -72,4 +72,6 @@ extern FlagType no_flags;
 
 extern int netlist_frozen;
 
+extern int debug_integer;
+
 #endif
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 1a76e97..7b26668 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -24,6 +24,8 @@ typedef struct
   /* Rational b-splines */
   double *weights; /* Pointer to array of weights for the control points */
 
+  /* Debug */
+  bool is_placeholder; /* For some edge type we don't know how to draw */
 
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 4837b11..a90a51e 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -218,13 +218,14 @@ draw_quad_edge (edge_ref e, void *data)
   double x1, y1, z1;
   double x2, y2, z2;
   int i;
+  bool debug = GPOINTER_TO_INT (data);
 
 #if 0
   int id = ID(e) % 12;
 
   glColor3f (colors[id][0], colors[id][1], colors[id][2]);
 #else
-  glColor3f (1., 1., 1.);
+  glColor4f (1., 1., 1., 0.3);
 #endif
 
   x1 = ((vertex3d *)ODATA(e))->x;
@@ -239,6 +240,14 @@ draw_quad_edge (edge_ref e, void *data)
     {
       edge_info *info = UNDIR_DATA(e);
 
+
+//        if (info->is_placeholder)
+        if (debug)
+          {
+            glColor4f (1.0, 0.0, 0.0, 1.0);
+            glDepthMask (TRUE);
+          }
+
 //      if (info->is_stitch)
 //        return;
 
@@ -271,6 +280,27 @@ draw_quad_edge (edge_ref e, void *data)
           ny = ((edge_info *)UNDIR_DATA(e))->ny;
           nz = ((edge_info *)UNDIR_DATA(e))->nz;
 
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          if ((e & 2) == 2)
+            {
+#if 0
+              /* Option 1, just draw the forward copy, which agrees with the normal */
+              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
+              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
+              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
+
+              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
+              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
+              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
+#else
+              /* Option 2, flip the normal */
+              nx = -nx;
+              ny = -ny;
+              nz = -nz;
+#endif
+            }
+
           /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
            * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
            */
@@ -363,6 +393,7 @@ draw_quad_edge (edge_ref e, void *data)
 
           glEnd ();
 
+          glDepthMask (FALSE);
           return;
         }
     }
@@ -376,6 +407,48 @@ draw_quad_edge (edge_ref e, void *data)
               STEP_Y_TO_COORD (PCB, y2),
               STEP_X_TO_COORD (PCB, z2));
   glEnd ();
+  glDepthMask (FALSE);
+}
+
+static void
+draw_contour (contour3d *contour, void *data)
+{
+  edge_ref e;
+  bool debug = GPOINTER_TO_INT (data);
+  int edge_no = 0;
+
+  e = contour->first_edge;
+
+//  printf ("Drawing contour\n");
+
+  do
+    {
+      edge_info *info = UNDIR_DATA(e);
+//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+      draw_quad_edge (e, data);
+
+      /* Stop if e was the only edge in a face - which we re-trace */
+      /* XXX: Probably only a development bug until we get the quad-edge links correct */
+//      if (LNEXT(e) == SYM(e))
+//        break;
+
+      /* LNEXT should take us counter-clockwise around the face */
+      /* LPREV should take us clockwise around the face */
+    }
+  while ((e = LNEXT(e)) != contour->first_edge);
+}
+
+static int face_no;
+
+static void
+draw_face (face3d *face, void *data)
+{
+//  if (face->contours != NULL)
+//      draw_contour (face->contours->data, NULL);
+//  printf ("Drawing face\n");
+  g_list_foreach (face->contours, (GFunc)draw_contour, GINT_TO_POINTER(face_no == debug_integer));
+
+  face_no++;
 }
 
 void
@@ -385,7 +458,14 @@ object3d_draw (object3d *object)
 
 //  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
 //  printf ("BEGIN DRAW...\n");
-  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+
+//  printf ("\nDrawing object\n");
+
+  face_no = 0;
+
+  g_list_foreach (object->faces, (GFunc)draw_face, NULL);
+
 //  printf ("....ENDED\n");
 }
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d4127bc..fce8341 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2344,6 +2344,7 @@ ghid_draw_everything (BoxType *drawn_area)
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
+      glDepthMask (FALSE); // Temporary kludge - lets us see objects through the sides of the board
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
@@ -2352,6 +2353,7 @@ ghid_draw_everything (BoxType *drawn_area)
       ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      glDepthMask (TRUE); // Temporary kludge - lets us see objects through the sides of the board
     }
 #endif
   }
@@ -2773,7 +2775,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   glShadeModel (GL_SMOOTH);
 
-  glEnable (GL_LIGHT0);
+//  glEnable (GL_LIGHT0);
 
   /* XXX: FIX OUR NORMALS */
   glEnable (GL_NORMALIZE);
@@ -2818,9 +2820,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glPopMatrix ();
   }
 
+//  glDisable (GL_DEPTH_TEST); /* TEST */
+  glDepthMask (FALSE); /* TEST */
+
   if (!global_view_2d)
     ghid_draw_packages (&region);
 
+  glDepthMask (TRUE); /* TEST */
+
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
   glDisable (GL_LIGHT0);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index e8ef1d8..86c003b 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1286,6 +1286,15 @@ ghid_polygon_debug_selection_changed_cb (GtkTreeSelection *treeselection, gpoint
   ghid_invalidate_all ();
 }
 
+static void
+debug_spin_changed_cb (GtkSpinButton *spinbutton, void *user_data)
+{
+  GHidPort *port = user_data;
+
+  debug_integer = gtk_spin_button_get_value_as_int (spinbutton);
+  ghid_invalidate_all (port);
+}
+
 /* 
  * Create the top_window contents.  The config settings should be loaded
  * before this is called.
@@ -1297,6 +1306,7 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *hbox_middle, *hbox;
   GtkWidget *vbox, *frame;
   GtkWidget *label;
+  GtkWidget *debug_spin;
   GtkTreeViewColumn *column;
   GtkTreeIter iter;
   /* FIXME: IFDEF HACK */
@@ -1391,6 +1401,12 @@ ghid_build_pcb_top_window (void)
                     G_CALLBACK (ghid_view_2d), NULL);
   gtk_box_pack_start (GTK_BOX(ghidgui->left_toolbar),
                       trackball, FALSE, FALSE, 0);
+
+  debug_spin = gtk_spin_button_new_with_range (0.0, 10000.0, 1.0);
+  gtk_box_pack_start (GTK_BOX(ghidgui->left_toolbar),
+                      debug_spin, FALSE, FALSE, 0);
+  g_signal_connect (G_OBJECT (debug_spin), "value_changed",
+                    G_CALLBACK (debug_spin_changed_cb), ghidgui);
 #endif
 
   /* ghidgui->mode_buttons_frame was created above in the call to
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index ad1644c..35c5072 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -192,6 +192,8 @@ find_mapped_item (SdaiShape_representation *sr,
 typedef struct process_step_info {
   /* Hash / list of SR -> step_model */
   object3d *object;
+  face3d *current_face;
+  contour3d *current_contour;
   double current_transform[4][4];
 
 } process_step_info;
@@ -373,6 +375,7 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
    */
 
   edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
+  our_edge_info->is_placeholder = true; /* Highlight for now */
 
   SDAI_Application_instance *entity = start_entity;
   STEPcomplex *stepcomplex = NULL;
@@ -726,91 +729,79 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
   if (dist1 > 0.01 || dist2 > 0.02)
     {
       printf ("Entity #%i end point to first control point distances %f and %f\n",
-              dist1, dist2);
+              start_entity->StepFileId (), dist1, dist2);
     }
 }
 
 static void
-process_edges (GHashTable *edges_hash_set, process_step_info *info) //object3d *object)
+process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, process_step_info *info)
 {
   GHashTableIter iter;
-  SdaiEdge *edge;
-  edge_ref our_edge;
   vertex3d *vertex;
   double x1, y1, z1;
   double x2, y2, z2;
-  bool orientation;
-  gpointer foo;
-  int bar;
-  bool kludge;
+  edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
 
-  g_hash_table_iter_init (&iter, edges_hash_set);
-  while (g_hash_table_iter_next (&iter, (void **)&edge, &foo))
+  if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+      strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
     {
-      bar = GPOINTER_TO_INT (foo);
-      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
-          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
-        {
-          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
-          continue;
-        }
-
-      orientation = (bar & 1) != 0;
-      kludge = (bar & 2) != 0;
+      printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+      return;
+    }
 
-      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
-      //     In practice, edge should point to an EDGE_CURVE sub-type
-      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
-      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+  // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+  //     In practice, edge should point to an EDGE_CURVE sub-type
+  SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+  SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
 
-      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+  // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
 
-      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
-      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+  SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+  SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
 
-      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
-        {
-          /* HAPPY WITH THIS TYPE */
-        }
-      else
-        {
-          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
-          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
-          continue;
-        }
+  if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+    {
+      /* HAPPY WITH THIS TYPE */
+    }
+  else
+    {
+      // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+      printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+      return;
+    }
 
-      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
-        {
-          /* HAPPY WITH THIS TYPE */
-        }
-      else
-        {
-          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
-          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
-          continue;
-        }
+  if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+    {
+      /* HAPPY WITH THIS TYPE */
+    }
+  else
+    {
+      // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+      printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+      return;
+    }
 
-      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
-      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+  SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+  SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
 
-      x1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ())->value;
-      y1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
-      z1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      x2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ())->value;
-      y2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
-      z2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  x1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ())->value;
+  y1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+  z1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  x2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ())->value;
+  y2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+  z2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
 
 #if 0
-      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
-              edge->StepFileId (), x1, y1, z1, x2, y2, z2);
+  printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+          edge->StepFileId (), x1, y1, z1, x2, y2, z2);
 #endif
 
-      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
-        {
-          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+  if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+    {
+      SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
 
-          SdaiCurve *curve = ec->edge_geometry_ ();
-          bool same_sense = ec->same_sense_ ();
+      SdaiCurve *curve = ec->edge_geometry_ ();
+      bool same_sense = ec->same_sense_ ();
 
 #ifdef DEBUG_NOT_IMPLEMENTED
 //          if (!same_sense)
@@ -818,103 +809,92 @@ process_edges (GHashTable *edges_hash_set, process_step_info *info) //object3d *
 #endif
 
 #if 0
-          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+      printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
 #endif
 
-          if (strcmp (curve->EntityName (), "Line") == 0)
-            {
-              transform_vertex (info->current_transform, &x1, &y1, &z1);
-              transform_vertex (info->current_transform, &x2, &y2, &z2);
+      if (strcmp (curve->EntityName (), "Line") == 0)
+        {
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
 
-              our_edge = make_edge ();
-              UNDIR_DATA (our_edge) = make_edge_info ();
-              object3d_add_edge (info->object, our_edge);
-              vertex = make_vertex3d (x1, y1, z1);
-              ODATA(our_edge) = vertex;
-              vertex = make_vertex3d (x2, y2, z2);
-              DDATA(our_edge) = vertex;
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
 
 //              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
-//              continue;
-            }
-          else if (strcmp (curve->EntityName (), "Circle") == 0)
-            {
-              SdaiCircle *circle = (SdaiCircle *)curve;
-              double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
-              double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-              double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-              double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-              double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-              double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-
-              double radius = circle->radius_();
-
-              edge_info *edge_info;
-
-              transform_vertex (info->current_transform, &cx, &cy, &cz);
-              transform_vertex (info->current_transform, &x1, &y1, &z1);
-              transform_vertex (info->current_transform, &x2, &y2, &z2);
+//              return;
+        }
+      else if (strcmp (curve->EntityName (), "Circle") == 0)
+        {
+          SdaiCircle *circle = (SdaiCircle *)curve;
+          double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+          double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+          double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+          double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
 
-              transform_vector (info->current_transform, &nx, &ny, &nz);
+          double radius = circle->radius_();
 
-              our_edge = make_edge ();
-              edge_info = make_edge_info ();
-              if (orientation) //(!kludge) //(same_sense)
-                {
-                  edge_info_set_round (edge_info, cx, cy, cz, nx, ny, nz, radius);
-                }
-              else
-                {
-                  edge_info_set_round (edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
-                }
+          transform_vertex (info->current_transform, &cx, &cy, &cz);
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
 
-              UNDIR_DATA (our_edge) = edge_info;
-              object3d_add_edge (info->object, our_edge);
-              vertex = make_vertex3d (x1, y1, z1);
-              ODATA(our_edge) = vertex;
-              vertex = make_vertex3d (x2, y2, z2);
-              DDATA(our_edge) = vertex;
+          transform_vector (info->current_transform, &nx, &ny, &nz);
 
-//              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
-//              continue;
-            }
-          else if (curve->IsComplex() || /* This is a guess - assuming complex curves are likely to be B_SPLINE_* complexes */
-                   strcmp (curve->EntityName (), "B_Spline_Curve_With_Knots") == 0)
+          if (orientation)
             {
-              transform_vertex (info->current_transform, &x1, &y1, &z1);
-              transform_vertex (info->current_transform, &x2, &y2, &z2);
-
-              our_edge = make_edge ();
-              UNDIR_DATA (our_edge) = make_edge_info ();
-              object3d_add_edge (info->object, our_edge);
-              vertex = make_vertex3d (x1, y1, z1);
-              ODATA(our_edge) = vertex;
-              vertex = make_vertex3d (x2, y2, z2);
-              DDATA(our_edge) = vertex;
-
-              process_bscwk (curve, our_edge, info, orientation);
+              edge_info_set_round (our_edge_info, cx, cy, cz, nx, ny, nz, radius);
             }
           else
             {
-#ifdef DEBUG_NOT_IMPLEMENTED
-              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
-              if (curve->IsComplex())
-                {
-                  printf ("CURVE IS COMPLEX\n");
-                }
-#endif
-              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
-              // XXX: Various derived types of the above, e.g.:
-              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
-              continue;
+              edge_info_set_round (our_edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
             }
 
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
+        }
+      else if (curve->IsComplex() || /* This is a guess - assuming complex curves are likely to be B_SPLINE_* complexes */
+               strcmp (curve->EntityName (), "B_Spline_Curve_With_Knots") == 0)
+        {
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
+          process_bscwk (curve, our_edge, info, orientation);
         }
       else
         {
-          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
-          continue;
+          our_edge_info->is_placeholder = true;
+#ifdef DEBUG_NOT_IMPLEMENTED
+          printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+          if (curve->IsComplex())
+            {
+              printf ("CURVE IS COMPLEX\n");
+            }
+#endif
+          // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+          // XXX: Various derived types of the above, e.g.:
+          //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+          return;
         }
+
+    }
+  else
+    {
+      printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+      return;
     }
 }
 
@@ -1087,13 +1067,31 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
   return step_model;
 }
 
+static void
+debug_edge (edge_ref edge, const char *message)
+{
+  edge_ref e = edge;
+  edge_info *info;
+
+  printf ("%s\n", message);
+  info = (edge_info *)UNDIR_DATA(e);
+  printf ("e: %p (%i%s)\n", e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+  while ((e = ONEXT(e)) != edge)
+    {
+      info = (edge_info *)UNDIR_DATA(e);
+      printf ("next: %p (%i%s)\n", e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+    }
+}
+
+static int edge_no = 0;
+
 static step_model *
 process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, process_step_info *info)
 {
   step_model *step_model;
 //  object3d *object;
   GHashTable *edges_hash_set;
-  bool on_plane;
+  int face_count = 0;
 
   // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), call the specific hander
   if (strcmp (sr->EntityName (), "Shape_Representation") == 0)
@@ -1171,8 +1169,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
 
-          on_plane = false;
-
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1181,7 +1177,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
-              on_plane = true;
 //              printf ("WARNING: planar surfaces are not supported yet\n");
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
@@ -1203,13 +1198,15 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #endif
             }
 
+          info->current_face = make_face3d ((char *)"");
+          object3d_add_face (info->object, info->current_face);
+
           for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
                iter != NULL;
                iter = iter->NextNode ())
             {
               SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
 
-
 #if 0
               bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
 
@@ -1227,9 +1224,12 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #if 0
               std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
 #endif
+//              printf ("FACE LOOP\n");
               if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
                 {
                   SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
+                  edge_ref first_edge_of_contour = 0;
+                  edge_ref previous_edge_of_contour = 0;
 
                   // NB: EDGE_LOOP uses multiple inheritance from LOOP and PATH, thus needs special handling to
                   //     access the elements belonging to PATH, such as edge_list ...
@@ -1246,14 +1246,14 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                       SdaiOriented_edge *oe = (SdaiOriented_edge *)((EntityNode *)iter)->node;
                       /* XXX: Will it _always?_ be an SdaiOriented_edge? */
 
+                      edge_ref our_edge;
+
                       // NB: Stepcode does not compute derived attributes, so we need to look at the EDGE
                       //     "edge_element" referred to by the ORIENTED_EDGE, to find the start and end vertices
 
                       SdaiEdge *edge = oe->edge_element_ ();
                       bool orientation = oe->orientation_ ();
 
-                      g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(orientation ? 1 : 0));
-
                       if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
                           strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
                         {
@@ -1293,57 +1293,77 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                           continue;
                         }
 
-#if 0
-                      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
-                      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
-
-                      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
-                              edge->StepFileId (),
-                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead())->value,
-                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode())->value,
-                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value,
-                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead())->value,
-                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode())->value,
-                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value);
-
-                      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
-                        {
-                          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
-
-                          SdaiCurve *curve = ec->edge_geometry_ ();
-                          bool same_sense = ec->same_sense_ ();
-
-                          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
-
-                          if (strcmp (curve->EntityName (), "Line") == 0)
-                            {
-//                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
-//                              continue;
-                            }
-                          else if (strcmp (curve->EntityName (), "Circle") == 0)
-                            {
-//                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
-//                              continue;
-                            }
-                          else
-                            {
-                              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
-                              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
-                              // XXX: Various derived types of the above, e.g.:
-                              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
-                              continue;
-                            }
+                      our_edge = (edge_ref)g_hash_table_lookup (edges_hash_set, edge);
 
+                      if (our_edge != 0)
+                        {
+                          /* Already processed this edge (but hopefully in the other direction!) */
+//                          our_edge = SYM(our_edge);
                         }
                       else
                         {
-                          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
-                          continue;
+                          our_edge = make_edge ();
+
+                          /* Temporary debug hack */
+                          edge_info *our_edge_info = make_edge_info ();
+                          our_edge_info->edge_identifier = ++edge_no;
+                          UNDIR_DATA(our_edge) = our_edge_info;
+
+                          /* Populate edge geometry
+                           *
+                           * NB: Forcing orientation to true, so we create the "forward" direction oriented edge
+                           *     with the non'SYM'd edge pointer. This lets us spot the reversed edges correctly
+                           *     when processing / rendering. (Which we do by spotting the poitner manipulation
+                           *     done by SYM on the original make_edge() pointer
+                           */
+                          process_edge_geometry (edge, true /*orientation*/, our_edge, info);
+//                          process_edge_geometry (edge, orientation, our_edge, info);
+
+                          g_hash_table_insert (edges_hash_set, edge, (void *)our_edge);
+                        }
+
+#if 1
+                      if (!orientation)
+                        our_edge = SYM(our_edge);
+#endif
+
+                      if (first_edge_of_contour == 0)
+                        {
+                          info->current_contour = make_contour3d (our_edge);
+                          face3d_add_contour (info->current_face, info->current_contour);
+                          first_edge_of_contour = our_edge;
                         }
+
+#if 0
+                      printf ("EDGE: (%f, %f, %f)-(%f, %f, %f)\n",
+                              ((vertex3d *)ODATA(our_edge))->x,
+                              ((vertex3d *)ODATA(our_edge))->y,
+                              ((vertex3d *)ODATA(our_edge))->x,
+                              ((vertex3d *)DDATA(our_edge))->x,
+                              ((vertex3d *)DDATA(our_edge))->y,
+                              ((vertex3d *)DDATA(our_edge))->x);
 #endif
 
+                      if (previous_edge_of_contour != 0)
+                        {
+                          /* XXX: Hopefully link up the edges around this face contour */
+//                          debug_edge (our_edge, "before splice");
+//                          splice (SYM(previous_edge_of_contour), our_edge);
+                          splice (our_edge, OPREV(SYM(previous_edge_of_contour)));
+//                          splice (previous_edge_of_contour, SYM(our_edge));
+//                          debug_edge (our_edge, "after splice");
+                        }
+
+                      /* Stash reference to this edge for linking next time */
+                      previous_edge_of_contour = our_edge;
                     }
 
+                  /* XXX: Hopefully link up the edges around this face contour */
+//                  debug_edge (first_edge_of_contour, "before splice");
+//                  splice (SYM(previous_edge_of_contour), first_edge_of_contour);
+                  splice (first_edge_of_contour, OPREV(SYM(previous_edge_of_contour)));
+//                  splice (previous_edge_of_contour, SYM(first_edge_of_contour));
+//                  debug_edge (first_edge_of_contour, "after splice");
                 }
               else
                 {
@@ -1351,11 +1371,9 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
                   continue;
                 }
             }
-
+          face_count ++;
         }
 
-        process_edges (edges_hash_set, info); //object);
-
         /* Deal with edges hash set */
         g_hash_table_destroy (edges_hash_set);
     }
diff --git a/src/main.c b/src/main.c
index 7c4e95c..58c6276 100644
--- a/src/main.c
+++ b/src/main.c
@@ -77,6 +77,7 @@
 extern void stroke_init (void);
 #endif
 
+int debug_integer;
 
 /* ----------------------------------------------------------------------
  * initialize signal and error handlers
