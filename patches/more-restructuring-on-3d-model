Bottom: 8650f4763da9678f45ed3863879e1b4497004405
Top:    f39a30bad6506e0164fe17a6f59b6a809cac62be
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-18 19:36:45 +0000

More restructuring on 3D model rendering


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c9e089..ccbd5e4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -171,8 +171,12 @@ PCB_SRCS = \
 	hid/common/edge3d.h \
 	hid/common/face3d.c \
 	hid/common/face3d.h \
+	hid/common/face3d_gl.c \
+	hid/common/face3d_gl.h \
 	hid/common/object3d.c \
 	hid/common/object3d.h \
+	hid/common/object3d_gl.c \
+	hid/common/object3d_gl.h \
 	hid/common/quad.c \
 	hid/common/quad.h \
 	hid/common/step_id.h \
diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 4f2937f..e931852 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -1501,6 +1501,67 @@ bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps)
 }
 
 borast_status_t
+bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps)
+{
+  int intersections;
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
+  borast_bo_start_event_t *events;
+  borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  borast_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+  POLYAREA *pa;
+  PLINE *contour;
+
+  pa = poly;
+  do {
+    for (contour = pa->contours; contour != NULL; contour = contour->next)
+      num_events += contour->Count;
+    /* FIXME: Remove horizontal edges? */
+    break;
+  } while ((pa = pa->f) != poly);
+
+  if (unlikely (0 == num_events))
+      return BORAST_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _borast_malloc_ab_plus_c (num_events,
+                                        sizeof (borast_bo_start_event_t) +
+                                        sizeof (borast_bo_event_t *),
+                                        sizeof (borast_bo_event_t *));
+      if (unlikely (events == NULL))
+          return BORAST_STATUS_NO_MEMORY;
+
+      event_ptrs = (borast_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  poly_area_to_start_events (poly, events, event_ptrs, &i);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * borast_traps_t. */
+  _borast_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                               num_events,
+                                               traps,
+                                               &intersections);
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return BORAST_STATUS_SUCCESS;
+}
+
+borast_status_t
 bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index a98cda1..c794ae8 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -5,8 +5,31 @@
 #include "quad.h"
 #include "contour3d.h"
 #include "appearance.h"
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
 #include "face3d.h"
 
+#define MEMCPY_VERTEX_DATA
+
 face3d *
 make_face3d (char *name)
 {
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index ddec03f..770792f 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,5 +1,9 @@
 typedef struct {
+  double ox, oy, oz;
+  double rx, ry, rz;
+
   double nx, ny, nz; /* Face normal?*/
+
   bool surface_orientation_reversed;
   GList *contours;
   char *name;
@@ -16,6 +20,10 @@ typedef struct {
   step_id surface_identifier;
   step_id face_identifier;
   step_id face_bound_identifier;
+
+  /* Rendering cache */
+  int tristrip_num_vertices;
+  float *tristrip_vertices;
 } face3d;
 
 face3d *make_face3d (char *name);
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
new file mode 100644
index 0000000..019304b
--- /dev/null
+++ b/src/hid/common/face3d_gl.c
@@ -0,0 +1,440 @@
+#include <glib.h>
+#include <stdbool.h>
+
+#include "step_id.h"
+#include "quad.h"
+#include "edge3d.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+
+#include "data.h"
+#include "hid.h"
+#include "sweep.h"
+#include "polygon.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
+#include "face3d.h"
+#include "face3d_gl.h"
+
+//#define MEMCPY_VERTEX_DATA
+
+#define CIRC_SEGS_D 64.0
+
+static void
+plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *u = (x - face->ox) * face->rx +
+       (y - face->oy) * face->ry +
+       (z - face->oz) * face->rz;
+
+  *v = (x - face->ox) * ortx +
+       (y - face->oy) * orty +
+       (z - face->oz) * ortz;
+}
+
+static void
+plane_uv_to_xyz (face3d *face, float u, float v, float *x, float *y, float *z)
+{
+  float ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + u * face->rx + v * ortx);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + u * face->ry + v * orty);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + u * face->rz + v * ortz);
+}
+
+static void
+ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  Vector p_v;
+  VNODE *node;
+  PLINE *p_contour = NULL;
+  POLYAREA *poly;
+  borast_traps_t traps;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  if (face->is_cylindrical)
+    return;
+
+//  if (face->is_b_spline)
+//    return;
+
+  /* Outer contour */ /* XXX: NOT ALWAYS IT WOULD SEEM! */
+//  contour = &ace->contours->data;
+
+  poly = poly_Create ();
+  if (poly == NULL)
+    return;
+
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+      bool hole = false; /* XXX ??? */
+
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          double ex, ey, ez;
+          double x, y, z;
+          float u, v;
+
+          ex = ((vertex3d *)DDATA(e))->x;
+          ey = ((vertex3d *)DDATA(e))->y;
+          ez = ((vertex3d *)DDATA(e))->z;
+
+          if (info->is_round)
+            {
+              int i;
+              double sx, sy, sz;
+              double cx, cy, cz;
+              double nx, ny, nz;
+              double refx, refy, refz;
+              double endx, endy, endz;
+              double ortx, orty, ortz;
+              double cosa, sina;
+              double recip_length;
+              double da;
+              int segs;
+              double angle_step;
+
+              sx = ((vertex3d *)ODATA(e))->x;
+              sy = ((vertex3d *)ODATA(e))->y;
+              sz = ((vertex3d *)ODATA(e))->z;
+
+              cx = ((edge_info *)UNDIR_DATA(e))->cx;
+              cy = ((edge_info *)UNDIR_DATA(e))->cy;
+              cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+              nx = ((edge_info *)UNDIR_DATA(e))->nx;
+              ny = ((edge_info *)UNDIR_DATA(e))->ny;
+              nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+              /* XXX: Do this without breaking abstraction? */
+              /* Detect SYM edges, reverse the circle normal */
+              if ((e & 2) == 2)
+                {
+                  nx = -nx;
+                  ny = -ny;
+                  nz = -nz;
+                }
+
+              /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+               * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+               */
+              refx = sx - cx;
+              refy = sy - cy;
+              refz = sz - cz;
+
+              /* Normalise refx */
+              recip_length = 1. / hypot (hypot (refx, refy), refz);
+              refx *= recip_length;
+              refy *= recip_length;
+              refz *= recip_length;
+
+              endx = ex - cx;
+              endy = ey - cy;
+              endz = ez - cz;
+
+              /* Normalise endx */
+              recip_length = 1. / hypot (hypot (endx, endy), endz);
+              endx *= recip_length;
+              endy *= recip_length;
+              endz *= recip_length;
+
+              /* ref cross normal */
+              /* ort will be orthogonal to normal and ref vector */
+              ortx = ny * refz - nz * refy;
+              orty = nz * refx - nx * refz;
+              ortz = nx * refy - ny * refx;
+
+              /* Cosine is dot product of ref (normalised) and end (normalised) */
+              cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+              /* Sine is dot product of ort (normalised) and end (normalised) */
+              sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+              if (sx == ex &&
+                  sy == ey &&
+                  sz == ez)
+                {
+                  da = 2.0 * M_PI;
+                }
+              else
+                {
+                  /* Delta angled */
+                  da = atan2 (sina, cosa);
+
+                  if (da < 0.0)
+                    da += 2.0 * M_PI;
+                }
+
+              /* Scale up ref and ort to the actual vector length */
+              refx *= info->radius;
+              refy *= info->radius;
+              refz *= info->radius;
+
+              ortx *= info->radius;
+              orty *= info->radius;
+              ortz *= info->radius;
+
+              segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+              segs = MAX(segs, 1);
+              angle_step = da / (double)segs;
+
+              for (i = 0; i < segs; i++)
+                {
+                  cosa = cos ((i + 1) * angle_step);
+                  sina = sin ((i + 1) * angle_step);
+                  x = info->cx + refx * cosa + ortx * sina;
+                  y = info->cy + refy * cosa + orty * sina;
+                  z = info->cz + refz * cosa + ortz * sina;
+
+                  plane_xyz_to_uv (face, x, y, z, &u, &v);
+
+                  /* XXX: Arbitrary scaling from parameter space to coords, assuming parameter space approx mm (which is likely wrong */
+                  p_v[0] = MM_TO_COORD (u);
+                  p_v[1] = MM_TO_COORD (v);
+                  node = poly_CreateNode (p_v);
+
+                  if (p_contour == NULL)
+                    {
+                      if ((p_contour = poly_NewContour (node)) == NULL)
+                        return;
+                    }
+                  else
+                    {
+                      poly_InclVertex (p_contour->head.prev, node);
+                    }
+                }
+            }
+          else
+            {
+              /* Straight line case */
+              plane_xyz_to_uv (face, ex, ey, ez, &u, &v);
+
+              /* XXX: Arbitrary scaling from parameter space to coords, assuming parameter space approx mm (which is likely wrong */
+              p_v[0] = MM_TO_COORD (u);
+              p_v[1] = MM_TO_COORD (v);
+              node = poly_CreateNode (p_v);
+
+              if (p_contour == NULL)
+                {
+                  if ((p_contour = poly_NewContour (node)) == NULL)
+                    return;
+                }
+              else
+                {
+                  poly_InclVertex (p_contour->head.prev, node);
+                }
+            }
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      poly_PreContour (p_contour, FALSE);
+
+      /* make sure it is a positive contour (outer) or negative (hole) */
+      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+        poly_InvContour (p_contour);
+
+      poly_InclContour (poly, p_contour);
+      contour = NULL;
+
+    }
+
+  /* XXX: Need to tesselate the polygon */
+  _borast_traps_init (&traps);
+  bo_poly_to_traps_no_draw (poly, &traps);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5; /* Three vertices + repeated start and end */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  if (num_uv_points == 0) {
+//    printf ("Strange, contour didn't tesselate\n");
+    return;
+  }
+
+  printf ("Tesselated with %i uv points\n", num_uv_points);
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, 3 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      plane_uv_to_xyz(face,
+                      COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                      COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                      &face->tristrip_vertices[vertex_comp + 0],
+                      &face->tristrip_vertices[vertex_comp + 1],
+                      &face->tristrip_vertices[vertex_comp + 2]);
+      vertex_comp += 3;
+    }
+}
+
+void
+face3d_fill(hidGC gc, face3d *face, bool selected)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+#ifdef MEMCPY_VERTEX_DATA
+  hidgl_priv *priv = hidgl->priv;
+#endif
+  int i;
+  int vertex_comp;
+
+  if (selected)
+    hidgl_flush_triangles (hidgl);
+
+  ensure_tristrip (face);
+
+//  glColor4f (1.0f, 0.0f, 0.0f, 0.3f);
+  glColor4f (1.0f, 0.0f, 0.0f, 1.0f);
+
+  hidgl_ensure_vertex_space (gc, face->tristrip_num_vertices);
+
+#ifdef MEMCPY_VERTEX_DATA
+  memcpy (&priv->buffer.triangle_array[priv->buffer.coord_comp_count],
+          face->tristrip_vertices,
+          sizeof (float) * 5 * face->tristrip_num_vertices);
+  priv->buffer.coord_comp_count += 5 * face->tristrip_num_vertices;
+  priv->buffer.vertex_count += face->tristrip_num_vertices;
+
+#else
+  vertex_comp = 0;
+  for (i = 0; i < face->tristrip_num_vertices; i++) {
+    float x, y, z;
+    x = face->tristrip_vertices[vertex_comp++];
+    y = face->tristrip_vertices[vertex_comp++];
+    z = face->tristrip_vertices[vertex_comp++];
+    hidgl_add_vertex_3D_tex (gc, x, y, z, 0.0, 0.0);
+  }
+#endif
+
+  hidgl_flush_triangles (hidgl);
+}
diff --git a/src/hid/common/face3d_gl.h b/src/hid/common/face3d_gl.h
new file mode 100644
index 0000000..f3599c8
--- /dev/null
+++ b/src/hid/common/face3d_gl.h
@@ -0,0 +1 @@
+void face3d_fill (hidGC gc, face3d *face, bool selected);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index a90a51e..51990bc 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -74,7 +74,6 @@
 #   include <GL/gl.h>
 #endif
 
-
 static Coord board_thickness;
 #define HACK_BOARD_THICKNESS board_thickness
 //#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
@@ -83,14 +82,6 @@ static Coord board_thickness;
 #define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
 #define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
 
-static GList *object3d_test_objects = NULL;
-
-void
-object3d_test_init (void)
-{
-  object3d_test_objects = object3d_from_board_outline ();
-}
-
 object3d *
 make_object3d (char *name)
 {
@@ -139,348 +130,6 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
-                       {1., 1., 0.},
-                       {0., 1., 0.},
-                       {0., 1., 1.},
-                       {0.5, 0., 0.},
-                       {0.5, 0.5, 0.},
-                       {0., 0.5, 0.},
-                       {0., 0.5, 0.5},
-                       {1., 0.5, 0.5},
-                       {1., 1., 0.5},
-                       {0.5, 1., 0.5},
-                       {0.5, 1., 1.}};
-
-
-#define CIRC_SEGS_D 64.0
-
-
-static void
-evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
-{
-//  info->
-}
-
-static void
-draw_bspline (edge_ref e)
-{
-  edge_info *info = UNDIR_DATA(e);
-  double x1, y1, z1;
-  double x2, y2, z2;
-  double lx, ly, lz;
-  double x, y, z;
-  int i;
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  glBegin (GL_LINES);
-
-#if 0
-  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-#endif
-
-  /* Just draw the control points for now... */
-  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      x = info->control_points[i * 3 + 0];
-      y = info->control_points[i * 3 + 1];
-      z = info->control_points[i * 3 + 2];
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-
-  glEnd ();
-}
-
-static void
-draw_quad_edge (edge_ref e, void *data)
-{
-  double x1, y1, z1;
-  double x2, y2, z2;
-  int i;
-  bool debug = GPOINTER_TO_INT (data);
-
-#if 0
-  int id = ID(e) % 12;
-
-  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
-#else
-  glColor4f (1., 1., 1., 0.3);
-#endif
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  if (UNDIR_DATA(e) != NULL)
-    {
-      edge_info *info = UNDIR_DATA(e);
-
-
-//        if (info->is_placeholder)
-        if (debug)
-          {
-            glColor4f (1.0, 0.0, 0.0, 1.0);
-            glDepthMask (TRUE);
-          }
-
-//      if (info->is_stitch)
-//        return;
-
-      if (info->is_bspline)
-        {
-          draw_bspline (e);
-          return;
-        }
-
-      if (info->is_round)
-        {
-          int i;
-          double cx, cy, cz;
-          double nx, ny, nz;
-          double refx, refy, refz;
-          double endx, endy, endz;
-          double ortx, orty, ortz;
-          double cosa;
-          double sina;
-          double recip_length;
-          double da;
-          int segs;
-          double angle_step;
-
-          cx = ((edge_info *)UNDIR_DATA(e))->cx;
-          cy = ((edge_info *)UNDIR_DATA(e))->cy;
-          cz = ((edge_info *)UNDIR_DATA(e))->cz;
-
-          nx = ((edge_info *)UNDIR_DATA(e))->nx;
-          ny = ((edge_info *)UNDIR_DATA(e))->ny;
-          nz = ((edge_info *)UNDIR_DATA(e))->nz;
-
-          /* XXX: Do this without breaking abstraction? */
-          /* Detect SYM edges, reverse the circle normal */
-          if ((e & 2) == 2)
-            {
-#if 0
-              /* Option 1, just draw the forward copy, which agrees with the normal */
-              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
-              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
-              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
-
-              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
-              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
-              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
-#else
-              /* Option 2, flip the normal */
-              nx = -nx;
-              ny = -ny;
-              nz = -nz;
-#endif
-            }
-
-          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
-           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
-           */
-          refx = x1 - cx;
-          refy = y1 - cy;
-          refz = z1 - cz;
-
-          /* Normalise refx */
-          recip_length = 1. / hypot (hypot (refx, refy), refz);
-          refx *= recip_length;
-          refy *= recip_length;
-          refz *= recip_length;
-
-          endx = x2 - cx;
-          endy = y2 - cy;
-          endz = z2 - cz;
-
-          /* Normalise endx */
-          recip_length = 1. / hypot (hypot (endx, endy), endz);
-          endx *= recip_length;
-          endy *= recip_length;
-          endz *= recip_length;
-
-          /* ref cross normal */
-          /* ort will be orthogonal to normal and ref vector */
-          ortx = ny * refz - nz * refy;
-          orty = nz * refx - nx * refz;
-          ortz = nx * refy - ny * refx;
-
-          /* Cosine is dot product of ref (normalised) and end (normalised) */
-          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
-          /* Sine is dot product of ort (normalised) and end (normalised) */
-          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
-
-          if (x1 == x2 &&
-              y1 == y2 &&
-              z1 == z2)
-            {
-              da = 2.0 * M_PI;
-            }
-          else
-            {
-              /* Delta angled */
-              da = atan2 (sina, cosa);
-
-              if (da < 0.0)
-                da += 2.0 * M_PI;
-            }
-
-#if 0
-          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
-          printf ("end (%f, %f, %f)\n", endx, endy, endz);
-          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
-          printf ("n (%f, %f, %f)\n", nx, ny, nz);
-          printf ("cosa %f, sina %f\n", cosa, sina);
-          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
-#endif
-
-          /* Scale up ref and ort to the actual vector length */
-          refx *= info->radius;
-          refy *= info->radius;
-          refz *= info->radius;
-
-          ortx *= info->radius;
-          orty *= info->radius;
-          ortz *= info->radius;
-
-          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
-          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
-          segs = MAX(segs, 1);
-          angle_step = da / (double)segs;
-
-          glBegin (GL_LINES);
-
-          for (i = 0; i < segs; i++)
-            {
-              cosa = cos (i * angle_step);
-              sina = sin (i * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-
-              cosa = cos ((i + 1) * angle_step);
-              sina = sin ((i + 1) * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-            }
-
-          glEnd ();
-
-          glDepthMask (FALSE);
-          return;
-        }
-    }
-
-//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-  glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, x1),
-              STEP_Y_TO_COORD (PCB, y1),
-              STEP_X_TO_COORD (PCB, z1));
-  glVertex3f (STEP_X_TO_COORD (PCB, x2),
-              STEP_Y_TO_COORD (PCB, y2),
-              STEP_X_TO_COORD (PCB, z2));
-  glEnd ();
-  glDepthMask (FALSE);
-}
-
-static void
-draw_contour (contour3d *contour, void *data)
-{
-  edge_ref e;
-  bool debug = GPOINTER_TO_INT (data);
-  int edge_no = 0;
-
-  e = contour->first_edge;
-
-//  printf ("Drawing contour\n");
-
-  do
-    {
-      edge_info *info = UNDIR_DATA(e);
-//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
-      draw_quad_edge (e, data);
-
-      /* Stop if e was the only edge in a face - which we re-trace */
-      /* XXX: Probably only a development bug until we get the quad-edge links correct */
-//      if (LNEXT(e) == SYM(e))
-//        break;
-
-      /* LNEXT should take us counter-clockwise around the face */
-      /* LPREV should take us clockwise around the face */
-    }
-  while ((e = LNEXT(e)) != contour->first_edge);
-}
-
-static int face_no;
-
-static void
-draw_face (face3d *face, void *data)
-{
-//  if (face->contours != NULL)
-//      draw_contour (face->contours->data, NULL);
-//  printf ("Drawing face\n");
-  g_list_foreach (face->contours, (GFunc)draw_contour, GINT_TO_POINTER(face_no == debug_integer));
-
-  face_no++;
-}
-
-void
-object3d_draw (object3d *object)
-{
-  g_return_if_fail (object->edges != NULL);
-
-//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
-//  printf ("BEGIN DRAW...\n");
-//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
-
-//  printf ("\nDrawing object\n");
-
-  face_no = 0;
-
-  g_list_foreach (object->faces, (GFunc)draw_face, NULL);
-
-//  printf ("....ENDED\n");
-}
-
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
-{
-  object3d_draw (object);
-}
-
-void
-object3d_draw_debug (void)
-{
-  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, NULL);
-}
-
 /*********************************************************************************************************/
 
 static int
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 3d228f6..4689664 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -8,9 +8,6 @@ typedef struct {
   void *user_data;
 } object3d;
 
-void object3d_test_init (void);
-void object3d_draw (object3d *object);
-void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
 void object3d_set_appearance (object3d *object, appearance *appear);
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
new file mode 100644
index 0000000..421cfb0
--- /dev/null
+++ b/src/hid/common/object3d_gl.c
@@ -0,0 +1,485 @@
+/* TODO ITEMS:
+ *
+ * Add PLINE simplification operation to consolidate co-circular segments for reduced geometry output.
+ * Look at whether arc-* intersections can be re-constructed back to original geometry, not fall back to line-line.
+ * Work on snap-rounding any edge which passes through the pixel square containing an any vertex (or intersection).
+ * Avoid self-touching output in contours, where that self-touching instance creates two otherwise distinct contours or holes.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#include <glib.h>
+
+#include "data.h"
+#include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+#include "face3d.h"
+#include "edge3d.h"
+#include "object3d.h"
+#include "polygon.h"
+#include "rats.h"
+
+#include "rtree.h"
+#include "rotate.h"
+
+#include "pcb-printf.h"
+#include "misc.h"
+#include "hid/hidint.h"
+
+#define PERFECT_ROUND_CONTOURS
+#define SUM_PINS_VIAS_ONCE
+#define HASH_OBJECTS
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "hid_draw.h"
+#include "hidgl.h"
+#include "face3d_gl.h"
+#include "object3d_gl.h"
+
+//static Coord board_thickness;
+#define HACK_BOARD_THICKNESS board_thickness
+//#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
+#define HACK_COPPER_THICKNESS MM_TO_COORD(0.035)
+#define HACK_PLATED_BARREL_THICKNESS MM_TO_COORD(0.08)
+#define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
+#define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
+
+static GList *object3d_test_objects = NULL;
+
+void
+object3d_test_init (void)
+{
+  object3d_test_objects = object3d_from_board_outline ();
+}
+
+float colors[12][3] = {{1., 0., 0.},
+                       {1., 1., 0.},
+                       {0., 1., 0.},
+                       {0., 1., 1.},
+                       {0.5, 0., 0.},
+                       {0.5, 0.5, 0.},
+                       {0., 0.5, 0.},
+                       {0., 0.5, 0.5},
+                       {1., 0.5, 0.5},
+                       {1., 1., 0.5},
+                       {0.5, 1., 0.5},
+                       {0.5, 1., 1.}};
+
+
+#define CIRC_SEGS_D 64.0
+
+
+struct draw_info {
+  hidGC gc;
+  bool selected;
+  bool debug_face;
+};
+
+
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+
+static void
+draw_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double lx, ly, lz;
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+  glBegin (GL_LINES);
+
+#if 0
+  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+#endif
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      x = info->control_points[i * 3 + 0];
+      y = info->control_points[i * 3 + 1];
+      z = info->control_points[i * 3 + 2];
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+
+  glEnd ();
+}
+
+static void
+draw_quad_edge (edge_ref e, void *data)
+{
+  struct draw_info *d_info = data;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  int i;
+  bool debug = GPOINTER_TO_INT (data);
+
+#if 0
+  int id = ID(e) % 12;
+
+  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
+#else
+  if (d_info->selected)
+    glColor4f (0.0, 1.0, 1., 0.5);
+  else
+    glColor4f (1., 1., 1., 0.3);
+#endif
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  if (UNDIR_DATA(e) != NULL)
+    {
+      edge_info *info = UNDIR_DATA(e);
+
+
+//        if (info->is_placeholder)
+        if (d_info->debug_face)
+          {
+            glColor4f (1.0, 0.0, 0.0, 1.0);
+            glDepthMask (TRUE);
+          }
+
+//      if (info->is_stitch)
+//        return;
+
+      if (info->is_bspline)
+        {
+          draw_bspline (e);
+          return;
+        }
+
+      if (info->is_round)
+        {
+          int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          if ((e & 2) == 2)
+            {
+#if 0
+              /* Option 1, just draw the forward copy, which agrees with the normal */
+              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
+              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
+              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
+
+              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
+              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
+              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
+#else
+              /* Option 2, flip the normal */
+              nx = -nx;
+              ny = -ny;
+              nz = -nz;
+#endif
+            }
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
+          glBegin (GL_LINES);
+
+          for (i = 0; i < segs; i++)
+            {
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+            }
+
+          glEnd ();
+
+//          glDepthMask (FALSE);
+          return;
+        }
+    }
+
+//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+  glBegin (GL_LINES);
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
+  glEnd ();
+//  glDepthMask (FALSE);
+}
+
+static void
+draw_contour (contour3d *contour, void *data)
+{
+//  struct draw_info *info = data;
+  edge_ref e;
+  int edge_no = 0;
+
+  e = contour->first_edge;
+
+//  printf ("Drawing contour\n");
+
+  do
+    {
+      edge_info *info = UNDIR_DATA(e);
+//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+      draw_quad_edge (e, data);
+
+      /* Stop if e was the only edge in a face - which we re-trace */
+      /* XXX: Probably only a development bug until we get the quad-edge links correct */
+//      if (LNEXT(e) == SYM(e))
+//        break;
+
+      /* LNEXT should take us counter-clockwise around the face */
+      /* LPREV should take us clockwise around the face */
+    }
+  while ((e = LNEXT(e)) != contour->first_edge);
+}
+
+static int face_no;
+
+static void
+draw_face_edges (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  info->debug_face = (face_no == debug_integer);
+  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+static void
+draw_face (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  face3d_fill (info->gc, face, info->selected);
+
+//  info->debug_face = (face_no == debug_integer);
+//
+//  return;
+//
+//  if (face->contours != NULL)
+//      draw_contour (face->contours->data, info);
+//  printf ("Drawing face\n");
+//  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+void
+object3d_draw (hidGC gc, object3d *object, bool selected)
+{
+  struct draw_info info;
+
+//  hidglGC hidgl_gc = (hidglGC)gc;
+//  hidgl_instance *hidgl = hidgl_gc->hidgl;
+//  hidgl_priv *priv = hidgl->priv;
+
+  g_return_if_fail (object->edges != NULL);
+
+  info.gc = gc;
+  info.selected = selected;
+
+//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
+//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+
+//  printf ("\nDrawing object\n");
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face_edges, &info);
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face, &info);
+
+//  printf ("....ENDED\n");
+}
+
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  hidGC gc = user_data;
+
+  object3d_draw (gc, object, false);
+}
+
+void
+object3d_draw_debug (hidGC gc)
+{
+  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, gc);
+}
diff --git a/src/hid/common/object3d_gl.h b/src/hid/common/object3d_gl.h
new file mode 100644
index 0000000..cbf5d1a
--- /dev/null
+++ b/src/hid/common/object3d_gl.h
@@ -0,0 +1,3 @@
+void object3d_test_init (void);
+void object3d_draw (hidGC gc, object3d *object, bool selected);
+void object3d_draw_debug (hidGC gc);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fce8341..0e78d54 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -54,6 +54,8 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #include "hid/common/draw_helpers.h"
 #include "hid/common/trackball.h"
 
+#include "hid/common/object3d_gl.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -2117,7 +2119,7 @@ via_hole_cyl_callback (const BoxType * b, void *cl)
 }
 
 static void
-hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
+hidgl_draw_step_model_instance (struct assembly_model_instance *instance, bool selected)
 {
   render_priv *priv = gport->render_priv;
   step_model *step_model = instance->model->step_model;
@@ -2177,7 +2179,7 @@ hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
                 -STEP_TO_COORD_Y (PCB, step_model->oy),
                 -STEP_TO_COORD_Z (PCB, step_model->oz));
 
-  object3d_draw (step_model->object);
+  object3d_draw (Output.fgGC, step_model->object, selected);
 
   hidgl_flush_triangles (priv->hidgl);
 
@@ -2195,7 +2197,7 @@ E_package_callback (const BoxType * b, void *cl)
 
   if (element->assembly_model_instance != NULL)
     {
-      hidgl_draw_step_model_instance (element->assembly_model_instance);
+      hidgl_draw_step_model_instance (element->assembly_model_instance, TEST_FLAG (SELECTEDFLAG, element));
     }
 
   if (FRONT (element))
@@ -2784,7 +2786,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDepthFunc (GL_LESS);
   glDisable (GL_STENCIL_TEST);
 
-  glEnable (GL_CULL_FACE);
+//  glEnable (GL_CULL_FACE); /* XXX: Fix model face filling */
   glCullFace (GL_BACK);
 
   if (1) {
@@ -2821,7 +2823,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
 //  glDisable (GL_DEPTH_TEST); /* TEST */
-  glDepthMask (FALSE); /* TEST */
+//  glDepthMask (FALSE); /* TEST */
 
   if (!global_view_2d)
     ghid_draw_packages (&region);
@@ -2835,9 +2837,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-  //object3d_draw_debug ();
+  //object3d_draw_debug (Output.fgGC);
   if (step_read_test != NULL)
-    object3d_draw (step_read_test);
+    object3d_draw (Output.fgGC, step_read_test, false);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 35c5072..677483b 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -189,6 +189,23 @@ find_mapped_item (SdaiShape_representation *sr,
     }
 }
 
+static void
+unpack_axis_geom (SdaiAxis2_placement_3d *axis,
+                  double *ox, double *oy, double *oz,
+                  double *ax, double *ay, double *az,
+                  double *rx, double *ry, double *rz)
+{
+  *ox = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ())->value;
+  *oy = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+  *oz = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *ax = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ay = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *az = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *rx = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ry = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *rz = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+}
+
 typedef struct process_step_info {
   /* Hash / list of SR -> step_model */
   object3d *object;
@@ -994,15 +1011,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("child axis o: (%f, %f, %f)\n"
@@ -1019,15 +1028,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
       /* Is this in the correct order? */
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("parent axis o: (%f, %f, %f)\n"
@@ -1169,6 +1170,9 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
 
+          info->current_face = make_face3d ((char *)"");
+          object3d_add_face (info->object, info->current_face);
+
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1177,11 +1181,42 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
+              SdaiPlane *plane = dynamic_cast<SdaiPlane *>(surface);
+
 //              printf ("WARNING: planar surfaces are not supported yet\n");
+
+              unpack_axis_geom (plane->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->nx = info->current_face->ax;
+              info->current_face->ny = info->current_face->ay;
+              info->current_face->nz = info->current_face->az;
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
+              SdaiCylindrical_surface *cylinder = dynamic_cast<SdaiCylindrical_surface *>(surface);
 //              printf ("WARNING: cylindrical suraces are not supported yet\n");
+
+              unpack_axis_geom (cylinder->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->radius = cylinder->radius_ ();
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
             {
@@ -1198,9 +1233,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #endif
             }
 
-          info->current_face = make_face3d ((char *)"");
-          object3d_add_face (info->object, info->current_face);
-
           for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
                iter != NULL;
                iter = iter->NextNode ())
@@ -1441,29 +1473,13 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       /* XXX: Looking only at the target vector.. need to find some examples where the parent transform coordinate system is not unity to get this correct */
       rotate_basis (info->current_transform, ax, ay, az, rx, ry, rz);
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       translate_origin (info->current_transform, -ox, -oy, -oz);
       rotate_basis_inverted (info->current_transform, ax, ay, az, rx, ry, rz);
diff --git a/src/sweep.h b/src/sweep.h
index e8f138f..644d70b 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,6 +1,7 @@
 #include "borast/borast-traps-private.h"
 
 borast_status_t bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps);
+borast_status_t bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps);
 borast_fixed_t _line_compute_intersection_x_for_y (const borast_line_t *line, borast_fixed_t y);
