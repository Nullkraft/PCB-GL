Bottom: 8650f4763da9678f45ed3863879e1b4497004405
Top:    2efee406972982673daeaa8182f66569bd73d2dd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-18 19:36:45 +0000

More restructuring on 3D model rendering


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c9e089..ccbd5e4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -171,8 +171,12 @@ PCB_SRCS = \
 	hid/common/edge3d.h \
 	hid/common/face3d.c \
 	hid/common/face3d.h \
+	hid/common/face3d_gl.c \
+	hid/common/face3d_gl.h \
 	hid/common/object3d.c \
 	hid/common/object3d.h \
+	hid/common/object3d_gl.c \
+	hid/common/object3d_gl.h \
 	hid/common/quad.c \
 	hid/common/quad.h \
 	hid/common/step_id.h \
diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 4f2937f..e931852 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -1501,6 +1501,67 @@ bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps)
 }
 
 borast_status_t
+bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps)
+{
+  int intersections;
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
+  borast_bo_start_event_t *events;
+  borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  borast_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+  POLYAREA *pa;
+  PLINE *contour;
+
+  pa = poly;
+  do {
+    for (contour = pa->contours; contour != NULL; contour = contour->next)
+      num_events += contour->Count;
+    /* FIXME: Remove horizontal edges? */
+    break;
+  } while ((pa = pa->f) != poly);
+
+  if (unlikely (0 == num_events))
+      return BORAST_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _borast_malloc_ab_plus_c (num_events,
+                                        sizeof (borast_bo_start_event_t) +
+                                        sizeof (borast_bo_event_t *),
+                                        sizeof (borast_bo_event_t *));
+      if (unlikely (events == NULL))
+          return BORAST_STATUS_NO_MEMORY;
+
+      event_ptrs = (borast_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  poly_area_to_start_events (poly, events, event_ptrs, &i);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * borast_traps_t. */
+  _borast_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                               num_events,
+                                               traps,
+                                               &intersections);
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return BORAST_STATUS_SUCCESS;
+}
+
+borast_status_t
 bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index ebcdc08..11b6579 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,9 +1,17 @@
 #include <glib.h>
+#include <stdint.h>
 #include <stdbool.h>
 
+#include <math.h>
+
 #include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
 #include "edge3d.h"
 
+#define CIRC_SEGS_D 64.0
+
+
 edge_info *
 make_edge_info (void)
 {
@@ -37,3 +45,240 @@ destroy_edge_info (edge_info *info)
 {
   g_slice_free (edge_info, info);
 }
+
+static void
+allocate_linearised_vertices (edge_ref e, int num_vertices)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->num_linearised_vertices = 0;
+  info->linearised_vertices = g_new0 (float, 3 * num_vertices);
+}
+
+static void
+add_vertex (edge_ref e, float x, float y, float z)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 0] = x;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 1] = y;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 2] = z;
+
+  info->num_linearised_vertices++;
+}
+
+#if 0
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+#endif
+
+static void
+sample_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+#if 0
+  for (i = 0; i < 20; i++)
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      add_vertex (x, y, z);
+    }
+#endif
+
+  allocate_linearised_vertices (e, info->num_control_points);
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++)
+    {
+      x = info->control_points[i * 3 + 0];
+      y = info->control_points[i * 3 + 1];
+      z = info->control_points[i * 3 + 2];
+
+      add_vertex (e, x, y, z);
+    }
+}
+
+static void
+sample_circle (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+  int i;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  double cx, cy, cz;
+  double nx, ny, nz;
+  double refx, refy, refz;
+  double endx, endy, endz;
+  double ortx, orty, ortz;
+  double cosa;
+  double sina;
+  double recip_length;
+  double da;
+  int segs;
+  double angle_step;
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  cx = ((edge_info *)UNDIR_DATA(e))->cx;
+  cy = ((edge_info *)UNDIR_DATA(e))->cy;
+  cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+  nx = ((edge_info *)UNDIR_DATA(e))->nx;
+  ny = ((edge_info *)UNDIR_DATA(e))->ny;
+  nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+  /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+   * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+   */
+  refx = x1 - cx;
+  refy = y1 - cy;
+  refz = z1 - cz;
+
+  /* Normalise refx */
+  recip_length = 1. / hypot (hypot (refx, refy), refz);
+  refx *= recip_length;
+  refy *= recip_length;
+  refz *= recip_length;
+
+  endx = x2 - cx;
+  endy = y2 - cy;
+  endz = z2 - cz;
+
+  /* Normalise endx */
+  recip_length = 1. / hypot (hypot (endx, endy), endz);
+  endx *= recip_length;
+  endy *= recip_length;
+  endz *= recip_length;
+
+  /* ref cross normal */
+  /* ort will be orthogonal to normal and ref vector */
+  ortx = ny * refz - nz * refy;
+  orty = nz * refx - nx * refz;
+  ortz = nx * refy - ny * refx;
+
+  /* Cosine is dot product of ref (normalised) and end (normalised) */
+  cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and end (normalised) */
+  sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+  if (x1 == x2 &&
+      y1 == y2 &&
+      z1 == z2)
+    {
+      da = 2.0 * M_PI;
+    }
+  else
+    {
+      /* Delta angled */
+      da = atan2 (sina, cosa);
+
+      if (da < 0.0)
+        da += 2.0 * M_PI;
+    }
+
+  /* Scale up ref and ort to the actual vector length */
+  refx *= info->radius;
+  refy *= info->radius;
+  refz *= info->radius;
+
+  ortx *= info->radius;
+  orty *= info->radius;
+  ortz *= info->radius;
+
+  segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+  segs = MAX(segs, 1);
+  angle_step = da / (double)segs;
+
+  allocate_linearised_vertices (e, segs + 1);
+
+  for (i = 0; i <= segs; i++)
+    {
+      cosa = cos (i * angle_step);
+      sina = sin (i * angle_step);
+      add_vertex (e, info->cx + refx * cosa + ortx * sina,
+                     info->cy + refy * cosa + orty * sina,
+                     info->cz + refz * cosa + ortz * sina);
+    }
+
+}
+
+static void
+sample_line (edge_ref e)
+{
+  double x, y, z;
+
+  allocate_linearised_vertices (e, 2);
+
+  x = ((vertex3d *)ODATA(e))->x;
+  y = ((vertex3d *)ODATA(e))->y;
+  z = ((vertex3d *)ODATA(e))->z;
+
+  add_vertex (e, x, y, z);
+
+  x = ((vertex3d *)DDATA(e))->x;
+  y = ((vertex3d *)DDATA(e))->y;
+  z = ((vertex3d *)DDATA(e))->z;
+
+  add_vertex (e, x, y, z);
+  /* Leave end-point */
+}
+
+void
+edge_ensure_linearised (edge_ref edge)
+{
+  edge_info *info;
+
+  /* Ensure we're looking at the forward edge */
+  edge &= (uintptr_t) ~3;
+
+  info = UNDIR_DATA(edge);
+
+  /* Already cached, nothing to do */
+  if (info->linearised_vertices != NULL)
+    return;
+
+  /* Can't do anything if we don't have the edge_info data */
+  if (info == NULL)
+    return;
+
+  if (info->is_bspline)
+    {
+      sample_bspline (edge);
+      return;
+    }
+
+  if (info->is_round)
+    {
+      sample_circle (edge);
+      return;
+    }
+
+  /* Must be linear */
+  sample_line (edge);
+}
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 7b26668..b77b835 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -30,9 +30,15 @@ typedef struct
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
   step_id edge_identifier;
+
+
+  /* Rendering data */
+  int num_linearised_vertices;
+  float *linearised_vertices; /* NB: Does not include the start_point */
 } edge_info;
 
 edge_info *make_edge_info (void);
 void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
+void edge_ensure_linearised (edge_ref edge);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index a98cda1..c794ae8 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -5,8 +5,31 @@
 #include "quad.h"
 #include "contour3d.h"
 #include "appearance.h"
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
 #include "face3d.h"
 
+#define MEMCPY_VERTEX_DATA
+
 face3d *
 make_face3d (char *name)
 {
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index ddec03f..f690587 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,9 +1,15 @@
 typedef struct {
+  double ox, oy, oz;
+  double rx, ry, rz;
+
   double nx, ny, nz; /* Face normal?*/
+
   bool surface_orientation_reversed;
   GList *contours;
   char *name;
 
+  bool is_planar;
+
   /* For cylindrical surfaces */
   bool is_cylindrical;
   double cx, cy, cz; /* A point on the axis */
@@ -16,6 +22,11 @@ typedef struct {
   step_id surface_identifier;
   step_id face_identifier;
   step_id face_bound_identifier;
+
+  /* Rendering cache */
+  int tristrip_num_vertices;
+  float *tristrip_vertices;
+  bool triangulate_failed;
 } face3d;
 
 face3d *make_face3d (char *name);
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
new file mode 100644
index 0000000..5b7f925
--- /dev/null
+++ b/src/hid/common/face3d_gl.c
@@ -0,0 +1,387 @@
+#include <glib.h>
+#include <stdbool.h>
+
+#include "step_id.h"
+#include "quad.h"
+#include "edge3d.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+
+#include "data.h"
+#include "hid.h"
+#include "sweep.h"
+#include "polygon.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
+#include "face3d.h"
+#include "face3d_gl.h"
+
+//#define MEMCPY_VERTEX_DATA
+
+#define CIRC_SEGS_D 64.0
+
+static void
+plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *u = (x - face->ox) * face->rx +
+       (y - face->oy) * face->ry +
+       (z - face->oz) * face->rz;
+
+  *v = (x - face->ox) * ortx +
+       (y - face->oy) * orty +
+       (z - face->oz) * ortz;
+}
+
+static void
+plane_uv_to_xyz (face3d *face, float u, float v, float *x, float *y, float *z)
+{
+  float ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + u * face->rx + v * ortx);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + u * face->ry + v * orty);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + u * face->rz + v * ortz);
+}
+
+static void
+ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  Vector p_v;
+  VNODE *node;
+  PLINE *p_contour = NULL;
+  POLYAREA *poly;
+  PLINE *dummy_contour;
+  borast_traps_t traps;
+  bool found_outer_contour = false;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (face->is_cylindrical)
+    return;
+
+//  if (face->is_b_spline)
+//    return;
+
+  poly = poly_Create ();
+  if (poly == NULL)
+    return;
+
+  /* Create a dummy outer contour (so we don't have to worry about the order below..
+   * when we encounter the outer contour, we substitute this dummy one for it.
+   */
+  p_v[0] = 0;
+  p_v[1] = 0;
+  node = poly_CreateNode (p_v);
+  dummy_contour = poly_NewContour (node);
+  dummy_contour->Flags.orient = PLF_DIR;
+  poly_InclContour (poly, dummy_contour);
+
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          float u, v;
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              plane_xyz_to_uv (face,
+                               info->linearised_vertices[vertex_idx * 3 + 0],
+                               info->linearised_vertices[vertex_idx * 3 + 1],
+                               info->linearised_vertices[vertex_idx * 3 + 2],
+                               &u, &v);
+
+              p_v[0] = MM_TO_COORD (u);
+              p_v[1] = MM_TO_COORD (v);
+              node = poly_CreateNode (p_v);
+
+              if (p_contour == NULL)
+                {
+                  if ((p_contour = poly_NewContour (node)) == NULL)
+                    return;
+                }
+              else
+                {
+                  poly_InclVertex (p_contour->head.prev, node);
+                }
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      poly_PreContour (p_contour, FALSE);
+
+      /* make sure it is a positive contour (outer) or negative (hole) */
+//      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+//      poly_InvContour (p_contour);
+
+      if (p_contour->Flags.orient == PLF_DIR)
+        {
+          PLINE *old_outer;
+
+          /* Found the outer contour */
+          if (found_outer_contour)
+            {
+              printf ("FOUND TWO OUTER CONTOURS FOR PLANAR FACE.. WILL END BADLY!\n");
+#if 1
+              face->triangulate_failed = true;
+              return;
+#endif
+            }
+
+          p_contour->next = poly->contours->next;
+          old_outer = poly->contours;
+          poly->contours = p_contour;
+
+          found_outer_contour = true;
+        }
+      else
+        {
+          if (!poly_InclContour (poly, p_contour))
+            {
+              printf ("Contour dropped - oops!\n");
+              poly_DelContour (&p_contour);
+            }
+        }
+      p_contour = NULL;
+
+      /* XXX: Assumption of outline first, holes second seems to be false! */
+//      hole = true;
+    }
+
+  if (!found_outer_contour)
+    {
+      printf ("DID NOT FIND OUTER CONTOUR... BADNESS\n");
+      face->triangulate_failed = true;
+      return;
+    }
+
+  poly_DelContour (&dummy_contour);
+
+  /* XXX: Need to tesselate the polygon */
+  _borast_traps_init (&traps);
+  bo_poly_to_traps_no_draw (poly, &traps);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5; /* Three vertices + repeated start and end */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  poly_Free (&poly);
+
+  if (num_uv_points == 0) {
+//    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+//  printf ("Tesselated with %i uv points\n", num_uv_points);
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, 3 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      plane_uv_to_xyz(face,
+                      COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                      COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                      &face->tristrip_vertices[vertex_comp + 0],
+                      &face->tristrip_vertices[vertex_comp + 1],
+                      &face->tristrip_vertices[vertex_comp + 2]);
+      vertex_comp += 3;
+    }
+
+  g_free (uv_points);
+}
+
+void
+face3d_fill(hidGC gc, face3d *face, bool selected)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+#ifdef MEMCPY_VERTEX_DATA
+  hidgl_priv *priv = hidgl->priv;
+#endif
+  int i;
+  int vertex_comp;
+
+  /* We only know how to deal with planar faces for now */
+  if (!face->is_planar)
+    return;
+
+  if (selected)
+    hidgl_flush_triangles (hidgl);
+
+  ensure_tristrip (face);
+
+//  glColor4f (1.0f, 0.0f, 0.0f, 0.3f);
+  if (selected)
+    glColor4f (0.0f, 1.0f, 1.0f, 1.0f);
+  else
+    glColor4f (0.8f, 0.8f, 0.8f, 1.0f);
+
+  hidgl_ensure_vertex_space (gc, face->tristrip_num_vertices);
+
+#ifdef MEMCPY_VERTEX_DATA
+  memcpy (&priv->buffer.triangle_array[priv->buffer.coord_comp_count],
+          face->tristrip_vertices,
+          sizeof (float) * 5 * face->tristrip_num_vertices);
+  priv->buffer.coord_comp_count += 5 * face->tristrip_num_vertices;
+  priv->buffer.vertex_count += face->tristrip_num_vertices;
+
+#else
+  vertex_comp = 0;
+  for (i = 0; i < face->tristrip_num_vertices; i++) {
+    float x, y, z;
+    x = face->tristrip_vertices[vertex_comp++];
+    y = face->tristrip_vertices[vertex_comp++];
+    z = face->tristrip_vertices[vertex_comp++];
+    hidgl_add_vertex_3D_tex (gc, x, y, z, 0.0, 0.0);
+  }
+#endif
+
+  hidgl_flush_triangles (hidgl);
+}
diff --git a/src/hid/common/face3d_gl.h b/src/hid/common/face3d_gl.h
new file mode 100644
index 0000000..f3599c8
--- /dev/null
+++ b/src/hid/common/face3d_gl.h
@@ -0,0 +1 @@
+void face3d_fill (hidGC gc, face3d *face, bool selected);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index a90a51e..51990bc 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -74,7 +74,6 @@
 #   include <GL/gl.h>
 #endif
 
-
 static Coord board_thickness;
 #define HACK_BOARD_THICKNESS board_thickness
 //#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
@@ -83,14 +82,6 @@ static Coord board_thickness;
 #define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
 #define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
 
-static GList *object3d_test_objects = NULL;
-
-void
-object3d_test_init (void)
-{
-  object3d_test_objects = object3d_from_board_outline ();
-}
-
 object3d *
 make_object3d (char *name)
 {
@@ -139,348 +130,6 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
-                       {1., 1., 0.},
-                       {0., 1., 0.},
-                       {0., 1., 1.},
-                       {0.5, 0., 0.},
-                       {0.5, 0.5, 0.},
-                       {0., 0.5, 0.},
-                       {0., 0.5, 0.5},
-                       {1., 0.5, 0.5},
-                       {1., 1., 0.5},
-                       {0.5, 1., 0.5},
-                       {0.5, 1., 1.}};
-
-
-#define CIRC_SEGS_D 64.0
-
-
-static void
-evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
-{
-//  info->
-}
-
-static void
-draw_bspline (edge_ref e)
-{
-  edge_info *info = UNDIR_DATA(e);
-  double x1, y1, z1;
-  double x2, y2, z2;
-  double lx, ly, lz;
-  double x, y, z;
-  int i;
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  glBegin (GL_LINES);
-
-#if 0
-  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-#endif
-
-  /* Just draw the control points for now... */
-  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      x = info->control_points[i * 3 + 0];
-      y = info->control_points[i * 3 + 1];
-      z = info->control_points[i * 3 + 2];
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-
-  glEnd ();
-}
-
-static void
-draw_quad_edge (edge_ref e, void *data)
-{
-  double x1, y1, z1;
-  double x2, y2, z2;
-  int i;
-  bool debug = GPOINTER_TO_INT (data);
-
-#if 0
-  int id = ID(e) % 12;
-
-  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
-#else
-  glColor4f (1., 1., 1., 0.3);
-#endif
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  if (UNDIR_DATA(e) != NULL)
-    {
-      edge_info *info = UNDIR_DATA(e);
-
-
-//        if (info->is_placeholder)
-        if (debug)
-          {
-            glColor4f (1.0, 0.0, 0.0, 1.0);
-            glDepthMask (TRUE);
-          }
-
-//      if (info->is_stitch)
-//        return;
-
-      if (info->is_bspline)
-        {
-          draw_bspline (e);
-          return;
-        }
-
-      if (info->is_round)
-        {
-          int i;
-          double cx, cy, cz;
-          double nx, ny, nz;
-          double refx, refy, refz;
-          double endx, endy, endz;
-          double ortx, orty, ortz;
-          double cosa;
-          double sina;
-          double recip_length;
-          double da;
-          int segs;
-          double angle_step;
-
-          cx = ((edge_info *)UNDIR_DATA(e))->cx;
-          cy = ((edge_info *)UNDIR_DATA(e))->cy;
-          cz = ((edge_info *)UNDIR_DATA(e))->cz;
-
-          nx = ((edge_info *)UNDIR_DATA(e))->nx;
-          ny = ((edge_info *)UNDIR_DATA(e))->ny;
-          nz = ((edge_info *)UNDIR_DATA(e))->nz;
-
-          /* XXX: Do this without breaking abstraction? */
-          /* Detect SYM edges, reverse the circle normal */
-          if ((e & 2) == 2)
-            {
-#if 0
-              /* Option 1, just draw the forward copy, which agrees with the normal */
-              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
-              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
-              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
-
-              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
-              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
-              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
-#else
-              /* Option 2, flip the normal */
-              nx = -nx;
-              ny = -ny;
-              nz = -nz;
-#endif
-            }
-
-          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
-           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
-           */
-          refx = x1 - cx;
-          refy = y1 - cy;
-          refz = z1 - cz;
-
-          /* Normalise refx */
-          recip_length = 1. / hypot (hypot (refx, refy), refz);
-          refx *= recip_length;
-          refy *= recip_length;
-          refz *= recip_length;
-
-          endx = x2 - cx;
-          endy = y2 - cy;
-          endz = z2 - cz;
-
-          /* Normalise endx */
-          recip_length = 1. / hypot (hypot (endx, endy), endz);
-          endx *= recip_length;
-          endy *= recip_length;
-          endz *= recip_length;
-
-          /* ref cross normal */
-          /* ort will be orthogonal to normal and ref vector */
-          ortx = ny * refz - nz * refy;
-          orty = nz * refx - nx * refz;
-          ortz = nx * refy - ny * refx;
-
-          /* Cosine is dot product of ref (normalised) and end (normalised) */
-          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
-          /* Sine is dot product of ort (normalised) and end (normalised) */
-          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
-
-          if (x1 == x2 &&
-              y1 == y2 &&
-              z1 == z2)
-            {
-              da = 2.0 * M_PI;
-            }
-          else
-            {
-              /* Delta angled */
-              da = atan2 (sina, cosa);
-
-              if (da < 0.0)
-                da += 2.0 * M_PI;
-            }
-
-#if 0
-          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
-          printf ("end (%f, %f, %f)\n", endx, endy, endz);
-          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
-          printf ("n (%f, %f, %f)\n", nx, ny, nz);
-          printf ("cosa %f, sina %f\n", cosa, sina);
-          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
-#endif
-
-          /* Scale up ref and ort to the actual vector length */
-          refx *= info->radius;
-          refy *= info->radius;
-          refz *= info->radius;
-
-          ortx *= info->radius;
-          orty *= info->radius;
-          ortz *= info->radius;
-
-          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
-          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
-          segs = MAX(segs, 1);
-          angle_step = da / (double)segs;
-
-          glBegin (GL_LINES);
-
-          for (i = 0; i < segs; i++)
-            {
-              cosa = cos (i * angle_step);
-              sina = sin (i * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-
-              cosa = cos ((i + 1) * angle_step);
-              sina = sin ((i + 1) * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-            }
-
-          glEnd ();
-
-          glDepthMask (FALSE);
-          return;
-        }
-    }
-
-//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-  glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, x1),
-              STEP_Y_TO_COORD (PCB, y1),
-              STEP_X_TO_COORD (PCB, z1));
-  glVertex3f (STEP_X_TO_COORD (PCB, x2),
-              STEP_Y_TO_COORD (PCB, y2),
-              STEP_X_TO_COORD (PCB, z2));
-  glEnd ();
-  glDepthMask (FALSE);
-}
-
-static void
-draw_contour (contour3d *contour, void *data)
-{
-  edge_ref e;
-  bool debug = GPOINTER_TO_INT (data);
-  int edge_no = 0;
-
-  e = contour->first_edge;
-
-//  printf ("Drawing contour\n");
-
-  do
-    {
-      edge_info *info = UNDIR_DATA(e);
-//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
-      draw_quad_edge (e, data);
-
-      /* Stop if e was the only edge in a face - which we re-trace */
-      /* XXX: Probably only a development bug until we get the quad-edge links correct */
-//      if (LNEXT(e) == SYM(e))
-//        break;
-
-      /* LNEXT should take us counter-clockwise around the face */
-      /* LPREV should take us clockwise around the face */
-    }
-  while ((e = LNEXT(e)) != contour->first_edge);
-}
-
-static int face_no;
-
-static void
-draw_face (face3d *face, void *data)
-{
-//  if (face->contours != NULL)
-//      draw_contour (face->contours->data, NULL);
-//  printf ("Drawing face\n");
-  g_list_foreach (face->contours, (GFunc)draw_contour, GINT_TO_POINTER(face_no == debug_integer));
-
-  face_no++;
-}
-
-void
-object3d_draw (object3d *object)
-{
-  g_return_if_fail (object->edges != NULL);
-
-//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
-//  printf ("BEGIN DRAW...\n");
-//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
-
-//  printf ("\nDrawing object\n");
-
-  face_no = 0;
-
-  g_list_foreach (object->faces, (GFunc)draw_face, NULL);
-
-//  printf ("....ENDED\n");
-}
-
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
-{
-  object3d_draw (object);
-}
-
-void
-object3d_draw_debug (void)
-{
-  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, NULL);
-}
-
 /*********************************************************************************************************/
 
 static int
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 3d228f6..4689664 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -8,9 +8,6 @@ typedef struct {
   void *user_data;
 } object3d;
 
-void object3d_test_init (void);
-void object3d_draw (object3d *object);
-void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
 void object3d_set_appearance (object3d *object, appearance *appear);
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
new file mode 100644
index 0000000..d350572
--- /dev/null
+++ b/src/hid/common/object3d_gl.c
@@ -0,0 +1,486 @@
+/* TODO ITEMS:
+ *
+ * Add PLINE simplification operation to consolidate co-circular segments for reduced geometry output.
+ * Look at whether arc-* intersections can be re-constructed back to original geometry, not fall back to line-line.
+ * Work on snap-rounding any edge which passes through the pixel square containing an any vertex (or intersection).
+ * Avoid self-touching output in contours, where that self-touching instance creates two otherwise distinct contours or holes.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#include <glib.h>
+
+#include "data.h"
+#include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+#include "face3d.h"
+#include "edge3d.h"
+#include "object3d.h"
+#include "polygon.h"
+#include "rats.h"
+
+#include "rtree.h"
+#include "rotate.h"
+
+#include "pcb-printf.h"
+#include "misc.h"
+#include "hid/hidint.h"
+
+#define PERFECT_ROUND_CONTOURS
+#define SUM_PINS_VIAS_ONCE
+#define HASH_OBJECTS
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "hid_draw.h"
+#include "hidgl.h"
+#include "face3d_gl.h"
+#include "object3d_gl.h"
+
+//static Coord board_thickness;
+#define HACK_BOARD_THICKNESS board_thickness
+//#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
+#define HACK_COPPER_THICKNESS MM_TO_COORD(0.035)
+#define HACK_PLATED_BARREL_THICKNESS MM_TO_COORD(0.08)
+#define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
+#define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
+
+static GList *object3d_test_objects = NULL;
+
+void
+object3d_test_init (void)
+{
+  object3d_test_objects = object3d_from_board_outline ();
+}
+
+float colors[12][3] = {{1., 0., 0.},
+                       {1., 1., 0.},
+                       {0., 1., 0.},
+                       {0., 1., 1.},
+                       {0.5, 0., 0.},
+                       {0.5, 0.5, 0.},
+                       {0., 0.5, 0.},
+                       {0., 0.5, 0.5},
+                       {1., 0.5, 0.5},
+                       {1., 1., 0.5},
+                       {0.5, 1., 0.5},
+                       {0.5, 1., 1.}};
+
+
+#define CIRC_SEGS_D 64.0
+
+
+struct draw_info {
+  hidGC gc;
+  bool selected;
+  bool debug_face;
+};
+
+
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+
+static void
+draw_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double lx, ly, lz;
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+  glBegin (GL_LINES);
+
+#if 0
+  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+#endif
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      x = info->control_points[i * 3 + 0];
+      y = info->control_points[i * 3 + 1];
+      z = info->control_points[i * 3 + 2];
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+
+  glEnd ();
+}
+
+static void
+draw_quad_edge (edge_ref e, void *data)
+{
+  struct draw_info *d_info = data;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  int i;
+  bool debug = GPOINTER_TO_INT (data);
+
+#if 0
+  int id = ID(e) % 12;
+
+  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
+#else
+  if (d_info->selected)
+    glColor4f (0.0, 1.0, 1., 0.5);
+  else
+    glColor4f (1., 1., 1., 0.3);
+#endif
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  if (UNDIR_DATA(e) != NULL)
+    {
+      edge_info *info = UNDIR_DATA(e);
+
+
+//        if (info->is_placeholder)
+        if (d_info->debug_face)
+          {
+            glColor4f (1.0, 0.0, 0.0, 1.0);
+            glDepthMask (TRUE);
+          }
+
+//      if (info->is_stitch)
+//        return;
+
+      if (info->is_bspline)
+        {
+          draw_bspline (e);
+          return;
+        }
+
+      if (info->is_round)
+        {
+          int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          if ((e & 2) == 2)
+            {
+#if 0
+              /* Option 1, just draw the forward copy, which agrees with the normal */
+              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
+              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
+              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
+
+              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
+              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
+              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
+#else
+              /* Option 2, flip the normal */
+              nx = -nx;
+              ny = -ny;
+              nz = -nz;
+#endif
+            }
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
+          glBegin (GL_LINES);
+
+          for (i = 0; i < segs; i++)
+            {
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+            }
+
+          glEnd ();
+
+//          glDepthMask (FALSE);
+          return;
+        }
+    }
+
+//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+  glBegin (GL_LINES);
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
+  glEnd ();
+//  glDepthMask (FALSE);
+}
+
+static void
+draw_contour (contour3d *contour, void *data)
+{
+//  struct draw_info *info = data;
+  edge_ref e;
+  int edge_no = 0;
+
+  e = contour->first_edge;
+
+//  printf ("Drawing contour\n");
+
+  do
+    {
+      edge_info *info = UNDIR_DATA(e);
+//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+      draw_quad_edge (e, data);
+
+      /* Stop if e was the only edge in a face - which we re-trace */
+      /* XXX: Probably only a development bug until we get the quad-edge links correct */
+//      if (LNEXT(e) == SYM(e))
+//        break;
+
+      /* LNEXT should take us counter-clockwise around the face */
+      /* LPREV should take us clockwise around the face */
+    }
+  while ((e = LNEXT(e)) != contour->first_edge);
+}
+
+static int face_no;
+
+static void
+draw_face_edges (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  info->debug_face = (face_no == debug_integer);
+  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+static void
+draw_face (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  face3d_fill (info->gc, face, info->selected);
+//  face3d_fill (info->gc, face, (face_no == debug_integer));
+
+//  info->debug_face = (face_no == debug_integer);
+//
+//  return;
+//
+//  if (face->contours != NULL)
+//      draw_contour (face->contours->data, info);
+//  printf ("Drawing face\n");
+//  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+void
+object3d_draw (hidGC gc, object3d *object, bool selected)
+{
+  struct draw_info info;
+
+//  hidglGC hidgl_gc = (hidglGC)gc;
+//  hidgl_instance *hidgl = hidgl_gc->hidgl;
+//  hidgl_priv *priv = hidgl->priv;
+
+  g_return_if_fail (object->edges != NULL);
+
+  info.gc = gc;
+  info.selected = selected;
+
+//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
+//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+
+//  printf ("\nDrawing object\n");
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face_edges, &info);
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face, &info);
+
+//  printf ("....ENDED\n");
+}
+
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  hidGC gc = user_data;
+
+  object3d_draw (gc, object, false);
+}
+
+void
+object3d_draw_debug (hidGC gc)
+{
+  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, gc);
+}
diff --git a/src/hid/common/object3d_gl.h b/src/hid/common/object3d_gl.h
new file mode 100644
index 0000000..cbf5d1a
--- /dev/null
+++ b/src/hid/common/object3d_gl.h
@@ -0,0 +1,3 @@
+void object3d_test_init (void);
+void object3d_draw (hidGC gc, object3d *object, bool selected);
+void object3d_draw_debug (hidGC gc);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fce8341..0816807 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -54,6 +54,8 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #include "hid/common/draw_helpers.h"
 #include "hid/common/trackball.h"
 
+#include "hid/common/object3d_gl.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -2117,7 +2119,7 @@ via_hole_cyl_callback (const BoxType * b, void *cl)
 }
 
 static void
-hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
+hidgl_draw_step_model_instance (struct assembly_model_instance *instance, bool selected)
 {
   render_priv *priv = gport->render_priv;
   step_model *step_model = instance->model->step_model;
@@ -2177,7 +2179,7 @@ hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
                 -STEP_TO_COORD_Y (PCB, step_model->oy),
                 -STEP_TO_COORD_Z (PCB, step_model->oz));
 
-  object3d_draw (step_model->object);
+  object3d_draw (Output.fgGC, step_model->object, selected);
 
   hidgl_flush_triangles (priv->hidgl);
 
@@ -2195,7 +2197,7 @@ E_package_callback (const BoxType * b, void *cl)
 
   if (element->assembly_model_instance != NULL)
     {
-      hidgl_draw_step_model_instance (element->assembly_model_instance);
+      hidgl_draw_step_model_instance (element->assembly_model_instance, TEST_FLAG (SELECTEDFLAG, element));
     }
 
   if (FRONT (element))
@@ -2784,7 +2786,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDepthFunc (GL_LESS);
   glDisable (GL_STENCIL_TEST);
 
-  glEnable (GL_CULL_FACE);
+//  glEnable (GL_CULL_FACE); /* XXX: Fix model face filling */
   glCullFace (GL_BACK);
 
   if (1) {
@@ -2835,9 +2837,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-  //object3d_draw_debug ();
+  //object3d_draw_debug (Output.fgGC);
   if (step_read_test != NULL)
-    object3d_draw (step_read_test);
+    object3d_draw (Output.fgGC, step_read_test, false);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 35c5072..a70b7c2 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -97,8 +97,8 @@ typedef std::list<SdaiMapped_item *> mi_list;
 
 SdaiProduct_definition *
 read_model_from_file (Registry *registry,
-                        InstMgr *instance_list,
-                        const char *filename)
+                      InstMgr *instance_list,
+                      const char *filename)
 {
   STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
 
@@ -189,6 +189,23 @@ find_mapped_item (SdaiShape_representation *sr,
     }
 }
 
+static void
+unpack_axis_geom (SdaiAxis2_placement_3d *axis,
+                  double *ox, double *oy, double *oz,
+                  double *ax, double *ay, double *az,
+                  double *rx, double *ry, double *rz)
+{
+  *ox = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ())->value;
+  *oy = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+  *oz = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *ax = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ay = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *az = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *rx = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ry = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *rz = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+}
+
 typedef struct process_step_info {
   /* Hash / list of SR -> step_model */
   object3d *object;
@@ -364,7 +381,7 @@ transform_vector (double m[4][4], double *x, double *y, double *z)
 static double
 distance (double a[3], double b[3])
 {
-  return hypot(hypot(a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
+  return hypot (hypot (a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
 }
 
 static void
@@ -994,15 +1011,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("child axis o: (%f, %f, %f)\n"
@@ -1019,15 +1028,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
       /* Is this in the correct order? */
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("parent axis o: (%f, %f, %f)\n"
@@ -1159,16 +1160,18 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
 
           /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
-          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          //SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
           /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
           SdaiFace_surface *fs = (SdaiFace_surface *) face;
 
           SdaiSurface *surface = fs->face_geometry_ ();
-
 #if 0
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
 
+          info->current_face = make_face3d ((char *)"");
+          object3d_add_face (info->object, info->current_face);
+
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1177,11 +1180,69 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
+              SdaiPlane *plane = dynamic_cast<SdaiPlane *>(surface);
+
 //              printf ("WARNING: planar surfaces are not supported yet\n");
+
+              unpack_axis_geom (plane->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_planar = true;
+
+              info->current_face->nx = info->current_face->ax;
+              info->current_face->ny = info->current_face->ay;
+              info->current_face->nz = info->current_face->az;
+
+              if (!fs->same_sense_ ())
+                {
+                  info->current_face->nx = -info->current_face->nx;
+                  info->current_face->ny = -info->current_face->ny;
+                  info->current_face->nz = -info->current_face->nz;
+
+//                  printf ("Not same sense, flipping normal\n");
+                }
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
+              SdaiCylindrical_surface *cylinder = dynamic_cast<SdaiCylindrical_surface *>(surface);
 //              printf ("WARNING: cylindrical suraces are not supported yet\n");
+
+              unpack_axis_geom (cylinder->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_cylindrical = true;
+              info->current_face->radius = cylinder->radius_ ();
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
             {
@@ -1198,9 +1259,6 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #endif
             }
 
-          info->current_face = make_face3d ((char *)"");
-          object3d_add_face (info->object, info->current_face);
-
           for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
                iter != NULL;
                iter = iter->NextNode ())
@@ -1441,29 +1499,13 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       /* XXX: Looking only at the target vector.. need to find some examples where the parent transform coordinate system is not unity to get this correct */
       rotate_basis (info->current_transform, ax, ay, az, rx, ry, rz);
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       translate_origin (info->current_transform, -ox, -oy, -oz);
       rotate_basis_inverted (info->current_transform, ax, ay, az, rx, ry, rz);
diff --git a/src/sweep.h b/src/sweep.h
index e8f138f..644d70b 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,6 +1,7 @@
 #include "borast/borast-traps-private.h"
 
 borast_status_t bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps);
+borast_status_t bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps);
 borast_fixed_t _line_compute_intersection_x_for_y (const borast_line_t *line, borast_fixed_t y);
