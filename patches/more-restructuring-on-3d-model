Bottom: 8650f4763da9678f45ed3863879e1b4497004405
Top:    05826333d3a88d5e00bd733048092c680b3fca1f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-18 19:36:45 +0000

More restructuring on 3D model rendering


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c9e089..ccbd5e4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -171,8 +171,12 @@ PCB_SRCS = \
 	hid/common/edge3d.h \
 	hid/common/face3d.c \
 	hid/common/face3d.h \
+	hid/common/face3d_gl.c \
+	hid/common/face3d_gl.h \
 	hid/common/object3d.c \
 	hid/common/object3d.h \
+	hid/common/object3d_gl.c \
+	hid/common/object3d_gl.h \
 	hid/common/quad.c \
 	hid/common/quad.h \
 	hid/common/step_id.h \
diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 4f2937f..e931852 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -1501,6 +1501,67 @@ bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps)
 }
 
 borast_status_t
+bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps)
+{
+  int intersections;
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
+  borast_bo_start_event_t *events;
+  borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  borast_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+  POLYAREA *pa;
+  PLINE *contour;
+
+  pa = poly;
+  do {
+    for (contour = pa->contours; contour != NULL; contour = contour->next)
+      num_events += contour->Count;
+    /* FIXME: Remove horizontal edges? */
+    break;
+  } while ((pa = pa->f) != poly);
+
+  if (unlikely (0 == num_events))
+      return BORAST_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _borast_malloc_ab_plus_c (num_events,
+                                        sizeof (borast_bo_start_event_t) +
+                                        sizeof (borast_bo_event_t *),
+                                        sizeof (borast_bo_event_t *));
+      if (unlikely (events == NULL))
+          return BORAST_STATUS_NO_MEMORY;
+
+      event_ptrs = (borast_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  poly_area_to_start_events (poly, events, event_ptrs, &i);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * borast_traps_t. */
+  _borast_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                               num_events,
+                                               traps,
+                                               &intersections);
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return BORAST_STATUS_SUCCESS;
+}
+
+borast_status_t
 bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
diff --git a/src/hid/common/edge3d.c b/src/hid/common/edge3d.c
index ebcdc08..97f564d 100644
--- a/src/hid/common/edge3d.c
+++ b/src/hid/common/edge3d.c
@@ -1,9 +1,18 @@
 #include <glib.h>
+#include <stdint.h>
 #include <stdbool.h>
+#include <stdio.h>
+
+#include <math.h>
 
 #include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
 #include "edge3d.h"
 
+#define CIRC_SEGS_D 64.0
+
+
 edge_info *
 make_edge_info (void)
 {
@@ -11,6 +20,9 @@ make_edge_info (void)
 
   info = g_slice_new0 (edge_info);
 
+  /* Default this one, as it was added after most code was written */
+  info->same_sense = true;
+
   return info;
 }
 
@@ -37,3 +49,274 @@ destroy_edge_info (edge_info *info)
 {
   g_slice_free (edge_info, info);
 }
+
+static void
+allocate_linearised_vertices (edge_ref e, int num_vertices)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->num_linearised_vertices = 0;
+  info->linearised_vertices = g_new0 (float, 3 * num_vertices);
+}
+
+static void
+add_vertex (edge_ref e, float x, float y, float z)
+{
+  edge_info *info = UNDIR_DATA(e);
+
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 0] = x;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 1] = y;
+  info->linearised_vertices[info->num_linearised_vertices * 3 + 2] = z;
+
+  info->num_linearised_vertices++;
+}
+
+#if 0
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+#endif
+
+static void
+sample_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+#if 0
+  for (i = 0; i < 20; i++)
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      add_vertex (x, y, z);
+    }
+#endif
+
+  allocate_linearised_vertices (e, info->num_control_points);
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++)
+    {
+      int cp_index;
+
+      if (info->same_sense)
+        cp_index = i;
+      else
+        cp_index = info->num_control_points - 1 - i;
+
+      x = info->control_points[cp_index * 3 + 0];
+      y = info->control_points[cp_index * 3 + 1];
+      z = info->control_points[cp_index * 3 + 2];
+
+      add_vertex (e, x, y, z);
+    }
+}
+
+static void
+sample_circle (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+  int i;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  double cx, cy, cz;
+  double nx, ny, nz;
+  double refx, refy, refz;
+  double endx, endy, endz;
+  double ortx, orty, ortz;
+  double cosa;
+  double sina;
+  double recip_length;
+  double da;
+  int segs;
+  double angle_step;
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  cx = ((edge_info *)UNDIR_DATA(e))->cx;
+  cy = ((edge_info *)UNDIR_DATA(e))->cy;
+  cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+  nx = ((edge_info *)UNDIR_DATA(e))->nx;
+  ny = ((edge_info *)UNDIR_DATA(e))->ny;
+  nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+  if (!info->same_sense)
+    {
+      nx = -nx;
+      ny = -ny;
+      nz = -nz;
+    }
+
+  /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+   * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+   */
+  refx = x1 - cx;
+  refy = y1 - cy;
+  refz = z1 - cz;
+
+  /* Normalise refx */
+  recip_length = 1. / hypot (hypot (refx, refy), refz);
+  refx *= recip_length;
+  refy *= recip_length;
+  refz *= recip_length;
+
+  endx = x2 - cx;
+  endy = y2 - cy;
+  endz = z2 - cz;
+
+  /* Normalise endx */
+  recip_length = 1. / hypot (hypot (endx, endy), endz);
+  endx *= recip_length;
+  endy *= recip_length;
+  endz *= recip_length;
+
+  /* ref cross normal */
+  /* ort will be orthogonal to normal and ref vector */
+  ortx = ny * refz - nz * refy;
+  orty = nz * refx - nx * refz;
+  ortz = nx * refy - ny * refx;
+
+  /* Cosine is dot product of ref (normalised) and end (normalised) */
+  cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and end (normalised) */
+  sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+  if (x1 == x2 &&
+      y1 == y2 &&
+      z1 == z2)
+    {
+      da = 2.0 * M_PI;
+    }
+  else
+    {
+      /* Delta angled */
+      da = atan2 (sina, cosa);
+
+      if (da < 0.0)
+        da += 2.0 * M_PI;
+    }
+
+  /* Scale up ref and ort to the actual vector length */
+  refx *= info->radius;
+  refy *= info->radius;
+  refz *= info->radius;
+
+  ortx *= info->radius;
+  orty *= info->radius;
+  ortz *= info->radius;
+
+  segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+  segs = MAX(segs, 1);
+  angle_step = da / (double)segs;
+
+  allocate_linearised_vertices (e, segs + 1);
+
+  for (i = 0; i <= segs; i++)
+    {
+      cosa = cos (i * angle_step);
+      sina = sin (i * angle_step);
+      add_vertex (e, info->cx + refx * cosa + ortx * sina,
+                     info->cy + refy * cosa + orty * sina,
+                     info->cz + refz * cosa + ortz * sina);
+    }
+
+}
+
+static void
+sample_line (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+  double x, y, z;
+
+  allocate_linearised_vertices (e, 2);
+
+  if (info->same_sense)
+    {
+      x = ((vertex3d *)ODATA(e))->x;
+      y = ((vertex3d *)ODATA(e))->y;
+      z = ((vertex3d *)ODATA(e))->z;
+
+      add_vertex (e, x, y, z);
+
+      x = ((vertex3d *)DDATA(e))->x;
+      y = ((vertex3d *)DDATA(e))->y;
+      z = ((vertex3d *)DDATA(e))->z;
+
+      add_vertex (e, x, y, z);
+    }
+  else
+    {
+      /* Unusual, but somtimes occurs */
+      //printf ("****************************************************\n");
+
+      x = ((vertex3d *)DDATA(e))->x;
+      y = ((vertex3d *)DDATA(e))->y;
+      z = ((vertex3d *)DDATA(e))->z;
+
+      add_vertex (e, x, y, z);
+
+      x = ((vertex3d *)ODATA(e))->x;
+      y = ((vertex3d *)ODATA(e))->y;
+      z = ((vertex3d *)ODATA(e))->z;
+
+      add_vertex (e, x, y, z);
+    }
+}
+
+void
+edge_ensure_linearised (edge_ref edge)
+{
+  edge_info *info;
+
+  /* Ensure we're looking at the forward edge */
+  edge &= (uintptr_t) ~3;
+
+  info = UNDIR_DATA(edge);
+
+  /* Already cached, nothing to do */
+  if (info->linearised_vertices != NULL)
+    return;
+
+  /* Can't do anything if we don't have the edge_info data */
+  if (info == NULL)
+    return;
+
+  if (info->is_bspline)
+    {
+      sample_bspline (edge);
+      return;
+    }
+
+  if (info->is_round)
+    {
+      sample_circle (edge);
+      return;
+    }
+
+  /* Must be linear */
+  sample_line (edge);
+}
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 7b26668..1259a68 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -3,6 +3,19 @@ typedef struct
   /* For edge curves */
   bool is_stitch; /* Allows us to identify the stitch edge along the side of a cylinder */
 
+  /* For curves which are defined along some primitive,
+   * such as cirular / b-spline below..
+   */
+
+  /* same_sense: true if the parameter value corresponding to the start vertex is
+   *             less than that of the end vertex. This has similar effec on
+   *             circles to flipping the defined normal.
+   *
+   * NB: As this parameter was added AFTER writing STEP emission code any edge
+   *     with this set to false will probably be broken in the emitted STEP.
+   */
+  bool same_sense;
+
   /* For circular curves */
   bool is_round;
   double cx;
@@ -30,9 +43,15 @@ typedef struct
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
   step_id edge_identifier;
+
+
+  /* Rendering data */
+  int num_linearised_vertices;
+  float *linearised_vertices; /* NB: Does not include the start_point */
 } edge_info;
 
 edge_info *make_edge_info (void);
 void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
+void edge_ensure_linearised (edge_ref edge);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index a98cda1..c794ae8 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -5,8 +5,31 @@
 #include "quad.h"
 #include "contour3d.h"
 #include "appearance.h"
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
 #include "face3d.h"
 
+#define MEMCPY_VERTEX_DATA
+
 face3d *
 make_face3d (char *name)
 {
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index ddec03f..045805b 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -1,9 +1,15 @@
 typedef struct {
+  double ox, oy, oz;
+  double rx, ry, rz;
+
   double nx, ny, nz; /* Face normal?*/
+
   bool surface_orientation_reversed;
   GList *contours;
   char *name;
 
+  bool is_planar;
+
   /* For cylindrical surfaces */
   bool is_cylindrical;
   double cx, cy, cz; /* A point on the axis */
@@ -16,6 +22,13 @@ typedef struct {
   step_id surface_identifier;
   step_id face_identifier;
   step_id face_bound_identifier;
+
+  /* Rendering cache */
+  int tristrip_num_vertices;
+  float *tristrip_vertices;
+  bool triangulate_failed;
+
+  bool is_debug;
 } face3d;
 
 face3d *make_face3d (char *name);
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
new file mode 100644
index 0000000..3f8f936
--- /dev/null
+++ b/src/hid/common/face3d_gl.c
@@ -0,0 +1,901 @@
+#include <glib.h>
+#include <stdbool.h>
+
+#include "step_id.h"
+#include "quad.h"
+#include "edge3d.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+
+#include "data.h"
+#include "hid.h"
+#include "sweep.h"
+#include "polygon.h"
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidgl.h"
+
+#include "face3d.h"
+#include "face3d_gl.h"
+
+//#define MEMCPY_VERTEX_DATA
+
+#define CIRC_SEGS_D 64.0
+
+
+#define BUFFER_STRIDE 6 /* 3x vertex + 3x normal */
+
+static void
+emit_tristrip (face3d *face)
+{
+  GLfloat *data_pointer = NULL;
+
+  int count;
+
+//  CHECK_IS_IN_CONTEXT ();
+
+  if (face->tristrip_num_vertices == 0)
+    return;
+
+//  if (priv->buffer.use_vbo) {
+//    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+
+//    if (priv->buffer.use_map) {
+//      glUnmapBuffer (GL_ARRAY_BUFFER);
+//      priv->buffer.triangle_array = NULL;
+//    } else {
+//      glBufferData (GL_ARRAY_BUFFER,
+//                    BUFFER_STRIDE * priv->buffer.vertex_count,
+//                    priv->buffer.triangle_array,
+//                    GL_STREAM_DRAW);
+//    }
+//  } else {
+    data_pointer = face->tristrip_vertices;
+//  }
+
+  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
+  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
+//  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_NORMAL_ARRAY);
+//  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  glTexCoord2f (0.0f, 0.0f);
+
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, face->tristrip_num_vertices);
+#if 0
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glDrawArrays (GL_LINE_STRIP, 0, priv->buffer.vertex_count);
+  glPopAttrib ();
+#endif
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_NORMAL_ARRAY);
+//  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+}
+
+static void
+cylinder_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double refx, refy, refz;
+  double ortx, orty, ortz;
+  double vx, vy, vz;
+  double recip_length;
+  double cosa, sina;
+
+  refx = face->rx;
+  refy = face->ry;
+  refz = face->rz;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  /* v is dot product of vector from surface origin to point, and the axis direction */
+  *v = (x - face->ox) * face->ax +
+       (y - face->oy) * face->ay +
+       (z - face->oz) * face->az;
+
+  /* Find the vector to x,y,z in the plane of the cylinder slice at *v */
+  vx = x - face->ox - *v * face->ax;
+  vy = y - face->oy - *v * face->ay;
+  vz = z - face->oz - *v * face->az;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (vx, vy), vz);
+  vx *= recip_length;
+  vy *= recip_length;
+  vz *= recip_length;
+
+  /* Cosine is dot product of ref (normalised) and v (normalised) */
+  cosa = refx * vx + refy * vy + refz * vz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and v (normalised) */
+  sina = ortx * vx + orty * vy + ortz * vz; // sin (phi) = cos (phi - 90)
+
+  /* U is the angle */
+  *u = atan2 (sina, cosa);
+
+  if (*u < 0.0)
+    *u += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *u *= 180. / M_PI;
+}
+
+static void
+cylinder_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z,
+                               float *nx, float *ny, float *nz)
+{
+  float ortx, orty, ortz;
+  double cosu, sinu;
+  double rcosu, rsinu;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  cosu = cos(u / 180. * M_PI);
+  sinu = sin(u / 180. * M_PI);
+
+  rcosu = face->radius * cosu;
+  rsinu = face->radius * sinu;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + rcosu * face->rx + rsinu * ortx + v * face->ax);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + rcosu * face->ry + rsinu * orty + v * face->ay);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + rcosu * face->rz + rsinu * ortz + v * face->az);
+
+  if (face->surface_orientation_reversed)
+    {
+      *nx = -(cosu * face->rx + sinu * ortx);
+      *ny = cosu * face->ry + sinu * orty; /* XXX: Note this is not negated, presumably due to PCB's coordinate space */
+      *nz = -(cosu * face->rz + sinu * ortz);
+    }
+  else
+    {
+      *nx = cosu * face->rx + sinu * ortx;
+      *ny = -(cosu * face->ry + sinu * orty); /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+      *nz = cosu * face->rz + sinu * ortz;
+    }
+}
+
+static void
+cylinder_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  Vector p_v;
+  VNODE *node;
+  PLINE *p_contour = NULL;
+  POLYAREA *poly;
+  PLINE *dummy_contour;
+  borast_traps_t traps;
+  bool found_outer_contour = false;
+  float u, v;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_cylindrical)
+    return;
+
+  poly = poly_Create ();
+  if (poly == NULL)
+    return;
+
+#if 1
+  /* Create a dummy outer contour (so we don't have to worry about the order below..
+   * when we encounter the outer contour, we substitute this dummy one for it.
+   */
+  p_v[0] = 0;
+  p_v[1] = 0;
+  node = poly_CreateNode (p_v);
+  dummy_contour = poly_NewContour (node);
+  dummy_contour->Flags.orient = PLF_DIR;
+  poly_InclContour (poly, dummy_contour);
+
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      float lost_phase = 0.0;
+      bool first_iteration = true;
+
+      int wobble = 0;
+
+      contour = c_iter->data;
+
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          float lu, lv;
+          float u, v;
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              cylinder_xyz_to_uv (face,
+                                  info->linearised_vertices[vertex_idx * 3 + 0],
+                                  info->linearised_vertices[vertex_idx * 3 + 1],
+                                  info->linearised_vertices[vertex_idx * 3 + 2],
+                                  &u, &v);
+
+              /* Add back on any wrapped phase */
+              u += lost_phase;
+
+              if (!first_iteration)
+                {
+//                  printf ("u = %f, delta since last u = %f\n", (double)u, (double)(u - lu));
+
+                  if (fabs (u - lu) > fabs (u + 360.0f - lu))
+                    {
+//                      printf ("Adding 360 degrees to lost phase\n");
+                      lost_phase += 360.0f;
+                      u += 360.0f;
+                    }
+                  else if (fabs (u - lu) > fabs (u - 360.0f - lu))
+                    {
+//                      printf ("Subtracting 360 degrees to lost phase\n");
+                      lost_phase -= 360.0f;
+                      u -= 360.0f;
+                    }
+                }
+
+
+              wobble = 10 - wobble;
+
+              p_v[0] = MM_TO_COORD (v) + wobble;
+              p_v[1] = MM_TO_COORD (u);
+              node = poly_CreateNode (p_v);
+
+              if (p_contour == NULL)
+                {
+                  if ((p_contour = poly_NewContour (node)) == NULL)
+                    return;
+                }
+              else
+                {
+                  poly_InclVertex (p_contour->head.prev, node);
+                }
+
+              lu = u;
+              lv = v;
+              first_iteration = false;
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      poly_PreContour (p_contour, FALSE);
+
+      /* make sure it is a positive contour (outer) or negative (hole) */
+//      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+
+
+//      if (p_contour->Flags.orient != PLF_DIR)
+      if (!face->surface_orientation_reversed)
+        poly_InvContour (p_contour);
+
+      if (p_contour->Flags.orient == PLF_DIR)
+        {
+          PLINE *old_outer;
+
+          /* Found the outer contour */
+          if (found_outer_contour)
+            {
+              printf ("FOUND TWO OUTER CONTOURS FOR CYLINDRICAL.. NEED TO HANDLE THIS..!\n");
+#if 1
+              face->triangulate_failed = true;
+              return;
+#endif
+            }
+
+          p_contour->next = poly->contours->next;
+          old_outer = poly->contours;
+          poly->contours = p_contour;
+
+          found_outer_contour = true;
+        }
+      else
+        {
+          if (!poly_InclContour (poly, p_contour))
+            {
+              printf ("Contour dropped - oops!\n");
+              poly_DelContour (&p_contour);
+            }
+        }
+      p_contour = NULL;
+
+      /* XXX: Assumption of outline first, holes second seems to be false! */
+//      hole = true;
+    }
+
+  if (!found_outer_contour)
+    {
+      printf ("DID NOT FIND OUTER CONTOUR... BADNESS\n");
+      face->triangulate_failed = true;
+      return;
+    }
+
+  poly_DelContour (&dummy_contour);
+#endif
+
+#if 0
+  v = 0.0;
+  for (i = 0; i <= 360; i+= 10)
+    {
+      u = i;
+      p_v[0] = MM_TO_COORD (v) + i; /* + i is a hack to keep the tesselator from combining strips across y */
+      p_v[1] = MM_TO_COORD (u);
+      node = poly_CreateNode (p_v);
+
+      if (p_contour == NULL)
+        {
+          if ((p_contour = poly_NewContour (node)) == NULL)
+            return;
+        }
+      else
+        {
+          poly_InclVertex (p_contour->head.prev, node);
+        }
+    }
+
+  v = -10.0;
+  for (i = 360; i >= 0; i-= 10)
+    {
+      u = i;
+      p_v[0] = MM_TO_COORD (v); // + i; /* + i is a hack to keep the tesselator from combining strips across y */
+      p_v[1] = MM_TO_COORD (u);
+      node = poly_CreateNode (p_v);
+      poly_InclVertex (p_contour->head.prev, node);
+    }
+
+    poly_PreContour (p_contour, FALSE);
+    if (!poly_InclContour (poly, p_contour))
+      {
+        printf ("Contour dropped - oops!\n");
+        poly_DelContour (&p_contour);
+      }
+#endif
+
+  /* XXX: Need to tesselate the polygon */
+  _borast_traps_init (&traps);
+  bo_poly_to_traps_no_draw (poly, &traps);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  poly_Free (&poly);
+
+  if (num_uv_points == 0) {
+    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+//  printf ("Tesselated with %i uv points\n", num_uv_points);
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    if (face->surface_orientation_reversed)
+      {
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top) - COORD_TO_MM(y_top); /* Subtract of COORD_TO_MM(y_top) undoes hack above which kept the tesselator from combining strips across y */
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top) - COORD_TO_MM(y_top);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot) - COORD_TO_MM(y_bot);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot) - COORD_TO_MM(y_bot);
+      }
+    else
+      {
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top) - COORD_TO_MM(y_top); /* Subtract of COORD_TO_MM(y_top) undoes hack above which kept the tesselator from combining strips across y */
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top) - COORD_TO_MM(y_top);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot) - COORD_TO_MM(y_bot);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot) - COORD_TO_MM(y_bot);
+      }
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      cylinder_uv_to_xyz_and_normal(face,
+                                    /* uv */
+                                    COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                                    COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                                    /* xyz */
+                                    &face->tristrip_vertices[vertex_comp + 0],
+                                    &face->tristrip_vertices[vertex_comp + 1],
+                                    &face->tristrip_vertices[vertex_comp + 2],
+                                    /* Vertex normal */
+                                    &face->tristrip_vertices[vertex_comp + 3],
+                                    &face->tristrip_vertices[vertex_comp + 4],
+                                    &face->tristrip_vertices[vertex_comp + 5]);
+
+#if 0
+      printf ("%f, %f  ->  %f, %f, %f\n",
+                         COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                         COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                         (double)face->tristrip_vertices[vertex_comp + 0],
+                         (double)face->tristrip_vertices[vertex_comp + 1],
+                         (double)face->tristrip_vertices[vertex_comp + 2]);
+#endif
+      vertex_comp += BUFFER_STRIDE;
+    }
+
+  g_free (uv_points);
+}
+
+static void
+plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *u = (x - face->ox) * face->rx +
+       (y - face->oy) * face->ry +
+       (z - face->oz) * face->rz;
+
+  *v = (x - face->ox) * ortx +
+       (y - face->oy) * orty +
+       (z - face->oz) * ortz;
+}
+
+static void
+plane_uv_to_xyz (face3d *face, float u, float v, float *x, float *y, float *z)
+{
+  float ortx, orty, ortz;
+
+  ortx = face->ny * face->rz - face->nz * face->ry;
+  orty = face->nz * face->rx - face->nx * face->rz;
+  ortz = face->nx * face->ry - face->ny * face->rx;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + u * face->rx + v * ortx);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + u * face->ry + v * orty);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + u * face->rz + v * ortz);
+}
+
+static void
+plane_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  Vector p_v;
+  VNODE *node;
+  PLINE *p_contour = NULL;
+  POLYAREA *poly;
+  PLINE *dummy_contour;
+  borast_traps_t traps;
+  bool found_outer_contour = false;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_planar)
+    return;
+
+  poly = poly_Create ();
+  if (poly == NULL)
+    return;
+
+  /* Create a dummy outer contour (so we don't have to worry about the order below..
+   * when we encounter the outer contour, we substitute this dummy one for it.
+   */
+  p_v[0] = 0;
+  p_v[1] = 0;
+  node = poly_CreateNode (p_v);
+  dummy_contour = poly_NewContour (node);
+  dummy_contour->Flags.orient = PLF_DIR;
+  poly_InclContour (poly, dummy_contour);
+
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          float u, v;
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              plane_xyz_to_uv (face,
+                               info->linearised_vertices[vertex_idx * 3 + 0],
+                               info->linearised_vertices[vertex_idx * 3 + 1],
+                               info->linearised_vertices[vertex_idx * 3 + 2],
+                               &u, &v);
+
+              p_v[0] = MM_TO_COORD (u);
+              p_v[1] = MM_TO_COORD (v);
+              node = poly_CreateNode (p_v);
+
+              if (p_contour == NULL)
+                {
+                  if ((p_contour = poly_NewContour (node)) == NULL)
+                    return;
+                }
+              else
+                {
+                  poly_InclVertex (p_contour->head.prev, node);
+                }
+            }
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      poly_PreContour (p_contour, FALSE);
+
+      /* make sure it is a positive contour (outer) or negative (hole) */
+//      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+//      poly_InvContour (p_contour);
+
+      if (p_contour->Flags.orient == PLF_DIR)
+        {
+          PLINE *old_outer;
+
+          /* Found the outer contour */
+          if (found_outer_contour)
+            {
+              printf ("FOUND TWO OUTER CONTOURS FOR PLANAR FACE.. WILL END BADLY!\n");
+#if 1
+              face->triangulate_failed = true;
+              return;
+#endif
+            }
+
+          p_contour->next = poly->contours->next;
+          old_outer = poly->contours;
+          poly->contours = p_contour;
+
+          found_outer_contour = true;
+        }
+      else
+        {
+          if (!poly_InclContour (poly, p_contour))
+            {
+              printf ("Contour dropped - oops!\n");
+              poly_DelContour (&p_contour);
+            }
+        }
+      p_contour = NULL;
+
+      /* XXX: Assumption of outline first, holes second seems to be false! */
+//      hole = true;
+    }
+
+  if (!found_outer_contour)
+    {
+      printf ("DID NOT FIND OUTER CONTOUR... BADNESS\n");
+      face->triangulate_failed = true;
+      return;
+    }
+
+  poly_DelContour (&dummy_contour);
+
+  /* XXX: Need to tesselate the polygon */
+  _borast_traps_init (&traps);
+  bo_poly_to_traps_no_draw (poly, &traps);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  poly_Free (&poly);
+
+  if (num_uv_points == 0) {
+//    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+//  printf ("Tesselated with %i uv points\n", num_uv_points);
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+#if 1
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+#endif
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      plane_uv_to_xyz(face,
+                      COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                      COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                      &face->tristrip_vertices[vertex_comp + 0],
+                      &face->tristrip_vertices[vertex_comp + 1],
+                      &face->tristrip_vertices[vertex_comp + 2]);
+
+      /* Vertex normal */
+      face->tristrip_vertices[vertex_comp + 3] = face->nx;
+      face->tristrip_vertices[vertex_comp + 4] = -face->ny; /* XXX: -ny */
+      face->tristrip_vertices[vertex_comp + 5] = face->nz;
+
+      vertex_comp += BUFFER_STRIDE;
+    }
+
+  g_free (uv_points);
+}
+
+void
+face3d_fill(hidGC gc, face3d *face, bool selected)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+  hidgl_instance *hidgl = hidgl_gc->hidgl;
+#ifdef MEMCPY_VERTEX_DATA
+  hidgl_priv *priv = hidgl->priv;
+#endif
+  int i;
+  int vertex_comp;
+
+  hidgl_flush_triangles (hidgl);
+
+  if (face->is_planar)
+    {
+      plane_ensure_tristrip (face);
+    }
+  else if (face->is_cylindrical)
+    {
+      cylinder_ensure_tristrip (face);
+    }
+  else
+    {
+      /* We only know how to deal with planar and cylindrical faces for now */
+      return;
+    }
+
+  if (face->is_debug)
+    glColor4f (1.0f, 0.0f, 0.0f, 0.5f);
+  else if (selected)
+    glColor4f (0.0f, 1.0f, 1.0f, 0.5f);
+//  else if (face->is_cylindrical)
+//    glColor4f (0.0f, 1.0f, 0.0f, 0.5f);
+  else
+    glColor4f (0.8f, 0.8f, 0.8f, 1.0f);
+
+#if 0
+  hidgl_ensure_vertex_space (gc, face->tristrip_num_vertices);
+
+#ifdef MEMCPY_VERTEX_DATA
+  memcpy (&priv->buffer.triangle_array[priv->buffer.coord_comp_count],
+          face->tristrip_vertices,
+          sizeof (float) * 5 * face->tristrip_num_vertices);
+  priv->buffer.coord_comp_count += 5 * face->tristrip_num_vertices;
+  priv->buffer.vertex_count += face->tristrip_num_vertices;
+
+#else
+  vertex_comp = 0;
+  for (i = 0; i < face->tristrip_num_vertices; i++) {
+    float x, y, z;
+    x = face->tristrip_vertices[vertex_comp++];
+    y = face->tristrip_vertices[vertex_comp++];
+    z = face->tristrip_vertices[vertex_comp++];
+    hidgl_add_vertex_3D_tex (gc, x, y, z, 0.0, 0.0);
+  }
+#endif
+#endif
+
+//  hidgl_flush_triangles (hidgl);
+  emit_tristrip (face);
+
+//  glDisable(GL_AUTO_NORMAL); /* Quick hack test */
+}
diff --git a/src/hid/common/face3d_gl.h b/src/hid/common/face3d_gl.h
new file mode 100644
index 0000000..f3599c8
--- /dev/null
+++ b/src/hid/common/face3d_gl.h
@@ -0,0 +1 @@
+void face3d_fill (hidGC gc, face3d *face, bool selected);
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index a90a51e..51990bc 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -74,7 +74,6 @@
 #   include <GL/gl.h>
 #endif
 
-
 static Coord board_thickness;
 #define HACK_BOARD_THICKNESS board_thickness
 //#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
@@ -83,14 +82,6 @@ static Coord board_thickness;
 #define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
 #define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
 
-static GList *object3d_test_objects = NULL;
-
-void
-object3d_test_init (void)
-{
-  object3d_test_objects = object3d_from_board_outline ();
-}
-
 object3d *
 make_object3d (char *name)
 {
@@ -139,348 +130,6 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
-                       {1., 1., 0.},
-                       {0., 1., 0.},
-                       {0., 1., 1.},
-                       {0.5, 0., 0.},
-                       {0.5, 0.5, 0.},
-                       {0., 0.5, 0.},
-                       {0., 0.5, 0.5},
-                       {1., 0.5, 0.5},
-                       {1., 1., 0.5},
-                       {0.5, 1., 0.5},
-                       {0.5, 1., 1.}};
-
-
-#define CIRC_SEGS_D 64.0
-
-
-static void
-evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
-{
-//  info->
-}
-
-static void
-draw_bspline (edge_ref e)
-{
-  edge_info *info = UNDIR_DATA(e);
-  double x1, y1, z1;
-  double x2, y2, z2;
-  double lx, ly, lz;
-  double x, y, z;
-  int i;
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  glBegin (GL_LINES);
-
-#if 0
-  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-#endif
-
-  /* Just draw the control points for now... */
-  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
-    {
-      x = info->control_points[i * 3 + 0];
-      y = info->control_points[i * 3 + 1];
-      z = info->control_points[i * 3 + 2];
-
-      if (i > 0)
-        {
-          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
-          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
-        }
-    }
-
-  glEnd ();
-}
-
-static void
-draw_quad_edge (edge_ref e, void *data)
-{
-  double x1, y1, z1;
-  double x2, y2, z2;
-  int i;
-  bool debug = GPOINTER_TO_INT (data);
-
-#if 0
-  int id = ID(e) % 12;
-
-  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
-#else
-  glColor4f (1., 1., 1., 0.3);
-#endif
-
-  x1 = ((vertex3d *)ODATA(e))->x;
-  y1 = ((vertex3d *)ODATA(e))->y;
-  z1 = ((vertex3d *)ODATA(e))->z;
-
-  x2 = ((vertex3d *)DDATA(e))->x;
-  y2 = ((vertex3d *)DDATA(e))->y;
-  z2 = ((vertex3d *)DDATA(e))->z;
-
-  if (UNDIR_DATA(e) != NULL)
-    {
-      edge_info *info = UNDIR_DATA(e);
-
-
-//        if (info->is_placeholder)
-        if (debug)
-          {
-            glColor4f (1.0, 0.0, 0.0, 1.0);
-            glDepthMask (TRUE);
-          }
-
-//      if (info->is_stitch)
-//        return;
-
-      if (info->is_bspline)
-        {
-          draw_bspline (e);
-          return;
-        }
-
-      if (info->is_round)
-        {
-          int i;
-          double cx, cy, cz;
-          double nx, ny, nz;
-          double refx, refy, refz;
-          double endx, endy, endz;
-          double ortx, orty, ortz;
-          double cosa;
-          double sina;
-          double recip_length;
-          double da;
-          int segs;
-          double angle_step;
-
-          cx = ((edge_info *)UNDIR_DATA(e))->cx;
-          cy = ((edge_info *)UNDIR_DATA(e))->cy;
-          cz = ((edge_info *)UNDIR_DATA(e))->cz;
-
-          nx = ((edge_info *)UNDIR_DATA(e))->nx;
-          ny = ((edge_info *)UNDIR_DATA(e))->ny;
-          nz = ((edge_info *)UNDIR_DATA(e))->nz;
-
-          /* XXX: Do this without breaking abstraction? */
-          /* Detect SYM edges, reverse the circle normal */
-          if ((e & 2) == 2)
-            {
-#if 0
-              /* Option 1, just draw the forward copy, which agrees with the normal */
-              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
-              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
-              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
-
-              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
-              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
-              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
-#else
-              /* Option 2, flip the normal */
-              nx = -nx;
-              ny = -ny;
-              nz = -nz;
-#endif
-            }
-
-          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
-           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
-           */
-          refx = x1 - cx;
-          refy = y1 - cy;
-          refz = z1 - cz;
-
-          /* Normalise refx */
-          recip_length = 1. / hypot (hypot (refx, refy), refz);
-          refx *= recip_length;
-          refy *= recip_length;
-          refz *= recip_length;
-
-          endx = x2 - cx;
-          endy = y2 - cy;
-          endz = z2 - cz;
-
-          /* Normalise endx */
-          recip_length = 1. / hypot (hypot (endx, endy), endz);
-          endx *= recip_length;
-          endy *= recip_length;
-          endz *= recip_length;
-
-          /* ref cross normal */
-          /* ort will be orthogonal to normal and ref vector */
-          ortx = ny * refz - nz * refy;
-          orty = nz * refx - nx * refz;
-          ortz = nx * refy - ny * refx;
-
-          /* Cosine is dot product of ref (normalised) and end (normalised) */
-          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
-          /* Sine is dot product of ort (normalised) and end (normalised) */
-          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
-
-          if (x1 == x2 &&
-              y1 == y2 &&
-              z1 == z2)
-            {
-              da = 2.0 * M_PI;
-            }
-          else
-            {
-              /* Delta angled */
-              da = atan2 (sina, cosa);
-
-              if (da < 0.0)
-                da += 2.0 * M_PI;
-            }
-
-#if 0
-          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
-          printf ("end (%f, %f, %f)\n", endx, endy, endz);
-          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
-          printf ("n (%f, %f, %f)\n", nx, ny, nz);
-          printf ("cosa %f, sina %f\n", cosa, sina);
-          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
-#endif
-
-          /* Scale up ref and ort to the actual vector length */
-          refx *= info->radius;
-          refy *= info->radius;
-          refz *= info->radius;
-
-          ortx *= info->radius;
-          orty *= info->radius;
-          ortz *= info->radius;
-
-          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
-          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
-          segs = MAX(segs, 1);
-          angle_step = da / (double)segs;
-
-          glBegin (GL_LINES);
-
-          for (i = 0; i < segs; i++)
-            {
-              cosa = cos (i * angle_step);
-              sina = sin (i * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-
-              cosa = cos ((i + 1) * angle_step);
-              sina = sin ((i + 1) * angle_step);
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
-                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
-                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
-            }
-
-          glEnd ();
-
-          glDepthMask (FALSE);
-          return;
-        }
-    }
-
-//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
-  glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, x1),
-              STEP_Y_TO_COORD (PCB, y1),
-              STEP_X_TO_COORD (PCB, z1));
-  glVertex3f (STEP_X_TO_COORD (PCB, x2),
-              STEP_Y_TO_COORD (PCB, y2),
-              STEP_X_TO_COORD (PCB, z2));
-  glEnd ();
-  glDepthMask (FALSE);
-}
-
-static void
-draw_contour (contour3d *contour, void *data)
-{
-  edge_ref e;
-  bool debug = GPOINTER_TO_INT (data);
-  int edge_no = 0;
-
-  e = contour->first_edge;
-
-//  printf ("Drawing contour\n");
-
-  do
-    {
-      edge_info *info = UNDIR_DATA(e);
-//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
-      draw_quad_edge (e, data);
-
-      /* Stop if e was the only edge in a face - which we re-trace */
-      /* XXX: Probably only a development bug until we get the quad-edge links correct */
-//      if (LNEXT(e) == SYM(e))
-//        break;
-
-      /* LNEXT should take us counter-clockwise around the face */
-      /* LPREV should take us clockwise around the face */
-    }
-  while ((e = LNEXT(e)) != contour->first_edge);
-}
-
-static int face_no;
-
-static void
-draw_face (face3d *face, void *data)
-{
-//  if (face->contours != NULL)
-//      draw_contour (face->contours->data, NULL);
-//  printf ("Drawing face\n");
-  g_list_foreach (face->contours, (GFunc)draw_contour, GINT_TO_POINTER(face_no == debug_integer));
-
-  face_no++;
-}
-
-void
-object3d_draw (object3d *object)
-{
-  g_return_if_fail (object->edges != NULL);
-
-//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
-//  printf ("BEGIN DRAW...\n");
-//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
-
-//  printf ("\nDrawing object\n");
-
-  face_no = 0;
-
-  g_list_foreach (object->faces, (GFunc)draw_face, NULL);
-
-//  printf ("....ENDED\n");
-}
-
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
-{
-  object3d_draw (object);
-}
-
-void
-object3d_draw_debug (void)
-{
-  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, NULL);
-}
-
 /*********************************************************************************************************/
 
 static int
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 3d228f6..4689664 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -8,9 +8,6 @@ typedef struct {
   void *user_data;
 } object3d;
 
-void object3d_test_init (void);
-void object3d_draw (object3d *object);
-void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
 void object3d_set_appearance (object3d *object, appearance *appear);
diff --git a/src/hid/common/object3d_gl.c b/src/hid/common/object3d_gl.c
new file mode 100644
index 0000000..c2c25a6
--- /dev/null
+++ b/src/hid/common/object3d_gl.c
@@ -0,0 +1,492 @@
+/* TODO ITEMS:
+ *
+ * Add PLINE simplification operation to consolidate co-circular segments for reduced geometry output.
+ * Look at whether arc-* intersections can be re-constructed back to original geometry, not fall back to line-line.
+ * Work on snap-rounding any edge which passes through the pixel square containing an any vertex (or intersection).
+ * Avoid self-touching output in contours, where that self-touching instance creates two otherwise distinct contours or holes.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#include <glib.h>
+
+#include "data.h"
+#include "step_id.h"
+#include "quad.h"
+#include "vertex3d.h"
+#include "contour3d.h"
+#include "appearance.h"
+#include "face3d.h"
+#include "edge3d.h"
+#include "object3d.h"
+#include "polygon.h"
+#include "rats.h"
+
+#include "rtree.h"
+#include "rotate.h"
+
+#include "pcb-printf.h"
+#include "misc.h"
+#include "hid/hidint.h"
+
+#define PERFECT_ROUND_CONTOURS
+#define SUM_PINS_VIAS_ONCE
+#define HASH_OBJECTS
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+//#undef REVERSED_PCB_CONTOURS
+
+#ifdef REVERSED_PCB_CONTOURS
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
+
+#ifndef WIN32
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#   define GL_GLEXT_PROTOTYPES 1
+#endif
+
+#ifdef HAVE_OPENGL_GL_H
+#   include <OpenGL/gl.h>
+#else
+#   include <GL/gl.h>
+#endif
+
+#include "hid_draw.h"
+#include "hidgl.h"
+#include "face3d_gl.h"
+#include "object3d_gl.h"
+
+//static Coord board_thickness;
+#define HACK_BOARD_THICKNESS board_thickness
+//#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
+#define HACK_COPPER_THICKNESS MM_TO_COORD(0.035)
+#define HACK_PLATED_BARREL_THICKNESS MM_TO_COORD(0.08)
+#define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
+#define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
+
+static GList *object3d_test_objects = NULL;
+
+void
+object3d_test_init (void)
+{
+  object3d_test_objects = object3d_from_board_outline ();
+}
+
+float colors[12][3] = {{1., 0., 0.},
+                       {1., 1., 0.},
+                       {0., 1., 0.},
+                       {0., 1., 1.},
+                       {0.5, 0., 0.},
+                       {0.5, 0.5, 0.},
+                       {0., 0.5, 0.},
+                       {0., 0.5, 0.5},
+                       {1., 0.5, 0.5},
+                       {1., 1., 0.5},
+                       {0.5, 1., 0.5},
+                       {0.5, 1., 1.}};
+
+
+#define CIRC_SEGS_D 64.0
+
+
+struct draw_info {
+  hidGC gc;
+  bool selected;
+  bool debug_face;
+};
+
+
+static void
+evaluate_bspline (edge_info *info, double u, double *x, double *y, double *z)
+{
+//  info->
+}
+
+static void
+draw_bspline (edge_ref e)
+{
+  edge_info *info = UNDIR_DATA(e);
+#if 0
+  double x1, y1, z1;
+  double x2, y2, z2;
+#endif
+  double lx, ly, lz;
+  double x, y, z;
+  int i;
+
+#if 0
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+#endif
+
+  glBegin (GL_LINES);
+
+#if 0
+  for (i = 0; i < 20; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      evaluate_bspline (edge_info, i / 20.0, &x, &y, &z);
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+#endif
+
+  /* Just draw the control points for now... */
+  for (i = 0; i < info->num_control_points; i++, lx = x, ly = y, lz = z) /* Pieces */
+    {
+      x = info->control_points[i * 3 + 0];
+      y = info->control_points[i * 3 + 1];
+      z = info->control_points[i * 3 + 2];
+
+      if (i > 0)
+        {
+          glVertex3f (STEP_X_TO_COORD (PCB, lx), STEP_Y_TO_COORD (PCB, ly), STEP_Z_TO_COORD (PCB, lz));
+          glVertex3f (STEP_X_TO_COORD (PCB,  x), STEP_Y_TO_COORD (PCB,  y), STEP_Z_TO_COORD (PCB,  z));
+        }
+    }
+
+  glEnd ();
+}
+
+static void
+draw_quad_edge (edge_ref e, void *data)
+{
+  struct draw_info *d_info = data;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  int i;
+  bool debug = GPOINTER_TO_INT (data);
+
+#if 0
+  int id = ID(e) % 12;
+
+  glColor3f (colors[id][0], colors[id][1], colors[id][2]);
+#else
+  if (d_info->selected)
+    glColor4f (0.0, 1.0, 1., 0.5);
+  else
+    glColor4f (1., 1., 1., 0.3);
+#endif
+
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
+  if (UNDIR_DATA(e) != NULL)
+    {
+      edge_info *info = UNDIR_DATA(e);
+
+
+        if (!d_info->selected &&
+            (info->is_placeholder ||
+            d_info->debug_face))
+          {
+            glColor4f (1.0, 0.0, 0.0, 1.0);
+            glDepthMask (TRUE);
+          }
+
+//      if (info->is_stitch)
+//        return;
+
+      if (info->is_bspline)
+        {
+          draw_bspline (e);
+          return;
+        }
+
+      if (info->is_round)
+        {
+          int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          if ((e & 2) == 2)
+            {
+#if 0
+              /* Option 1, just draw the forward copy, which agrees with the normal */
+              x1 = ((vertex3d *)ODATA(SYM(e)))->x;
+              y1 = ((vertex3d *)ODATA(SYM(e)))->y;
+              z1 = ((vertex3d *)ODATA(SYM(e)))->z;
+
+              x2 = ((vertex3d *)DDATA(SYM(e)))->x;
+              y2 = ((vertex3d *)DDATA(SYM(e)))->y;
+              z2 = ((vertex3d *)DDATA(SYM(e)))->z;
+#else
+              /* Option 2, flip the normal */
+              nx = -nx;
+              ny = -ny;
+              nz = -nz;
+#endif
+            }
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
+          glBegin (GL_LINES);
+
+          for (i = 0; i < segs; i++)
+            {
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+            }
+
+          glEnd ();
+
+//          glDepthMask (FALSE);
+          return;
+        }
+    }
+
+//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+  glBegin (GL_LINES);
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
+  glEnd ();
+//  glDepthMask (FALSE);
+}
+
+static void
+draw_contour (contour3d *contour, void *data)
+{
+//  struct draw_info *info = data;
+  edge_ref e;
+  int edge_no = 0;
+
+  e = contour->first_edge;
+
+//  printf ("Drawing contour\n");
+
+  do
+    {
+      edge_info *info = UNDIR_DATA(e);
+//      printf ("Edge %i: %p (%i%s)\n", edge_no++, e, info->edge_identifier, ((e & 2) == 2) ? "R" : "");
+      draw_quad_edge (e, data);
+
+      /* Stop if e was the only edge in a face - which we re-trace */
+      /* XXX: Probably only a development bug until we get the quad-edge links correct */
+//      if (LNEXT(e) == SYM(e))
+//        break;
+
+      /* LNEXT should take us counter-clockwise around the face */
+      /* LPREV should take us clockwise around the face */
+    }
+  while ((e = LNEXT(e)) != contour->first_edge);
+}
+
+static int face_no;
+
+static void
+draw_face_edges (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  info->debug_face = (face_no == debug_integer);
+  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+static void
+draw_face (face3d *face, void *data)
+{
+  struct draw_info *info = data;
+
+  face->is_debug = (face_no == debug_integer);
+  face3d_fill (info->gc, face, info->selected);
+//  face3d_fill (info->gc, face, (face_no == debug_integer));
+
+//  info->debug_face = (face_no == debug_integer);
+//
+//  return;
+//
+//  if (face->contours != NULL)
+//      draw_contour (face->contours->data, info);
+//  printf ("Drawing face\n");
+//  g_list_foreach (face->contours, (GFunc)draw_contour, info);
+
+  face_no++;
+}
+
+void
+object3d_draw (hidGC gc, object3d *object, bool selected)
+{
+  struct draw_info info;
+
+//  hidglGC hidgl_gc = (hidglGC)gc;
+//  hidgl_instance *hidgl = hidgl_gc->hidgl;
+//  hidgl_priv *priv = hidgl->priv;
+
+  g_return_if_fail (object->edges != NULL);
+
+  info.gc = gc;
+  info.selected = selected;
+
+//  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
+//  g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+
+//  printf ("\nDrawing object\n");
+
+  glDisable(GL_LIGHTING); /* XXX: HACK */
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face_edges, &info);
+
+  glEnable(GL_LIGHTING); /* XXX: HACK */
+
+  face_no = 0;
+  g_list_foreach (object->faces, (GFunc)draw_face, &info);
+
+//  printf ("....ENDED\n");
+}
+
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  hidGC gc = user_data;
+
+  object3d_draw (gc, object, false);
+}
+
+void
+object3d_draw_debug (hidGC gc)
+{
+  g_list_foreach (object3d_test_objects, (GFunc)object3d_draw_debug_single, gc);
+}
diff --git a/src/hid/common/object3d_gl.h b/src/hid/common/object3d_gl.h
new file mode 100644
index 0000000..cbf5d1a
--- /dev/null
+++ b/src/hid/common/object3d_gl.h
@@ -0,0 +1,3 @@
+void object3d_test_init (void);
+void object3d_draw (hidGC gc, object3d *object, bool selected);
+void object3d_draw_debug (hidGC gc);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fce8341..5529f5b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -54,6 +54,8 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #include "hid/common/draw_helpers.h"
 #include "hid/common/trackball.h"
 
+#include "hid/common/object3d_gl.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -2117,7 +2119,7 @@ via_hole_cyl_callback (const BoxType * b, void *cl)
 }
 
 static void
-hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
+hidgl_draw_step_model_instance (struct assembly_model_instance *instance, bool selected)
 {
   render_priv *priv = gport->render_priv;
   step_model *step_model = instance->model->step_model;
@@ -2177,7 +2179,7 @@ hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
                 -STEP_TO_COORD_Y (PCB, step_model->oy),
                 -STEP_TO_COORD_Z (PCB, step_model->oz));
 
-  object3d_draw (step_model->object);
+  object3d_draw (Output.fgGC, step_model->object, selected);
 
   hidgl_flush_triangles (priv->hidgl);
 
@@ -2195,7 +2197,7 @@ E_package_callback (const BoxType * b, void *cl)
 
   if (element->assembly_model_instance != NULL)
     {
-      hidgl_draw_step_model_instance (element->assembly_model_instance);
+      hidgl_draw_step_model_instance (element->assembly_model_instance, TEST_FLAG (SELECTEDFLAG, element));
     }
 
   if (FRONT (element))
@@ -2771,22 +2773,27 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     hidgl_flush_triangles (priv->hidgl);
   }
 
-//  glEnable (GL_LIGHTING);
+  glEnable (GL_LIGHTING);
 
   glShadeModel (GL_SMOOTH);
 
-//  glEnable (GL_LIGHT0);
+  glEnable (GL_LIGHT0);
 
   /* XXX: FIX OUR NORMALS */
-  glEnable (GL_NORMALIZE);
+//  glEnable (GL_NORMALIZE);
 //  glEnable (GL_RESCALE_NORMAL);
 
   glDepthFunc (GL_LESS);
   glDisable (GL_STENCIL_TEST);
 
-  glEnable (GL_CULL_FACE);
+  glEnable (GL_CULL_FACE); /* XXX: Fix model face filling */
   glCullFace (GL_BACK);
 
+  glEnable (GL_COLOR_MATERIAL);
+
+  // Front material ambient and diffuse colors track glColor
+  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
+
   if (1) {
     GLfloat global_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};
     glLightModelfv (GL_LIGHT_MODEL_AMBIENT, global_ambient);
@@ -2808,12 +2815,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 //    GLfloat position[] = {0.5, -1., 1., 0.};
 //    GLfloat position[] = {0.0, -0.5, 1., 0.};
     GLfloat position[] = {0.0, 0.0, 1., 0.};
+//    GLfloat position[] = {0.0, 0.0, 10., 1.};
     GLfloat abspos = sqrt (position[0] * position[0] +
                            position[1] * position[1] +
                            position[2] * position[2]);
-    position[0] /= abspos;
-    position[1] /= abspos;
-    position[2] /= abspos;
+//    position[0] /= abspos;
+//    position[1] /= abspos;
+//    position[2] /= abspos;
     glPushMatrix ();
     glLoadIdentity ();
     glLightfv (GL_LIGHT0, GL_POSITION, position);
@@ -2821,7 +2829,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
 //  glDisable (GL_DEPTH_TEST); /* TEST */
-  glDepthMask (FALSE); /* TEST */
+//  glDepthMask (FALSE); /* TEST */
 
   if (!global_view_2d)
     ghid_draw_packages (&region);
@@ -2835,9 +2843,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-  //object3d_draw_debug ();
+  //object3d_draw_debug (Output.fgGC);
   if (step_read_test != NULL)
-    object3d_draw (step_read_test);
+    object3d_draw (Output.fgGC, step_read_test, false);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 35c5072..c543c57 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -97,8 +97,8 @@ typedef std::list<SdaiMapped_item *> mi_list;
 
 SdaiProduct_definition *
 read_model_from_file (Registry *registry,
-                        InstMgr *instance_list,
-                        const char *filename)
+                      InstMgr *instance_list,
+                      const char *filename)
 {
   STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
 
@@ -189,6 +189,23 @@ find_mapped_item (SdaiShape_representation *sr,
     }
 }
 
+static void
+unpack_axis_geom (SdaiAxis2_placement_3d *axis,
+                  double *ox, double *oy, double *oz,
+                  double *ax, double *ay, double *az,
+                  double *rx, double *ry, double *rz)
+{
+  *ox = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ())->value;
+  *oy = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+  *oz = ((RealNode *)axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *ax = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ay = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *az = ((RealNode *)axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+  *rx = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+  *ry = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+  *rz = ((RealNode *)axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+}
+
 typedef struct process_step_info {
   /* Hash / list of SR -> step_model */
   object3d *object;
@@ -364,7 +381,7 @@ transform_vector (double m[4][4], double *x, double *y, double *z)
 static double
 distance (double a[3], double b[3])
 {
-  return hypot(hypot(a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
+  return hypot (hypot (a[0] - b[0], a[1] - b[1]), a[2] - b[2]);
 }
 
 static void
@@ -375,7 +392,7 @@ process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, proce
    */
 
   edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
-  our_edge_info->is_placeholder = true; /* Highlight for now */
+//  our_edge_info->is_placeholder = true; /* Highlight for now */
 
   SDAI_Application_instance *entity = start_entity;
   STEPcomplex *stepcomplex = NULL;
@@ -803,10 +820,7 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
       SdaiCurve *curve = ec->edge_geometry_ ();
       bool same_sense = ec->same_sense_ ();
 
-#ifdef DEBUG_NOT_IMPLEMENTED
-//          if (!same_sense)
-//            printf ("XXX: HAVE NOT TESTED THIS CASE.... same_sense is false\n");
-#endif
+      our_edge_info->same_sense = same_sense;
 
 #if 0
       printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
@@ -844,7 +858,44 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
 
           transform_vector (info->current_transform, &nx, &ny, &nz);
 
-          if (orientation)
+          if (orientation) // NOT REQUIRED, SINCE WE ADDED same_sense to the edge info ----> (orientation == same_sense)
+            {
+              edge_info_set_round (our_edge_info, cx, cy, cz, nx, ny, nz, radius);
+            }
+          else
+            {
+              edge_info_set_round (our_edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
+            }
+
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
+        }
+      else if (strcmp (curve->EntityName (), "Ellipse") == 0)
+        {
+          SdaiEllipse *ellipse = (SdaiEllipse *)curve;
+          double cx = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+          double cy = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+          double cz = ((RealNode *)ellipse->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          double nx = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+          double ny = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          double nz = ((RealNode *)ellipse->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+          our_edge_info->is_placeholder = true;
+#if 0 /* NOT YET IMPLEMENTED */
+          double radius = circle->radius_();
+
+          transform_vertex (info->current_transform, &cx, &cy, &cz);
+
+          transform_vector (info->current_transform, &nx, &ny, &nz);
+
+          if (orientation) // NOT REQUIRED, SINCE WE ADDED same_sense to the edge info ----> (orientation == same_sense)
             {
               edge_info_set_round (our_edge_info, cx, cy, cz, nx, ny, nz, radius);
             }
@@ -852,6 +903,7 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
             {
               edge_info_set_round (our_edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
             }
+#endif
 
           object3d_add_edge (info->object, our_edge);
           vertex = make_vertex3d (x1, y1, z1);
@@ -887,6 +939,18 @@ process_edge_geometry (SdaiEdge *edge, bool orientation, edge_ref our_edge, proc
           // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
           // XXX: Various derived types of the above, e.g.:
           //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+
+          transform_vertex (info->current_transform, &x1, &y1, &z1);
+          transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+          our_edge_info->is_placeholder = true;
+
+          object3d_add_edge (info->object, our_edge);
+          vertex = make_vertex3d (x1, y1, z1);
+          ODATA(our_edge) = vertex;
+          vertex = make_vertex3d (x2, y2, z2);
+          DDATA(our_edge) = vertex;
+
           return;
         }
 
@@ -940,7 +1004,9 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
   srr_list srr_list;
 
   // Find all SHAPE_REPRESENTATION_RELATIONSHIP with rep_1 = sr
-  find_all_srr_with_rep_1 (instance_list, &srr_list, 0, sr);
+  find_all_srr_with_rep_1_or_2 (instance_list, &srr_list, 0, sr);
+
+  bool processed_any = false;
 
   for (srr_list::iterator iter = srr_list.begin (); iter != srr_list.end (); iter++)
     {
@@ -949,22 +1015,34 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
 
       SdaiShape_representation *child_sr = dynamic_cast<SdaiShape_representation *>(srr->rep_2_ ());
 
+      /* Catch the silly case where the model confuses rep_1 and rep_2 */
+      if (child_sr == sr)
+        child_sr = dynamic_cast<SdaiShape_representation *>(srr->rep_1_ ());
+
       /* XXX: Actually only want to "process" the SR once per SR, then create _instances_ of it */
       /* XXX: Do something with the result */
       // Leave existing transformation
       process_sr_or_subtype (instance_list, child_sr, info);
+      processed_any = true;
     }
 
+  /* Kludge... don't look for the complex transformed relationships if we already found a simple one. */
+  if (processed_any)
+    return step_model;
 
   srr_rrwt_list srr_rrwt_list;
 
   // Find all SHAPE_REPRESENTATION_RELATIONSHIP with rep_1 = sr
-  find_all_srr_rrwt_with_rep_1 (instance_list, &srr_rrwt_list, 0, sr);
+  find_all_srr_rrwt_with_rep_1_or_2 (instance_list, &srr_rrwt_list, 0, sr);
 
   /* XXX: Encountered some models where the child was rep1, the parent rep2??.
    *      E.g. from Samtec, ERM5-075-02.0-L-DV-TR.stp
    */
 
+  /* XXX: Should probably use the NAUO stuff to figure out and follow the assembly structure,
+   *      not just guess at what to include based upon finding SHAPE_REPRESENTATION_RELATIONSHIPs.
+   */
+
   for (srr_rrwt_list::iterator iter = srr_rrwt_list.begin (); iter != srr_rrwt_list.end (); iter++)
     {
       double backup_transform[4][4];
@@ -984,8 +1062,16 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
 
       copy_4x4 (info->current_transform, backup_transform);
 
-      child_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_1_());
-      parent_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_2_());
+      if (item->forwards)
+        {
+          child_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_1_());
+          parent_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_2_());
+        }
+      else
+        {
+          child_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_2_());
+          parent_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_1_());
+        }
 
       if (parent_axis == NULL ||
           child_axis == NULL)
@@ -994,15 +1080,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("child axis o: (%f, %f, %f)\n"
@@ -1019,15 +1097,7 @@ process_shape_representation(InstMgr *instance_list, SdaiShape_representation *s
       /* Is this in the correct order? */
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
 #ifdef DEBUG_TRANSFORMS
       printf ("parent axis o: (%f, %f, %f)\n"
@@ -1159,16 +1229,18 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
 
           /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
-          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          //SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
           /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
           SdaiFace_surface *fs = (SdaiFace_surface *) face;
 
           SdaiSurface *surface = fs->face_geometry_ ();
-
 #if 0
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
 
+          info->current_face = make_face3d ((char *)"");
+          object3d_add_face (info->object, info->current_face);
+
           if (surface->IsComplex ())
             {
 #ifdef DEBUG_NOT_IMPLEMENTED
@@ -1177,15 +1249,105 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Plane") == 0)
             {
+              SdaiPlane *plane = dynamic_cast<SdaiPlane *>(surface);
+
 //              printf ("WARNING: planar surfaces are not supported yet\n");
+
+              unpack_axis_geom (plane->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_planar = true;
+
+              info->current_face->nx = info->current_face->ax;
+              info->current_face->ny = info->current_face->ay;
+              info->current_face->nz = info->current_face->az;
+
+              if (!fs->same_sense_ ())
+                {
+                  info->current_face->nx = -info->current_face->nx;
+                  info->current_face->ny = -info->current_face->ny;
+                  info->current_face->nz = -info->current_face->nz;
+
+                  /* XXX: Could use face->surface_orientation_reversed ? */
+//                  printf ("Not same sense, flipping normal\n");
+                }
+
+              info->current_face->surface_orientation_reversed = false;
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
-//              printf ("WARNING: cylindrical suraces are not supported yet\n");
+              SdaiCylindrical_surface *cylinder = dynamic_cast<SdaiCylindrical_surface *>(surface);
+//              printf ("WARNING: cylindrical surfaces are not supported yet\n");
+
+              unpack_axis_geom (cylinder->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_cylindrical = true;
+              info->current_face->radius = cylinder->radius_ ();
+
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
+                {
+                  info->current_face->surface_orientation_reversed = true;
+                }
+
+            }
+          else if (strcmp (surface->EntityName (), "Conical_Surface") == 0)
+            {
+//              printf ("WARNING: conical surfaces are not supported yet\n");
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
             {
-//              printf ("WARNING: toroidal suraces are not supported yet\n");
+//              printf ("WARNING: toroidal surfaces are not supported yet\n");
             }
           else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
             {
@@ -1198,14 +1360,12 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 #endif
             }
 
-          info->current_face = make_face3d ((char *)"");
-          object3d_add_face (info->object, info->current_face);
-
           for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
                iter != NULL;
                iter = iter->NextNode ())
             {
               SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
+              bool face_bound_orientation = fb->orientation_ ();
 
 #if 0
               bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
@@ -1329,7 +1489,10 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 
                       if (first_edge_of_contour == 0)
                         {
-                          info->current_contour = make_contour3d (our_edge);
+                          if (face_bound_orientation)
+                            info->current_contour = make_contour3d (our_edge);
+                          else
+                            info->current_contour = make_contour3d (SYM(our_edge));
                           face3d_add_contour (info->current_face, info->current_contour);
                           first_edge_of_contour = our_edge;
                         }
@@ -1346,24 +1509,22 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
 
                       if (previous_edge_of_contour != 0)
                         {
-                          /* XXX: Hopefully link up the edges around this face contour */
-//                          debug_edge (our_edge, "before splice");
-//                          splice (SYM(previous_edge_of_contour), our_edge);
-                          splice (our_edge, OPREV(SYM(previous_edge_of_contour)));
-//                          splice (previous_edge_of_contour, SYM(our_edge));
-//                          debug_edge (our_edge, "after splice");
+                          /* Link up the edges around this face contour */
+                          if (face_bound_orientation)
+                            splice (our_edge, OPREV(SYM(previous_edge_of_contour)));
+                          else
+                            splice (OPREV(our_edge), SYM(previous_edge_of_contour));
                         }
 
                       /* Stash reference to this edge for linking next time */
                       previous_edge_of_contour = our_edge;
                     }
 
-                  /* XXX: Hopefully link up the edges around this face contour */
-//                  debug_edge (first_edge_of_contour, "before splice");
-//                  splice (SYM(previous_edge_of_contour), first_edge_of_contour);
-                  splice (first_edge_of_contour, OPREV(SYM(previous_edge_of_contour)));
-//                  splice (previous_edge_of_contour, SYM(first_edge_of_contour));
-//                  debug_edge (first_edge_of_contour, "after splice");
+                  /* Link up the edges around this face contour */
+                  if (face_bound_orientation)
+                    splice (first_edge_of_contour, OPREV(SYM(previous_edge_of_contour)));
+                  else
+                    splice (OPREV(first_edge_of_contour), SYM(previous_edge_of_contour));
                 }
               else
                 {
@@ -1441,29 +1602,13 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           continue;
         }
 
-      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (child_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       /* XXX: Looking only at the target vector.. need to find some examples where the parent transform coordinate system is not unity to get this correct */
       rotate_basis (info->current_transform, ax, ay, az, rx, ry, rz);
       translate_origin (info->current_transform, ox, oy, oz);
 
-      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
-      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
-      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
-      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
-      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
-      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
-      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      unpack_axis_geom (parent_axis, &ox, &oy, &oz, &ax, &ay, &az, &rx, &ry, &rz);
 
       translate_origin (info->current_transform, -ox, -oy, -oz);
       rotate_basis_inverted (info->current_transform, ax, ay, az, rx, ry, rz);
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
index 9b78fc9..eeb73e0 100644
--- a/src/hid/step/object3d_step.c
+++ b/src/hid/step/object3d_step.c
@@ -291,7 +291,7 @@ object3d_to_step_body_fragment (step_file *step,
       step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
 
       /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
-      info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+      info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, info->same_sense);
       step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
       step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
     }
diff --git a/src/hid/step/utils.cpp b/src/hid/step/utils.cpp
index caab465..564567f 100644
--- a/src/hid/step/utils.cpp
+++ b/src/hid/step/utils.cpp
@@ -292,7 +292,7 @@ find_axis2_placement_3d_in_sr (SdaiShape_representation *sr)
 }
 
 void
-find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *rep_1)
+find_all_srr_with_rep_1_or_2( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *desired)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
   int search_index;
@@ -308,9 +308,9 @@ find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_a
                                instance_list->GetApplication_instance ("Shape_representation_relationship", search_index)))
     {
       SdaiRepresentation *found_rep_1 = srr->rep_1_ ();
-#ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
+//#ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
       SdaiRepresentation *found_rep_2 = srr->rep_2_ ();
-#endif
+//#endif
 
       if (srr->IsComplex())
         {
@@ -318,7 +318,8 @@ find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_a
           return;
         }
 
-      if (found_rep_1 == rep_1)
+      if (found_rep_1 == desired ||
+          found_rep_2 == desired)
         srr_list->push_back (srr);
 
 #ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
@@ -335,7 +336,7 @@ find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_a
 }
 
 void
-find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *rep_1)
+find_all_srr_rrwt_with_rep_1_or_2( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *desired)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
   int search_index;
@@ -433,7 +434,8 @@ find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_li
       std::cout << std::endl;
 #endif
 
-      if (found_rep_1 == rep_1 &&
+#if 1
+      if (found_rep_1 == desired &&
           found_srr &&
           found_rrwt)
         {
@@ -441,9 +443,27 @@ find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_li
 
           item->rep_2 = found_rep_2;
           item->idt = idt;
+          item->forwards = true;
+
+          srr_rrwt_list->push_back (item);
+        }
+#endif
+
+#if 1
+      /* Model is confused about rep1 / rep2 case */
+      if (found_rep_2 == desired &&
+          found_srr &&
+          found_rrwt)
+        {
+          srr_rrwt *item = new srr_rrwt;
+
+          item->rep_2 = found_rep_1;
+          item->idt = idt;
+          item->forwards = false;
 
           srr_rrwt_list->push_back (item);
         }
+#endif
 
       int id = entity->StepFileId ();
       MgrNode * mnode = instance_list->FindFileId (id);
diff --git a/src/hid/step/utils.h b/src/hid/step/utils.h
index 1ae2f18..432ff33 100644
--- a/src/hid/step/utils.h
+++ b/src/hid/step/utils.h
@@ -29,6 +29,7 @@
 typedef struct srr_rrwt {
   SdaiRepresentation *rep_2;
   SdaiItem_defined_transformation *idt;
+  bool forwards;
 } srr_rrwt;
 
 typedef std::list<SdaiProduct_definition *> pd_list;
@@ -50,5 +51,5 @@ SdaiShape_representation *find_sr_for_pd (InstMgr *instance_list, SdaiProduct_de
 
 SdaiAxis2_placement_3d *find_axis2_placement_3d_in_sr (SdaiShape_representation *sr);
 
-void find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *rep_1);
-void find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *rep_1);
+void find_all_srr_with_rep_1_or_2( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *desired);
+void find_all_srr_rrwt_with_rep_1_or_2( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *desired);
diff --git a/src/sweep.h b/src/sweep.h
index e8f138f..644d70b 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,6 +1,7 @@
 #include "borast/borast-traps-private.h"
 
 borast_status_t bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps);
+borast_status_t bo_poly_to_traps_no_draw (POLYAREA *poly, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps);
 borast_status_t bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps);
 borast_fixed_t _line_compute_intersection_x_for_y (const borast_line_t *line, borast_fixed_t y);
