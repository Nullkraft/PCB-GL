Bottom: 82a7c1730a00e4a486240daf71840c6fab0a8f92
Top:    ffb3f7dcdb01a250a7db686d7bae0b0f7a714c98
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-29 23:19:48 +0100

hid/gerber: Don't use the core's drawing functions


---

diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index b9830e6..557a3ba 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -25,6 +25,7 @@
 #include "error.h"
 #include "draw.h"
 #include "pcb-printf.h"
+#include "print.h"
 
 #include "hid.h"
 #include "hid_draw.h"
@@ -46,7 +47,7 @@
 static HID_Attribute * gerber_get_export_options (int *n);
 static void gerber_do_export (HID_Attr_Val * options);
 static void gerber_parse_arguments (int *argc, char ***argv);
-static int gerber_set_layer (const char *name, int group, int empty);
+static bool set_layer (const char *name, int group);
 static hidGC gerber_make_gc (void);
 static void gerber_destroy_gc (hidGC gc);
 static void gerber_use_mask (enum mask_mode mode);
@@ -309,7 +310,6 @@ static int lncount = 0;
 static int finding_apertures = 0;
 static int pagecount = 0;
 static int linewidth = -1;
-static int lastgroup = -1;
 static int lastcap = -1;
 static int print_group[MAX_LAYER];
 static int print_layer[MAX_LAYER];
@@ -406,26 +406,6 @@ gerber_get_export_options (int *n)
   return gerber_options;
 }
 
-static int
-group_for_layer (int l)
-{
-  if (l < max_copper_layer + 2 && l >= 0)
-    return GetLayerGroupNumberByNumber (l);
-  /* else something unique */
-  return max_group + 3 + l;
-}
-
-static int
-layer_sort (const void *va, const void *vb)
-{
-  int a = *(int *) va;
-  int b = *(int *) vb;
-  int d = group_for_layer (b) - group_for_layer (a);
-  if (d)
-    return d;
-  return b - a;
-}
-
 static void
 maybe_close_f (FILE *f)
 {
@@ -526,12 +506,88 @@ assign_file_suffix (char *dest, int idx)
 }
 
 static void
+gerber_expose (HID * hid, BoxType *drawn_area, void *item)
+{
+  int i;
+  int group;
+  int nplated, nunplated;
+
+  HID *old_gui = gui;
+  hidGC savebg = Output.bgGC;
+  hidGC savefg = Output.fgGC;
+  hidGC savepm = Output.pmGC;
+
+  gui = hid;
+  Output.fgGC = gui->graphics->make_gc ();
+  Output.bgGC = gui->graphics->make_gc ();
+  Output.pmGC = gui->graphics->make_gc ();
+
+  hid->graphics->set_color (Output.pmGC, "erase");
+  hid->graphics->set_color (Output.bgGC, "drill");
+
+  memset (print_group, 0, sizeof (print_group));
+  for (i = 0; i < max_copper_layer; i++)
+    {
+      LayerType *layer = PCB->Data->Layer + i;
+      print_group[GetLayerGroupNumberByNumber (i)] = all_layers || !IsLayerEmpty (layer);
+    }
+
+  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
+
+  /* draw all copper layer groups in group order */
+  for (group = 0; group < max_copper_layer; group++)
+    {
+      if (!print_group[group])
+        continue;
+
+      if (set_layer (0, group))
+        DrawLayerGroup (group, drawn_area);
+    }
+
+  CountHoles (&nplated, &nunplated, drawn_area);
+
+  if (nplated && set_layer ("plated-drill", SL (PDRILL, 0)))
+    DrawHoles (true, false, drawn_area);
+
+  if (nunplated && set_layer ("unplated-drill", SL (UDRILL, 0)))
+    DrawHoles (false, true, drawn_area);
+
+  if (set_layer ("componentmask", SL (MASK, TOP)))
+    DrawMask (COMPONENT_LAYER, drawn_area);
+
+  if (set_layer ("soldermask", SL (MASK, BOTTOM)))
+    DrawMask (SOLDER_LAYER, drawn_area);
+
+  if (set_layer ("topsilk", SL (SILK, TOP)))
+    DrawSilk (COMPONENT_LAYER, drawn_area);
+
+  if (set_layer ("bottomsilk", SL (SILK, BOTTOM)))
+    DrawSilk (SOLDER_LAYER, drawn_area);
+
+  if (set_layer ("toppaste", SL (PASTE, TOP)))
+    DrawPaste (COMPONENT_LAYER, drawn_area);
+
+  if (set_layer ("bottompaste", SL (PASTE, BOTTOM)))
+    DrawPaste (SOLDER_LAYER, drawn_area);
+
+  if (set_layer ("fab", SL (FAB, 0)))
+    PrintFab (Output.fgGC);
+
+  gui->graphics->destroy_gc (Output.fgGC);
+  gui->graphics->destroy_gc (Output.bgGC);
+  gui->graphics->destroy_gc (Output.pmGC);
+  gui = old_gui;
+  Output.fgGC = savefg;
+  Output.bgGC = savebg;
+  Output.pmGC = savepm;
+}
+
+static void
 gerber_do_export (HID_Attr_Val * options)
 {
   const char *fnbase;
   int i;
-  static int saved_layer_stack[MAX_LAYER];
-  int save_ons[MAX_LAYER + 2];
   FlagType save_thindraw;
 
   save_thindraw = PCB->Flags;
@@ -591,27 +647,22 @@ gerber_do_export (HID_Attr_Val * options)
   else
     {
       memset (print_group, 0, sizeof (print_group));
-      memset (print_layer, 0, sizeof (print_layer));
-    }
+      for (i = 0; i < max_copper_layer; i++)
+        {
+          LayerType *layer = PCB->Data->Layer + i;
+          print_group[GetLayerGroupNumberByNumber (i)] = !IsLayerEmpty (layer);
+        }
+      print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+      print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
 
-  hid_save_and_show_layer_ons (save_ons);
-  for (i = 0; i < max_copper_layer; i++)
-    {
-      LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
-	print_group[GetLayerGroupNumberByNumber (i)] = 1;
+      memset (print_layer, 0, sizeof (print_layer));
+      for (i = 0; i < max_copper_layer; i++)
+        if (print_group[GetLayerGroupNumberByNumber (i)])
+          print_layer[i] = 1;
     }
-  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
-  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
-  for (i = 0; i < max_copper_layer; i++)
-    if (print_group[GetLayerGroupNumberByNumber (i)])
-      print_layer[i] = 1;
 
-  memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
   linewidth = -1;
   lastcap = -1;
-  lastgroup = -1;
 
   region.X1 = 0;
   region.Y1 = 0;
@@ -621,20 +672,16 @@ gerber_do_export (HID_Attr_Val * options)
   pagecount = 1;
   resetApertures ();
 
-  lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  gerber_expose (&gerber_hid, &region, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
-
-  memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
+  gerber_expose (&gerber_hid, &region, 0);
 
   maybe_close_f (f);
   f = NULL;
-  hid_restore_layer_ons (save_ons);
   PCB->Flags = save_thindraw;
 }
 
@@ -657,26 +704,26 @@ drill_sort (const void *va, const void *vb)
   return a->y - b->y;
 }
 
-static int
-gerber_set_layer (const char *name, int group, int empty)
+static bool
+set_layer (const char *name, int group)
 {
+  time_t currenttime;
+  char utcTime[64];
+#ifdef HAVE_GETPWUID
+  struct passwd *pwentry;
+#endif
+  ApertureList *aptr_list;
+  Aperture *search;
+
   int want_outline;
   char *cp;
   int idx = (group >= 0
-	     && group <
-	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+             && group <
+             max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (name == NULL)
     name = PCB->Data->Layer[idx].Name;
 
-  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
-    return 0;
-
-  if (strcmp (name, "invisible") == 0)
-    return 0;
-  if (SL_TYPE (idx) == SL_ASSY)
-    return 0;
-
   flash_drills = 0;
   if (strcmp (name, "outline") == 0 ||
       strcmp (name, "route") == 0)
@@ -687,20 +734,20 @@ gerber_set_layer (const char *name, int group, int empty)
       int i;
       /* dump pending drills in sequence */
       qsort (pending_drills, n_pending_drills, sizeof (pending_drills[0]),
-	     drill_sort);
+             drill_sort);
       for (i = 0; i < n_pending_drills; i++)
-	{
-	  if (i == 0 || pending_drills[i].diam != pending_drills[i - 1].diam)
-	    {
-	      Aperture *ap = findAperture (curr_aptr_list, pending_drills[i].diam, ROUND);
-	      fprintf (f, "T%02d\r\n", ap->dCode);
-	    }
+        {
+          if (i == 0 || pending_drills[i].diam != pending_drills[i - 1].diam)
+            {
+              Aperture *ap = findAperture (curr_aptr_list, pending_drills[i].diam, ROUND);
+              fprintf (f, "T%02d\r\n", ap->dCode);
+            }
           /* Notice the last zeroes are literal zeroes here, a x10 scale factor.  *
            *                                                      v        v      */
-	  pcb_fprintf (f, metric ? "X%06.0muY%06.0mu\r\n" : "X%06.0ml0Y%06.0ml0\r\n",
-		   gerberDrX (PCB, pending_drills[i].x),
-		   gerberDrY (PCB, pending_drills[i].y));
-	}
+          pcb_fprintf (f, metric ? "X%06.0muY%06.0mu\r\n" : "X%06.0ml0Y%06.0ml0\r\n",
+                   gerberDrX (PCB, pending_drills[i].x),
+                   gerberDrY (PCB, pending_drills[i].y));
+        }
       free (pending_drills);
       n_pending_drills = max_pending_drills = 0;
       pending_drills = NULL;
@@ -709,127 +756,111 @@ gerber_set_layer (const char *name, int group, int empty)
   is_drill = (SL_TYPE (idx) == SL_PDRILL || SL_TYPE (idx) == SL_UDRILL);
   is_mask = (SL_TYPE (idx) == SL_MASK);
   current_mask = HID_MASK_OFF;
-#if 0
-  printf ("Layer %s group %d drill %d mask %d\n", name, group, is_drill,
-	  is_mask);
-#endif
 
-  if (group < 0 || group != lastgroup)
-    {
-      time_t currenttime;
-      char utcTime[64];
-#ifdef HAVE_GETPWUID
-      struct passwd *pwentry;
-#endif
-      ApertureList *aptr_list;
-      Aperture *search;
+  lastX = -1;
+  lastY = -1;
+  linewidth = -1;
+  lastcap = -1;
 
-      lastgroup = group;
-      lastX = -1;
-      lastY = -1;
-      linewidth = -1;
-      lastcap = -1;
+  aptr_list = setLayerApertureList (layer_list_idx++);
 
-      aptr_list = setLayerApertureList (layer_list_idx++);
+  if (finding_apertures)
+    goto emit_outline;
 
-      if (finding_apertures)
-	goto emit_outline;
+  if (aptr_list->count == 0 && !all_layers)
+    return 0;
 
-      if (aptr_list->count == 0 && !all_layers)
-	return 0;
+  maybe_close_f (f);
+  f = NULL;
 
-      maybe_close_f (f);
-      f = NULL;
+  pagecount++;
+  assign_file_suffix (filesuff, idx);
+  f = fopen (filename, "wb");   /* Binary needed to force CR-LF */
+  if (f == NULL) 
+    {
+      Message ( "Error:  Could not open %s for writing.\n", filename);
+      return 1;
+    }
 
-      pagecount++;
-      assign_file_suffix (filesuff, idx);
-      f = fopen (filename, "wb");   /* Binary needed to force CR-LF */
-      if (f == NULL) 
-	{
-	  Message ( "Error:  Could not open %s for writing.\n", filename);
-	  return 1;
-	}
+  was_drill = is_drill;
 
-      was_drill = is_drill;
+  if (verbose)
+    {
+      int c = aptr_list->count;
+      printf ("Gerber: %d aperture%s in %s\n", c,
+              c == 1 ? "" : "s", filename);
+    }
 
-      if (verbose)
-	{
-	  int c = aptr_list->count;
-	  printf ("Gerber: %d aperture%s in %s\n", c,
-		  c == 1 ? "" : "s", filename);
-	}
+  if (is_drill)
+    {
+      /* We omit the ,TZ here because we are not omitting trailing zeros.  Our format is
+         always six-digit 0.1 mil or µm resolution (i.e. 001100 = 0.11" or 1.1mm)*/
+      fprintf (f, "M48\r\n");
+      fprintf (f, metric ? "METRIC,000.000\r\n" : "INCH\r\n");
+      for (search = aptr_list->data; search; search = search->next)
+              pcb_fprintf (f, metric ? "T%02dC%.3`mm\r\n" : "T%02dC%.3`mi\r\n", search->dCode, search->width);
+      fprintf (f, "%%\r\n");
+      /* FIXME */
+      return 1;
+    }
 
-      if (is_drill)
-	{
-	  /* We omit the ,TZ here because we are not omitting trailing zeros.  Our format is
-	     always six-digit 0.1 mil or µm resolution (i.e. 001100 = 0.11" or 1.1mm)*/
-	  fprintf (f, "M48\r\n");
-	  fprintf (f, metric ? "METRIC,000.000\r\n" : "INCH\r\n");
-	  for (search = aptr_list->data; search; search = search->next)
-		  pcb_fprintf (f, metric ? "T%02dC%.3`mm\r\n" : "T%02dC%.3`mi\r\n", search->dCode, search->width);
-	  fprintf (f, "%%\r\n");
-	  /* FIXME */
-	  return 1;
-	}
+  fprintf (f, "G04 start of page %d for group %d idx %d *\r\n",
+           pagecount, group, idx);
 
-      fprintf (f, "G04 start of page %d for group %d idx %d *\r\n",
-	       pagecount, group, idx);
-
-      /* Create a portable timestamp. */
-      currenttime = time (NULL);
-      {
-	/* avoid gcc complaints */
-	const char *fmt = "%c UTC";
-	strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
-      }
-      /* Print a cute file header at the beginning of each file. */
-      fprintf (f, "G04 Title: %s, %s *\r\n", UNKNOWN (PCB->Name),
-	       UNKNOWN (name));
-      fprintf (f, "G04 Creator: %s " VERSION " *\r\n", Progname);
-      fprintf (f, "G04 CreationDate: %s *\r\n", utcTime);
+  /* Create a portable timestamp. */
+  currenttime = time (NULL);
+  {
+    /* avoid gcc complaints */
+    const char *fmt = "%c UTC";
+    strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
+  }
+  /* Print a cute file header at the beginning of each file. */
+  fprintf (f, "G04 Title: %s, %s *\r\n", UNKNOWN (PCB->Name),
+           UNKNOWN (name));
+  fprintf (f, "G04 Creator: %s " VERSION " *\r\n", Progname);
+  fprintf (f, "G04 CreationDate: %s *\r\n", utcTime);
 
 #ifdef HAVE_GETPWUID
-      /* ID the user. */
-      pwentry = getpwuid (getuid ());
-      fprintf (f, "G04 For: %s *\r\n", pwentry->pw_name);
+  /* ID the user. */
+  pwentry = getpwuid (getuid ());
+  fprintf (f, "G04 For: %s *\r\n", pwentry->pw_name);
 #endif
 
-      fprintf (f, "G04 Format: Gerber/RS-274X *\r\n");
-      pcb_fprintf (f, metric ? "G04 PCB-Dimensions (mm): %.2mm %.2mm *\r\n" :
-	       "G04 PCB-Dimensions (mil): %.2ml %.2ml *\r\n",
-	       PCB->MaxWidth, PCB->MaxHeight);
-      fprintf (f, "G04 PCB-Coordinate-Origin: lower left *\r\n");
+  fprintf (f, "G04 Format: Gerber/RS-274X *\r\n");
+  pcb_fprintf (f, metric ? "G04 PCB-Dimensions (mm): %.2mm %.2mm *\r\n" :
+           "G04 PCB-Dimensions (mil): %.2ml %.2ml *\r\n",
+           PCB->MaxWidth, PCB->MaxHeight);
+  fprintf (f, "G04 PCB-Coordinate-Origin: lower left *\r\n");
 
-      /* Signal data in inches. */
-      fprintf (f, metric ? "%%MOMM*%%\r\n" : "%%MOIN*%%\r\n");
+  /* Signal data in inches. */
+  fprintf (f, metric ? "%%MOMM*%%\r\n" : "%%MOIN*%%\r\n");
 
-      /* Signal Leading zero suppression, Absolute Data, 2.5 format in inch, 4.3 in mm */
-      fprintf (f, metric ? "%%FSLAX43Y43*%%\r\n" : "%%FSLAX25Y25*%%\r\n");
+  /* Signal Leading zero suppression, Absolute Data, 2.5 format in inch, 4.3 in mm */
+  fprintf (f, metric ? "%%FSLAX43Y43*%%\r\n" : "%%FSLAX25Y25*%%\r\n");
 
-      /* build a legal identifier. */
-      if (layername)
-	free (layername);
-      layername = strdup (filesuff);
-      if (strrchr (layername, '.'))
-	* strrchr (layername, '.') = 0;
-
-      for (cp=layername; *cp; cp++)
-	{
-	  if (isalnum((int) *cp))
-	    *cp = toupper((int) *cp);
-	  else
-	    *cp = '_';
-	}
-      fprintf (f, "%%LN%s*%%\r\n", layername);
-      lncount = 1;
+  /* build a legal identifier. */
+  if (layername)
+    free (layername);
+  layername = strdup (filesuff);
+  if (strrchr (layername, '.'))
+    * strrchr (layername, '.') = 0;
 
-      for (search = aptr_list->data; search; search = search->next)
-        fprintAperture(f, search);
-      if (aptr_list->count == 0)
-	/* We need to put *something* in the file to make it be parsed
-	   as RS-274X instead of RS-274D. */
-	fprintf (f, "%%ADD11C,0.0100*%%\r\n");
+  for (cp=layername; *cp; cp++)
+    {
+      if (isalnum((int) *cp))
+        *cp = toupper((int) *cp);
+      else
+        *cp = '_';
     }
+  fprintf (f, "%%LN%s*%%\r\n", layername);
+  lncount = 1;
+
+  for (search = aptr_list->data; search; search = search->next)
+    fprintAperture(f, search);
+  if (aptr_list->count == 0)
+    /* We need to put *something* in the file to make it be parsed
+       as RS-274X instead of RS-274D. */
+    fprintf (f, "%%ADD11C,0.0100*%%\r\n");
 
  emit_outline:
   /* If we're printing a copper layer other than the outline layer,
@@ -842,37 +873,37 @@ gerber_set_layer (const char *name, int group, int empty)
   if (copy_outline_mode == COPY_OUTLINE_SILK
       && SL_TYPE (idx) == SL_SILK)
     want_outline = 1;
-  if (copy_outline_mode == COPY_OUTLINE_ALL
-      && (SL_TYPE (idx) == SL_SILK
-	  || SL_TYPE (idx) == SL_MASK
-	  || SL_TYPE (idx) == SL_FAB
-	  || SL_TYPE (idx) == SL_ASSY
-	  || SL_TYPE (idx) == 0))
+  if (copy_outline_mode == COPY_OUTLINE_ALL &&
+      (SL_TYPE (idx) == SL_SILK ||
+       SL_TYPE (idx) == SL_MASK ||
+       SL_TYPE (idx) == SL_FAB  ||
+       SL_TYPE (idx) == SL_ASSY ||
+       SL_TYPE (idx) == 0))
     want_outline = 1;
 
-  if (want_outline
-      && strcmp (name, "outline")
-      && strcmp (name, "route"))
+  if (want_outline &&
+      strcmp (name, "outline") != 0 &&
+      strcmp (name, "route") != 0)
     {
-      if (outline_layer
-	  && outline_layer != PCB->Data->Layer+idx)
-	DrawLayer (outline_layer, &region);
+      if (outline_layer &&
+          outline_layer != PCB->Data->Layer+idx)
+        DrawLayer (outline_layer, &region);
       else if (!outline_layer)
-	{
-	  hidGC gc = gui->graphics->make_gc ();
-	  printf("name %s idx %d\n", name, idx);
-	  if (SL_TYPE (idx) == SL_SILK)
-	    gui->graphics->set_line_width (gc, PCB->minSlk);
-	  else if (group >= 0)
-	    gui->graphics->set_line_width (gc, PCB->minWid);
-	  else
-	    gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
-	  gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-	  gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->destroy_gc (gc);
-	}
+        {
+          hidGC gc = gui->graphics->make_gc ();
+          printf("name %s idx %d\n", name, idx);
+          if (SL_TYPE (idx) == SL_SILK)
+            gui->graphics->set_line_width (gc, PCB->minSlk);
+          else if (group >= 0)
+            gui->graphics->set_line_width (gc, PCB->minWid);
+          else
+            gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
+          gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
+          gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
+          gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+          gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
+          gui->graphics->destroy_gc (gc);
+        }
     }
 
   return 1;
@@ -1280,7 +1311,6 @@ hid_gerber_init ()
   gerber_hid.get_export_options  = gerber_get_export_options;
   gerber_hid.do_export           = gerber_do_export;
   gerber_hid.parse_arguments     = gerber_parse_arguments;
-  gerber_hid.set_layer           = gerber_set_layer;
   gerber_hid.calibrate           = gerber_calibrate;
   gerber_hid.set_crosshair       = gerber_set_crosshair;
