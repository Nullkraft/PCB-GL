Bottom: 304bcaa3f26845edcf32c9fa6a9a6eb891fde045
Top:    73ab8972a4f7a995dc678734dc5bdfd4d2e2d428
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 15:55:52 +0000

Hidcairo


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 47b171d..76b0ef3 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -159,7 +159,7 @@ PCB_SRCS = \
 	hid/common/hid_resource.h \
 	hid/hidint.h 
 
-EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS} toporouter.c toporouter.h
+EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS} ${CAIRO_SRCS} toporouter.c toporouter.h
 DBUS_SRCS= \
 	dbus-pcbmain.c \
 	dbus-pcbmain.h \
@@ -200,6 +200,10 @@ GL_SRCS= \
 	borast/borast-wideint-private.h \
 	borast/borast-wideint-type-private.h
 
+CAIRO_SRCS= \
+	hid/common/hidcairo.c \
+	hid/common/hidcairo.h
+
 BUILT_SOURCES = \
 	core_lists.h \
 	gpcb-menu.h \
@@ -375,6 +379,15 @@ else
 LIBGTK_SRCS+=	${LIBGTK_GDK_SRCS}
 endif
 
+# If we are building with Cairo support, we need some extra files
+if USE_GL
+#CAIRO
+PCB_SRCS+=	${CAIRO_SRCS}
+#LIBGTK_SRCS+=	${LIBGTK_CAIRO_SRCS}
+else
+#LIBGTK_SRCS+=	${LIBGTK_GDK_SRCS}
+endif
+
 # If we are building on win32, then compile in some icons for the
 # desktop and application toolbar
 if WIN32
diff --git a/src/hid/common/hidcairo.c b/src/hid/common/hidcairo.c
new file mode 100644
index 0000000..4872abf
--- /dev/null
+++ b/src/hid/common/hidcairo.c
@@ -0,0 +1,561 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2009-2011 PCB Contributers (See ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <cairo.h>
+#include <gdk/gdk.h>
+
+#include "data.h"
+#include "hid_draw.h"
+#include "hidcairo.h"
+#include "hid/hidint.h"
+#include "draw_helpers.h"
+
+typedef struct hidcairo_gc_struct {
+  struct hid_gc_struct gc; /* Parent */
+
+  char *colorname;
+  double brightness;
+  double saturation;
+  cairo_line_cap_t line_cap;
+  cairo_line_join_t line_join;
+  double line_width;
+} *hidcairoGC;
+
+typedef struct render_priv {
+  cairo_t *cr;
+  GdkColormap *colormap;
+  int cur_mask;
+} render_priv;
+
+
+static hidGC
+hidcairo_make_gc (HID_DRAW *hid_draw)
+{
+  hidGC gc = (hidGC) calloc(1, sizeof(struct hidcairo_gc_struct));
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+
+  gc->hid = NULL;
+  gc->hid_draw = hid_draw;
+
+  /* Initial color settings need configuring */
+  hidcairo_gc->colorname = NULL;
+  hidcairo_gc->brightness = 1.0;
+  hidcairo_gc->saturation = 1.0;
+
+  hidcairo_gc->line_cap = CAIRO_LINE_CAP_ROUND;
+  hidcairo_gc->line_join = CAIRO_LINE_JOIN_MITER;
+  hidcairo_gc->line_width = 0.0;
+
+  return gc;
+}
+
+static void
+hidcairo_destroy_gc (hidGC gc)
+{
+  free (gc);
+}
+
+static void
+hidcairo_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
+{
+  render_priv *priv = hid_draw->priv;
+
+  if (mode == priv->cur_mask)
+    return;
+
+  switch (mode)
+    {
+    case HID_MASK_BEFORE:
+      cairo_push_group (priv->cr);
+      break;
+
+    case HID_MASK_CLEAR:
+      cairo_set_operator (priv->cr, CAIRO_OPERATOR_CLEAR);
+      break;
+
+    case HID_MASK_AFTER:
+      /* The HID asks not to receive this mask type, so warn if we get it */
+      g_return_if_reached ();
+
+    case HID_MASK_OFF:
+      cairo_pop_group_to_source (priv->cr);
+      cairo_set_operator (priv->cr, CAIRO_OPERATOR_OVER);
+      cairo_paint (priv->cr);
+      break;
+    }
+  priv->cur_mask = mode;
+}
+
+typedef struct
+{
+  int color_set;
+  GdkColor color;
+  double red;
+  double green;
+  double blue;
+} ColorCache;
+
+static void
+_set_color (hidGC gc)
+{
+  render_priv *priv = gc->hid_draw->priv;
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+
+  static void *cache = NULL;
+  hidval cval;
+  ColorCache *cc;
+  double r, g, b;
+  double luminance;
+
+  if (hidcairo_gc->colorname == NULL)
+    return;
+
+  if (priv->colormap == NULL)
+    priv->colormap = gdk_colormap_get_system ();
+
+  if (strcmp (hidcairo_gc->colorname, "erase") == 0)
+    {
+      r = 0.0; // gport->bg_color.red   / 65535.;
+      g = 0.0; // gport->bg_color.green / 65535.;
+      b = 1.0; // gport->bg_color.blue  / 65535.;
+    }
+  else if (strcmp (hidcairo_gc->colorname, "drill") == 0)
+    {
+      r = 1.0; // gport->offlimits_color.red   / 65535.;
+      g = 0.0; // gport->offlimits_color.green / 65535.;
+      b = 0.0; // gport->offlimits_color.blue  / 65535.;
+    }
+  else
+    {
+      if (hid_cache_color (0, hidcairo_gc->colorname, &cval, &cache))
+        cc = (ColorCache *) cval.ptr;
+      else
+        {
+          cc = (ColorCache *) malloc (sizeof (ColorCache));
+          memset (cc, 0, sizeof (*cc));
+          cval.ptr = cc;
+          hid_cache_color (1, hidcairo_gc->colorname, &cval, &cache);
+        }
+
+      if (!cc->color_set)
+        {
+          if (gdk_color_parse (hidcairo_gc->colorname, &cc->color))
+            gdk_color_alloc (priv->colormap, &cc->color);
+          else
+            gdk_color_white (priv->colormap, &cc->color);
+          cc->red   = cc->color.red   / 65535.;
+          cc->green = cc->color.green / 65535.;
+          cc->blue  = cc->color.blue  / 65535.;
+          cc->color_set = 1;
+        }
+      r = cc->red;
+      g = cc->green;
+      b = cc->blue;
+    }
+
+  r *= hidcairo_gc->brightness;
+  g *= hidcairo_gc->brightness;
+  b *= hidcairo_gc->brightness;
+
+  /* B/W Equivalent brightness */
+  luminance = (r + g + b) / 3.0;
+
+  /* Fade between B/W and colour */
+  r = r * hidcairo_gc->saturation + luminance * (1.0 - hidcairo_gc->saturation);
+  g = g * hidcairo_gc->saturation + luminance * (1.0 - hidcairo_gc->saturation);
+  b = b * hidcairo_gc->saturation + luminance * (1.0 - hidcairo_gc->saturation);
+
+  cairo_set_source_rgb (priv->cr, r, g, b);
+}
+
+static void
+use_gc (hidGC gc)
+{
+  render_priv *priv = gc->hid_draw->priv;
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+
+  cairo_set_line_cap (priv->cr, hidcairo_gc->line_cap);
+  cairo_set_line_join (priv->cr, hidcairo_gc->line_join);
+  cairo_set_line_width (priv->cr, hidcairo_gc->line_width);
+  _set_color (gc);
+}
+
+static void
+hidcairo_set_color (hidGC gc, const char *colorname)
+{
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+
+  if (hidcairo_gc->colorname != NULL && strcmp (hidcairo_gc->colorname, colorname) == 0)
+    return;
+
+  free (hidcairo_gc->colorname);
+  hidcairo_gc->colorname = strdup (colorname);
+
+//  _set_color (gc);
+}
+
+// static void
+// hidcairo_saturation (hidGC gc, double saturation)
+// {
+//   if (hidcairo_gc->saturation == saturation)
+//     return;
+
+//   hidcairo_gc->saturation = saturation;
+//   _set_color (gc);
+// }
+
+// static void
+// hidcairo_set_brightness (hidGC gc, double brightness)
+// {
+//   if (hidcairo_gc->brightness == brightness)
+//     return;
+
+//   hidcairo_gc->brightness = brightness;
+//   _set_color (gc);
+// }
+
+static void
+hidcairo_set_line_cap (hidGC gc, EndCapStyle style)
+{
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+  cairo_line_cap_t cairo_cap;
+  cairo_line_join_t cairo_join;
+
+  switch (style)
+    {
+      default:
+      case Round_Cap:   cairo_cap = CAIRO_LINE_CAP_ROUND;  cairo_join = CAIRO_LINE_JOIN_MITER; break;
+      case Beveled_Cap: cairo_cap = CAIRO_LINE_CAP_SQUARE; cairo_join = CAIRO_LINE_JOIN_BEVEL; break;
+      case Trace_Cap:   cairo_cap = CAIRO_LINE_CAP_ROUND;  cairo_join = CAIRO_LINE_JOIN_MITER; break;
+      case Square_Cap:  cairo_cap = CAIRO_LINE_CAP_SQUARE; cairo_join = CAIRO_LINE_JOIN_MITER; break;
+    }
+
+  hidcairo_gc->line_cap = cairo_cap;
+  hidcairo_gc->line_join = cairo_join;
+}
+
+static void
+hidcairo_set_line_width (hidGC gc, Coord width)
+{
+  render_priv *priv = gc->hid_draw->priv;
+  hidcairoGC hidcairo_gc = (hidcairoGC)gc;
+  hidcairo_gc->line_width = width;
+
+  if (width == 0)
+    {
+      double dx = 1.5; /* XXX: Min line width in device coordinates... for now lets assume pixels */
+      double dy = 0.0;
+
+      cairo_device_to_user_distance (priv->cr, &dx, &dy);
+      hidcairo_gc->line_width = hypot (dx, dy); /* In case of rotation transform */
+    }
+}
+
+static void
+hidcairo_set_draw_xor (hidGC gc, int xor_)
+{
+  /* XXX: NOP */
+}
+
+static void
+hidcairo_set_draw_faded (hidGC gc, int faded)
+{
+  /* XXX: NOP */
+}
+
+static void
+hidcairo_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  render_priv *priv = gc->hid_draw->priv;
+
+  use_gc (gc);
+  cairo_move_to (priv->cr, x1, y1);
+  cairo_line_to (priv->cr, x2, y2);
+  cairo_stroke (priv->cr);
+}
+
+static void
+hidcairo_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius, Angle start_angle, Angle delta_angle)
+{
+  render_priv *priv = gc->hid_draw->priv;
+
+  /* Unfortunately we can get called with zero radius arcs when thindrawing solder mask clearance in vias in some cases */
+  if (xradius == 0 || yradius == 0)
+    return;
+
+  g_return_if_fail (xradius != 0 || yradius != 0);
+
+  use_gc (gc);
+  cairo_save (priv->cr);
+  cairo_translate (priv->cr, cx, cy);
+  cairo_scale (priv->cr, xradius, yradius);
+  if (cairo_status (priv->cr) != CAIRO_STATUS_SUCCESS)
+    {
+      printf ("Oh crap, xradius = %li, yradius = %li. status = %i\n", xradius, yradius, cairo_status (priv->cr));
+    }
+
+  if (delta_angle < 0.0)
+    cairo_arc          (priv->cr, 0.0, 0.0, 1.0, (180 - start_angle) * M_PI / 180., (180 - start_angle - delta_angle) * M_PI / 180.);
+  else
+    cairo_arc_negative (priv->cr, 0.0, 0.0, 1.0, (180 - start_angle) * M_PI / 180., (180 - start_angle - delta_angle) * M_PI / 180.);
+
+  cairo_restore (priv->cr);
+  cairo_stroke (priv->cr);
+}
+
+static void
+hidcairo_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  render_priv *priv = gc->hid_draw->priv;
+
+  use_gc (gc);
+  cairo_rectangle (priv->cr, x1, y1, x2 - x1, y2 - y1);
+  cairo_stroke (priv->cr);
+}
+
+static void
+hidcairo_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
+{
+  render_priv *priv = gc->hid_draw->priv;
+
+  use_gc (gc);
+  cairo_arc (priv->cr, cx, cy, radius, 0.0, M_PI * 2.0);
+  cairo_fill (priv->cr);
+}
+
+static void
+hidcairo_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
+{
+  render_priv *priv = gc->hid_draw->priv;
+  int i;
+
+  g_return_if_fail (n_coords > 1);
+
+  use_gc (gc);
+  cairo_move_to (priv->cr, x[0], y[0]);
+  for (i = 1; i < n_coords; i++)
+    cairo_line_to (priv->cr, x[i], y[i]);
+  cairo_close_path (priv->cr);
+  cairo_fill (priv->cr);
+}
+
+static void
+hidcairo_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
+{
+  render_priv *priv = gc->hid_draw->priv;
+
+  use_gc (gc);
+  cairo_rectangle (priv->cr, x1, y1, x2 - x1, y2 - y1);
+  cairo_fill (priv->cr);
+}
+
+
+/* The following APIs render using PCB data-structures, not immediate parameters */
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_line (hidGC gc, LineType *line)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_arc (hidGC gc, ArcType *arc)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_text (hidGC gc, TextType *text, Coord min_line_width)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_pad (hidGC gc, PadType *pad, bool clip, bool mask)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_draw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+// {
+// }
+
+/* NB: Caller is responsible for calling use_gc (gc) */
+static void
+fill_polyarea (hidGC gc, POLYAREA * pa)
+{
+  /* Ignore clip_box, just draw everything */
+
+  render_priv *priv = gc->hid_draw->priv;
+  VNODE *v;
+  PLINE *pl;
+
+  pl = pa->contours;
+
+  do
+    {
+      v = &pl->head;
+      cairo_move_to (priv->cr, v->point[0], v->point[1]);
+      v = v->next;
+      do
+        {
+          cairo_line_to (priv->cr, v->point[0], v->point[1]);
+        }
+      while ((v = v->next) != &pl->head);
+    }
+  while ((pl = pl->next) != NULL);
+
+  cairo_fill (priv->cr);
+}
+
+static void
+hidcairo_fill_pcb_polygon (hidGC gc, PolygonType *poly)
+{
+  use_gc (gc);
+  fill_polyarea (gc, poly->Clipped);
+  if (TEST_FLAG (FULLPOLYFLAG, poly))
+    {
+      POLYAREA *pa;
+
+      for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
+        fill_polyarea (gc, pa);
+    }
+}
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_fill_pcb_pad (hidGC gc, PadType *pad, bool clip, bool mask)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clip, bool mask)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+// {
+// }
+
+// USE COMMON ROUTINE
+// static void
+// hidcairo_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+// {
+// }
+
+void
+hidcairo_class_init (HID_DRAW_CLASS *klass)
+{
+//  memset (&klass, 0, sizeof (HID_DRAW));
+
+//  common_draw_helpers_init (&klass);
+
+  klass->make_gc               = hidcairo_make_gc;
+  klass->destroy_gc            = hidcairo_destroy_gc;
+  klass->use_mask              = hidcairo_use_mask;
+
+  klass->set_line_cap          = hidcairo_set_line_cap;
+  klass->set_line_width        = hidcairo_set_line_width;
+
+  klass->set_color             = hidcairo_set_color;
+  klass->set_draw_xor          = hidcairo_set_draw_xor;
+  klass->set_draw_faded        = hidcairo_set_draw_faded;
+
+  klass->draw_line             = hidcairo_draw_line;
+  klass->draw_arc              = hidcairo_draw_arc;
+  klass->draw_rect             = hidcairo_draw_rect;
+  klass->fill_circle           = hidcairo_fill_circle;
+  klass->fill_polygon          = hidcairo_fill_polygon;
+  klass->fill_rect             = hidcairo_fill_rect;
+
+  /* The following APIs render using PCB data-structures, not immediate parameters */
+
+  // USE COMMON ROUTINE: klass->draw_pcb_line         = hidcairo_draw_pcb_line;
+  // USE COMMON ROUTINE: klass->draw_pcb_arc          = hidcairo_draw_pcb_arc;
+  // USE COMMON ROUTINE: klass->draw_pcb_text         = hidcairo_draw_pcb_text;
+  // USE COMMON ROUTINE: klass->draw_pcb_polygon      = hidcairo_draw_pcb_polygon;
+  // USE COMMON ROUTINE: klass->draw_pcb_polygon      = hidcairo_gui_draw_pcb_polygon;
+  // USE COMMON ROUTINE: klass->draw_pcb_pad          = hidcairo_draw_pcb_pad;
+  // USE COMMON ROUTINE: klass->draw_pcb_pv           = hidcairo_draw_pcb_pv;
+  klass->draw_pcb_polygon      = common_gui_draw_pcb_polygon;      // USE COMMON GUI ROUTINE
+  klass->draw_pcb_pad          = common_gui_draw_pcb_pad;          // USE COMMON GUI ROUTINE
+  klass->draw_pcb_pv           = common_gui_draw_pcb_pv;           // USE COMMON GUI ROUTINE
+
+  /* The following are not meant to be called outside of the GUI implementations of the above APIs */
+  klass->_fill_pcb_polygon     = hidcairo_fill_pcb_polygon;
+  // USE COMMON ROUTINE: klass->_thindraw_pcb_polygon = hidcairo_thindraw_pcb_polygon;
+  // USE COMMON ROUTINE: klass->_fill_pcb_pad         = hidcairo_fill_pcb_pad;
+  // USE COMMON ROUTINE: klass->_thindraw_pcb_pad     = hidcairo_thindraw_pcb_pad;
+  // USE COMMON ROUTINE: klass->_fill_pcb_pv          = hidcairo_fill_pcb_pv;
+  // USE COMMON ROUTINE: klass->_thindraw_pcb_pv      = hidcairo_thindraw_pcb_pv;
+}
+
+void
+hidcairo_init (HID_DRAW *hid_draw)
+{
+}
+
+void
+hidcairo_start_render (HID_DRAW *hid_draw, cairo_t *cr)
+{
+  render_priv *priv;
+
+  g_return_if_fail (hid_draw->priv == NULL);
+
+  priv = (render_priv *)calloc (1, sizeof (render_priv));
+  hid_draw->priv = priv;
+
+  cairo_reference (cr);
+  priv->cr = cr;
+}
+
+void
+hidcairo_finish_render (HID_DRAW *hid_draw)
+{
+  render_priv *priv = hid_draw->priv;
+
+  cairo_destroy (priv->cr);
+  free (priv);
+
+  hid_draw->priv = NULL;
+}
diff --git a/src/hid/common/hidcairo.h b/src/hid/common/hidcairo.h
new file mode 100644
index 0000000..43c55ee
--- /dev/null
+++ b/src/hid/common/hidcairo.h
@@ -0,0 +1,6 @@
+void hidcairo_class_init (HID_DRAW_CLASS *klass);
+void hidcairo_init (HID_DRAW *hid_draw);
+void hidcairo_start_render (HID_DRAW *hid_draw, cairo_t *cr);
+void hidcairo_finish_render (HID_DRAW *hid_draw);
+
+//extern HID_DRAW cairo_graphics;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 0ce72fb..967ea36 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -41,12 +41,16 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 
 #include "hid/common/hidnogui.h"
 #include "hid/common/draw_helpers.h"
+#include "hid/common/hidnogui.h"
 #include "hid/common/trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#include "hid/common/hidcairo.h"
+#include <cairo.h>
+
 //#define VIEW_ORTHO
 
 extern HID ghid_hid;
@@ -95,6 +99,8 @@ typedef struct render_priv {
   GList *active_gc_list;
   double edit_depth;
 
+  HID_DRAW *hid_draw_cairo;
+
 } render_priv;
 
 typedef struct gtk_gc_struct
@@ -1068,6 +1074,72 @@ draw_crosshair (hidGC gc, render_priv *priv)
   glDisable (GL_COLOR_LOGIC_OP);
 }
 
+static HID_DRAW_CLASS ghidcairo_graphics_class;
+
+static cairo_t *_cr = NULL;
+static bool cairo_subcomposite = false;
+
+static int
+hidcairo_set_layer (HID_DRAW *hid_draw, const char *name, int group, int _empty)
+{
+  bool group_visible = false;
+
+  if (group >= 0 && group < max_group)
+    {
+      group_visible = is_layer_group_visible (group);
+    }
+  else
+    {
+      switch (SL_TYPE (group))
+	{
+	case SL_INVISIBLE:
+	  group_visible = PCB->InvisibleObjectsOn;
+	  break;
+	case SL_MASK:
+	  group_visible = SL_MYSIDE (group) && TEST_FLAG (SHOWMASKFLAG, PCB);
+	  break;
+	case SL_SILK:
+	  group_visible = SL_MYSIDE (group) && PCB->ElementOn;
+	  break;
+	case SL_ASSY:
+	  break;
+	case SL_PDRILL:
+	case SL_UDRILL:
+	  group_visible = true;
+	  break;
+	case SL_RATS:
+	  group_visible = PCB->RatOn;
+	  break;
+	}
+    }
+
+//  cairo_pop_group_to_source (_cr);
+//  cairo_paint_with_alpha (_cr, 0.8);
+
+  if (group_visible)
+    {
+      cairo_subcomposite = true;
+      cairo_push_group (_cr);
+    }
+  else
+    {
+      cairo_subcomposite = false;
+    }
+
+  return group_visible;
+}
+
+static void
+hidcairo_end_layer (HID_DRAW *hid_draw)
+{
+  if (cairo_subcomposite)
+    {
+      cairo_pop_group_to_source (_cr);
+      cairo_paint_with_alpha (_cr, 0.7);
+      cairo_subcomposite = false;
+    }
+}
+
 void
 ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
@@ -1109,6 +1181,27 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   hidgl_instance_init (&ghid_graphics);
 
   priv->hid_draw = &ghid_graphics;
+
+  /* CAIRO TEST */
+
+  memset (&ghidcairo_graphics_class, 0, sizeof (HID_DRAW_CLASS));
+
+  common_nogui_graphics_class_init (&ghidcairo_graphics_class);
+  common_draw_helpers_class_init (&ghidcairo_graphics_class);
+  hidcairo_class_init (&ghidcairo_graphics_class);
+
+  ghidcairo_graphics_class.set_layer      = hidcairo_set_layer;
+  ghidcairo_graphics_class.end_layer      = hidcairo_end_layer;
+
+  ghidcairo_graphics_class.gui = true;
+
+  priv->hid_draw_cairo = calloc (1, sizeof (HID_DRAW));
+  priv->hid_draw_cairo->klass = &ghidcairo_graphics_class;
+  priv->hid_draw_cairo->poly_before = true;
+  common_nogui_graphics_init (priv->hid_draw_cairo);
+  common_draw_helpers_init (priv->hid_draw_cairo);
+  hidcairo_init (priv->hid_draw_cairo);
+
 }
 
 void
@@ -1142,6 +1235,9 @@ ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
                                 drawarea_glcontext,
                                 TRUE,
                                 GDK_GL_RGBA_TYPE);
+
+
+  gtk_widget_set_double_buffered (widget, true); /* XXX: For Cairo testing only */
 }
 
 void
@@ -2336,6 +2432,7 @@ ghid_draw_everything (hidGC gc)
 }
 
 #define Z_NEAR 3.0
+#if 0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
@@ -2736,6 +2833,33 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   return FALSE;
 }
+#else
+gboolean
+ghid_drawing_area_expose_cb (GtkWidget *widget,
+                             GdkEventExpose *ev,
+                             GHidPort *port)
+{
+  render_priv *priv = port->render_priv;
+
+  _cr = gdk_cairo_create (widget->window);
+
+  cairo_set_source_rgb (_cr, 0.0, 0.0, 0.0);
+  cairo_paint (_cr);
+
+  cairo_scale (_cr, 1.0 / 100000., 1.0 / 100000.); /* XXX */
+
+  hidcairo_start_render (priv->hid_draw_cairo, _cr);
+  hid_expose_callback (priv->hid_draw_cairo, 0);
+  hidcairo_finish_render (priv->hid_draw_cairo);
+
+  cairo_destroy (_cr);
+  _cr = NULL;
+
+  g_timer_start (priv->time_since_expose);
+
+  return FALSE;
+}
+#endif
 
 /* This realize callback is used to work around a crash bug in some mesa
  * versions (observed on a machine running the intel i965 driver. It isn't
