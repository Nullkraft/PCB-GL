Bottom: 3c5ec373323ed7c64b1ad0bfd71cb1181a36a977
Top:    c08964286551f2d37a95b25fabfeb39b1a82d1fd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-14 01:21:13 +0000

Introduce macros for traversing between edges and nodes in a specified direction

This greatly simplifies the code, at the cost of the traversal direction being
slightly less explicit.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 356ce0f..66a1654 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -90,6 +90,10 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 #define PREV_VERTEX(v) ((v)->prev)
 #define NEXT_EDGE(e) ((e)->next)
 #define PREV_EDGE(e) ((e)->prev)
+#define VERTEX_SIDE_DIR_EDGE(v,s) (((s) == 'P') ? VERTEX_BACKWARD_EDGE (v) : VERTEX_FORWARD_EDGE (v)) /* Move backwards for 'P' side, forwards for 'N' */
+#define EDGE_SIDE_DIR_VERTEX(e,s) (((s) == 'P') ? EDGE_BACKWARD_VERTEX (e) : EDGE_FORWARD_VERTEX (e)) /* Move backwards for 'P' side, forwards for 'N' */
+#define VERTEX_DIRECTION_EDGE(v,d) (((d) == FORW) ? VERTEX_FORWARD_EDGE (v) : VERTEX_BACKWARD_EDGE (v)) /* Move backwards for BACKW, forwards for FORW */
+#define EDGE_DIRECTION_VERTEX(e,d) (((d) == FORW) ? EDGE_FORWARD_VERTEX (e) : EDGE_BACKWARD_VERTEX (e)) /* Move backwards for BACKW, forwards for FORW */
 
 #define ISECTED 3
 #define UNKNWN  0
@@ -1166,7 +1170,7 @@ label_contour (PLINE * a)
 
   do
     {
-      if (cure->cvc_next)	/* examine cross vertex */
+      if (EDGE_BACKWARD_VERTEX (cure)->cvc_next)	/* examine cross vertex */
 	{
 	  label = edge_label (cure);
 	  if (first_labelled == NULL)
@@ -1617,8 +1621,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 
   if (!(*curv)->cvc_prev)	/* not a cross-vertex */
     {
-      if ((*cdir == FORW) ? VERTEX_FORWARD_EDGE (*curv)->Flags.mark :
-                           VERTEX_BACKWARD_EDGE (*curv)->Flags.mark)
+      if (VERTEX_DIRECTION_EDGE (*curv, *cdir)->Flags.mark)
 	return FALSE;
       return TRUE;
     }
@@ -1634,10 +1637,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
   do
     {
       /* Get the edge e, associated with that descriptor */
-      if (d->side == 'P')
-        e = VERTEX_BACKWARD_EDGE (d->parent);
-      else
-        e = VERTEX_FORWARD_EDGE (d->parent);
+      e = VERTEX_SIDE_DIR_EDGE (d->parent, d->side);
       newone = *cdir;
       if (!e->Flags.mark && j_rule (d->poly, e, &newone))
 	{
@@ -1645,12 +1645,8 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 	      (d->side == 'P' && newone == BACKW))
 	    {
 #ifdef DEBUG_JUMP
-	      if (newone == FORW)
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_FORWARD_VERTEX (e)->point[0], EDGE_FORWARD_VERTEX (e)->point[1]);
-	      else
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_BACKWARD_VERTEX (e)->point[0], EDGE_BACKWARD_VERTEX (e)->point[1]);
+	      DEBUGP ("jump leaving node at %#mD\n",
+	              EDGE_DIRECTION_VERTEX (e, newone)->point[0], EDGE_DIRECTION_VERTEX (e, newone)->point[1]);
 #endif
 	      *curv = d->parent;
 	      *cdir = newone;
@@ -1679,10 +1675,10 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
       if (!jump (&curv, &dir, j_rule))
 	break;
       /* add vertex (edge?) to polygon */
-      if ((newn = poly_CreateNodeFull (curv->point, (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->is_round : VERTEX_BACKWARD_EDGE (curv)->is_round,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cx       : VERTEX_BACKWARD_EDGE (curv)->cx,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cy       : VERTEX_BACKWARD_EDGE (curv)->cy,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->radius   : VERTEX_BACKWARD_EDGE (curv)->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      if ((newn = poly_CreateNodeFull (curv->point, VERTEX_DIRECTION_EDGE (curv, dir)->is_round,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cx,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cy,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->radius)) == NULL)
         return err_no_memory;
       if (!*result)
 	{
@@ -1699,7 +1695,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
 #endif
 
       /* Now mark the edge as included.  */
-      newn = (dir == FORW) ? VERTEX_FORWARD_EDGE (curv) : VERTEX_BACKWARD_EDGE (curv);
+      newn = VERTEX_DIRECTION_EDGE (curv, dir);
       newn->Flags.mark = 1;
       /* for SHARED edge mark both */
       if (newn->shared)
