Bottom: afa136149cd8a9a77132afbd988705da3c7fc59d
Top:    13e52e4b148a7abd839d4e0c859b6e874997e4e6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-17 19:55:10 +0000

Introduce macros for traversing between edges and nodes in a specified direction

This greatly simplifies the code, at the cost of the traversal direction being
slightly less explicit.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 054bef4..da48a07 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -90,6 +90,10 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 #define PREV_VERTEX(v) ((v)->prev)
 #define NEXT_EDGE(e) ((e)->next)
 #define PREV_EDGE(e) ((e)->prev)
+#define VERTEX_SIDE_DIR_EDGE(v,s) (((s) == 'P') ? VERTEX_BACKWARD_EDGE (v) : VERTEX_FORWARD_EDGE (v)) /* Move backwards for 'P' side, forwards for 'N' */
+#define EDGE_SIDE_DIR_VERTEX(e,s) (((s) == 'P') ? EDGE_BACKWARD_VERTEX (e) : EDGE_FORWARD_VERTEX (e)) /* Move backwards for 'P' side, forwards for 'N' */
+#define VERTEX_DIRECTION_EDGE(v,d) (((d) == FORW) ? VERTEX_FORWARD_EDGE (v) : VERTEX_BACKWARD_EDGE (v)) /* Move backwards for BACKW, forwards for FORW */
+#define EDGE_DIRECTION_VERTEX(e,d) (((d) == FORW) ? EDGE_FORWARD_VERTEX (e) : EDGE_BACKWARD_VERTEX (e)) /* Move backwards for BACKW, forwards for FORW */
 
 #define ISECTED 3
 #define UNKNWN  0
@@ -1113,7 +1117,7 @@ label_contour (PLINE * a)
 
   do
     {
-      if (cure->cvc_next)	/* examine cross vertex */
+      if (EDGE_BACKWARD_VERTEX (cure)->cvc_next)	/* examine cross vertex */
 	{
 	  label = edge_label (cure);
 	  if (first_labelled == NULL)
@@ -1564,8 +1568,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 
   if (!(*curv)->cvc_prev)	/* not a cross-vertex */
     {
-      if ((*cdir == FORW) ? VERTEX_FORWARD_EDGE (*curv)->Flags.mark :
-                           VERTEX_BACKWARD_EDGE (*curv)->Flags.mark)
+      if (VERTEX_DIRECTION_EDGE (*curv, *cdir)->Flags.mark)
 	return FALSE;
       return TRUE;
     }
@@ -1581,10 +1584,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
   do
     {
       /* Get the edge e, associated with that descriptor */
-      if (d->side == 'P')
-        e = VERTEX_BACKWARD_EDGE (d->parent);
-      else
-        e = VERTEX_FORWARD_EDGE (d->parent);
+      e = VERTEX_SIDE_DIR_EDGE (d->parent, d->side);
       newone = *cdir;
       if (!e->Flags.mark && j_rule (d->poly, e, &newone))
 	{
@@ -1592,12 +1592,8 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 	      (d->side == 'P' && newone == BACKW))
 	    {
 #ifdef DEBUG_JUMP
-	      if (newone == FORW)
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_FORWARD_VERTEX (e)->point[0], EDGE_FORWARD_VERTEX (e)->point[1]);
-	      else
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_BACKWARD_VERTEX (e)->point[0], EDGE_BACKWARD_VERTEX (e)->point[1]);
+	      DEBUGP ("jump leaving node at %#mD\n",
+	              EDGE_DIRECTION_VERTEX (e, newone)->point[0], EDGE_DIRECTION_VERTEX (e, newone)->point[1]);
 #endif
 	      *curv = d->parent;
 	      *cdir = newone;
@@ -1642,7 +1638,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
       DEBUGP ("gather vertex at %#mD\n", curv->point[0], curv->point[1]);
 #endif
       /* Now mark the edge as included.  */
-      newn = (dir == FORW) ? VERTEX_FORWARD_EDGE (curv) : VERTEX_BACKWARD_EDGE (curv);
+      newn = VERTEX_DIRECTION_EDGE (curv, dir);
       newn->Flags.mark = 1;
       /* for SHARED edge mark both */
       if (newn->shared)
