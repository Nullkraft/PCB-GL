Bottom: 160c1e0303cd87de74bd5816bfdc081973cc7d45
Top:    639246b8f3c0dc6f963d5f230bf17f278d99065d
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-13 19:55:50 +0000

Introduce macros for traversing between edges and nodes in a specified direction

This greatly simplifies the code, at the cost of the traversal direction being
slightly less explicit.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index ce673da..e805cab 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -98,6 +98,10 @@ static void poly_InclVertex_int (VNODE * after, VNODE * node);
 #define PREV_VERTEX(v) ((v)->prev)
 #define NEXT_EDGE(e) ((e)->next)
 #define PREV_EDGE(e) ((e)->prev)
+#define VERTEX_SIDE_DIR_EDGE(v,s) (((s) == 'P') ? VERTEX_BACKWARD_EDGE (v) : VERTEX_FORWARD_EDGE (v)) /* Move backwards for 'P' side, forwards for 'N' */
+#define EDGE_SIDE_DIR_VERTEX(e,s) (((s) == 'P') ? EDGE_BACKWARD_VERTEX (e) : EDGE_FORWARD_VERTEX (e)) /* Move backwards for 'P' side, forwards for 'N' */
+#define VERTEX_DIRECTION_EDGE(v,d) (((d) == FORW) ? VERTEX_FORWARD_EDGE (v) : VERTEX_BACKWARD_EDGE (v)) /* Move backwards for BACKW, forwards for FORW */
+#define EDGE_DIRECTION_VERTEX(e,d) (((d) == FORW) ? EDGE_FORWARD_VERTEX (e) : EDGE_BACKWARD_VERTEX (e)) /* Move backwards for BACKW, forwards for FORW */
 
 #define ISECTED 3
 #define UNKNWN  0
@@ -356,8 +360,7 @@ new_descriptor (VNODE * a, char poly, char side)
   l->poly = poly;
   l->side = side;
   l->next = l->prev = l;
-  if ((side == 'P' && a->prev->is_round == false) || /* previous, not round */
-      (side != 'P' && a      ->is_round == false))   /* next,     not round */
+  if (VERTEX_SIDE_DIR_EDGE (a, side)->is_round == false)  /* not round */
     { /* Line-segment case */
 
 #if 0
@@ -413,20 +416,21 @@ new_descriptor (VNODE * a, char poly, char side)
        * 90 degrees CW)
        */
 
+      center[0] = VERTEX_SIDE_DIR_EDGE (a, side)->cx;
+      center[1] = VERTEX_SIDE_DIR_EDGE (a, side)->cy;
+      l->curvature = (double)-compare_ccw_cw (a->point, center, EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (a, side), side)->point) / VERTEX_SIDE_DIR_EDGE (a, side)->radius;
+#if 0
       if (side == 'P')		/* previous */
         {
-          center[0] = VERTEX_BACKWARD_EDGE (a)->cx;
-          center[1] = VERTEX_BACKWARD_EDGE (a)->cy;
           l->curvature = (double)+compare_ccw_cw (EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (a))->point, center, a->point) / VERTEX_BACKWARD_EDGE (a)->radius;
           // OR: ?
           // l->curvature = (double)-compare_ccw_cw (a->point, center, a->prev->point) / a->prev->radius;
         }
       else				/* next */
         {
-          center[0] = VERTEX_FORWARD_EDGE (a)->cx;
-          center[1] = VERTEX_FORWARD_EDGE (a)->cy;
           l->curvature = (double)-compare_ccw_cw (a->point, center, EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (a))->point) / VERTEX_FORWARD_EDGE (a)->radius;
         }
+#endif
 
       /* First of all, make v the radial line */
       vect_sub (v, center, a->point);
@@ -626,6 +630,40 @@ node_add_single_point (VNODE * a, Vector p)
   return new_node;
 }				/* node_add_point */
 
+static void
+cvc_list_dump (CVCList *list)
+{
+  VNODE *node = list->parent;
+  CVCList *iter;
+
+#if 0
+  /* Only print for the vertex we're interested in at the moment */
+  if (!(
+      (node->point[0] == 69088001 || node->point[0] == 69088000 || node->point[0] == 69087998) &&
+      node->point[1] == 29336999))
+    return;
+#endif
+
+  pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
+
+  iter = list;
+  do {
+    pcb_fprintf (stderr, "angle = %.30e, poly = %c, side = %c, (%mn, %mn)-(%mn, %mn), curvature = %f Vertices: %p-%p Edge: %p\n",
+                 iter->angle,
+                 iter->poly,
+                 iter->side,
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[0],
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[1],
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[0],
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side))->point[1],
+                 iter->curvature,
+                 EDGE_BACKWARD_VERTEX (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side)),
+                 EDGE_FORWARD_VERTEX  (VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side)),
+                 VERTEX_SIDE_DIR_EDGE (iter->parent, iter->side));
+  } while ((iter = iter->next) != list);
+
+}
+
 /*
 edge_label
  (C) 2006 harry eaton
@@ -754,34 +792,6 @@ edge_label (VNODE * pn)
   return region;
 }				/* edge_label */
 
-static void
-cvc_list_dump (CVCList *list)
-{
-  VNODE *node = list->parent;
-  CVCList *iter;
-
-  /* Only print for the vertex we're interested in at the moment */
-  if (!(
-      (node->point[0] == 69088001 || node->point[0] == 69088000 || node->point[0] == 69087998) &&
-      node->point[1] == 29336999))
-    return;
-
-  pcb_fprintf (stderr, "Dumping CVC list at (%$mn, %$mn)\n", node->point[0], node->point[1]);
-
-  iter = list;
-  do {
-    pcb_fprintf (stderr, "angle = %f, poly = %c, side = %c, (%mm, %mm)-(%mm, %mm)\n",
-                 iter->angle,
-                 iter->poly,
-                 iter->side,
-                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
-                 ((iter->side == 'P') ? EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_BACKWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1],
-                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[0],
-                 ((iter->side == 'P') ? EDGE_FORWARD_VERTEX (VERTEX_BACKWARD_EDGE (iter->parent)) : EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (iter->parent)))->point[1]);
-  } while ((iter = iter->next) != list);
-
-}
-
 /*
  add_descriptors
  (C) 2006 harry eaton
@@ -2039,7 +2049,7 @@ label_contour (PLINE * a)
 
   do
     {
-      if (cure->cvc_next)	/* examine cross vertex */
+      if (EDGE_BACKWARD_VERTEX (cure)->cvc_next)	/* examine cross vertex */
 	{
 	  label = edge_label (cure);
 	  if (first_labelled == NULL)
@@ -2490,8 +2500,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 
   if (!(*curv)->cvc_prev)	/* not a cross-vertex */
     {
-      if ((*cdir == FORW) ? VERTEX_FORWARD_EDGE (*curv)->Flags.mark :
-                           VERTEX_BACKWARD_EDGE (*curv)->Flags.mark)
+      if (VERTEX_DIRECTION_EDGE (*curv, *cdir)->Flags.mark)
 	return FALSE;
       return TRUE;
     }
@@ -2507,10 +2516,7 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
   do
     {
       /* Get the edge e, associated with that descriptor */
-      if (d->side == 'P')
-        e = VERTEX_BACKWARD_EDGE (d->parent);
-      else
-        e = VERTEX_FORWARD_EDGE (d->parent);
+      e = VERTEX_SIDE_DIR_EDGE (d->parent, d->side);
       newone = *cdir;
       if (!e->Flags.mark && j_rule (d->poly, e, &newone))
 	{
@@ -2518,12 +2524,8 @@ jump (VNODE **curv, DIRECTION *cdir, J_Rule j_rule)
 	      (d->side == 'P' && newone == BACKW))
 	    {
 #ifdef DEBUG_JUMP
-	      if (newone == FORW)
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_FORWARD_VERTEX (e)->point[0], EDGE_FORWARD_VERTEX (e)->point[1]);
-	      else
-		DEBUGP ("jump leaving node at %#mD\n",
-			EDGE_BACKWARD_VERTEX (e)->point[0], EDGE_BACKWARD_VERTEX (e)->point[1]);
+	      DEBUGP ("jump leaving node at %#mD\n",
+	              EDGE_DIRECTION_VERTEX (e, newone)->point[0], EDGE_DIRECTION_VERTEX (e, newone)->point[1]);
 #endif
 	      *curv = d->parent;
 	      *cdir = newone;
@@ -2549,10 +2551,10 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
   do
     {
       /* add vertex (edge?) to polygon */
-      if ((newn = poly_CreateNodeFull (curv->point, (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->is_round : VERTEX_BACKWARD_EDGE (curv)->is_round,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cx       : VERTEX_BACKWARD_EDGE (curv)->cx,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cy       : VERTEX_BACKWARD_EDGE (curv)->cy,
-                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->radius   : VERTEX_BACKWARD_EDGE (curv)->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      if ((newn = poly_CreateNodeFull (curv->point, VERTEX_DIRECTION_EDGE (curv, dir)->is_round,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cx,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cy,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->radius)) == NULL)
         return err_no_memory;
 
       if (dir == FORW)
@@ -2599,7 +2601,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
 #endif
 
       /* Now mark the edge as included.  */
-      newn = (dir == FORW) ? VERTEX_FORWARD_EDGE (curv) : VERTEX_BACKWARD_EDGE (curv);
+      newn = VERTEX_DIRECTION_EDGE (curv, dir);
       newn->Flags.mark = 1;
       /* for SHARED edge mark both */
       if (newn->shared)
