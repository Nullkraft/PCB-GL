Bottom: 83db8e54b231941d58fab2c3297d387868982ee7
Top:    40b43038bb2ed4ce16e933b2f8f8143e2e9eaf34
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-12-04 19:20:04 +0000

hid/common/hidgl: Debug out of context rendering


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 23b2fa3..732cef5 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -69,6 +69,18 @@
 #endif
 
 
+static bool in_context = false;
+
+#define CHECK_IS_IN_CONTEXT(retcode) \
+  do { \
+    if (!in_context) { \
+      fprintf (stderr, "hidgl: Drawing called out of context in function %s\n", \
+             __FUNCTION__); \
+      return retcode; \
+    } \
+  } while (0)
+
+
 static void
 hidgl_reset_triangle_array (hidgl_instance *hidgl)
 {
@@ -89,6 +101,8 @@ hidgl_flush_triangles (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
 
+  CHECK_IS_IN_CONTEXT ();
+
   if (priv->buffer.triangle_count == 0)
     return;
 
@@ -107,6 +121,8 @@ hidgl_ensure_triangle_space (hidGC gc, int count)
   hidgl_instance *hidgl = hidgl_gc->hidgl;
   hidgl_priv *priv = hidgl->priv;
 
+  CHECK_IS_IN_CONTEXT ();
+
   if (count > TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
@@ -208,6 +224,7 @@ static void draw_cap (hidGC gc, Coord width, Coord x, Coord y, Angle angle, doub
   int slices = calc_slices (radius / scale, M_PI);
   int i;
 
+  CHECK_IS_IN_CONTEXT ();
   if (slices < MIN_TRIANGLES_PER_CAP)
     slices = MIN_TRIANGLES_PER_CAP;
 
@@ -236,6 +253,7 @@ hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, C
   int circular_caps = 0;
   int hairline = 0;
 
+  CHECK_IS_IN_CONTEXT ();
   if (width == 0.0)
     hairline = 1;
 
@@ -312,6 +330,7 @@ hidgl_draw_arc (hidGC gc, Coord width, Coord x, Coord y, Coord rx, Coord ry,
   int i;
   int hairline = 0;
 
+  CHECK_IS_IN_CONTEXT ();
   if (width == 0.0)
     hairline = 1;
 
@@ -377,6 +396,8 @@ hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
+  CHECK_IS_IN_CONTEXT ();
+
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, hidgl_gc->depth);
   glVertex3f (x1, y2, hidgl_gc->depth);
@@ -396,6 +417,7 @@ hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr, double scale)
   int slices;
   int i;
 
+  CHECK_IS_IN_CONTEXT ();
   slices = calc_slices (vr / scale, 2 * M_PI);
 
   if (slices < MIN_TRIANGLES_PER_CIRCLE)
@@ -547,6 +569,8 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
   GLUtesselator *tobj;
   GLdouble *vertices;
 
+  CHECK_IS_IN_CONTEXT ();
+
   assert (n_coords > 0);
 
   vertices = malloc (sizeof(GLdouble) * n_coords * 3);
@@ -629,6 +653,8 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, double scale)
   struct do_hole_info info;
   int stencil_bit;
 
+  CHECK_IS_IN_CONTEXT ();
+
   info.gc = gc;
   info.scale = scale;
   global_scale = scale;
@@ -710,6 +736,8 @@ hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box, do
 void
 hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  CHECK_IS_IN_CONTEXT ();
+
   hidgl_ensure_triangle_space (gc, 2);
   hidgl_add_triangle (gc, x1, y1, x1, y2, x2, y2);
   hidgl_add_triangle (gc, x2, y1, x2, y2, x1, y1);
@@ -776,6 +804,8 @@ hidgl_init_gc (hidgl_instance *hidgl, hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
+  CHECK_IS_IN_CONTEXT ();
+
   hidgl_gc->hidgl = hidgl;
   hidgl_gc->depth = 0.0;
 }
@@ -790,6 +820,11 @@ hidgl_start_render (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
 
+  if (in_context)
+    fprintf (stderr, "hidgl: hidgl_start_render() - Already in rendering context!\n");
+
+  in_context = true;
+
 //  hidgl_init ();
   glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
 
@@ -813,6 +848,10 @@ hidgl_start_render (hidgl_instance *hidgl)
 void
 hidgl_finish_render (hidgl_instance *hidgl)
 {
+  if (!in_context)
+    fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
+
+  in_context = false;
 }
 
 int
@@ -828,6 +867,8 @@ hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
 {
   hidgl_priv *priv = hidgl->priv;
 
+  CHECK_IS_IN_CONTEXT ();
+
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
   glStencilMask (~priv->assigned_bits);
   glClearStencil (0);
