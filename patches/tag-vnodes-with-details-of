Bottom: 003020401af79a65b1e11591670fa27f5ad56f4b
Top:    cca6d1ed0cf2b426f17d1126fd5c165c2dd02f7a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-13 18:57:50 +0000

Tag VNODEs with details of circular contour segments

The idea here is to track that the PWL segments actually came from a
particular underlying curve. This should allow us to reconstruct that
curve (approximately at least) if these segments survive in the final
polygon (are not intersected or removed by boolean operations).

The convention is that the curve shape tagging of a vertex corresponds
to the edge spanning this, and the net vertex around the list. (As per
other existing edge related flags).

NB: STILL DOES NOT WORK CORRECTLY IN ALL CASES. SEE:

circ_segs_test4_still_procuces_bad_contour_when_starting_with_arc.pcb

(SUSPECTED BUG IN THE GATHER / JUMP ROUTINES)


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 0bded43..3c1cee1 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -149,12 +149,14 @@ thindraw_contour (hidGC gc, PLINE *pl)
   hid_draw_set_line_width (gc, 0);
   hid_draw_set_line_cap (gc, Round_Cap);
 
+#if 0
   /* If the contour is round, use an arc drawing routine. */
   if (pl->is_round)
     {
       hid_draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
       return;
     }
+#endif
 
   /* Need at least two points in the contour */
   if (pl->head.next == NULL)
@@ -169,8 +171,33 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      hid_draw_line (gc, last_x, last_y, this_x, this_y);
-      // hid_draw_fill_circle (gc, this_x, this_y, 30);
+      if (v->prev->is_round)
+        {
+          Angle start_angle, end_angle, delta_angle;
+
+          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->prev->cy), -(v->prev->point[0] - v->prev->cx)));
+          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->prev->cy), -(      v->point[0] - v->prev->cx)));
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          hid_draw_arc (gc, v->prev->cx, v->prev->cy, v->prev->radius, v->prev->radius, start_angle, delta_angle);
+
+          /* Fill the head vertex */
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
+        }
+      else
+        {
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (1.5));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (1.5), MIL_TO_COORD (1.5), 0, 360);
+          hid_draw_line (gc, last_x, last_y, this_x, this_y);
+        }
 
       last_x = this_x;
       last_y = this_y;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5617d47..da7344b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -904,9 +904,11 @@ ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
   double old_alpha_mult = gtk_gc->alpha_mult;
   common_thindraw_pcb_polygon (gc, poly, clip_box);
+#if 0
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
   hid_draw_fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, old_alpha_mult);
+#endif
 }
 
 void
@@ -1643,7 +1645,8 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
     polygon.BoundingBox = *drawn_area;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+//  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw_thin_pcb_polygon (gc, &polygon, drawn_area);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -2685,7 +2688,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-  object3d_draw_debug ();
+  //object3d_draw_debug ();
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/macro.h b/src/macro.h
index a34693a..a38d525 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -69,6 +69,7 @@
 #define XOR(a,b)		(((a) && !(b)) || (!(a) && (b)))
 #define SQUARE(x)		((float) (x) * (float) (x))
 #define TO_RADIANS(degrees)	(M180 * (degrees))
+#define TO_DEGREES(radians)	((radians) / M180)
 
 /* ---------------------------------------------------------------------------
  * layer macros
diff --git a/src/polyarea.h b/src/polyarea.h
index c606077..be95bd2 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -88,6 +88,9 @@ struct VNODE
     CVCList *cvc_prev;
     CVCList *cvc_next;
     Vector point;
+    bool is_round;
+    Coord cx, cy;
+    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -122,6 +125,7 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
+VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index 477a5c8..9fe8cf6 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -104,8 +104,12 @@ dicer output is used for HIDs which cannot render things with holes
 #include <dmalloc.h>
 #endif
 
+
+#define DEBUG_CIRCSEGS
+
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
+//#define UNSUBTRACT_BLOAT MIL_TO_COORD (0.1)
 #define UNSUBTRACT_BLOAT 10
 #define SUBTRACT_PIN_VIA_BATCH_SIZE 100
 #define SUBTRACT_LINE_BATCH_SIZE 20
@@ -278,7 +282,7 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -286,6 +290,18 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
 
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -302,7 +318,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
   else
@@ -317,7 +333,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
 }
@@ -337,24 +353,37 @@ original_poly (PolygonType * p)
   /* first make initial polygon contour */
   for (n = 0; n < p->PointN; n++)
     {
+      VNODE *node;
+      //Cardinal prev_n;
+
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
       v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+
+      //prev_n = prev_contour_point (p, n);
+
+      /* XXX: Need to handle the case of a leftover circular contour point */
+      if (0)
+        node = poly_CreateNodeArcApproximation (v, 0, 0, 0);
+      else
+        node = poly_CreateNode (v);
+
       if (contour == NULL)
         {
-          if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+          if ((contour = poly_NewContour (node)) == NULL)
             return NULL;
         }
       else
         {
-          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          poly_InclVertex (contour->head.prev, node);
         }
 
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
           Coord cx, cy;
+          Coord radius;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -365,7 +394,7 @@ original_poly (PolygonType * p)
 
 
           calc_arc_from_points_and_included_angle (&p->Points[n], &p->Points[next_n], p->Points[n].included_angle,
-                                                   &cx, &cy, NULL, NULL, NULL);
+                                                   &cx, &cy, &radius, NULL, NULL);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;
@@ -373,7 +402,7 @@ original_poly (PolygonType * p)
           v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
 #endif
 
-          degree_circle (contour, cx, cy, v, p->Points[n].included_angle);
+          degree_circle (contour, cx, cy, radius, v, p->Points[n].included_angle);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;  /* DEBUG TO SHOW THE CENTER OF THE ARC */
@@ -477,8 +506,24 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
-  poly_InclVertex (c->head.prev, poly_CreateNode (v));
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -493,7 +538,7 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -509,6 +554,23 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
@@ -516,7 +578,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 
   /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
   range = POLY_CIRC_SEGS / fraction;
-  for (i = 0; i < range; i++)
+  for (i = 0; i < range - 1; i++)
     {
       /* rotate the vector */
       t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -524,7 +586,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -540,7 +602,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
     return NULL;
   v[0] = x + radius;
   v[1] = y;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNodeArcApproximation (v, x, y, radius))) == NULL)
     return NULL;
   frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
@@ -559,22 +621,31 @@ RoundRect (Coord x1, Coord x2, Coord y1, Coord y2, Coord t)
 
   assert (x2 > x1);
   assert (y2 > y1);
+
   v[0] = x1 - t;
-  v[1] = y1;
+  v[1] = y2;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
+  v[0] = x1 - t;
+  v[1] = y1;
   frac_circle (contour, x1, y1, v, 4);
-  v[0] = x2;
+  v[0] = x1;
   v[1] = y1 - t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2;
+  v[1] = y1 - t;
   frac_circle (contour, x2, y1, v, 4);
   v[0] = x2 + t;
-  v[1] = y2;
+  v[1] = y1;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2 + t;
+  v[1] = y2;
   frac_circle (contour, x2, y2, v, 4);
-  v[0] = x1;
+  v[0] = x2;
   v[1] = y2 + t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x1;
+  v[1] = y2 + t;
   frac_circle (contour, x1, y2, v, 4);
   return ContourToPoly (contour);
 }
@@ -613,18 +684,30 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
 
   ang = a->StartAngle;
   da = (1.0 * a->Delta) / segs;
-  radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
+  /* XXX: No need for radius ofsetting bodgery for the exact arc representation */
+  if (rx == ry)
+    radius_adj = 0.;
+  else
+    radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
+
+  /* XXX: First point is a vertex? */
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
-  for (i = 0; i < segs - 1; i++)
-    {
-      ang += da;
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, -a->Delta);
+  else
+    for (i = 0; i < segs - 1; i++)
+      {
+        ang += da;
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+      }
   /* find last point */
   ang = a->StartAngle + a->Delta;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -635,13 +718,18 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   rx = (a->Width + half) * (1+radius_adj);
   ry = (a->Width + half) * (1+radius_adj);
   da = -da;
-  for (i = 0; i < segs; i++)
-    {
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      ang += da;
-    }
+  v[0] = a->X - rx * cos (ang * M180);
+  v[1] = a->Y + ry * sin (ang * M180);
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, a->Delta);
+  else
+    for (i = 0; i < segs; i++)
+      {
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        ang += da;
+      }
   /* now add other round cap */
   ang = a->StartAngle;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -721,33 +809,34 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.Y -= dx;
     }
 
-  v[0] = l->Point2.X - dx;
-  v[1] = l->Point2.Y - dy;
+  v[0] = l->Point1.X - dx;
+  v[1] = l->Point1.Y - dy;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
 
+  v[0] = l->Point2.X - dx;
+  v[1] = l->Point2.Y - dy;
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point2.X + dx;
-      v[1] = l->Point2.Y + dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
 
+  v[0] = l->Point2.X + dx;
+  v[1] = l->Point2.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point1.X - dx;
-      v[1] = l->Point1.Y - dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
 
+//  v[0] = l->Point1.X - dx;
+//  v[1] = l->Point1.Y - dy;
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
@@ -804,25 +893,37 @@ SquarePadPoly (PadType * pad, Coord clear)
       c->Point2.Y -= cx;
     }
 
-  v[0] = c->Point1.X - tx;
-  v[1] = c->Point1.Y - ty;
+  v[0] = c->Point1.X + tx;
+  v[1] = c->Point1.Y + ty;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
+
+  v[0] = c->Point1.X - tx;
+  v[1] = c->Point1.Y - ty;
   frac_circle (contour, (t->Point1.X - tx), (t->Point1.Y - ty), v, 4);
 
+  v[0] = t->Point1.X - cx;
+  v[1] = t->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point2.X - cx;
   v[1] = t->Point2.Y - cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X - tx), (t->Point2.Y - ty), v, 4);
 
+  v[0] = c->Point2.X - tx;
+  v[1] = c->Point2.Y - ty;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = c->Point2.X + tx;
   v[1] = c->Point2.Y + ty;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X + tx), (t->Point2.Y + ty), v, 4);
 
+  v[0] = t->Point2.X + cx;
+  v[1] = t->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point1.X + cx;
   v[1] = t->Point1.Y + cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point1.X + tx), (t->Point1.Y + ty), v, 4);
 
   /* now we have the line contour */
@@ -1788,6 +1889,10 @@ ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
           strcmp (layer->Name, "route") == 0)
         Data->outline_valid = false;
     }
+  else if (type == PIN_TYPE || type == VIA_TYPE)
+    {
+        Data->outline_valid = false;
+    }
 
   if (type == POLYGON_TYPE)
     InitClip (PCB->Data, (LayerType *) ptr1, (PolygonType *) ptr2);
@@ -2123,10 +2228,18 @@ arc_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = ArcPoly (arc, arc->Thickness)))
+#else
   if (!(np = ArcPoly (arc, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2139,10 +2252,18 @@ line_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = LinePoly (line, line->Thickness)))
+#else
   if (!(np = LinePoly (line, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2155,10 +2276,18 @@ pv_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = CirclePoly (pv->X, pv->Y, pv->Thickness / 2)))
+#else
   if (!(np = CirclePoly (pv->X, pv->Y, pv->DrillingHole / 2)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2174,8 +2303,11 @@ polygon_outline_callback (const BoxType * b, void *cl)
   if (!(np = original_poly (poly)))
     return 0;
 
-
+#ifdef DEBUG_CIRCSEGS
   poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2267,13 +2399,19 @@ POLYAREA *board_outline_poly (bool include_holes)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
-#if 0
+#if 1
+#ifdef DEBUG_CIRCSEGS
+  info.poly = NULL;
+#else
   info.poly = whole_world;
+#endif
 
   r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
   r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
 
+#ifndef DEBUG_CIRCSEGS
   if (include_holes)
+#endif
     {
       r_search (PCB->Data->pin_tree, &region, NULL, pv_outline_callback, &info);
       r_search (PCB->Data->via_tree, &region, NULL, pv_outline_callback, &info);
@@ -2281,6 +2419,10 @@ POLYAREA *board_outline_poly (bool include_holes)
 
   clipped = info.poly;
 
+#ifdef DEBUG_CIRCSEGS
+  return clipped;
+#endif
+
   /* Now we just need to work out which pieces of polygon are inside
      and outside the board! */
 
@@ -2328,6 +2470,7 @@ POLYAREA *board_outline_poly (bool include_holes)
   g_list_free (pieces_to_delete);
 #endif
 
+#ifdef DEBUG_CIRCSEGS
   // The actual operation we want is to split the test polygon into multiple pieces
   // along the intersection with the polygon contours of any polygon on the outer layer.
   // The result would be nested, touching (not normally produced by the PBO code),
@@ -2341,6 +2484,7 @@ POLYAREA *board_outline_poly (bool include_holes)
     return whole_world;
   else
     poly_Free (&whole_world);
+#endif
 
   return clipped;
 }
diff --git a/src/polygon1.c b/src/polygon1.c
index 254b0bc..bb0b18f 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -49,6 +49,7 @@
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
+#include "pcb-printf.h"
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
@@ -108,12 +109,13 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
   if (UNLIKELY (((ptr) = (type *)malloc(sizeof(type))) == NULL))	\
     error(err_no_memory);
 
+//#define DEBUG_INTERSECT
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
-#undef DEBUG_JUMP
-#undef DEBUG_GATHER
+//#define DEBUG_JUMP
+//#define DEBUG_GATHER
 #undef DEBUG_ANGLE
-#undef DEBUG
+//#define DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -175,6 +177,41 @@ poly_dump (POLYAREA * p)
 }
 #endif
 
+static VNODE *
+poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+{
+  VNODE *res;
+  Coord *c;
+
+  assert (v);
+  res = (VNODE *) calloc (1, sizeof (VNODE));
+  if (res == NULL)
+    return NULL;
+  // bzero (res, sizeof (VNODE) - sizeof(Vector));
+  c = res->point;
+  *c++ = *v++;
+  *c = *v;
+
+  res->is_round = is_round;
+  res->cx = cx;
+  res->cy = cy;
+  res->radius = radius;
+
+  return res;
+}
+
+VNODE *
+poly_CreateNode (Vector v)
+{
+  return poly_CreateNodeFull (v, false, 0, 0, 0);
+}
+
+VNODE *
+poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+{
+  return poly_CreateNodeFull (v, true, cx, cy, radius);
+}
+
 /***************************************************************/
 /* routines for processing intersections */
 
@@ -195,6 +232,7 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
+/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, EDGE_BACKWARD_VERTEX (dest)->point))
     return EDGE_BACKWARD_VERTEX (dest);
   if (vect_equal (po, EDGE_FORWARD_VERTEX (dest)->point))
@@ -912,6 +950,9 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
+      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
+      task->node_seg->v->is_round = false;
+
       /* Do insersion */
       PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
       NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
@@ -1637,8 +1678,11 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
       /* see where to go next */
       if (!jump (&curv, &dir, j_rule))
 	break;
-      /* add vertex to polygon */
-      if ((newn = poly_CreateNode (curv->point)) == NULL)
+      /* add vertex (edge?) to polygon */
+      if ((newn = poly_CreateNodeFull (curv->point, (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->is_round : VERTEX_BACKWARD_EDGE (curv)->is_round,
+                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cx       : VERTEX_BACKWARD_EDGE (curv)->cx,
+                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->cy       : VERTEX_BACKWARD_EDGE (curv)->cy,
+                                                    (dir == FORW) ? VERTEX_FORWARD_EDGE (curv)->radius   : VERTEX_BACKWARD_EDGE (curv)->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
         return err_no_memory;
       if (!*result)
 	{
@@ -1651,8 +1695,9 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
 	  poly_InclVertex (PREV_VERTEX (&(*result)->head), newn);
 	}
 #ifdef DEBUG_GATHER
-      DEBUGP ("gather vertex at %#mD\n", curv->point[0], curv->point[1]);
+      DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", curv->point[0], curv->point[1], dir);
 #endif
+
       /* Now mark the edge as included.  */
       newn = (dir == FORW) ? VERTEX_FORWARD_EDGE (curv) : VERTEX_BACKWARD_EDGE (curv);
       newn->Flags.mark = 1;
@@ -1660,7 +1705,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
       if (newn->shared)
 	newn->shared->Flags.mark = 1;
 
-      /* Advance to the next vertex.  */
+      /* Advance to the next vertex (edge?).  */
       curv = (dir == FORW) ? NEXT_VERTEX (curv) : PREV_VERTEX (curv);
     }
   while (1);
@@ -2349,6 +2394,8 @@ poly_Boolean (const POLYAREA * a_org, const POLYAREA * b_org,
   return poly_Boolean_free (a, b, res, action);
 }				/* poly_Boolean */
 
+static void test_polyInvContour (void);
+
 /* just like poly_Boolean but frees the input polys */
 int
 poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
@@ -2359,6 +2406,8 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
   jmp_buf e;
   int code;
 
+  test_polyInvContour ();
+
   *res = NULL;
 
   if (!a)
@@ -2542,23 +2591,6 @@ node_neighbours (VNODE * a, VNODE * b)
   return (a == b) || (a->next == b) || (b->next == a) || (a->next == b->next);
 }
 
-VNODE *
-poly_CreateNode (Vector v)
-{
-  VNODE *res;
-  Coord *c;
-
-  assert (v);
-  res = (VNODE *) calloc (1, sizeof (VNODE));
-  if (res == NULL)
-    return NULL;
-  // bzero (res, sizeof (VNODE) - sizeof(Vector));
-  c = res->point;
-  *c++ = *v++;
-  *c = *v;
-  return res;
-}
-
 void
 poly_IniContour (PLINE * c)
 {
@@ -2586,6 +2618,10 @@ poly_NewContour (VNODE *node)
   poly_IniContour (res);
 
   Vcopy (res->head.point, node->point);
+  res->head.is_round = node->is_round;
+  res->head.cx = node->cx;
+  res->head.cy = node->cy;
+  res->head.radius = node->radius;
   cntrbox_adjust (res, res->head.point);
   free (node);
 
@@ -2703,6 +2739,47 @@ flip_cb (const BoxType * b, void *cl)
   return 1;
 }
 
+#ifndef DEBUG
+static void
+pline_dump (VNODE * v)
+{
+  VNODE *s;
+
+  s = v;
+  do
+    {
+      pcb_fprintf (stderr, "%mn %mn  - %s, radius %mn\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line", v->is_round ? v->radius : 0);
+    }
+  while ((v = v->next) != s);
+}
+#endif
+
+static void
+test_polyInvContour (void)
+{
+  static bool done = false;
+  PLINE *contour;
+  Vector v;
+
+  if (done)
+    return;
+
+  printf ("Testing inv_contour\n");
+
+  v[0] = 0, v[1] = 0;           contour = poly_NewContour (poly_CreateNodeArcApproximation (v, 0, 0, 1));
+  v[0] = 0, v[1] = 2; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 3));
+  v[0] = 0, v[1] = 4; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 5));
+  v[0] = 0; v[1] = 6; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 7));
+
+  pline_dump (&contour->head);
+  poly_InvContour (contour);
+  pline_dump (&contour->head);
+
+  poly_FreeContours (&contour);
+
+  done = true;
+}
+
 void
 poly_InvContour (PLINE * c)
 {
@@ -2711,16 +2788,48 @@ poly_InvContour (PLINE * c)
   int r;
 #endif
 
+  /* Stash the first data which will get over-written in the loop */
+
+  bool stash_is_round = c->head.is_round;
+  Coord stash_cx = c->head.cx;
+  Coord stash_cy = c->head.cy;
+  Coord stash_radius = c->head.radius;
+
+  bool next_is_round;
+  Coord next_cx;
+  Coord next_cy;
+  Coord next_radius;
+
+//  printf ("poly_InvContour\n");
+
   assert (c != NULL);
   cur = &c->head;
   do
     {
+      /* Swap the attachement of round contour information */
+      next_is_round = cur->next->is_round;
+      next_cx = cur->next->cx;
+      next_cy = cur->next->cy;
+      next_radius = cur->next->radius;
+
+      cur->next->is_round = stash_is_round;
+      cur->next->cx = stash_cx;
+      cur->next->cy = stash_cy;
+      cur->next->radius = stash_radius;
+
+      stash_is_round = next_is_round;
+      stash_cx = next_cx;
+      stash_cy = next_cy;
+      stash_radius = next_radius;
+
       next = NEXT_EDGE (cur);
       NEXT_EDGE(cur) = PREV_EDGE (cur);
       PREV_EDGE (cur) = next;
+
       /* fix the segment tree */
     }
   while ((cur = next) != &c->head);
+
   c->Flags.orient ^= 1;
   if (c->tree)
     {
@@ -2760,11 +2869,26 @@ poly_InclVertex (VNODE * after, VNODE * node)
   /* remove points on same line */
   if (PREV_VERTEX (PREV_VERTEX (node)) == node)
     return;			/* we don't have 3 points in the poly yet */
+
+  /* NB: a-b below is the two-dimensional cross product of the vectors
+   *     node->prev->prev->point -> node->prev->point  and
+   *     node->prev->prev->point -> node->point.
+   *
+   * Its magnitude is the area of the parallelogram with those vectors as sides.
+   * If the vectors are colinear, this is zero.
+   */
   a = (node->point[1] - PREV_VERTEX (PREV_VERTEX (node))->point[1]);
   a *= (PREV_VERTEX (node)->point[0] - PREV_VERTEX (PREV_VERTEX (node))->point[0]);
   b = (node->point[0] - PREV_VERTEX (PREV_VERTEX (node))->point[0]);
   b *= (PREV_VERTEX (node)->point[1] - PREV_VERTEX (PREV_VERTEX (node))->point[1]);
-  if (fabs (a - b) < EPSILON)
+
+//  printf ("a-b = %f\n", a-b);
+
+  /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
+  if (0)
+//  if (fabs (a - b) < 1000000) //EPSILON &&
+//      !node->prev->is_round && !node->is_round)
+//      !node->prev->is_round && !node->is_round)
     {
       VNODE *t = PREV_VERTEX (node);
       NEXT_VERTEX (PREV_VERTEX (t)) = node;
@@ -2780,7 +2904,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   assert (src != NULL);
   *dst = NULL;
-  *dst = poly_NewContour (poly_CreateNode (src->head.point));
+  *dst = poly_NewContour (poly_CreateNodeFull (src->head.point, src->head.is_round, src->head.cx, src->head.cy, src->head.radius));
   if (*dst == NULL)
     return FALSE;
 
@@ -2792,7 +2916,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   for (cur = NEXT_EDGE (&src->head); cur != &src->head; cur = NEXT_VERTEX (cur))
     {
-      if ((newnode = poly_CreateNode (cur->point)) == NULL)
+      if ((newnode = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL)
 	return FALSE;
       // newnode->Flags = cur->Flags;
       poly_InclVertex (PREV_EDGE (&(*dst)->head), newnode);
