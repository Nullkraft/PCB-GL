Bottom: de3963c506100eeaa9f22f458d90d8bbd9652799
Top:    ada50cf844fd3dc1a14886bc343dd39e1aaf6cc9
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-12 01:15:59 +0000

Tag VNODEs with details of circular contour segments

The idea here is to track that the PWL segments actually came from a
particular underlying curve. This should allow us to reconstruct that
curve (approximately at least) if these segments survive in the final
polygon (are not intersected or removed by boolean operations).

The convention is that the curve shape tagging of a vertex corresponds
to the edge spanning this, and the previous vertex around the list.

NB: STILL DOES NOT WORK CORRECTLY IN ALL CASES. SEE:

circ_segs_test4_still_procuces_bad_contour_when_starting_with_arc.pcb

(SUSPECTED BUG IN THE GATHER / JUMP ROUTINES)


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index dfa9db4..978ab3d 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -149,12 +149,14 @@ thindraw_contour (hidGC gc, PLINE *pl)
   hid_draw_set_line_width (gc, 0);
   hid_draw_set_line_cap (gc, Round_Cap);
 
+#if 0
   /* If the contour is round, use an arc drawing routine. */
   if (pl->is_round)
     {
       hid_draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
       return;
     }
+#endif
 
   /* Need at least two points in the contour */
   if (pl->head.next == NULL)
@@ -169,8 +171,33 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      hid_draw_line (gc, last_x, last_y, this_x, this_y);
-      // hid_draw_fill_circle (gc, this_x, this_y, 30);
+      if (v->is_round)
+        {
+          Angle start_angle, end_angle, delta_angle;
+
+          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->cy), -(v->prev->point[0] - v->cx)));
+          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->cy), -(      v->point[0] - v->cx)));
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          hid_draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
+
+          /* Fill the head vertex */
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
+        }
+      else
+        {
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (1.5));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (1.5), MIL_TO_COORD (1.5), 0, 360);
+          hid_draw_line (gc, last_x, last_y, this_x, this_y);
+        }
 
       last_x = this_x;
       last_y = this_y;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 34d3257..5db9b1d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -904,9 +904,11 @@ ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
   double old_alpha_mult = gtk_gc->alpha_mult;
   common_thindraw_pcb_polygon (gc, poly, clip_box);
+#if 0
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
   hid_draw_fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, old_alpha_mult);
+#endif
 }
 
 void
@@ -1643,7 +1645,8 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
     polygon.BoundingBox = *drawn_area;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+//  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw_thin_pcb_polygon (gc, &polygon, drawn_area);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -2694,7 +2697,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-  object3d_draw_debug ();
+  //object3d_draw_debug ();
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/macro.h b/src/macro.h
index a34693a..a38d525 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -69,6 +69,7 @@
 #define XOR(a,b)		(((a) && !(b)) || (!(a) && (b)))
 #define SQUARE(x)		((float) (x) * (float) (x))
 #define TO_RADIANS(degrees)	(M180 * (degrees))
+#define TO_DEGREES(radians)	((radians) / M180)
 
 /* ---------------------------------------------------------------------------
  * layer macros
diff --git a/src/polyarea.h b/src/polyarea.h
index c606077..be95bd2 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -88,6 +88,9 @@ struct VNODE
     CVCList *cvc_prev;
     CVCList *cvc_next;
     Vector point;
+    bool is_round;
+    Coord cx, cy;
+    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -122,6 +125,7 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
+VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index b51a34e..1548677 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -104,11 +104,15 @@ dicer output is used for HIDs which cannot render things with holes
 #include <dmalloc.h>
 #endif
 
+
+#define DEBUG_CIRCSEGS
+
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
+//#define UNSUBTRACT_BLOAT MIL_TO_COORD (0.1)
 #define UNSUBTRACT_BLOAT 10
-#define SUBTRACT_PIN_VIA_BATCH_SIZE 100
-#define SUBTRACT_LINE_BATCH_SIZE 20
+#define SUBTRACT_PIN_VIA_BATCH_SIZE 100 /*100*/
+#define SUBTRACT_LINE_BATCH_SIZE 20 /*20*/
 
 static double rotate_circle_seg[4];
 static double bw_rotate_circle_seg[4];
@@ -278,7 +282,7 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point, already laid by caller */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -302,7 +306,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
   else
@@ -317,7 +321,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
 }
@@ -337,24 +341,37 @@ original_poly (PolygonType * p)
   /* first make initial polygon contour */
   for (n = 0; n < p->PointN; n++)
     {
+      VNODE *node;
+      //Cardinal prev_n;
+
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
       v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+
+      //prev_n = prev_contour_point (p, n);
+
+      /* XXX: Need to handle the case of a leftover circular contour point */
+      if (0)
+        node = poly_CreateNodeArcApproximation (v, 0, 0, 0);
+      else
+        node = poly_CreateNode (v);
+
       if (contour == NULL)
         {
-          if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+          if ((contour = poly_NewContour (node)) == NULL)
             return NULL;
         }
       else
         {
-          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          poly_InclVertex (contour->head.prev, node);
         }
 
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
           Coord cx, cy;
+          Coord radius;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -365,7 +382,7 @@ original_poly (PolygonType * p)
 
 
           calc_arc_from_points_and_included_angle (&p->Points[n], &p->Points[next_n], p->Points[n].included_angle,
-                                                   &cx, &cy, NULL, NULL, NULL);
+                                                   &cx, &cy, &radius, NULL, NULL);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;
@@ -373,7 +390,7 @@ original_poly (PolygonType * p)
           v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
 #endif
 
-          degree_circle (contour, cx, cy, v, p->Points[n].included_angle);
+          degree_circle (contour, cx, cy, radius, v, p->Points[n].included_angle);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;  /* DEBUG TO SHOW THE CENTER OF THE ARC */
@@ -477,6 +494,12 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+//    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
   poly_InclVertex (c->head.prev, poly_CreateNode (v));
   /* move vector to origin */
@@ -493,7 +516,7 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -509,6 +532,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
 
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
@@ -524,7 +548,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -540,7 +564,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
     return NULL;
   v[0] = x + radius;
   v[1] = y;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNodeArcApproximation (v, x, y, radius))) == NULL)
     return NULL;
   frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
@@ -1779,6 +1803,10 @@ ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
           strcmp (layer->Name, "route") == 0)
         Data->outline_valid = false;
     }
+  else if (type == PIN_TYPE || type == VIA_TYPE)
+    {
+        Data->outline_valid = false;
+    }
 
   if (type == POLYGON_TYPE)
     InitClip (PCB->Data, (LayerType *) ptr1, (PolygonType *) ptr2);
@@ -2114,10 +2142,18 @@ arc_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = ArcPoly (arc, arc->Thickness)))
+#else
   if (!(np = ArcPoly (arc, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2130,10 +2166,18 @@ line_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = LinePoly (line, line->Thickness)))
+#else
   if (!(np = LinePoly (line, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2146,10 +2190,18 @@ pv_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = CirclePoly (pv->X, pv->Y, pv->Thickness / 2)))
+#else
   if (!(np = CirclePoly (pv->X, pv->Y, pv->DrillingHole / 2)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2165,8 +2217,11 @@ polygon_outline_callback (const BoxType * b, void *cl)
   if (!(np = original_poly (poly)))
     return 0;
 
-
+#ifdef DEBUG_CIRCSEGS
   poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2257,13 +2312,19 @@ POLYAREA *board_outline_poly (bool include_holes)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
-#if 0
+#if 1
+#ifdef DEBUG_CIRCSEGS
+  info.poly = NULL;
+#else
   info.poly = whole_world;
+#endif
 
   r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
   r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
 
+#ifndef DEBUG_CIRCSEGS
   if (include_holes)
+#endif
     {
       r_search (PCB->Data->pin_tree, &region, NULL, pv_outline_callback, &info);
       r_search (PCB->Data->via_tree, &region, NULL, pv_outline_callback, &info);
@@ -2271,6 +2332,10 @@ POLYAREA *board_outline_poly (bool include_holes)
 
   clipped = info.poly;
 
+#ifdef DEBUG_CIRCSEGS
+  return clipped;
+#endif
+
   /* Now we just need to work out which pieces of polygon are inside
      and outside the board! */
 
@@ -2306,6 +2371,7 @@ POLYAREA *board_outline_poly (bool include_holes)
   g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
 #endif
 
+#ifdef DEBUG_CIRCSEGS
   // The actual operation we want is to split the test polygon into multiple pieces
   // along the intersection with the polygon contours of any polygon on the outer layer.
   // The result would be nested, touching (not normally produced by the PBO code),
@@ -2319,6 +2385,7 @@ POLYAREA *board_outline_poly (bool include_holes)
     return whole_world;
   else
     poly_Free (&whole_world);
+#endif
 
   return clipped;
 }
diff --git a/src/polygon1.c b/src/polygon1.c
index ef82f37..694a161 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -49,6 +49,7 @@
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
+#include "pcb-printf.h"
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
@@ -95,12 +96,13 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
   if (UNLIKELY (((ptr) = (type *)malloc(sizeof(type))) == NULL))	\
     error(err_no_memory);
 
+//#define DEBUG_INTERSECT
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
-#undef DEBUG_JUMP
-#undef DEBUG_GATHER
+//#define DEBUG_JUMP
+//#define DEBUG_GATHER
 #undef DEBUG_ANGLE
-#undef DEBUG
+//#define DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -162,6 +164,41 @@ poly_dump (POLYAREA * p)
 }
 #endif
 
+static VNODE *
+poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+{
+  VNODE *res;
+  Coord *c;
+
+  assert (v);
+  res = (VNODE *) calloc (1, sizeof (VNODE));
+  if (res == NULL)
+    return NULL;
+  // bzero (res, sizeof (VNODE) - sizeof(Vector));
+  c = res->point;
+  *c++ = *v++;
+  *c = *v;
+
+  res->is_round = is_round;
+  res->cx = cx;
+  res->cy = cy;
+  res->radius = radius;
+
+  return res;
+}
+
+VNODE *
+poly_CreateNode (Vector v)
+{
+  return poly_CreateNodeFull (v, false, 0, 0, 0);
+}
+
+VNODE *
+poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+{
+  return poly_CreateNodeFull (v, true, cx, cy, radius);
+}
+
 /***************************************************************/
 /* routines for processing intersections */
 
@@ -181,6 +218,7 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
+/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
@@ -875,6 +913,10 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
+      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
+//      task->node_seg->v->is_round = false;
+      task->node_seg->v->next->is_round = false;
+
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
       task->new_node->next = task->node_seg->v->next;
@@ -1615,11 +1657,30 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
+      VNODE *jump_cur_temp;
+      DIRECTION jump_dir_temp;
+
+      jump_cur_temp = cur;
+      jump_dir_temp = dir;
+
+#if 1
+      /* see where to go next */
+      if (!jump (&jump_cur_temp, &jump_dir_temp, v_rule))
+	break;
+#endif
+
+#if 0
       /* see where to go next */
       if (!jump (&cur, &dir, v_rule))
 	break;
+#endif
       /* add edge to polygon */
-      if ((newn = poly_CreateNode (cur->point)) == NULL)
+//      if ((newn = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      /* XXX: The cur->next part of the line below is somewhat tested, but was determined by trial and error */
+      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->next->is_round,
+                                                   (dir == FORW) ? cur->cx       : cur->next->cx,
+                                                   (dir == FORW) ? cur->cy       : cur->next->cy,
+                                                   (dir == FORW) ? cur->radius   : cur->next->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
         return err_no_memory;
       if (!*result)
 	{
@@ -1632,8 +1693,18 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 	  poly_InclVertex ((*result)->head.prev, newn);
 	}
 #ifdef DEBUG_GATHER
-      DEBUGP ("gather vertex at %#mD\n", cur->point[0], cur->point[1]);
+      DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", cur->point[0], cur->point[1], dir);
+#endif
+#if 1
+      cur = jump_cur_temp;
+      dir = jump_dir_temp;
+#endif
+#if 0
+      /* see where to go next */
+      if (!jump (&cur, &dir, v_rule))
+	break;
 #endif
+
       /* Now mark the edge as included.  */
       newn = (dir == FORW ? cur : cur->prev);
       newn->Flags.mark = 1;
@@ -1643,6 +1714,11 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 
       /* Advance to the next edge.  */
       cur = (dir == FORW ? cur->next : cur->prev);
+#if 0
+      /* see where to go next */
+      if (!jump (&cur, &dir, v_rule))
+	break;
+#endif
     }
   while (1);
   return err_ok;
@@ -2293,6 +2369,8 @@ poly_Boolean (const POLYAREA * a_org, const POLYAREA * b_org,
   return poly_Boolean_free (a, b, res, action);
 }				/* poly_Boolean */
 
+static void test_polyInvContour (void);
+
 /* just like poly_Boolean but frees the input polys */
 int
 poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
@@ -2303,6 +2381,8 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
   jmp_buf e;
   int code;
 
+  test_polyInvContour ();
+
   *res = NULL;
 
   if (!a)
@@ -2486,23 +2566,6 @@ node_neighbours (VNODE * a, VNODE * b)
   return (a == b) || (a->next == b) || (b->next == a) || (a->next == b->next);
 }
 
-VNODE *
-poly_CreateNode (Vector v)
-{
-  VNODE *res;
-  Coord *c;
-
-  assert (v);
-  res = (VNODE *) calloc (1, sizeof (VNODE));
-  if (res == NULL)
-    return NULL;
-  // bzero (res, sizeof (VNODE) - sizeof(Vector));
-  c = res->point;
-  *c++ = *v++;
-  *c = *v;
-  return res;
-}
-
 void
 poly_IniContour (PLINE * c)
 {
@@ -2530,6 +2593,10 @@ poly_NewContour (VNODE *node)
   poly_IniContour (res);
 
   Vcopy (res->head.point, node->point);
+  res->head.is_round = node->is_round;
+  res->head.cx = node->cx;
+  res->head.cy = node->cy;
+  res->head.radius = node->radius;
   cntrbox_adjust (res, res->head.point);
   free (node);
 
@@ -2647,6 +2714,47 @@ flip_cb (const BoxType * b, void *cl)
   return 1;
 }
 
+#ifndef DEBUG
+static void
+pline_dump (VNODE * v)
+{
+  VNODE *s;
+
+  s = v;
+  do
+    {
+      pcb_fprintf (stderr, "%mm %mm  - %s\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line");
+    }
+  while ((v = v->next) != s);
+}
+#endif
+
+static void
+test_polyInvContour (void)
+{
+  static bool done = false;
+  PLINE *contour;
+  Vector v;
+
+  if (done)
+    return;
+
+  printf ("Testing inv_contour\n");
+
+  v[0] = 0, v[1] = 0; contour = poly_NewContour (poly_CreateNode (v));
+  v[0] = 0, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 0));
+  v[0] = 1, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = 1; v[1] = 0; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  pline_dump (&contour->head);
+  poly_InvContour (contour);
+  pline_dump (&contour->head);
+
+  poly_FreeContours (&contour);
+
+  done = true;
+}
+
 void
 poly_InvContour (PLINE * c)
 {
@@ -2655,16 +2763,46 @@ poly_InvContour (PLINE * c)
   int r;
 #endif
 
+  /* Stash the first data which will get over-written in the loop */
+
+  bool stash_is_round = c->head.prev->is_round;
+  Coord stash_cx = c->head.prev->cx;
+  Coord stash_cy = c->head.prev->cy;
+  Coord stash_radius = c->head.prev->radius;
+
+//  printf ("poly_InvContour\n");
+
   assert (c != NULL);
   cur = &c->head;
   do
     {
+#if 1
+      /* Swap the attachement of round contour information */
+      cur->prev->is_round = cur->is_round;
+      cur->prev->cx = cur->cx;
+      cur->prev->cy = cur->cy;
+      cur->prev->radius = cur->radius;
+#endif
+
       next = cur->next;
       cur->next = cur->prev;
       cur->prev = next;
+
       /* fix the segment tree */
     }
   while ((cur = next) != &c->head);
+
+  /* NB: Remember that the list just got reversed.. the last
+   *     entry in the old order got stale data from the wraparound
+   *     Fix that up now.
+   */
+#if 1
+  c->head.next->next->is_round = stash_is_round;
+  c->head.next->next->cx = stash_cx;
+  c->head.next->next->cy = stash_cy;
+  c->head.next->next->radius = stash_radius;
+#endif
+
   c->Flags.orient ^= 1;
   if (c->tree)
     {
@@ -2704,11 +2842,25 @@ poly_InclVertex (VNODE * after, VNODE * node)
   /* remove points on same line */
   if (node->prev->prev == node)
     return;			/* we don't have 3 points in the poly yet */
+
+  /* NB: a-b below is the two-dimensional cross product of the vectors
+   *     node->prev->prev->point -> node->prev->point  and
+   *     node->prev->prev->point -> node->point.
+   *
+   * Its magnitude is the area of the parallelogram with those vectors as sides.
+   * If the vectors are colinear, this is zero.
+   */
   a = (node->point[1] - node->prev->prev->point[1]);
   a *= (node->prev->point[0] - node->prev->prev->point[0]);
   b = (node->point[0] - node->prev->prev->point[0]);
   b *= (node->prev->point[1] - node->prev->prev->point[1]);
-  if (fabs (a - b) < EPSILON)
+
+//  printf ("a-b = %f\n", a-b);
+
+  /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
+  if (fabs (a - b) < 1000000) //EPSILON &&
+//      !node->prev->is_round && !node->is_round)
+//      !node->prev->is_round && !node->is_round)
     {
       VNODE *t = node->prev;
       t->prev->next = node;
@@ -2724,7 +2876,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   assert (src != NULL);
   *dst = NULL;
-  *dst = poly_NewContour (poly_CreateNode (src->head.point));
+  *dst = poly_NewContour (poly_CreateNodeFull (src->head.point, src->head.is_round, src->head.cx, src->head.cy, src->head.radius));
   if (*dst == NULL)
     return FALSE;
 
@@ -2736,7 +2888,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   for (cur = src->head.next; cur != &src->head; cur = cur->next)
     {
-      if ((newnode = poly_CreateNode (cur->point)) == NULL)
+      if ((newnode = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL)
 	return FALSE;
       // newnode->Flags = cur->Flags;
       poly_InclVertex ((*dst)->head.prev, newnode);
