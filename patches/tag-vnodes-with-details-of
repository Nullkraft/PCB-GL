Bottom: 7e66c4d84e7da103e8f155ea9c6797861c56c893
Top:    dc696b239a39c2d413a48923bf9f1172434ee79d
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-24 20:19:13 +0000

Tag VNODEs with details of circular contour segments

The idea here is to track that the PWL segments actually came from a
particular underlying curve. This should allow us to reconstruct that
curve (approximately at least) if these segments survive in the final
polygon (are not intersected or removed by boolean operations).

The convention is that the curve shape tagging of a vertex corresponds
to the edge spanning this, and the net vertex around the list. (As per
other existing edge related flags).

NB: STILL DOES NOT WORK CORRECTLY IN ALL CASES. SEE:

circ_segs_test4_still_procuces_bad_contour_when_starting_with_arc.pcb

(SUSPECTED BUG IN THE GATHER / JUMP ROUTINES)


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 0bded43..1d6e71d 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -169,8 +169,33 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      hid_draw_line (gc, last_x, last_y, this_x, this_y);
-      // hid_draw_fill_circle (gc, this_x, this_y, 30);
+      if (v->prev->is_round)
+        {
+          Angle start_angle, end_angle, delta_angle;
+
+          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->prev->cy), -(v->prev->point[0] - v->prev->cx)));
+          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->prev->cy), -(      v->point[0] - v->prev->cx)));
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          hid_draw_arc (gc, v->prev->cx, v->prev->cy, v->prev->radius, v->prev->radius, start_angle, delta_angle);
+
+          /* Fill the head vertex */
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
+        }
+      else
+        {
+          if (v == &pl->head)
+            hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (1.5));
+          else
+            hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (1.5), MIL_TO_COORD (1.5), 0, 360);
+          hid_draw_line (gc, last_x, last_y, this_x, this_y);
+        }
 
       last_x = this_x;
       last_y = this_y;
diff --git a/src/macro.h b/src/macro.h
index a34693a..a38d525 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -69,6 +69,7 @@
 #define XOR(a,b)		(((a) && !(b)) || (!(a) && (b)))
 #define SQUARE(x)		((float) (x) * (float) (x))
 #define TO_RADIANS(degrees)	(M180 * (degrees))
+#define TO_DEGREES(radians)	((radians) / M180)
 
 /* ---------------------------------------------------------------------------
  * layer macros
diff --git a/src/polyarea.h b/src/polyarea.h
index 6f0f6b0..94bdf45 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -89,6 +89,9 @@ struct VNODE
     CVCList *cvc_prev;
     CVCList *cvc_next;
     Vector point;
+    bool is_round;
+    Coord cx, cy;
+    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -123,6 +126,7 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
+VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index 978a449..5e4e1fc 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -291,7 +291,7 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -299,6 +299,18 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
 
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -315,7 +327,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
   else
@@ -330,7 +342,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
 }
@@ -350,24 +362,37 @@ original_poly (PolygonType * p)
   /* first make initial polygon contour */
   for (n = 0; n < p->PointN; n++)
     {
+      VNODE *node;
+      //Cardinal prev_n;
+
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
       v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+
+      //prev_n = prev_contour_point (p, n);
+
+      /* XXX: Need to handle the case of a leftover circular contour point */
+      if (0)
+        node = poly_CreateNodeArcApproximation (v, 0, 0, 0);
+      else
+        node = poly_CreateNode (v);
+
       if (contour == NULL)
         {
-          if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+          if ((contour = poly_NewContour (node)) == NULL)
             return NULL;
         }
       else
         {
-          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          poly_InclVertex (contour->head.prev, node);
         }
 
       if (p->Points[n].included_angle != 0)
         {
           Cardinal next_n;
           Coord cx, cy;
+          Coord radius;
 
           next_n = n + 1;
           if (next_n == p->PointN ||
@@ -378,7 +403,7 @@ original_poly (PolygonType * p)
 
 
           calc_arc_from_points_and_included_angle (&p->Points[n], &p->Points[next_n], p->Points[n].included_angle,
-                                                   &cx, &cy, NULL, NULL, NULL);
+                                                   &cx, &cy, &radius, NULL, NULL);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;
@@ -386,7 +411,7 @@ original_poly (PolygonType * p)
           v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
 #endif
 
-          degree_circle (contour, cx, cy, v, p->Points[n].included_angle);
+          degree_circle (contour, cx, cy, radius, v, p->Points[n].included_angle);
 
 #if 0 /* DEBUG TO SHOW THE CENTER OF THE ARC */
           v[0] = cx, v[1] = cy;  /* DEBUG TO SHOW THE CENTER OF THE ARC */
@@ -490,8 +515,24 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
-  poly_InclVertex (c->head.prev, poly_CreateNode (v));
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -506,7 +547,7 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -522,6 +563,23 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
@@ -529,7 +587,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 
   /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
   range = POLY_CIRC_SEGS / fraction;
-  for (i = 0; i < range; i++)
+  for (i = 0; i < range - 1; i++)
     {
       /* rotate the vector */
       t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -537,7 +595,7 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -553,7 +611,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
     return NULL;
   v[0] = x + radius;
   v[1] = y;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNodeArcApproximation (v, x, y, radius))) == NULL)
     return NULL;
   frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
@@ -572,22 +630,31 @@ RoundRect (Coord x1, Coord x2, Coord y1, Coord y2, Coord t)
 
   assert (x2 > x1);
   assert (y2 > y1);
+
   v[0] = x1 - t;
-  v[1] = y1;
+  v[1] = y2;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
+  v[0] = x1 - t;
+  v[1] = y1;
   frac_circle (contour, x1, y1, v, 4);
-  v[0] = x2;
+  v[0] = x1;
   v[1] = y1 - t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2;
+  v[1] = y1 - t;
   frac_circle (contour, x2, y1, v, 4);
   v[0] = x2 + t;
-  v[1] = y2;
+  v[1] = y1;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2 + t;
+  v[1] = y2;
   frac_circle (contour, x2, y2, v, 4);
-  v[0] = x1;
+  v[0] = x2;
   v[1] = y2 + t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x1;
+  v[1] = y2 + t;
   frac_circle (contour, x1, y2, v, 4);
   return ContourToPoly (contour);
 }
@@ -626,18 +693,30 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
 
   ang = a->StartAngle;
   da = (1.0 * a->Delta) / segs;
-  radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
+  /* XXX: No need for radius ofsetting bodgery for the exact arc representation */
+  if (rx == ry)
+    radius_adj = 0.;
+  else
+    radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
+
+  /* XXX: First point is a vertex? */
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
-  for (i = 0; i < segs - 1; i++)
-    {
-      ang += da;
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, -a->Delta);
+  else
+    for (i = 0; i < segs - 1; i++)
+      {
+        ang += da;
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+      }
   /* find last point */
   ang = a->StartAngle + a->Delta;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -648,13 +727,18 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   rx = (a->Width + half) * (1+radius_adj);
   ry = (a->Width + half) * (1+radius_adj);
   da = -da;
-  for (i = 0; i < segs; i++)
-    {
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      ang += da;
-    }
+  v[0] = a->X - rx * cos (ang * M180);
+  v[1] = a->Y + ry * sin (ang * M180);
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, a->Delta);
+  else
+    for (i = 0; i < segs; i++)
+      {
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        ang += da;
+      }
   /* now add other round cap */
   ang = a->StartAngle;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -734,33 +818,34 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.Y -= dx;
     }
 
-  v[0] = l->Point2.X - dx;
-  v[1] = l->Point2.Y - dy;
+  v[0] = l->Point1.X - dx;
+  v[1] = l->Point1.Y - dy;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
 
+  v[0] = l->Point2.X - dx;
+  v[1] = l->Point2.Y - dy;
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point2.X + dx;
-      v[1] = l->Point2.Y + dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
 
+  v[0] = l->Point2.X + dx;
+  v[1] = l->Point2.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point1.X - dx;
-      v[1] = l->Point1.Y - dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
 
+//  v[0] = l->Point1.X - dx;
+//  v[1] = l->Point1.Y - dy;
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
@@ -817,25 +902,37 @@ SquarePadPoly (PadType * pad, Coord clear)
       c->Point2.Y -= cx;
     }
 
-  v[0] = c->Point1.X - tx;
-  v[1] = c->Point1.Y - ty;
+  v[0] = c->Point1.X + tx;
+  v[1] = c->Point1.Y + ty;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
+
+  v[0] = c->Point1.X - tx;
+  v[1] = c->Point1.Y - ty;
   frac_circle (contour, (t->Point1.X - tx), (t->Point1.Y - ty), v, 4);
 
+  v[0] = t->Point1.X - cx;
+  v[1] = t->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point2.X - cx;
   v[1] = t->Point2.Y - cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X - tx), (t->Point2.Y - ty), v, 4);
 
+  v[0] = c->Point2.X - tx;
+  v[1] = c->Point2.Y - ty;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = c->Point2.X + tx;
   v[1] = c->Point2.Y + ty;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X + tx), (t->Point2.Y + ty), v, 4);
 
+  v[0] = t->Point2.X + cx;
+  v[1] = t->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point1.X + cx;
   v[1] = t->Point1.Y + cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point1.X + tx), (t->Point1.Y + ty), v, 4);
 
   /* now we have the line contour */
diff --git a/src/polygon1.c b/src/polygon1.c
index 885f268..e3ed7b8 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -109,6 +109,7 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 
 #define error(code)  longjmp(*(e), code)
 
+#undef DEBUG_INTERSECT
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
 #undef DEBUG_JUMP
@@ -154,9 +155,11 @@ pline_dump (VNODE * v)
   do
     {
       n = NEXT_VERTEX(v);
-      pcb_fprintf (stderr, "Line [%#mS %#mS %#mS %#mS 10 10 \"%s\"]\n",
+      pcb_fprintf (stderr, "Line [%$mn %$mn %$mn %$mn 10 10 \"%s\"] # %s, radius %$mn\n",
 	       v->point[0], v->point[1],
-	       n->point[0], n->point[1], theState (v));
+	       n->point[0], n->point[1], theState (v),
+	       VERTEX_FORWARD_EDGE (v)->is_round ? "Round" : "Line",
+	       VERTEX_FORWARD_EDGE (v)->is_round ? v->radius : 0);
     }
   while ((v = NEXT_VERTEX(v)) != s);
 }
@@ -181,6 +184,41 @@ poly_dump (POLYAREA * p)
   while ((p = p->f) != f);
 }
 
+static VNODE *
+poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+{
+  VNODE *res;
+  Coord *c;
+
+  assert (v);
+  res = g_slice_new0 (VNODE);
+  if (res == NULL)
+    return NULL;
+
+  c = res->point;
+  *c++ = *v++;
+  *c = *v;
+
+  res->is_round = is_round;
+  res->cx = cx;
+  res->cy = cy;
+  res->radius = radius;
+
+  return res;
+}
+
+VNODE *
+poly_CreateNode (Vector v)
+{
+  return poly_CreateNodeFull (v, false, 0, 0, 0);
+}
+
+VNODE *
+poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+{
+  return poly_CreateNodeFull (v, true, cx, cy, radius);
+}
+
 /***************************************************************/
 /* routines for processing intersections */
 
@@ -201,6 +239,7 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
+/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, EDGE_BACKWARD_VERTEX (dest)->point))
     return EDGE_BACKWARD_VERTEX (dest);
   if (vect_equal (po, EDGE_FORWARD_VERTEX (dest)->point))
@@ -991,6 +1030,9 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
+      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
+      task->node_seg->v->is_round = false;
+
       /* Do insersion */
       PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
       NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
@@ -1731,8 +1773,11 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
-      /* add vertex to polygon */
-      if ((newn = poly_CreateNode (curv->point)) == NULL)
+      /* add vertex (edge?) to polygon */
+      if ((newn = poly_CreateNodeFull (curv->point, VERTEX_DIRECTION_EDGE (curv, dir)->is_round,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cx,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->cy,
+                                                    VERTEX_DIRECTION_EDGE (curv, dir)->radius)) == NULL)
         return err_no_memory;
       if (!*result)
 	{
@@ -1745,8 +1790,9 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
 	  poly_InclVertex (PREV_VERTEX (&(*result)->head), newn);
 	}
 #ifdef DEBUG_GATHER
-      DEBUGP ("gather vertex at %#mD\n", curv->point[0], curv->point[1]);
+      DEBUGP ("gather vertex at %$mn, %$mn, Dir=%i\n", curv->point[0], curv->point[1], dir);
 #endif
+
       /* Now mark the edge as included.  */
       newn = VERTEX_DIRECTION_EDGE (curv, dir);
       newn->Flags.mark = 1;
@@ -1754,7 +1800,7 @@ Gather (VNODE *startv, PLINE **result, J_Rule j_rule, DIRECTION initdir)
       if (newn->shared)
 	newn->shared->Flags.mark = 1;
 
-      /* Advance to the next vertex.  */
+      /* Advance to the next vertex (edge?).  */
       curv = (dir == FORW) ? NEXT_VERTEX (curv) : PREV_VERTEX (curv);
 
       /* see where to go next */
@@ -3078,23 +3124,6 @@ node_neighbours (VNODE * a, VNODE * b)
   return (a == b) || (a->next == b) || (b->next == a) || (a->next == b->next);
 }
 
-VNODE *
-poly_CreateNode (Vector v)
-{
-  VNODE *res;
-  Coord *c;
-
-  assert (v);
-  res = g_slice_new0 (VNODE);
-  if (res == NULL)
-    return NULL;
-
-  c = res->point;
-  *c++ = *v++;
-  *c = *v;
-  return res;
-}
-
 void
 poly_IniContour (PLINE * c)
 {
@@ -3122,6 +3151,10 @@ poly_NewContour (VNODE *node)
   poly_IniContour (res);
 
   Vcopy (res->head.point, node->point);
+  res->head.is_round = node->is_round;
+  res->head.cx = node->cx;
+  res->head.cy = node->cy;
+  res->head.radius = node->radius;
   cntrbox_adjust (res, res->head.point);
   g_slice_free (VNODE, node);
 
@@ -3247,16 +3280,48 @@ poly_InvContour (PLINE * c)
   int r;
 #endif
 
+  /* Stash the first data which will get over-written in the loop */
+
+  bool stash_is_round = c->head.is_round;
+  Coord stash_cx = c->head.cx;
+  Coord stash_cy = c->head.cy;
+  Coord stash_radius = c->head.radius;
+
+  bool next_is_round;
+  Coord next_cx;
+  Coord next_cy;
+  Coord next_radius;
+
+//  printf ("poly_InvContour\n");
+
   assert (c != NULL);
   cur = &c->head;
   do
     {
+      /* Swap the attachement of round contour information */
+      next_is_round = cur->next->is_round;
+      next_cx = cur->next->cx;
+      next_cy = cur->next->cy;
+      next_radius = cur->next->radius;
+
+      cur->next->is_round = stash_is_round;
+      cur->next->cx = stash_cx;
+      cur->next->cy = stash_cy;
+      cur->next->radius = stash_radius;
+
+      stash_is_round = next_is_round;
+      stash_cx = next_cx;
+      stash_cy = next_cy;
+      stash_radius = next_radius;
+
       next = NEXT_EDGE (cur);
       NEXT_EDGE(cur) = PREV_EDGE (cur);
       PREV_EDGE (cur) = next;
+
       /* fix the segment tree */
     }
   while ((cur = next) != &c->head);
+
   c->Flags.orient ^= 1;
   if (c->tree)
     {
@@ -3296,11 +3361,26 @@ poly_InclVertex (VNODE * after, VNODE * node)
   /* remove points on same line */
   if (PREV_VERTEX (PREV_VERTEX (node)) == node)
     return;			/* we don't have 3 points in the poly yet */
+
+  /* NB: a-b below is the two-dimensional cross product of the vectors
+   *     node->prev->prev->point -> node->prev->point  and
+   *     node->prev->prev->point -> node->point.
+   *
+   * Its magnitude is the area of the parallelogram with those vectors as sides.
+   * If the vectors are colinear, this is zero.
+   */
   a = (node->point[1] - PREV_VERTEX (PREV_VERTEX (node))->point[1]);
   a *= (PREV_VERTEX (node)->point[0] - PREV_VERTEX (PREV_VERTEX (node))->point[0]);
   b = (node->point[0] - PREV_VERTEX (PREV_VERTEX (node))->point[0]);
   b *= (PREV_VERTEX (node)->point[1] - PREV_VERTEX (PREV_VERTEX (node))->point[1]);
-  if (fabs (a - b) < EPSILON)
+
+//  printf ("a-b = %f\n", a-b);
+
+  /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
+  if (0)
+//  if (fabs (a - b) < 1000000) //EPSILON &&
+//      !node->prev->is_round && !node->is_round)
+//      !node->prev->is_round && !node->is_round)
     {
       VNODE *t = PREV_VERTEX (node);
       NEXT_VERTEX (PREV_VERTEX (t)) = node;
@@ -3316,7 +3396,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   assert (src != NULL);
   *dst = NULL;
-  *dst = poly_NewContour (poly_CreateNode (src->head.point));
+  *dst = poly_NewContour (poly_CreateNodeFull (src->head.point, src->head.is_round, src->head.cx, src->head.cy, src->head.radius));
   if (*dst == NULL)
     return FALSE;
 
@@ -3328,7 +3408,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   for (cur = NEXT_EDGE (&src->head); cur != &src->head; cur = NEXT_VERTEX (cur))
     {
-      if ((newnode = poly_CreateNode (cur->point)) == NULL)
+      if ((newnode = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL)
 	return FALSE;
       // newnode->Flags = cur->Flags;
       poly_InclVertex (PREV_EDGE (&(*dst)->head), newnode);
