Bottom: 513b7435a91fcc9d6820d2dc4cef427793ac40f4
Top:    bd354bbc105b261c6ea2d6f6a2b6b81d5d2e5b9a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-12-27 19:33:39 +0000

Tag the from vertex with the circular information, not the to vertex.

This fits more closely with the other data tagged against these structures,
so avoids the need to mess too much with gather / jump.


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index af21e3f..22bdf3b 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -173,18 +173,18 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      if (v->is_round)
+      if (v->prev->is_round)
         {
           Angle start_angle, end_angle, delta_angle;
 
-          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->cy), -(v->prev->point[0] - v->cx)));
-          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->cy), -(      v->point[0] - v->cx)));
+          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->prev->cy), -(v->prev->point[0] - v->prev->cx)));
+          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->prev->cy), -(      v->point[0] - v->prev->cx)));
           delta_angle = end_angle - start_angle;
 
           if (delta_angle > 180.) delta_angle -= 360.;
           if (delta_angle < -180.) delta_angle += 360.;
 
-          gui->graphics->draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
+          gui->graphics->draw_arc (gc, v->prev->cx, v->prev->cy, v->prev->radius, v->prev->radius, start_angle, delta_angle);
 
           /* Fill the head vertex */
           if (v == &pl->head)
diff --git a/src/polygon.c b/src/polygon.c
index d91b5a0..509b93b 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -282,7 +282,7 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -290,6 +290,18 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
 
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -500,14 +512,26 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
   /* XXX: Circle already has the first node added */
 //  if (fraction > 1)
 //    poly_InclVertex (c->head.prev, poly_CreateNode (v));
-//    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
 
   /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
   range = POLY_CIRC_SEGS / fraction;
-  for (i = 0; i < range; i++)
+  for (i = 0; i < range - 1; i++)
     {
       /* rotate the vector */
       t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -550,22 +574,31 @@ RoundRect (Coord x1, Coord x2, Coord y1, Coord y2, Coord t)
 
   assert (x2 > x1);
   assert (y2 > y1);
+
   v[0] = x1 - t;
-  v[1] = y1;
+  v[1] = y2;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
+  v[0] = x1 - t;
+  v[1] = y1;
   frac_circle (contour, x1, y1, v, 4);
-  v[0] = x2;
+  v[0] = x1;
   v[1] = y1 - t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2;
+  v[1] = y1 - t;
   frac_circle (contour, x2, y1, v, 4);
   v[0] = x2 + t;
-  v[1] = y2;
+  v[1] = y1;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2 + t;
+  v[1] = y2;
   frac_circle (contour, x2, y2, v, 4);
-  v[0] = x1;
+  v[0] = x2;
   v[1] = y2 + t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x1;
+  v[1] = y2 + t;
   frac_circle (contour, x1, y2, v, 4);
   return ContourToPoly (contour);
 }
@@ -604,18 +637,30 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
 
   ang = a->StartAngle;
   da = (1.0 * a->Delta) / segs;
-  radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
+  /* XXX: No need for radius ofsetting bodgery for the exact arc representation */
+  if (rx == ry)
+    radius_adj = 0.;
+  else
+    radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
+
+  /* XXX: First point is a vertex? */
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
-  for (i = 0; i < segs - 1; i++)
-    {
-      ang += da;
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, -a->Delta);
+  else
+    for (i = 0; i < segs - 1; i++)
+      {
+        ang += da;
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+      }
   /* find last point */
   ang = a->StartAngle + a->Delta;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -626,13 +671,18 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   rx = (a->Width + half) * (1+radius_adj);
   ry = (a->Width + half) * (1+radius_adj);
   da = -da;
-  for (i = 0; i < segs; i++)
-    {
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      ang += da;
-    }
+  v[0] = a->X - rx * cos (ang * M180);
+  v[1] = a->Y + ry * sin (ang * M180);
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, a->Delta);
+  else
+    for (i = 0; i < segs; i++)
+      {
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        ang += da;
+      }
   /* now add other round cap */
   ang = a->StartAngle;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -712,34 +762,34 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.Y -= dx;
     }
 
+  v[0] = l->Point1.X - dx;
+  v[1] = l->Point1.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
 
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
-    return 0;
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point2.X + dx;
-      v[1] = l->Point2.Y + dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
 
+  v[0] = l->Point2.X + dx;
+  v[1] = l->Point2.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point1.X - dx;
-      v[1] = l->Point1.Y - dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
 
+//  v[0] = l->Point1.X - dx;
+//  v[1] = l->Point1.Y - dy;
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
@@ -796,25 +846,37 @@ SquarePadPoly (PadType * pad, Coord clear)
       c->Point2.Y -= cx;
     }
 
-  v[0] = c->Point1.X - tx;
-  v[1] = c->Point1.Y - ty;
+  v[0] = c->Point1.X + tx;
+  v[1] = c->Point1.Y + ty;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
+
+  v[0] = c->Point1.X - tx;
+  v[1] = c->Point1.Y - ty;
   frac_circle (contour, (t->Point1.X - tx), (t->Point1.Y - ty), v, 4);
 
+  v[0] = t->Point1.X - cx;
+  v[1] = t->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point2.X - cx;
   v[1] = t->Point2.Y - cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X - tx), (t->Point2.Y - ty), v, 4);
 
+  v[0] = c->Point2.X - tx;
+  v[1] = c->Point2.Y - ty;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = c->Point2.X + tx;
   v[1] = c->Point2.Y + ty;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X + tx), (t->Point2.Y + ty), v, 4);
 
+  v[0] = t->Point2.X + cx;
+  v[1] = t->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point1.X + cx;
   v[1] = t->Point1.Y + cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point1.X + tx), (t->Point1.Y + ty), v, 4);
 
   /* now we have the line contour */
diff --git a/src/polygon1.c b/src/polygon1.c
index 694a161..10f3d7f 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -914,8 +914,8 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       insert_node_task *next = task->next;
 
       /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-//      task->node_seg->v->is_round = false;
-      task->node_seg->v->next->is_round = false;
+      task->node_seg->v->is_round = false;
+//      task->node_seg->v->next->is_round = false;
 
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
@@ -1657,19 +1657,16 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
-      VNODE *jump_cur_temp;
-      DIRECTION jump_dir_temp;
-
-      jump_cur_temp = cur;
-      jump_dir_temp = dir;
+#if 0
+      VNODE *jump_cur_temp = cur;
+      DIRECTION jump_dir_temp = dir;
 
-#if 1
       /* see where to go next */
       if (!jump (&jump_cur_temp, &jump_dir_temp, v_rule))
 	break;
 #endif
 
-#if 0
+#if 1
       /* see where to go next */
       if (!jump (&cur, &dir, v_rule))
 	break;
@@ -1677,10 +1674,10 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
       /* add edge to polygon */
 //      if ((newn = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
       /* XXX: The cur->next part of the line below is somewhat tested, but was determined by trial and error */
-      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->next->is_round,
-                                                   (dir == FORW) ? cur->cx       : cur->next->cx,
-                                                   (dir == FORW) ? cur->cy       : cur->next->cy,
-                                                   (dir == FORW) ? cur->radius   : cur->next->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->prev->is_round,
+                                                   (dir == FORW) ? cur->cx       : cur->prev->cx,
+                                                   (dir == FORW) ? cur->cy       : cur->prev->cy,
+                                                   (dir == FORW) ? cur->radius   : cur->prev->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
         return err_no_memory;
       if (!*result)
 	{
@@ -1695,7 +1692,7 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 #ifdef DEBUG_GATHER
       DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", cur->point[0], cur->point[1], dir);
 #endif
-#if 1
+#if 0
       cur = jump_cur_temp;
       dir = jump_dir_temp;
 #endif
@@ -2723,7 +2720,7 @@ pline_dump (VNODE * v)
   s = v;
   do
     {
-      pcb_fprintf (stderr, "%mm %mm  - %s\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line");
+      pcb_fprintf (stderr, "%mn %mn  - %s, radius %mn\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line", v->is_round ? v->radius : 0);
     }
   while ((v = v->next) != s);
 }
@@ -2741,10 +2738,10 @@ test_polyInvContour (void)
 
   printf ("Testing inv_contour\n");
 
-  v[0] = 0, v[1] = 0; contour = poly_NewContour (poly_CreateNode (v));
-  v[0] = 0, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 0));
-  v[0] = 1, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-  v[0] = 1; v[1] = 0; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = 0, v[1] = 0;           contour = poly_NewContour (poly_CreateNodeArcApproximation (v, 0, 0, 1));
+  v[0] = 0, v[1] = 2; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 3));
+  v[0] = 0, v[1] = 4; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 5));
+  v[0] = 0; v[1] = 6; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 7));
 
   pline_dump (&contour->head);
   poly_InvContour (contour);
@@ -2765,10 +2762,22 @@ poly_InvContour (PLINE * c)
 
   /* Stash the first data which will get over-written in the loop */
 
+#if 0
   bool stash_is_round = c->head.prev->is_round;
   Coord stash_cx = c->head.prev->cx;
   Coord stash_cy = c->head.prev->cy;
   Coord stash_radius = c->head.prev->radius;
+#else
+  bool stash_is_round = c->head.is_round;
+  Coord stash_cx = c->head.cx;
+  Coord stash_cy = c->head.cy;
+  Coord stash_radius = c->head.radius;
+
+  bool next_is_round;
+  Coord next_cx;
+  Coord next_cy;
+  Coord next_radius;
+#endif
 
 //  printf ("poly_InvContour\n");
 
@@ -2776,12 +2785,28 @@ poly_InvContour (PLINE * c)
   cur = &c->head;
   do
     {
-#if 1
+#if 0
       /* Swap the attachement of round contour information */
       cur->prev->is_round = cur->is_round;
       cur->prev->cx = cur->cx;
       cur->prev->cy = cur->cy;
       cur->prev->radius = cur->radius;
+#else
+      /* Swap the attachement of round contour information */
+      next_is_round = cur->next->is_round;
+      next_cx = cur->next->cx;
+      next_cy = cur->next->cy;
+      next_radius = cur->next->radius;
+
+      cur->next->is_round = stash_is_round;
+      cur->next->cx = stash_cx;
+      cur->next->cy = stash_cy;
+      cur->next->radius = stash_radius;
+
+      stash_is_round = next_is_round;
+      stash_cx = next_cx;
+      stash_cy = next_cy;
+      stash_radius = next_radius;
 #endif
 
       next = cur->next;
@@ -2796,7 +2821,7 @@ poly_InvContour (PLINE * c)
    *     entry in the old order got stale data from the wraparound
    *     Fix that up now.
    */
-#if 1
+#if 0
   c->head.next->next->is_round = stash_is_round;
   c->head.next->next->cx = stash_cx;
   c->head.next->next->cy = stash_cy;
@@ -2858,7 +2883,8 @@ poly_InclVertex (VNODE * after, VNODE * node)
 //  printf ("a-b = %f\n", a-b);
 
   /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
-  if (fabs (a - b) < 1000000) //EPSILON &&
+  if (0)
+//  if (fabs (a - b) < 1000000) //EPSILON &&
 //      !node->prev->is_round && !node->is_round)
 //      !node->prev->is_round && !node->is_round)
     {
