Bottom: d96582f51ac8d10d7d0c45ce1129d4edeede5650
Top:    5972fbafebefaa4b01ddb28e6a31513ecd2dafe6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-12 01:16:00 +0000

Tag the from vertex with the circular information, not the to vertex.

This fits more closely with the other data tagged against these structures,
so avoids the need to mess too much with gather / jump.


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 978ab3d..0aa9779 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -171,18 +171,18 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      if (v->is_round)
+      if (v->prev->is_round)
         {
           Angle start_angle, end_angle, delta_angle;
 
-          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->cy), -(v->prev->point[0] - v->cx)));
-          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->cy), -(      v->point[0] - v->cx)));
+          start_angle = TO_DEGREES (atan2 ((v->prev->point[1] - v->prev->cy), -(v->prev->point[0] - v->prev->cx)));
+          end_angle   = TO_DEGREES (atan2 ((      v->point[1] - v->prev->cy), -(      v->point[0] - v->prev->cx)));
           delta_angle = end_angle - start_angle;
 
           if (delta_angle > 180.) delta_angle -= 360.;
           if (delta_angle < -180.) delta_angle += 360.;
 
-          hid_draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
+          hid_draw_arc (gc, v->prev->cx, v->prev->cy, v->prev->radius, v->prev->radius, start_angle, delta_angle);
 
           /* Fill the head vertex */
           if (v == &pl->head)
diff --git a/src/polygon.c b/src/polygon.c
index 1f8aa77..01d44f3 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -282,7 +282,7 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
@@ -290,6 +290,18 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
 
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -499,9 +511,19 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
   /* XXX: Circle already has the first node added */
 //  if (fraction > 1)
 //    poly_InclVertex (c->head.prev, poly_CreateNode (v));
-//    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
-  poly_InclVertex (c->head.prev, poly_CreateNode (v));
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -534,13 +556,29 @@ frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
   int i, range;
   double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
 
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
 
   /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
   range = POLY_CIRC_SEGS / fraction;
-  for (i = 0; i < range; i++)
+  for (i = 0; i < range - 1; i++)
     {
       /* rotate the vector */
       t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -583,22 +621,31 @@ RoundRect (Coord x1, Coord x2, Coord y1, Coord y2, Coord t)
 
   assert (x2 > x1);
   assert (y2 > y1);
+
   v[0] = x1 - t;
-  v[1] = y1;
+  v[1] = y2;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
+  v[0] = x1 - t;
+  v[1] = y1;
   frac_circle (contour, x1, y1, v, 4);
-  v[0] = x2;
+  v[0] = x1;
   v[1] = y1 - t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2;
+  v[1] = y1 - t;
   frac_circle (contour, x2, y1, v, 4);
   v[0] = x2 + t;
-  v[1] = y2;
+  v[1] = y1;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x2 + t;
+  v[1] = y2;
   frac_circle (contour, x2, y2, v, 4);
-  v[0] = x1;
+  v[0] = x2;
   v[1] = y2 + t;
   poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = x1;
+  v[1] = y2 + t;
   frac_circle (contour, x1, y2, v, 4);
   return ContourToPoly (contour);
 }
@@ -637,18 +684,30 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
 
   ang = a->StartAngle;
   da = (1.0 * a->Delta) / segs;
-  radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
+  /* XXX: No need for radius ofsetting bodgery for the exact arc representation */
+  if (rx == ry)
+    radius_adj = 0.;
+  else
+    radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
+
+  /* XXX: First point is a vertex? */
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
-  for (i = 0; i < segs - 1; i++)
-    {
-      ang += da;
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, -a->Delta);
+  else
+    for (i = 0; i < segs - 1; i++)
+      {
+        ang += da;
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+      }
   /* find last point */
   ang = a->StartAngle + a->Delta;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -659,13 +718,18 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   rx = (a->Width + half) * (1+radius_adj);
   ry = (a->Width + half) * (1+radius_adj);
   da = -da;
-  for (i = 0; i < segs; i++)
-    {
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      ang += da;
-    }
+  v[0] = a->X - rx * cos (ang * M180);
+  v[1] = a->Y + ry * sin (ang * M180);
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, a->Delta);
+  else
+    for (i = 0; i < segs; i++)
+      {
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        ang += da;
+      }
   /* now add other round cap */
   ang = a->StartAngle;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -745,34 +809,34 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.Y -= dx;
     }
 
+  v[0] = l->Point1.X - dx;
+  v[1] = l->Point1.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
 
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
-    return 0;
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point2.X + dx;
-      v[1] = l->Point2.Y + dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
 
+  v[0] = l->Point2.X + dx;
+  v[1] = l->Point2.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point1.X - dx;
-      v[1] = l->Point1.Y - dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
 
+//  v[0] = l->Point1.X - dx;
+//  v[1] = l->Point1.Y - dy;
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
@@ -829,25 +893,37 @@ SquarePadPoly (PadType * pad, Coord clear)
       c->Point2.Y -= cx;
     }
 
-  v[0] = c->Point1.X - tx;
-  v[1] = c->Point1.Y - ty;
+  v[0] = c->Point1.X + tx;
+  v[1] = c->Point1.Y + ty;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
+
+  v[0] = c->Point1.X - tx;
+  v[1] = c->Point1.Y - ty;
   frac_circle (contour, (t->Point1.X - tx), (t->Point1.Y - ty), v, 4);
 
+  v[0] = t->Point1.X - cx;
+  v[1] = t->Point1.Y - cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point2.X - cx;
   v[1] = t->Point2.Y - cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X - tx), (t->Point2.Y - ty), v, 4);
 
+  v[0] = c->Point2.X - tx;
+  v[1] = c->Point2.Y - ty;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = c->Point2.X + tx;
   v[1] = c->Point2.Y + ty;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point2.X + tx), (t->Point2.Y + ty), v, 4);
 
+  v[0] = t->Point2.X + cx;
+  v[1] = t->Point2.Y + cy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = t->Point1.X + cx;
   v[1] = t->Point1.Y + cy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   frac_circle (contour, (t->Point1.X + tx), (t->Point1.Y + ty), v, 4);
 
   /* now we have the line contour */
diff --git a/src/polygon1.c b/src/polygon1.c
index 47e679d..b489dde 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -914,8 +914,8 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       insert_node_task *next = task->next;
 
       /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-//      task->node_seg->v->is_round = false;
-      task->node_seg->v->next->is_round = false;
+      task->node_seg->v->is_round = false;
+//      task->node_seg->v->next->is_round = false;
 
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
@@ -1657,19 +1657,16 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
-      VNODE *jump_cur_temp;
-      DIRECTION jump_dir_temp;
-
-      jump_cur_temp = cur;
-      jump_dir_temp = dir;
+#if 0
+      VNODE *jump_cur_temp = cur;
+      DIRECTION jump_dir_temp = dir;
 
-#if 1
       /* see where to go next */
       if (!jump (&jump_cur_temp, &jump_dir_temp, v_rule))
 	break;
 #endif
 
-#if 0
+#if 1
       /* see where to go next */
       if (!jump (&cur, &dir, v_rule))
 	break;
@@ -1677,10 +1674,10 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
       /* add edge to polygon */
 //      if ((newn = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
       /* XXX: The cur->next part of the line below is somewhat tested, but was determined by trial and error */
-      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->next->is_round,
-                                                   (dir == FORW) ? cur->cx       : cur->next->cx,
-                                                   (dir == FORW) ? cur->cy       : cur->next->cy,
-                                                   (dir == FORW) ? cur->radius   : cur->next->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->prev->is_round,
+                                                   (dir == FORW) ? cur->cx       : cur->prev->cx,
+                                                   (dir == FORW) ? cur->cy       : cur->prev->cy,
+                                                   (dir == FORW) ? cur->radius   : cur->prev->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
         return err_no_memory;
       if (!*result)
 	{
@@ -1695,7 +1692,7 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 #ifdef DEBUG_GATHER
       DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", cur->point[0], cur->point[1], dir);
 #endif
-#if 1
+#if 0
       cur = jump_cur_temp;
       dir = jump_dir_temp;
 #endif
@@ -2723,7 +2720,7 @@ pline_dump (VNODE * v)
   s = v;
   do
     {
-      pcb_fprintf (stderr, "%mm %mm  - %s\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line");
+      pcb_fprintf (stderr, "%mn %mn  - %s, radius %mn\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line", v->is_round ? v->radius : 0);
     }
   while ((v = v->next) != s);
 }
@@ -2741,10 +2738,10 @@ test_polyInvContour (void)
 
   printf ("Testing inv_contour\n");
 
-  v[0] = 0, v[1] = 0; contour = poly_NewContour (poly_CreateNode (v));
-  v[0] = 0, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 0));
-  v[0] = 1, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-  v[0] = 1; v[1] = 0; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = 0, v[1] = 0;           contour = poly_NewContour (poly_CreateNodeArcApproximation (v, 0, 0, 1));
+  v[0] = 0, v[1] = 2; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 3));
+  v[0] = 0, v[1] = 4; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 5));
+  v[0] = 0; v[1] = 6; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 7));
 
   pline_dump (&contour->head);
   poly_InvContour (contour);
@@ -2765,10 +2762,22 @@ poly_InvContour (PLINE * c)
 
   /* Stash the first data which will get over-written in the loop */
 
+#if 0
   bool stash_is_round = c->head.prev->is_round;
   Coord stash_cx = c->head.prev->cx;
   Coord stash_cy = c->head.prev->cy;
   Coord stash_radius = c->head.prev->radius;
+#else
+  bool stash_is_round = c->head.is_round;
+  Coord stash_cx = c->head.cx;
+  Coord stash_cy = c->head.cy;
+  Coord stash_radius = c->head.radius;
+
+  bool next_is_round;
+  Coord next_cx;
+  Coord next_cy;
+  Coord next_radius;
+#endif
 
 //  printf ("poly_InvContour\n");
 
@@ -2776,12 +2785,28 @@ poly_InvContour (PLINE * c)
   cur = &c->head;
   do
     {
-#if 1
+#if 0
       /* Swap the attachement of round contour information */
       cur->prev->is_round = cur->is_round;
       cur->prev->cx = cur->cx;
       cur->prev->cy = cur->cy;
       cur->prev->radius = cur->radius;
+#else
+      /* Swap the attachement of round contour information */
+      next_is_round = cur->next->is_round;
+      next_cx = cur->next->cx;
+      next_cy = cur->next->cy;
+      next_radius = cur->next->radius;
+
+      cur->next->is_round = stash_is_round;
+      cur->next->cx = stash_cx;
+      cur->next->cy = stash_cy;
+      cur->next->radius = stash_radius;
+
+      stash_is_round = next_is_round;
+      stash_cx = next_cx;
+      stash_cy = next_cy;
+      stash_radius = next_radius;
 #endif
 
       next = cur->next;
@@ -2796,7 +2821,7 @@ poly_InvContour (PLINE * c)
    *     entry in the old order got stale data from the wraparound
    *     Fix that up now.
    */
-#if 1
+#if 0
   c->head.next->next->is_round = stash_is_round;
   c->head.next->next->cx = stash_cx;
   c->head.next->next->cy = stash_cy;
@@ -2858,7 +2883,8 @@ poly_InclVertex (VNODE * after, VNODE * node)
 //  printf ("a-b = %f\n", a-b);
 
   /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
-  if (fabs (a - b) < 1000000) //EPSILON &&
+  if (0)
+//  if (fabs (a - b) < 1000000) //EPSILON &&
 //      !node->prev->is_round && !node->is_round)
 //      !node->prev->is_round && !node->is_round)
     {
