Bottom: 690f9fd0574069d9b3465754a8b26d59f47b2147
Top:    4c87a03e2ebe163558d68268ee1220735b366c1f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-18 14:11:33 +0000

Alternative, more thorough STEP export code


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 20ff48a..286185e 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -157,6 +157,10 @@ PCB_SRCS = \
 	hid/common/draw_helpers.h \
 	hid/common/hid_resource.c \
 	hid/common/hid_resource.h \
+	hid/common/appearance.c \
+	hid/common/appearance.h \
+	hid/common/contour3d.c \
+	hid/common/contour3d.h \
 	hid/common/edge3d.c \
 	hid/common/edge3d.h \
 	hid/common/face3d.c \
@@ -165,9 +169,10 @@ PCB_SRCS = \
 	hid/common/object3d.h \
 	hid/common/quad.c \
 	hid/common/quad.h \
+	hid/common/step_id.h \
 	hid/common/vertex3d.c \
 	hid/common/vertex3d.h \
-	hid/hidint.h 
+	hid/hidint.h
 
 EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS} toporouter.c toporouter.h
 nodist_EXTRA_pcb_SOURCES = dummy.cpp
@@ -475,7 +480,11 @@ LIBSTEP_SRCS = \
 	hid/step/assembly.cpp \
 	hid/step/assembly.h \
 	hid/step/utils.cpp \
-	hid/step/utils.h
+	hid/step/utils.h \
+	hid/step/step_writer.c \
+	hid/step/step_writer.h \
+	hid/step/object3d_step.c \
+	hid/step/object3d_step.h
 libstep_a_SOURCES = ${LIBSTEP_SRCS} hid/step/step_lists.h
 
 pcb_LDFLAGS = \
diff --git a/src/hid/common/appearance.c b/src/hid/common/appearance.c
new file mode 100644
index 0000000..92790fcc
--- /dev/null
+++ b/src/hid/common/appearance.c
@@ -0,0 +1,25 @@
+#include <glib.h>
+
+#include "appearance.h"
+
+appearance
+*make_appearance (void)
+{
+  appearance *appear = g_new0 (appearance, 1);
+
+  return appear;
+}
+
+void
+destroy_appearance (appearance *appear)
+{
+  g_free (appear);
+}
+
+void
+appearance_set_color (appearance *appear, float r, float g, float b)
+{
+  appear->r = r;
+  appear->g = g;
+  appear->b = b;
+}
diff --git a/src/hid/common/appearance.h b/src/hid/common/appearance.h
new file mode 100644
index 0000000..d4917d7
--- /dev/null
+++ b/src/hid/common/appearance.h
@@ -0,0 +1,7 @@
+typedef struct {
+  float r, g, b;
+} appearance;
+
+appearance *make_appearance (void);
+void destroy_appearance (appearance *appearance);
+void appearance_set_color (appearance *appearance, float r, float g, float b);
diff --git a/src/hid/common/contour3d.c b/src/hid/common/contour3d.c
new file mode 100644
index 0000000..13e865e
--- /dev/null
+++ b/src/hid/common/contour3d.c
@@ -0,0 +1,24 @@
+#include <glib.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include "step_id.h"
+#include "quad.h"
+#include "contour3d.h"
+
+contour3d *
+make_contour3d (edge_ref first_edge)
+{
+  contour3d *contour;
+
+  contour = g_new0 (contour3d, 1);
+  contour->first_edge = first_edge;
+
+  return contour;
+}
+
+void
+destroy_contour3d (contour3d *contour)
+{
+  g_free (contour);
+}
diff --git a/src/hid/common/contour3d.h b/src/hid/common/contour3d.h
new file mode 100644
index 0000000..837e666
--- /dev/null
+++ b/src/hid/common/contour3d.h
@@ -0,0 +1,9 @@
+typedef struct {
+  edge_ref first_edge;
+
+  /* STEP crap - to hell with encapsulation */
+  step_id face_bound_identifier;
+} contour3d;
+
+contour3d *make_contour3d (edge_ref first_edge);
+void destroy_contour3d (contour3d *contour);
diff --git a/src/hid/common/face3d.c b/src/hid/common/face3d.c
index e69de29..13d7501 100644
--- a/src/hid/common/face3d.c
+++ b/src/hid/common/face3d.c
@@ -0,0 +1,65 @@
+#include <glib.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include "step_id.h"
+#include "quad.h"
+#include "contour3d.h"
+#include "appearance.h"
+#include "face3d.h"
+
+face3d *
+make_face3d (void)
+{
+  face3d *face;
+
+  face = g_new0 (face3d, 1);
+
+  return face;
+}
+
+void
+destroy_face3d (face3d *face)
+{
+  g_list_free_full (face->contours, (GDestroyNotify)destroy_contour3d);
+  g_free (face);
+}
+
+void
+face3d_add_contour (face3d *face, contour3d *contour)
+{
+  face->contours = g_list_append (face->contours, contour);
+}
+
+void
+face3d_set_appearance (face3d *face, appearance *appear)
+{
+  face->appear = appear;
+}
+
+void
+face3d_set_normal (face3d *face, double nx, double ny, double nz)
+{
+  face->nx = nx;
+  face->ny = ny;
+  face->nz = nz;
+}
+
+void
+face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius)
+{
+  face->is_cylindrical = true;
+  face->cx = cx;
+  face->cy = cy;
+  face->cz = cz;
+  face->ax = ax;
+  face->ay = ay;
+  face->az = az;
+  face->radius = radius;
+}
+
+void
+face3d_set_surface_orientation_reversed (face3d *face)
+{
+  face->surface_orientation_reversed = true;
+}
diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index e69de29..0998a22 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -0,0 +1,26 @@
+typedef struct {
+  double nx, ny, nz; /* Face normal?*/
+  GList *contours;
+
+  /* For cylindrical surfaces */
+  bool is_cylindrical;
+  double cx, cy, cz; /* A point on the axis */
+  double ax, ay, az; /* Direction of the axis */
+  double radius;
+
+  appearance *appear;
+
+  /* STEP crap - to hell with encapsulation */
+  step_id surface_identifier;
+  bool surface_orientation_reversed;
+  step_id face_identifier;
+  step_id face_bound_identifier;
+} face3d;
+
+face3d *make_face3d (void);
+void destroy_face3d (face3d *face);
+void face3d_add_contour (face3d *face, contour3d *contour);
+void face3d_set_appearance (face3d *face, appearance *appear);
+void face3d_set_normal (face3d *face, double nx, double ny, double nz);
+void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
+void face3d_set_surface_orientation_reversed (face3d *face);
diff --git a/src/hid/common/step_id.h b/src/hid/common/step_id.h
new file mode 100644
index 0000000..86a4974
--- /dev/null
+++ b/src/hid/common/step_id.h
@@ -0,0 +1,2 @@
+typedef int step_id;
+typedef GList* step_id_list;
diff --git a/src/hid/common/vertex3d.c b/src/hid/common/vertex3d.c
index df5fd0e..cf20fb2 100644
--- a/src/hid/common/vertex3d.c
+++ b/src/hid/common/vertex3d.c
@@ -1,17 +1,15 @@
+#include <glib.h>
 #include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
 
-static int global_vertex3d_count;
+#include "step_id.h"
+#include "vertex3d.h"
 
-typedef struct
-{
-  float x;
-  float y;
-  float z;
-  int id;
-} vertex3d;
+static int global_vertex3d_count;
 
 vertex3d *
-make_vertex3d (float x, float y, float z)
+make_vertex3d (double x, double y, double z)
 {
   vertex3d *v;
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1dbfdac..b2539ca 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -15,7 +15,13 @@
 #include "gui-pinout-preview.h"
 #include "pcb-printf.h"
 
+#include "hid/common/step_id.h"
 #include "hid/common/quad.h"
+#include "hid/common/vertex3d.h"
+#include "hid/common/contour3d.h"
+#include "hid/common/appearance.h"
+#include "hid/common/face3d.h"
+#include "hid/common/edge3d.h"
 #include "hid/common/object3d.h"
 
 #ifndef WIN32
diff --git a/src/hid/step/object3d_step.c b/src/hid/step/object3d_step.c
new file mode 100644
index 0000000..6879a98
--- /dev/null
+++ b/src/hid/step/object3d_step.c
@@ -0,0 +1,391 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <stdbool.h>
+
+#include <glib.h>
+
+#include "hid/common/step_id.h"
+#include "hid/common/quad.h"
+#include "hid/common/vertex3d.h"
+#include "hid/common/contour3d.h"
+#include "hid/common/appearance.h"
+#include "hid/common/face3d.h"
+#include "hid/common/edge3d.h"
+#include "hid/common/object3d.h"
+#include "polygon.h"
+#include "data.h"
+
+#include "step_writer.h"
+
+#include "pcb-printf.h"
+
+#include "object3d_step.h"
+
+
+#define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
+
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#endif
+
+
+static step_id_list
+presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
+{
+  step_id colour = step_colour_rgb (step, "", appear->r, appear->g, appear->b);
+  step_id fill_area_style = step_fill_area_style (step, "", make_step_id_list (1, step_fill_area_style_colour (step, "", colour)));
+  step_id surface_side_style = step_surface_side_style (step, "", make_step_id_list (1, step_surface_style_fill_area (step, fill_area_style)));
+  step_id_list styles_list = make_step_id_list (1, step_surface_style_usage (step, "BOTH", surface_side_style));
+  step_id_list psa_list = make_step_id_list (1, step_presentation_style_assignment (step, styles_list));
+
+  return psa_list;
+}
+
+static step_file *
+start_ap214_file (const char *filename)
+{
+  FILE *f;
+  time_t currenttime;
+  struct tm utc;
+
+  f = fopen (filename, "w");
+  if (f == NULL)
+    {
+      perror (filename);
+      return NULL;
+    }
+
+  currenttime = time (NULL);
+  gmtime_r (&currenttime, &utc);
+
+  fprintf (f, "ISO-10303-21;\n");
+  fprintf (f, "HEADER;\n");
+  fprintf (f, "FILE_DESCRIPTION (\n"
+              "/* description */ ('STEP AP214 export of circuit board'),\n"
+              "/* implementation level */ '1');\n");
+  fprintf (f, "FILE_NAME (/* name */ '%s',\n"
+              "/* time_stamp */ '%.4d-%.2d-%.2dT%.2d:%.2d:%.2d',\n"
+              "/* author */ ( '' ),\n"
+              "/* organisation */ ( '' ),\n"
+              "/* preprocessor_version */ 'PCB STEP EXPORT',\n"
+              "/* originating system */ '%s " VERSION "',\n"
+              "/* authorisation */ '' );\n",
+           filename,
+           1900 + utc.tm_year, 1 + utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec,
+           Progname);
+  fprintf (f, "FILE_SCHEMA (( 'AUTOMOTIVE_DESIGN' ));\n");
+  fprintf (f, "ENDSEC;\n");
+  fprintf (f, "\n");
+  fprintf (f, "DATA;\n");
+
+  return step_output_file (f);
+}
+
+static void
+finish_ap214_file (step_file *step)
+{
+  fprintf (step->f, "ENDSEC;\n" );
+  fprintf (step->f, "END-ISO-10303-21;\n" );
+  fclose (step->f);
+}
+
+static void
+object3d_to_step_fragment (step_file *step, object3d *object, char *part_id, char *part_name, char *part_description, char *body_name,
+                           step_id *shape_definition_representation, step_id *placement_axis)
+{
+  step_id application_context_identifier;
+  step_id product_identifier;
+  step_id product_definition_identifier;
+  step_id product_definition_shape_identifier;
+  step_id geometric_representation_context_identifier;
+  step_id shape_representation_identifier;
+  step_id brep_identifier;
+  step_id anchor_axis_identifier;
+  step_id pcb_shell_identifier;
+  step_id brep_style_identifier;
+  step_id shape_definition_representation_identifier;
+  GList *styled_item_identifiers = NULL;
+  GList *shell_face_list = NULL;
+  GList *face_iter;
+  GList *edge_iter;
+  GList *vertex_iter;
+  GList *contour_iter;
+
+  /* Setup the context of the "product" we are defining", and that it is a 'part' */
+  application_context_identifier = step_application_context (step, "automotive_design");
+  step_application_protocol_definition (step, "draft international standard", "automotive_design", "1998", application_context_identifier);
+  product_identifier = step_product (step, part_id, part_name /* This one is picked up by freecad */, part_description,
+                                     make_step_id_list (1, step_product_context (step, "NONE", application_context_identifier, "mechanical")));
+  step_product_related_product_category (step, "part", NULL, make_step_id_list (1, product_identifier));
+
+  /* Setup the specific definition of the product we are defining */
+  product_definition_identifier = step_product_definition (step, "UNKNOWN", "",
+                                                           step_product_definition_formation (step, "any", "", product_identifier), /* Versioning for the product */
+                                                           step_product_definition_context (step, "detailed design", application_context_identifier, "design"));
+  product_definition_shape_identifier = step_product_definition_shape (step, "NONE", "NONE", product_definition_identifier);
+
+  geometric_representation_context_identifier = make_3d_metric_step_geometric_representation_context (step);
+
+#define FWD 1
+#define REV 2
+#define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
+
+  /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+
+    if (face->is_cylindrical) {
+      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+       */
+      face->surface_identifier =
+        step_cylindrical_surface (step, "NONE",
+                                  step_axis2_placement_3d (step, "NONE",
+                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                  face->radius);
+    } else {
+      contour3d *outer_contour = face->contours->data;
+      vertex3d *ov = ODATA (outer_contour->first_edge);
+      vertex3d *dv = DDATA (outer_contour->first_edge);
+
+      double rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
+      face->surface_identifier =
+        step_plane (step, "NONE",
+                    step_axis2_placement_3d (step, "NONE",
+                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */ 
+                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
+                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
+    }
+  }
+
+  /* Define the infinite lines corresponding to every edge (either lines or circles)*/
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+
+    if (info->is_round) {
+      info->infinite_line_identifier =
+        step_circle (step, "NONE",
+                     step_axis2_placement_3d (step, "NONE",
+                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                    info->radius);
+    } else {
+      vertex3d *ov = ODATA (edge);
+      vertex3d *dv = DDATA (edge);
+
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
+      info->infinite_line_identifier =
+        step_line (step, "NONE",
+                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                   step_vector (step, "NONE",
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
+                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
+    }
+  }
+
+  /* Define the vertices */
+  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter)) {
+    vertex3d *vertex = vertex_iter->data;
+
+    vertex->vertex_identifier =
+      step_vertex_point (step, "NONE", step_cartesian_point (step, "NONE", vertex->x, vertex->y, vertex->z));
+  }
+
+  /* Define the Edges */
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+    step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
+    step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
+
+    /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
+    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+    step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
+    step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
+  }
+
+  /* Define the faces */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+    bool outer_contour = true;
+    step_id_list face_contour_list = NULL;
+
+    for (contour_iter = face->contours;
+         contour_iter != NULL;
+         contour_iter = g_list_next (contour_iter), outer_contour = false) {
+      contour3d *contour = contour_iter->data;
+      edge_ref edge;
+      step_id edge_loop;
+      step_id_list edge_loop_edges = NULL;
+
+      edge = contour->first_edge;
+      do {
+        edge_loop_edges = g_list_append (edge_loop_edges, GINT_TO_POINTER (ORIENTED_EDGE_IDENTIFIER (edge)));
+      } while (edge = LNEXT (edge), edge != contour->first_edge);
+
+      edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
+
+      if (outer_contour)
+        contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, true);
+      else
+        contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
+
+      face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
+    }
+
+    face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
+    shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
+  }
+
+  /* Closed shell which bounds the brep solid */
+  pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
+  brep_identifier = step_manifold_solid_brep (step, body_name /* This is picked up as the solid body name by Solidworks */, pcb_shell_identifier);
+
+#if 1
+  /* Body style */
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
+
+  /* Face styles */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+
+    if (face->appear != NULL) {
+      step_id orsi = step_over_riding_styled_item (step, "NONE",
+                                                   presentation_style_assignments_from_appearance (step, face->appear),
+                                                   face->face_identifier, brep_style_identifier);
+      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+    }
+  }
+
+  /* Emit references to the styled and over_ridden styled items */
+  step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
+
+  /* Need an anchor in 3D space to orient the shape */
+  anchor_axis_identifier = step_axis2_placement_3d (step, "NONE",
+                                                    step_cartesian_point (step, "NONE", 0.0, 0.0, 0.0),
+                                                          step_direction (step, "NONE", 0.0, 0.0, 1.0),
+                                                          step_direction (step, "NONE", 1.0, 0.0, 0.0)),
+
+  shape_representation_identifier =
+    step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
+                                             make_step_id_list (2, brep_identifier, anchor_axis_identifier), geometric_representation_context_identifier);
+
+  shape_definition_representation_identifier =
+  step_shape_definition_representation (step, product_definition_shape_identifier, shape_representation_identifier);
+
+  if (shape_definition_representation != NULL)
+    *shape_definition_representation = shape_definition_representation_identifier;
+
+  if (placement_axis != NULL)
+    *placement_axis = anchor_axis_identifier;
+
+#undef ORIENTED_EDGE_IDENTIFIER
+#undef FWD
+#undef REV
+}
+
+void
+object3d_list_export_to_step_assy (GList *objects, const char *filename)
+{
+  step_file *step;
+  step_id comp_shape_definition_representation;
+  step_id comp_placement_axis;
+  GList *object_iter;
+  int part;
+  bool multiple_parts;
+
+  multiple_parts = (g_list_next (objects) != NULL);
+
+  step = start_ap214_file (filename);
+
+  for (object_iter = objects, part = 1;
+       object_iter != NULL;
+       object_iter = g_list_next (object_iter), part++) {
+
+    object3d *object = object_iter->data;
+    GString *part_id;
+    GString *part_name;
+    GString *body_name;
+
+    part_id   = g_string_new ("board");
+    part_name = g_string_new ("PCB board");
+    body_name = g_string_new ("PCB board body");
+
+    if (multiple_parts) {
+      g_string_append_printf (part_id, "-%i", part);
+      g_string_append_printf (part_name, " - %i", part);
+      g_string_append_printf (body_name, " - %i", part);
+    }
+
+    object3d_to_step_fragment (step, object, part_id->str, part_name->str, "PCB model", body_name->str,
+                               &comp_shape_definition_representation, &comp_placement_axis);
+
+    g_string_free (part_id, true);
+    g_string_free (part_name, true);
+    g_string_free (body_name, true);
+  }
+
+  finish_ap214_file (step);
+
+  /* XXX: TODO: MAKE AN ASSEMBLY PRODUCT AND GATHER THE ABOVE PIECES INSIDE IT */
+}
+
+void
+object3d_export_to_step (object3d *object, const char *filename)
+{
+  step_file *step;
+
+  step = start_ap214_file (filename);
+  object3d_to_step_fragment (step, object, "board", "PCB board", "PCB model", "PCB board body", NULL, NULL);
+  finish_ap214_file (step);
+}
diff --git a/src/hid/step/object3d_step.h b/src/hid/step/object3d_step.h
new file mode 100644
index 0000000..5dc6f4d
--- /dev/null
+++ b/src/hid/step/object3d_step.h
@@ -0,0 +1,2 @@
+void object3d_list_export_to_step_assy (GList *objects, const char *filename);
+void object3d_export_to_step (object3d *object, const char *filename);
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index c109dc5..2e2e86d 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -26,6 +26,16 @@
 #include "polygon.h"
 #include "misc.h"
 
+#include "hid/common/step_id.h"
+#include "hid/common/quad.h"
+#include "hid/common/vertex3d.h"
+#include "hid/common/contour3d.h"
+#include "hid/common/appearance.h"
+#include "hid/common/face3d.h"
+#include "hid/common/edge3d.h"
+#include "hid/common/object3d.h"
+#include "object3d_step.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -36,23 +46,8 @@
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
 
-static int step_set_layer (const char *name, int group, int empty);
-static void use_gc (hidGC gc);
-
-typedef struct step_gc_struct
-{
-  struct hid_gc_struct hid_gc; /* Parent */
-
-  EndCapStyle cap;
-  Coord width;
-  unsigned char r, g, b;
-  int erase;
-  int faded;
-} *stepGC;
 
 HID step_hid;
-static HID_DRAW step_graphics;
-static HID_DRAW_CLASS step_graphics_class;
 
 HID_Attribute step_attribute_list[] = {
   /* other HIDs expect this to be first.  */
@@ -73,27 +68,7 @@ Name of the STEP output file. Can contain a path.
 
 REGISTER_ATTRIBUTES (step_attribute_list)
 
-/* All file-scope data is in global struct */
-static struct {
-
-  FILE *f;
-  bool print_group[MAX_LAYER];
-  bool print_layer[MAX_LAYER];
-
-  const char *filename;
-
-  LayerType *outline_layer;
-
-  HID_Attr_Val step_values[NUM_OPTIONS];
-
-  bool is_mask;
-  bool is_drill;
-  bool is_assy;
-  bool is_copper;
-  bool is_paste;
-
-  int next_identifier;
-} global;
+static HID_Attr_Val step_option_values[NUM_OPTIONS];
 
 static HID_Attribute *
 step_get_export_options (int *n)
@@ -107,658 +82,6 @@ step_get_export_options (int *n)
   return step_attribute_list;
 }
 
-static int
-group_for_layer (int l)
-{
-  if (l < max_copper_layer + 2 && l >= 0)
-    return GetLayerGroupNumberByNumber (l);
-  /* else something unique */
-  return max_group + 3 + l;
-}
-
-static int
-layer_sort (const void *va, const void *vb)
-{
-  int a = *(int *) va;
-  int b = *(int *) vb;
-  int d = group_for_layer (b) - group_for_layer (a);
-  if (d)
-    return d;
-  return b - a;
-}
-
-void
-step_start_file (FILE *f, const char *filename)
-{
-  time_t currenttime = time (NULL);
-  struct tm utc;
-
-  gmtime_r (&currenttime, &utc);
-
-  fprintf (f, "ISO-10303-21;\n");
-  fprintf (f, "HEADER;\n");
-  fprintf (f, "FILE_DESCRIPTION (\n"
-              "/* description */ ('STEP AP214 export of circuit board'),\n"
-              "/* implementation level */ '1');\n");
-  fprintf (f, "FILE_NAME (/* name */ '%s',\n"
-              "/* time_stamp */ '%.4d-%.2d-%.2dT%.2d:%.2d:%.2d',\n"
-              "/* author */ ( '' ),\n"
-              "/* organisation */ ( '' ),\n"
-              "/* preprocessor_version */ 'PCB STEP EXPORT',\n"
-              "/* originating system */ '%s " VERSION "',\n"
-              "/* authorisation */ '' );\n",
-           filename,
-           1900 + utc.tm_year, 1 + utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec,
-           Progname);
-  fprintf (f, "FILE_SCHEMA (( 'AUTOMOTIVE_DESIGN' ));\n");
-  fprintf (f, "ENDSEC;\n");
-  fprintf (f, "\n");
-  fprintf (f, "DATA;\n");
-
-  /* TEST */
-
-  /* Setup the context of the "product" we are defining", and that it is a 'part' */
-
-  fprintf (f, "#1 = APPLICATION_CONTEXT ( 'automotive_design' ) ;\n"
-              "#2 = APPLICATION_PROTOCOL_DEFINITION ( 'draft international standard', 'automotive_design', 1998, #1 );\n"
-              "#3 = PRODUCT_CONTEXT ( 'NONE', #1, 'mechanical' ) ;\n"
-              "#4 = PRODUCT ('%s', '%s', '%s', (#3)) ;\n"
-              "#5 = PRODUCT_RELATED_PRODUCT_CATEGORY ('part', $, (#4)) ;\n",
-              "test_pcb_id", "test_pcb_name", "test_pcb_description");
-
-  /* Setup the specific definition of the product we are defining */
-  fprintf (f, "#6 = PRODUCT_DEFINITION_CONTEXT ( 'detailed design', #1, 'design' ) ;\n"
-              "#7 = PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE ( 'ANY', '', #4, .NOT_KNOWN. ) ;\n"
-              "#8 = PRODUCT_DEFINITION ( 'UNKNOWN', '', #7, #6 ) ;\n"
-              "#9 = PRODUCT_DEFINITION_SHAPE ( 'NONE', 'NONE',  #8 ) ;\n");
-
-  /* Need an anchor in 3D space to orient the shape */
-  fprintf (f, "#10 =    CARTESIAN_POINT ( 'NONE',  ( 0.0, 0.0, 0.0 ) ) ;\n"
-              "#11 =          DIRECTION ( 'NONE',  ( 0.0, 0.0, 1.0 ) ) ;\n"
-              "#12 =          DIRECTION ( 'NONE',  ( 1.0, 0.0, 0.0 ) ) ;\n"
-              "#13 = AXIS2_PLACEMENT_3D ( 'NONE', #10, #11, #12 ) ;\n");
-
-  /* Grr.. more boilerplate - this time unit definitions */
-
-  fprintf (f, "#14 = UNCERTAINTY_MEASURE_WITH_UNIT (LENGTH_MEASURE( 1.0E-005 ), #15, 'distance_accuracy_value', 'NONE');\n"
-              "#15 =( LENGTH_UNIT ( ) NAMED_UNIT ( * ) SI_UNIT ( .MILLI., .METRE. ) );\n"
-              "#16 =( NAMED_UNIT ( * ) PLANE_ANGLE_UNIT ( ) SI_UNIT ( $, .RADIAN. ) );\n"
-              "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
-              "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
-
-  /* BREP STUFF FROM #21 onwards say? */
-  fprintf (f, "#19 = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( #21, #13 ), #18 ) ;\n" /* #21 is the Manifold_solid_brep */
-              "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #19 ) ;\n",
-              "test_pcb_absr_name");
-
-  global.next_identifier = 21;
-}
-
-static int
-get_contour_npoints (PLINE *contour)
-{
-  /* HACK FOR ROUND CONTOURS */
-  if (contour->is_round)
-    return 1;
-
-  return contour->Count;
-}
-
-static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
-{
-  VNODE *vertex = &contour->head;
-
-  if (contour->is_round)
-    {
-      /* HACK SPECIAL CASE FOR ROUND CONTOURS */
-
-      /* We define an arbitrary point on the contour. This is used, for example,
-       * to define a coordinate system along the contour, and coincides with where
-       * we add a straight edge down the side of an extruded cylindrical shape.
-       */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
-
-      return;
-    }
-
-  while (n > 0) {
-    vertex = vertex->next; /* The VNODE structure is circularly linked, so wrapping is OK */
-    n--;
-  }
-
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
-}
-
-#define FWD 1
-#define REV 2
-static void
-step_emit_board_contour (FILE *f, PLINE *contour)
-{
-  int ncontours;
-  int npoints;
-
-  int brep_identifier;
-
-  int bottom_plane_identifier;
-  int top_plane_identifier;
-  int *side_plane_identifier;
-
-  int *bottom_infinite_line_identifier;
-  int *top_infinite_line_identifier;
-  int *side_infinite_line_identifier;
-
-  int *bottom_vertex_identifier;
-  int *top_vertex_identifier;
-
-  int *bottom_edge_identifier;
-  int *top_edge_identifier;
-  int *side_edge_identifier;
-
-  int *bottom_face_bound_identifier;
-  int *top_face_bound_identifier;
-
-  int bottom_face_identifier;
-  int top_face_identifier;
-  int *side_face_identifier;
-
-  int pcb_shell_identifier;
-
-  int i;
-
-  PLINE *ct;
-
-  char *face_name;
-
-  ncontours = 0;
-  npoints = 0;
-  ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
-
-  /* TODO: Avoid needing to store these identifiers by nailing down our usage pattern of identifiers */
-  /* Allocate some storage for identifiers */
-
-            side_plane_identifier = g_malloc (sizeof (int) * npoints);
-  bottom_infinite_line_identifier = g_malloc (sizeof (int) * npoints);
-     top_infinite_line_identifier = g_malloc (sizeof (int) * npoints);
-    side_infinite_line_identifier = g_malloc (sizeof (int) * npoints);
-         bottom_vertex_identifier = g_malloc (sizeof (int) * npoints);
-            top_vertex_identifier = g_malloc (sizeof (int) * npoints);
-           bottom_edge_identifier = g_malloc (sizeof (int) * npoints);
-              top_edge_identifier = g_malloc (sizeof (int) * npoints);
-             side_edge_identifier = g_malloc (sizeof (int) * npoints);
-             side_face_identifier = g_malloc (sizeof (int) * npoints);
-
-     bottom_face_bound_identifier = g_malloc (sizeof (int) * ncontours);
-        top_face_bound_identifier = g_malloc (sizeof (int) * ncontours);
-
-  /* For a n-sided outline, we need: */
-
-  // PLANES:               2 + n
-  // 2 bottom + top planes
-  // n side planes
-
-  // INFINITE LINES:       3n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-  // n for the sides (joining the top + bottom vertex of the extruded shape (n sided outline = n vertices)
-
-  // VERTICES:             2n
-  // n for the bottom (in the bottom plane)
-  // n for the top (in the top plane)
-
-  // EDGES:                3n          (6n oriented edges)
-  // n for the bottom
-  // n for the top
-  // n for the sides
-
-  // FACES:                2 + n
-  // 2 bottom + top faces
-  // n side faces
-
-  // A consistent numbering scheme will avoid needing complex data-structures here!
-
-  /* Save a place for the brep identifier */
-  brep_identifier = global.next_identifier++;
-
-  /* Define the bottom and top planes */
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0,  1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', (  1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           global.next_identifier, 0.0, 0.0, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           global.next_identifier + 1,
-           global.next_identifier + 2,
-           global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-           global.next_identifier + 4, global.next_identifier + 3);
-  bottom_plane_identifier = global.next_identifier + 4;
-  global.next_identifier = global.next_identifier + 5;
-
-  fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-              "#%i = DIRECTION ( 'NONE', (  0.0,  0.0, -1.0 ) ) ; "
-              "#%i = DIRECTION ( 'NONE', ( -1.0,  0.0,  0.0 ) ) ; "
-              "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-              "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-           global.next_identifier, 0.0, 0.0, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-           global.next_identifier + 1,
-           global.next_identifier + 2,
-           global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-           global.next_identifier + 4, global.next_identifier + 3);
-  top_plane_identifier = global.next_identifier + 4;
-  global.next_identifier = global.next_identifier + 5;
-
-  /* Define the side planes */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Surface edges bounded by a cylindrical surface, not n-planes) */
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = CYLINDRICAL_SURFACE ( 'NONE', #%i, %f ) ;\n",
-                 global.next_identifier, /* A point on the axis of the cylinder */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0.0,
-                 global.next_identifier + 1, /* Direction of surface axis... not sure if the sign of the direction matters */ 0.0, 0.0, 1.0,
-                 global.next_identifier + 2, /* URM???? NOT SURE WHAT THIS DIRECTION IS FOR                                */ 1.0, 0.0, 0.0,
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-                 global.next_identifier + 4, global.next_identifier + 3, COORD_TO_MM (ct->radius));
-
-        side_plane_identifier[i] = global.next_identifier + 4;
-        global.next_identifier = global.next_identifier + 5;
-      }
-    else
-      {
-        get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-        get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i, #%i, #%i ) ; "
-                    "#%i = PLANE ( 'NONE',  #%i ) ;\n",
-                 global.next_identifier,     /* A point on the plane                      */ x1, y1, 0.0,
-                 global.next_identifier + 1, /* An axis direction pointing into the shape */ -(y2 - y1), (x2 - x1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 global.next_identifier + 2, /* A reference direction pointing.. "meh"?   */ 0.0, 0.0, 1.0,
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-                 global.next_identifier + 4, global.next_identifier + 3);
-        side_plane_identifier[i] = global.next_identifier + 4;
-        global.next_identifier = global.next_identifier + 5;
-      }
-  }
-
-  /* Define the infinite lines */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1, x2, y2;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    get_contour_coord_n_in_mm (ct, adjusted_i,     &x1, &y1);
-    get_contour_coord_n_in_mm (ct, adjusted_i + 1, &x2, &y2);
-
-    if (ct->is_round)
-      {
-        /* HACK SPECIAL CASE FOR ROUND CONTOURS (Top and bottom faces bounded a circular contour, not n-lines) */
-
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 global.next_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 global.next_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 global.next_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-                 global.next_identifier + 4, global.next_identifier + 3, COORD_TO_MM (ct->radius));
-        bottom_infinite_line_identifier[i] = global.next_identifier + 4;
-        global.next_identifier = global.next_identifier + 5;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ;"
-                    "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
-                 global.next_identifier,     /* Center of the circle   */ COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 global.next_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- NOT SURE IF I NEED TO FLIP THE DIRECTION??
-                 global.next_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // NOT SURE WHAT THIS IS!
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 1, global.next_identifier + 2,
-                 global.next_identifier + 4, global.next_identifier + 3, COORD_TO_MM (ct->radius));
-        top_infinite_line_identifier[i] = global.next_identifier + 4;
-        global.next_identifier = global.next_identifier + 5;
-      }
-    else
-      {
-        /* Bottom */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 global.next_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 global.next_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 global.next_identifier + 2, global.next_identifier + 1,
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 2);
-        bottom_infinite_line_identifier[i] = global.next_identifier + 3;
-        global.next_identifier = global.next_identifier + 4;
-
-        /* Top */
-        fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                    "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                    "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-                 global.next_identifier,     /* A point on the line         */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-                 global.next_identifier + 1, /* A direction along the line  */ (x2 - x1), (y2 - y1), 0.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-                 global.next_identifier + 2, global.next_identifier + 1,
-                 global.next_identifier + 3, global.next_identifier, global.next_identifier + 2);
-        top_infinite_line_identifier[i] = global.next_identifier + 3;
-        global.next_identifier = global.next_identifier + 4;
-      }
-
-    /* Side */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i =       DIRECTION ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VECTOR ( 'NONE', #%i, 1000.0 ) ; "
-                "#%i = LINE ( 'NONE', #%i, #%i ) ;\n",
-             global.next_identifier,     /* A point on the line         */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             global.next_identifier + 1, /* A direction along the line  */ 0.0, 0.0, 1.0, // <--- NOT SURE IF I NEED TO NORMALISE THIS, OR FLIP THE DIRECTION??
-             global.next_identifier + 2, global.next_identifier + 1,
-             global.next_identifier + 3, global.next_identifier, global.next_identifier + 2);
-    side_infinite_line_identifier[i] = global.next_identifier + 3;
-    global.next_identifier = global.next_identifier + 4;
-  }
-
-  /* Define the vertices */
-  for (i = 0; i < npoints; i++) {
-    double x1, y1;
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    get_contour_coord_n_in_mm (ct, adjusted_i, &x1, &y1);
-
-    /* Bottom */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             global.next_identifier,     /* Vertex coordinate  */ x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             global.next_identifier + 1, global.next_identifier);
-    bottom_vertex_identifier[i] = global.next_identifier + 1;
-    global.next_identifier = global.next_identifier + 2;
-
-    /* Top */
-    fprintf (f, "#%i = CARTESIAN_POINT ( 'NONE', ( %f, %f, %f )) ; "
-                "#%i = VERTEX_POINT ( 'NONE', #%i ) ;\n",
-             global.next_identifier,     /* Vertex coordinate  */ x1, y1, COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0,
-             global.next_identifier + 1, global.next_identifier);
-    top_vertex_identifier[i] = global.next_identifier + 1;
-    global.next_identifier = global.next_identifier + 2;
-  }
-
-  /* Define the Edges */
-  for (i = 0; i < npoints; i++) {
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    /* Due to the way the index wrapping works, this works for circular cutouts as well as n-sided */
-
-    /* Bottom */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             global.next_identifier, bottom_vertex_identifier[i], bottom_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], bottom_infinite_line_identifier[i],      // <-- MIGHT NEED TO REVERSE THIS???
-             global.next_identifier + 1, global.next_identifier,
-             global.next_identifier + 2, global.next_identifier);
-    bottom_edge_identifier[i] = global.next_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    global.next_identifier = global.next_identifier + 3;
-
-    /* Top */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             global.next_identifier, top_vertex_identifier[i], top_vertex_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)], top_infinite_line_identifier[i],                 // <-- MIGHT NEED TO REVERSE THIS???
-             global.next_identifier + 1, global.next_identifier,
-             global.next_identifier + 2, global.next_identifier);
-    top_edge_identifier[i] = global.next_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    global.next_identifier = global.next_identifier + 3;
-
-    /* Side */
-    fprintf (f, "#%i = EDGE_CURVE ( 'NONE', #%i, #%i, #%i,   .T. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .F. ) ; "
-                "#%i = ORIENTED_EDGE ( 'NONE', *, *, #%i, .T. ) ;\n",
-             global.next_identifier, bottom_vertex_identifier[i], top_vertex_identifier[i], side_infinite_line_identifier[i],
-             global.next_identifier + 1, global.next_identifier,
-             global.next_identifier + 2, global.next_identifier);
-    side_edge_identifier[i] = global.next_identifier; /* Add 1 for same oriented, add 2 for back oriented */
-    global.next_identifier = global.next_identifier + 3;
-  }
-
-  /* Define the faces */
-
-  /* Bottom */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               global.next_identifier);
-      for (i = start_i + get_contour_npoints (ct) - 1; i > start_i; i--)
-        fprintf (f, "#%i, ", bottom_edge_identifier[i] + FWD);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               bottom_edge_identifier[start_i] + FWD,
-               global.next_identifier + 1, icont > 0 ? "" : "OUTER_", global.next_identifier);
-      bottom_face_bound_identifier[icont] = global.next_identifier + 1;
-      global.next_identifier = global.next_identifier + 2;
-    }
-
-    fprintf (f, "#%i = ADVANCED_FACE ( 'Bottom', ( ",
-             global.next_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               bottom_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             bottom_face_bound_identifier[ncontours - 1], bottom_plane_identifier);
-    bottom_face_identifier = global.next_identifier;
-    global.next_identifier = global.next_identifier + 1;
-  }
-
-  /* Top */
-  {
-    PLINE *ct = contour;
-    int icont;
-    int start_i;
-
-    start_i = 0;
-    for (icont = 0; icont < ncontours; icont++, start_i += get_contour_npoints (ct), ct = ct->next) {
-      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( ",
-               global.next_identifier);
-      for (i = start_i; i < start_i + get_contour_npoints (ct) - 1; i++)
-        fprintf (f, "#%i, ", top_edge_identifier[i] + REV);
-      fprintf (f, "#%i ) ) ; "
-                  "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ; \n",
-               top_edge_identifier[start_i + get_contour_npoints (ct) - 1] + REV,
-               global.next_identifier + 1, icont > 0 ? "" : "OUTER_", global.next_identifier);
-      top_face_bound_identifier[icont] = global.next_identifier + 1;
-      global.next_identifier = global.next_identifier + 2;
-    }
-
-    fprintf (f, "#%i = ADVANCED_FACE ( 'Top', ( ",
-             global.next_identifier);
-    for (icont = 0; icont < ncontours - 1; icont++)
-      fprintf (f, "#%i, ",
-               top_face_bound_identifier[icont]);
-    fprintf (f, "#%i ), #%i, .F. ) ;\n",
-             top_face_bound_identifier[ncontours - 1], top_plane_identifier);
-    top_face_identifier = global.next_identifier;
-    global.next_identifier = global.next_identifier + 1;
-  }
-
-  /* Sides */
-  for (i = 0; i < npoints; i++) {
-
-    /* Walk through the contours until we find the right one to look at */
-    PLINE *ct = contour;
-    int adjusted_i = i;
-    int i_start = 0;
-
-    while (adjusted_i >= get_contour_npoints (ct)) {
-      adjusted_i -= get_contour_npoints (ct);
-      i_start += get_contour_npoints (ct);
-      ct = ct->next;
-    }
-
-    face_name = (ct->name != NULL) ? ct->name : "";
-
-    fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ( #%i, #%i, #%i, #%i ) ) ; "
-                "#%i = FACE_OUTER_BOUND ( 'NONE', #%i, .T. ) ; "
-                "#%i = ADVANCED_FACE ( '%s', ( #%i ), #%i, .F. ) ;\n",
-             global.next_identifier, side_edge_identifier[i_start + (adjusted_i + 1) % get_contour_npoints (ct)] + REV, top_edge_identifier[i] + FWD, side_edge_identifier[i] + FWD, bottom_edge_identifier[i] + REV,
-             global.next_identifier + 1, global.next_identifier,
-             global.next_identifier + 2, face_name, global.next_identifier + 1, side_plane_identifier[i]);
-    side_face_identifier[i] = global.next_identifier + 2;
-    global.next_identifier = global.next_identifier + 3;
-  }
-
-  /* Closed shell which bounds the brep solid */
-  pcb_shell_identifier = global.next_identifier;
-  global.next_identifier++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ( #%i, #%i, ", pcb_shell_identifier, bottom_face_identifier, top_face_identifier);
-  for (i = 0; i < npoints - 1; i++) {
-    fprintf (f, "#%i, ", side_face_identifier[i]);
-  }
-  fprintf (f, "#%i) ) ;\n",
-           side_face_identifier[npoints - 1]);
-
-  /* Finally emit the brep solid definition */
-  fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
-
-  g_free (side_plane_identifier);
-  g_free (bottom_infinite_line_identifier);
-  g_free (top_infinite_line_identifier);
-  g_free (side_infinite_line_identifier);
-  g_free (bottom_vertex_identifier);
-  g_free (top_vertex_identifier);
-  g_free (bottom_edge_identifier);
-  g_free (top_edge_identifier);
-  g_free (side_edge_identifier);
-  g_free (side_face_identifier);
-  g_free (bottom_face_bound_identifier);
-  g_free (top_face_bound_identifier);
-}
-#undef FWD
-#undef REV
-
-static void
-step_end_file (FILE *f)
-{
-  fprintf (f, "ENDSEC;\n" );
-  fprintf (f, "END-ISO-10303-21;\n" );
-}
-
-static void
-step_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
-{
-  int i;
-  static int saved_layer_stack[MAX_LAYER];
-  FlagType save_thindraw;
-  POLYAREA *outline;
-
-  save_thindraw = PCB->Flags;
-  CLEAR_FLAG(THINDRAWFLAG, PCB);
-  CLEAR_FLAG(THINDRAWPOLYFLAG, PCB);
-  CLEAR_FLAG(CHECKPLANESFLAG, PCB);
-
-  global.f = the_file;
-
-  step_start_file (global.f, global.filename);
-
-  outline = board_outline_poly (true);
-  step_emit_board_contour (global.f, outline->contours);
-  poly_Free (&outline);
-
-  memset (global.print_group, 0, sizeof (global.print_group));
-  memset (global.print_layer, 0, sizeof (global.print_layer));
-
-  global.outline_layer = NULL;
-
-  for (i = 0; i < max_copper_layer; i++)
-    {
-      LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
-        global.print_group[GetLayerGroupNumberByNumber (i)] = 1;
-
-      if (strcmp (layer->Name, "outline") == 0 ||
-          strcmp (layer->Name, "route") == 0)
-        {
-          global.outline_layer = layer;
-        }
-    }
-  global.print_group[GetLayerGroupNumberByNumber (bottom_silk_layer)] = 1;
-  global.print_group[GetLayerGroupNumberByNumber (top_silk_layer)] = 1;
-  for (i = 0; i < max_copper_layer; i++)
-    if (global.print_group[GetLayerGroupNumberByNumber (i)])
-      global.print_layer[i] = 1;
-
-  memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
-
-  /* reset static vars */
-  step_set_layer (NULL, 0, -1);
-  use_gc (NULL);
-
-//  hid_expose_callback (&step_hid, NULL, 0);
-
-  step_set_layer (NULL, 0, -1);  /* reset static vars */
-//  hid_expose_callback (&step_hid, NULL, 0);
-
-  memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
-  PCB->Flags = save_thindraw;
-}
-
 /* NB: Result is in mm */
 static void
 parse_cartesian_point_3d_string (const char *str, double *x, double *y, double *z)
@@ -809,36 +132,26 @@ parse_numeric_attribute (ElementType *element, char *attr_name, double *res)
 static void
 step_do_export (HID_Attr_Val * options)
 {
-  FILE *fh;
-  int save_ons[MAX_LAYER + 2];
   int i;
+  const char *filename;
   const char *temp_pcb_filename = "_pcb.step";
+  GList *board_outline_list;
 
   if (!options)
     {
       step_get_export_options (0);
       for (i = 0; i < NUM_OPTIONS; i++)
-        global.step_values[i] = step_attribute_list[i].default_val;
-      options = global.step_values;
-    }
-
-  global.filename = options[HA_stepfile].str_value;
-  if (!global.filename)
-    global.filename = "pcb-out.step";
-
-  fh = fopen (temp_pcb_filename, "w");
-  if (fh == NULL)
-    {
-      perror (temp_pcb_filename);
-      return;
+        step_option_values[i] = step_attribute_list[i].default_val;
+      options = step_option_values;
     }
 
-  hid_save_and_show_layer_ons (save_ons);
-  step_hid_export_to_file (fh, options);
-  hid_restore_layer_ons (save_ons);
+  filename = options[HA_stepfile].str_value;
+  if (filename == NULL)
+    filename = "pcb-out.step";
 
-  step_end_file (fh);
-  fclose (fh);
+  board_outline_list = object3d_from_board_outline ();
+  object3d_list_export_to_step_assy (board_outline_list, temp_pcb_filename);
+  g_list_free_full (board_outline_list, (GDestroyNotify)destroy_object3d);
 
   {
     GList *models = NULL;
@@ -1008,34 +321,7 @@ step_do_export (HID_Attr_Val * options)
       }
     END_LOOP;
 
-#if 0
-    model = g_new0 (struct assembly_model, 1);
-    model->filename = "SOP65P780X200-22N_JEDEC_MO-150AF.step";
-    models = g_list_append (models, model);
-
-    instance = g_new0 (struct assembly_model_instance, 1);
-    instance->name = "DUMMY COMPONENT - 1";
-    instance->ox = 33.0,  instance->oy = 99.0,  instance->oz = -0.8; /* Locate origin (Z corresponds to bottom of board) */
-    instance->ax =  0.0,  instance->ay =  0.0,  instance->az = -1.0; /* Flip component Z-axis to orient on bottom of board */
-    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
-    model->instances = g_list_append (model->instances, instance);
-
-    instance = g_new0 (struct assembly_model_instance, 1);
-    instance->name = "DUMMY COMPONENT - 2";
-    instance->ox = 46.0,  instance->oy = 99.0,  instance->oz = -0.8; /* Locate origin (Z corresponds to bottom of board) */
-    instance->ax =  0.0,  instance->ay =  0.0,  instance->az = -1.0; /* Flip component Z-axis to orient on back of board */
-    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
-    model->instances = g_list_append (model->instances, instance);
-
-    instance = g_new0 (struct assembly_model_instance, 1);
-    instance->name = "DUMMY COMPONENT - 3";
-    instance->ox = 75.0,  instance->oy = 21.0,  instance->oz =  0.8; /* Locate origin (Z corresponds to top of board) */
-    instance->ax =  0.0,  instance->ay =  0.0,  instance->az =  1.0; /* Flip component Z-axis to orient on top of board */
-    instance->rx =  1.0,  instance->ry =  0.0,  instance->rz =  0.0; /* X-axis to corresponds to our X-axis */
-    model->instances = g_list_append (model->instances, instance);
-#endif
-
-    export_step_assembly (global.filename, models);
+    export_step_assembly (filename, models);
 
     /* XXX: LEAK ALL THE MODEL DATA.. BEING LAZY RIGHT NOW */
   }
@@ -1048,208 +334,6 @@ step_parse_arguments (int *argc, char ***argv)
   hid_parse_command_line (argc, argv);
 }
 
-static int
-step_set_layer (const char *name, int group, int empty)
-{
-  static int lastgroup = -1;
-  int idx = (group >= 0 && group < max_group)
-            ? PCB->LayerGroups.Entries[group][0]
-            : group;
-  if (name == 0)
-    name = PCB->Data->Layer[idx].Name;
-
-  if (empty == -1)
-    lastgroup = -1;
-  if (empty)
-    return 0;
-
-  if (idx >= 0 && idx < max_copper_layer && !global.print_layer[idx])
-    return 0;
-
-  if (strcmp (name, "invisible") == 0)
-    return 0;
-
-  global.is_drill = (SL_TYPE (idx) == SL_PDRILL || SL_TYPE (idx) == SL_UDRILL);
-  global.is_mask  = (SL_TYPE (idx) == SL_MASK);
-  global.is_assy  = (SL_TYPE (idx) == SL_ASSY);
-  global.is_copper = (SL_TYPE (idx) == 0);
-  global.is_paste  = (SL_TYPE (idx) == SL_PASTE);
-
-  if (group < 0 || group != lastgroup)
-    {
-      lastgroup = group;
-
-      use_gc (NULL);  /* reset static vars */
-    }
-
-  return 1;
-}
-
-static hidGC
-step_make_gc (void)
-{
-  hidGC gc = (hidGC) calloc (1, sizeof (struct step_gc_struct));
-  stepGC step_gc = (stepGC)gc;
-
-  gc->hid = &step_hid;
-  gc->hid_draw = &step_graphics;
-
-  step_gc->cap = Trace_Cap;
-
-  return gc;
-}
-
-static void
-step_destroy_gc (hidGC gc)
-{
-  free (gc);
-}
-
-static void
-step_use_mask (enum mask_mode mode)
-{
-  /* does nothing */
-}
-
-static void
-step_set_color (hidGC gc, const char *name)
-{
-  stepGC step_gc = (stepGC)gc;
-
-  if (strcmp (name, "erase") == 0 || strcmp (name, "drill") == 0)
-    {
-      step_gc->r = step_gc->g = step_gc->b = 255;
-      step_gc->erase = 1;
-    }
-  else
-    {
-      int r, g, b;
-      sscanf (name + 1, "%02x%02x%02x", &r, &g, &b);
-      step_gc->r = r;
-      step_gc->g = g;
-      step_gc->b = b;
-      step_gc->erase = 0;
-    }
-}
-
-static void
-step_set_line_cap (hidGC gc, EndCapStyle style)
-{
-  stepGC step_gc = (stepGC)gc;
-
-  step_gc->cap = style;
-}
-
-static void
-step_set_line_width (hidGC gc, Coord width)
-{
-  stepGC step_gc = (stepGC)gc;
-
-  step_gc->width = width;
-}
-
-static void
-step_set_draw_xor (hidGC gc, int xor_)
-{
-}
-
-static void
-step_set_draw_faded (hidGC gc, int faded)
-{
-}
-
-static void
-use_gc (hidGC gc)
-{
-  stepGC step_gc = (stepGC)gc;
-
-  static int lastcap = -1;
-  static int lastcolor = -1;
-
-  if (gc == NULL)
-    {
-      lastcap = lastcolor = -1;
-      return;
-    }
-  if (gc->hid != &step_hid)
-    {
-      fprintf (stderr, "Fatal: GC from another HID passed to step HID\n");
-      abort ();
-    }
-  if (lastcap != step_gc->cap)
-    {
-      fprintf (global.f, "%%d setlinecap %%d setlinejoin\n");
-      lastcap = step_gc->cap;
-    }
-#define CBLEND(gc) (((step_gc->r)<<24)|((step_gc->g)<<16)|((step_gc->b)<<8))
-  if (lastcolor != CBLEND (gc))
-    {
-      double r, g, b;
-      r = step_gc->r;
-      g = step_gc->g;
-      b = step_gc->b;
-      if (step_gc->r == step_gc->g && step_gc->g == step_gc->b)
-        fprintf (global.f, "%g gray\n", r / 255.0);
-      else
-        fprintf (global.f, "%g %g %g rgb\n", r / 255.0, g / 255.0, b / 255.0);
-      lastcolor = CBLEND (gc);
-    }
-}
-
-static void
-step_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
-{
-}
-
-static void
-step_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
-{
-}
-
-static void
-step_draw_arc (hidGC gc, Coord cx, Coord cy, Coord width, Coord height,
-               Angle start_angle, Angle delta_angle)
-{
-}
-
-static void
-step_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
-{
-}
-
-static void
-step_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
-{
-}
-
-static void
-fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
-{
-}
-
-static void
-step_draw_pcb_polygon (hidGC gc, PolygonType * poly, const BoxType * clip_box)
-{
-  fill_polyarea (gc, poly->Clipped, clip_box);
-  if (TEST_FLAG (FULLPOLYFLAG, poly))
-    {
-      POLYAREA *pa;
-
-      for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
-    }
-}
-
-static void
-step_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
-{
-}
-
-static void
-step_set_crosshair (int x, int y, int action)
-{
-}
-
 #include "dolists.h"
 
 void step_step_init (HID *hid)
@@ -1257,40 +341,12 @@ void step_step_init (HID *hid)
   hid->get_export_options = step_get_export_options;
   hid->do_export          = step_do_export;
   hid->parse_arguments    = step_parse_arguments;
-  hid->set_crosshair      = step_set_crosshair;
-}
-
-void step_step_graphics_class_init (HID_DRAW_CLASS *klass)
-{
-  klass->set_layer          = step_set_layer;
-  klass->make_gc            = step_make_gc;
-  klass->destroy_gc         = step_destroy_gc;
-  klass->use_mask           = step_use_mask;
-  klass->set_color          = step_set_color;
-  klass->set_line_cap       = step_set_line_cap;
-  klass->set_line_width     = step_set_line_width;
-  klass->set_draw_xor       = step_set_draw_xor;
-  klass->set_draw_faded     = step_set_draw_faded;
-  klass->draw_line          = step_draw_line;
-  klass->draw_arc           = step_draw_arc;
-  klass->draw_rect          = step_draw_rect;
-  klass->fill_circle        = step_fill_circle;
-  klass->fill_polygon       = step_fill_polygon;
-  klass->fill_rect          = step_fill_rect;
-
-  klass->draw_pcb_polygon   = step_draw_pcb_polygon;
-}
-
-void step_step_graphics_init (HID_DRAW *hid_draw)
-{
-  hid_draw->poly_before = true;
 }
 
 void
 hid_step_init ()
 {
   memset (&step_hid, 0, sizeof (HID));
-  memset (&step_graphics, 0, sizeof (HID_DRAW));
 
   common_nogui_init (&step_hid);
   step_step_init (&step_hid);
@@ -1300,12 +356,6 @@ hid_step_init ()
   step_hid.description        = "STEP AP214 export";
   step_hid.exporter           = 1;
 
-  common_draw_helpers_class_init (&step_graphics_class);
-  step_step_graphics_class_init (&step_graphics_class);
-
-  common_nogui_graphics_init (&step_graphics);
-  common_draw_helpers_init (&step_graphics);
-
   hid_register_hid (&step_hid);
 
 #include "step_lists.h"
diff --git a/src/hid/step/step_writer.c b/src/hid/step/step_writer.c
new file mode 100644
index 0000000..9655d8f
--- /dev/null
+++ b/src/hid/step/step_writer.c
@@ -0,0 +1,466 @@
+#include <glib.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "step_writer.h"
+
+static char *
+step_bool (bool expr)
+{
+  return expr ? ".T." : ".F.";
+}
+
+static void
+fprint_id_list (FILE *f, step_id_list list)
+{
+  GList *iter;
+
+  fprintf (f, "( ");
+  for (iter = list;
+       iter != NULL && g_list_next (iter) != NULL;
+       iter = g_list_next (iter)) {
+    fprintf (f, "#%i, ", GPOINTER_TO_INT (iter->data));
+  }
+  if (iter == NULL)
+    fprintf (f, ")");
+  else
+    fprintf (f, "#%i )", GPOINTER_TO_INT (iter->data));
+}
+
+static void
+destroy_step_id_list (step_id_list list)
+{
+  g_list_free (list);
+}
+
+step_id_list
+step_id_list_append (step_id_list list, step_id id)
+{
+  return g_list_append (list, GINT_TO_POINTER (id));
+}
+
+/* NB: The GList this produces will leak if not passed back to one of the step_* functions which uses the list and destroys it */
+step_id_list
+make_step_id_list (int count, ...)
+{
+  step_id_list list = NULL;
+  va_list args;
+  int i;
+
+  va_start (args, NULL);
+
+  for (i = 0; i < count; i++) {
+    step_id id = va_arg (args, step_id);
+    list = g_list_append (list, GINT_TO_POINTER (id));
+  }
+
+  va_end (args);
+
+  return list;
+}
+
+step_file
+*step_output_file (FILE *f)
+{
+  step_file *file;
+
+  file = g_new0 (step_file, 1);
+  file->f = f;
+  file->next_id = 1;
+
+  return file;
+}
+
+void
+destroy_step_output_file (step_file *file)
+{
+  g_free (file);
+}
+
+/* XXX: Just reading out boiler-plate at this point */
+step_id
+make_3d_metric_step_geometric_representation_context (step_file *file)
+{
+  fprintf (file->f, "#%i = ( LENGTH_UNIT ( ) NAMED_UNIT ( * ) SI_UNIT ( .MILLI., .METRE. ) );\n", file->next_id);
+  fprintf (file->f, "#%i = ( NAMED_UNIT ( * ) PLANE_ANGLE_UNIT ( ) SI_UNIT ( $, .RADIAN. ) );\n", file->next_id + 1);
+  fprintf (file->f, "#%i = ( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n", file->next_id + 2);
+  fprintf (file->f, "#%i = UNCERTAINTY_MEASURE_WITH_UNIT (LENGTH_MEASURE( 1.0E-005 ), #%i, 'distance_accuracy_value', 'NONE');\n", file->next_id + 3, file->next_id);
+
+  fprintf (file->f, "#%i = ( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) "
+                            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #%i ) ) "
+                            "GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #%i, #%i, #%i ) ) "
+                            "REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n",
+                    file->next_id + 4, file->next_id + 3, file->next_id, file->next_id + 1, file->next_id + 2);
+  file->next_id += 4;
+
+  return file->next_id++;
+}
+
+step_id
+step_application_context (step_file *file, char *application)
+{
+  fprintf (file->f, "#%i = APPLICATION_CONTEXT ( '%s' ) ;\n", file->next_id, application);
+
+  return file->next_id++;
+}
+
+step_id
+step_application_protocol_definition (step_file *file, char *status, char *application_interpreted_model_schema_name,
+                                      char *application_protocol_year, step_id application)
+{
+  fprintf (file->f, "#%i = APPLICATION_PROTOCOL_DEFINITION ( '%s', '%s', %s, #%i );\n",
+                    file->next_id, status, application_interpreted_model_schema_name, application_protocol_year, application);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_context (step_file *file, char *name, step_id frame_of_reference, char *discipline_type)
+{
+  fprintf (file->f, "#%i = PRODUCT_CONTEXT ( '%s', #%i, '%s' ) ;\n",
+                    file->next_id, name, frame_of_reference, discipline_type);
+
+  return file->next_id++;
+}
+
+step_id
+step_product (step_file *file, char *id, char *name, char *description, step_id_list frame_of_reference)
+{
+  fprintf (file->f, "#%i = PRODUCT ('%s', '%s', '%s', ", file->next_id, id, name, description);
+  fprint_id_list (file->f, frame_of_reference);
+  fprintf (file->f, ") ;\n");
+  destroy_step_id_list (frame_of_reference);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_related_product_category (step_file *file, char *name, char *description, step_id_list products)
+{
+  if (description != NULL)
+    fprintf (file->f, "#%i = PRODUCT_RELATED_PRODUCT_CATEGORY ('%s', '%s', ", file->next_id, name, description);
+  else
+    fprintf (file->f, "#%i = PRODUCT_RELATED_PRODUCT_CATEGORY ('%s', $, ", file->next_id, name);
+
+  fprint_id_list (file->f, products);
+  fprintf (file->f, ") ;\n");
+  destroy_step_id_list (products);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_definition_context (step_file *file, char *name, step_id frame_of_reference, char *life_cycle_stage)
+{
+  fprintf (file->f, "#%i = PRODUCT_DEFINITION_CONTEXT ( '%s', #%i, '%s' ) ;\n",
+                    file->next_id, name, frame_of_reference, life_cycle_stage);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_definition_formation (step_file *file, char *id, char *description, step_id of_product)
+{
+  fprintf (file->f, "#%i = PRODUCT_DEFINITION_FORMATION ( '%s', '%s', #%i) ;\n",
+                    file->next_id, id, description, of_product);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_definition (step_file *file, char *id, char *description, step_id formation, step_id frame_of_reference)
+{
+  fprintf (file->f, "#%i = PRODUCT_DEFINITION ( '%s', '%s', #%i, #%i ) ;\n",
+                    file->next_id, id, description, formation, frame_of_reference);
+
+  return file->next_id++;
+}
+
+step_id
+step_product_definition_shape (step_file *file, char *name, char *description, step_id definition)
+{
+  fprintf (file->f, "#%i = PRODUCT_DEFINITION_SHAPE ( '%s', '%s',  #%i ) ;\n",
+                    file->next_id, name, description, definition);
+
+  return file->next_id++;
+}
+
+step_id
+step_cartesian_point (step_file *file, char *name, double x, double y, double z)
+{
+  fprintf (file->f, "#%i = CARTESIAN_POINT ( '%s', ( %f, %f, %f ) ) ;\n",
+                    file->next_id, name, x, y, z);
+  return file->next_id++;
+}
+
+step_id
+step_direction (step_file *file, char *name, double x, double y, double z)
+{
+  fprintf (file->f, "#%i = DIRECTION ( '%s', ( %f, %f, %f ) ) ;\n",
+                    file->next_id, name, x, y, z);
+  return file->next_id++;
+}
+
+step_id
+step_axis2_placement_3d (step_file *file, char *name, step_id location, step_id axis, step_id ref_direction)
+{
+  fprintf (file->f, "#%i = AXIS2_PLACEMENT_3D ( '%s', #%i, #%i, #%i ) ;\n",
+                    file->next_id, name, location, axis, ref_direction);
+  return file->next_id++;
+}
+
+step_id
+step_plane (step_file *file, char *name, step_id position)
+{
+  fprintf (file->f, "#%i = PLANE ( '%s', #%i ) ;\n",
+                    file->next_id, name, position);
+  return file->next_id++;
+}
+
+step_id
+step_cylindrical_surface (step_file *file, char *name, step_id position, double radius)
+{
+  fprintf (file->f, "#%i = CYLINDRICAL_SURFACE ( '%s', #%i, %f ) ;\n",
+                    file->next_id, name, position, radius);
+  return file->next_id++;
+}
+
+step_id
+step_circle (step_file *file, char *name, step_id position, double radius)
+{
+  fprintf (file->f, "#%i = CIRCLE ( '%s', #%i, %f ) ;\n",
+                    file->next_id, name, position, radius);
+  return file->next_id++;
+}
+
+step_id
+step_vector (step_file *file, char *name, step_id orientation, double magnitude)
+{
+  fprintf (file->f, "#%i = VECTOR ( '%s', #%i, %f ) ;\n",
+                    file->next_id, name, orientation, magnitude);
+  return file->next_id++;
+}
+
+step_id
+step_line (step_file *file, char *name, step_id pnt, step_id dir)
+{
+  fprintf (file->f, "#%i = LINE ( '%s', #%i, #%i ) ;\n",
+                    file->next_id, name, pnt, dir);
+  return file->next_id++;
+}
+
+step_id
+step_vertex_point (step_file *file, char *name, step_id pnt)
+{
+  fprintf (file->f, "#%i = VERTEX_POINT ( '%s', #%i ) ;\n",
+                    file->next_id, name, pnt);
+  return file->next_id++;
+}
+
+step_id
+step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense)
+{
+  fprintf (file->f, "\n#%i = EDGE_CURVE ( '%s', #%i, #%i, #%i, %s ) ; ",
+                    file->next_id, name, edge_start, edge_end, edge_geometry, step_bool (same_sense));
+  return file->next_id++;
+}
+
+step_id
+step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation)
+{
+  fprintf (file->f, "#%i = ORIENTED_EDGE ( '%s', *, *, #%i, %s ) ; ",
+                    file->next_id, name, edge_element, step_bool (orientation));
+  return file->next_id++;
+}
+
+step_id
+step_edge_loop (step_file *file, char *name, step_id_list edge_list)
+{
+  fprintf (file->f, "#%i = EDGE_LOOP ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, edge_list);
+  fprintf (file->f, " ) ; ");
+  destroy_step_id_list (edge_list);
+
+  return file->next_id++;
+}
+
+step_id
+step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
+{
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ; ",
+                    file->next_id, name, bound, step_bool (orientation));
+
+  return file->next_id++;
+}
+
+step_id
+step_face_outer_bound (step_file *file, char *name, step_id bound, bool orientation)
+{
+  fprintf (file->f, "#%i = FACE_OUTER_BOUND ( '%s', #%i, %s ) ;\n",
+                    file->next_id, name, bound, step_bool (orientation));
+
+  return file->next_id++;
+}
+
+step_id
+step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id face_geometry, bool same_sense)
+{
+  fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, bounds);
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
+  destroy_step_id_list (bounds);
+
+  return file->next_id++;
+}
+
+step_id
+step_closed_shell (step_file *file, char *name, step_id_list cfs_faces)
+{
+  fprintf (file->f, "#%i = CLOSED_SHELL ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, cfs_faces);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (cfs_faces);
+
+  return file->next_id++;
+}
+
+step_id
+step_manifold_solid_brep (step_file *file, char *name, step_id outer)
+{
+  fprintf (file->f, "#%i = MANIFOLD_SOLID_BREP ( '%s', #%i ) ;\n", file->next_id, name, outer);
+
+  return file->next_id++;
+}
+
+step_id
+step_advanced_brep_shape_representation (step_file *file, char *name, step_id_list items, step_id context_of_items)
+{
+  fprintf (file->f, "#%i = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, items);
+  fprintf (file->f, ", #%i ) ;\n", context_of_items);
+  destroy_step_id_list (items);
+
+  return file->next_id++;
+}
+
+step_id
+step_shape_definition_representation (step_file *file, step_id definition, step_id used_representation)
+{
+  fprintf (file->f, "#%i = SHAPE_DEFINITION_REPRESENTATION ( #%i, #%i ) ;\n", file->next_id, definition, used_representation);
+
+  return file->next_id++;
+}
+
+step_id
+step_colour_rgb (step_file *file, char *name, double red, double green, double blue)
+{
+  fprintf (file->f, "#%i = COLOUR_RGB ( '%s', %f, %f, %f ) ;\n",
+                    file->next_id, name, red, green, blue);
+  return file->next_id++;
+}
+
+step_id
+step_fill_area_style_colour (step_file *file, char *name, step_id fill_colour)
+{
+  fprintf (file->f, "#%i = FILL_AREA_STYLE_COLOUR ( '%s', #%i ) ;\n",
+                    file->next_id, name, fill_colour);
+
+  return file->next_id++;
+}
+
+step_id
+step_fill_area_style (step_file *file, char *name, step_id_list fill_styles)
+{
+  fprintf (file->f, "#%i = FILL_AREA_STYLE ('%s', ", file->next_id, name);
+  fprint_id_list (file->f, fill_styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (fill_styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_surface_style_fill_area (step_file *file, step_id fill_area)
+{
+  fprintf (file->f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",
+                    file->next_id, fill_area);
+
+  return file->next_id++;
+}
+
+step_id
+step_surface_side_style (step_file *file, char *name, step_id_list styles)
+{
+  fprintf (file->f, "#%i = SURFACE_SIDE_STYLE ('%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+/* XXX: surface_side should be an enum ".POSITIVE.", ".NEGATIVE." or ".BOTH." */
+step_id
+step_surface_style_usage (step_file *file, char *surface_side, step_id style)
+{
+  fprintf (file->f, "#%i = SURFACE_STYLE_USAGE ( .%s. , #%i ) ;\n",
+                    file->next_id, surface_side, style);
+
+  return file->next_id++;
+}
+
+step_id
+step_presentation_style_assignment (step_file *file, step_id_list styles)
+{
+  fprintf (file->f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ", file->next_id);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_styled_item (step_file *file, char *name, step_id_list styles, step_id item)
+{
+  fprintf (file->f, "#%i = STYLED_ITEM ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, ", #%i ) ;\n", item);
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_over_riding_styled_item (step_file *file, char *name, step_id_list styles, step_id item, step_id over_ridden_style)
+{
+  fprintf (file->f, "#%i = OVER_RIDING_STYLED_ITEM ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, ", #%i, #%i ) ;\n", item, over_ridden_style);
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_presentation_layer_assignment (step_file *file, char *name, char *description, step_id_list assigned_items)
+{
+  fprintf (file->f, "#%i = PRESENTATION_LAYER_ASSIGNMENT ( '%s', '%s', ", file->next_id, name, description);
+  fprint_id_list (file->f, assigned_items);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (assigned_items);
+
+  return file->next_id++;
+}
+
+step_id
+step_mechanical_design_geometric_presentation_representation (step_file *file, char *name, step_id_list items, step_id context_of_items)
+{
+  fprintf (file->f, "#%i = MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION (  '%s', ", file->next_id, name);
+  fprint_id_list (file->f, items);
+  fprintf (file->f, ", #%i ) ;\n", context_of_items);
+  destroy_step_id_list (items);
+
+  return file->next_id++;
+}
diff --git a/src/hid/step/step_writer.h b/src/hid/step/step_writer.h
new file mode 100644
index 0000000..c86aa1e
--- /dev/null
+++ b/src/hid/step/step_writer.h
@@ -0,0 +1,59 @@
+typedef int step_id;
+
+typedef GList* step_id_list;
+
+typedef struct {
+  FILE *f;
+  step_id next_id;
+
+} step_file;
+
+step_id_list step_id_list_append (step_id_list list, step_id id);
+step_id_list make_step_id_list (int count, ...);
+
+step_file *step_output_file (FILE *f);
+void destroy_step_output_file (step_file *file);
+
+step_id make_3d_metric_step_geometric_representation_context (step_file *file); /* XXX: Just reading out boiler-plate at this point */
+
+step_id step_application_context (step_file *file, char *application);
+step_id step_application_protocol_definition (step_file *file, char *status, char *application_interpreted_model_schema_name, char *application_protocol_year, step_id application);
+step_id step_product_context (step_file *file, char *name, step_id frame_of_reference, char *discipline_type);
+step_id step_product (step_file *file, char *id, char *name, char *description, step_id_list frame_of_reference);
+step_id step_product_related_product_category (step_file *file, char *name, char *description, step_id_list products);
+step_id step_product_definition_context (step_file *file, char *name, step_id frame_of_reference, char *life_cycle_stage);
+step_id step_product_definition_formation (step_file *file, char *id, char *description, step_id of_product);
+step_id step_product_definition (step_file *file, char *id, char *description, step_id formation, step_id frame_of_reference);
+step_id step_product_definition_shape (step_file *file, char *name, char *description, step_id definition);
+
+step_id step_cartesian_point (step_file *file, char *name, double x, double y, double z);
+step_id step_direction (step_file *file, char *name, double x, double y, double z);
+step_id step_axis2_placement_3d (step_file *file, char *name, step_id location, step_id axis, step_id ref_direction);
+step_id step_plane (step_file *file, char *name, step_id position);
+step_id step_cylindrical_surface (step_file *file, char *name, step_id position, double radius);
+step_id step_circle (step_file *file, char *name, step_id position, double radius);
+step_id step_vector (step_file *file, char *name, step_id orientation, double magnitude);
+step_id step_line (step_file *file, char *name, step_id pnt, step_id dir);
+step_id step_vertex_point (step_file *file, char *name, step_id pnt);
+step_id step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense);
+step_id step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation);
+step_id step_edge_loop (step_file *file, char *name, step_id_list edge_list);
+step_id step_face_bound (step_file *file, char *name, step_id bound, bool orientation);
+step_id step_face_outer_bound (step_file *file, char *name, step_id bound, bool orientation);
+step_id step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id face_geometry, bool same_sense);
+step_id step_closed_shell (step_file *file, char *name, step_id_list cfs_faces);
+step_id step_manifold_solid_brep (step_file *file, char *name, step_id outer);
+step_id step_advanced_brep_shape_representation (step_file *file, char *name, step_id_list items, step_id context_of_items);
+step_id step_shape_definition_representation (step_file *file, step_id definition, step_id used_representation);
+
+step_id step_colour_rgb (step_file *file, char *name, double red, double green, double blue);
+step_id step_fill_area_style_colour (step_file *file, char *name, step_id fill_colour);
+step_id step_fill_area_style (step_file *file, char *name, step_id_list fill_styles);
+step_id step_surface_style_fill_area (step_file *file, step_id fill_area);
+step_id step_surface_side_style (step_file *file, char *name, step_id_list styles);
+step_id step_surface_style_usage (step_file *file, char *surface_side, step_id style); /* XXX: surface_side should be an enum "POSITIVE, NEGATIVE or BOTH" */
+step_id step_presentation_style_assignment (step_file *file, step_id_list styles);
+step_id step_styled_item (step_file *file, char *name, step_id_list styles, step_id item);
+step_id step_over_riding_styled_item (step_file *file, char *name, step_id_list styles, step_id item, step_id over_ridden_style);
+step_id step_presentation_layer_assignment (step_file *file, char *name, char *description, step_id_list assigned_items);
+step_id step_mechanical_design_geometric_presentation_representation (step_file *file, char *name, step_id_list items, step_id context_of_items);
