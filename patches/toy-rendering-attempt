Bottom: 61e2445ecfa2a5acafb6d39c09cbe02b55700dc4
Top:    9a876fa9fc9ce15d7fb8fd5797156bca2769ec8c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 14:59:08 +0000

Toy rendering attempt


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c3d25a..8c9e089 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -24,10 +24,12 @@ bin_PROGRAMS=	pcb
 
 if DEBUG_BUILD
 # don't disable assert()
+AM_CFLAGS= -Wno-unused-parameter
 else
-AM_CFLAGS= -DNDEBUG
+AM_CFLAGS= -DNDEBUG -Wno-unused-parameter
 endif
 
+
 PCB_SRCS = \
 	action.c \
 	action.h \
@@ -484,6 +486,8 @@ LIBSTEP_SRCS = \
 	hid/step/step.h \
 	hid/step/assembly.cpp \
 	hid/step/assembly.h \
+	hid/step/model.cpp \
+	hid/step/model.h \
 	hid/step/utils.cpp \
 	hid/step/utils.h \
 	hid/step/step_writer.c \
diff --git a/src/action.c b/src/action.c
index 4e8ceb7..12ca76d 100644
--- a/src/action.c
+++ b/src/action.c
@@ -91,6 +91,8 @@
 #include <sys/wait.h>
 #endif
 
+#define DEBUG
+
 /* ---------------------------------------------------------------------------
  * some local types
  */
diff --git a/src/data.c b/src/data.c
index 9d6588c..99df27a 100644
--- a/src/data.c
+++ b/src/data.c
@@ -41,7 +41,7 @@
  */
 
 CrosshairType Crosshair;	/* information about cursor settings */
-MarkType Marked;		/* a cross-hair mark */
+_MarkType Marked;		/* a cross-hair mark */
 OutputType Output;		/* some widgets ... used for drawing */
 PCBType *PCB;			/* pointer to layout struct */
 
diff --git a/src/data.h b/src/data.h
index 89d9b87..1006a61 100644
--- a/src/data.h
+++ b/src/data.h
@@ -39,7 +39,7 @@
 
 extern CrosshairType Crosshair;
 
-extern MarkType Marked;
+extern _MarkType Marked;
 
 extern OutputType Output;
 
diff --git a/src/global.h b/src/global.h
index b8efc7b..e8badb6 100644
--- a/src/global.h
+++ b/src/global.h
@@ -364,6 +364,7 @@ typedef struct
   GList *Arc;
   BoxType VBox;
   AttributeListType Attributes;
+  void *assembly_model_instance; /* XXX: Opaque type? */
 } ElementType;
 
 /* ---------------------------------------------------------------------------
@@ -609,7 +610,7 @@ typedef struct
 {
   bool status;
   Coord X, Y;
-} MarkType;
+} _MarkType;
 
 /* ---------------------------------------------------------------------------
  * our resources
diff --git a/src/hid/common/edge3d.h b/src/hid/common/edge3d.h
index 3080865..1a76e97 100644
--- a/src/hid/common/edge3d.h
+++ b/src/hid/common/edge3d.h
@@ -13,6 +13,18 @@ typedef struct
   double nz;
   double radius;
 
+  /* For b-splines */
+  bool is_bspline;
+  int degree;
+  int num_control_points; /* Number of (triplet x,y,z) control points - control points array holds 3x more doubles */
+  double *control_points; /* Pointer to array of control points (in x,y,z triplets) */
+  /* Number of knots is (num_control_points + degree + 1) */
+  double *knots;          /* Pointer to array of knot values */
+
+  /* Rational b-splines */
+  double *weights; /* Pointer to array of weights for the control points */
+
+
   /* XXX: STEP specific - breaks encapsulation */
   step_id infinite_line_identifier;
   step_id edge_identifier;
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index e7a2720..4e0acb4 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -153,11 +153,14 @@ float colors[12][3] = {{1., 0., 0.},
                        {0.5, 1., 1.}};
 
 
-#define CIRC_SEGS 64
+#define CIRC_SEGS_D 64.0
 
 static void
 draw_quad_edge (edge_ref e, void *data)
 {
+  double x1, y1, z1;
+  double x2, y2, z2;
+
 #if 0
   int id = ID(e) % 12;
 
@@ -166,47 +169,168 @@ draw_quad_edge (edge_ref e, void *data)
   glColor3f (1., 1., 1.);
 #endif
 
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
+
+//      if (!info->is_bspline)
+//        return;
+
 //      if (info->is_stitch)
 //        return;
       if (info->is_round)
         {
           int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
           glBegin (GL_LINES);
-          for (i = 0; i < CIRC_SEGS; i++)
+
+          for (i = 0; i < segs; i++)
             {
-              /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
             }
+
           glEnd ();
+
           return;
         }
     }
 
+//  printf ("Drawing line (%f, %f, %f)-(%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
   glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
   glEnd ();
 }
 
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
+void
+object3d_draw (object3d *object)
 {
   g_return_if_fail (object->edges != NULL);
 
 //  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
   g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+//  printf ("....ENDED\n");
+}
+
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  object3d_draw (object);
 }
 
 void
@@ -673,7 +797,7 @@ object3d_from_contours (POLYAREA *contours,
         }
 
 #ifndef NDEBUG
-      ct = contour;
+      ct = outer_contour;
       start_of_ct = 0;
       offset_in_ct = 0;
       ct_npoints = get_contour_npoints (ct);
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index b288cf2..3d228f6 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -9,6 +9,7 @@ typedef struct {
 } object3d;
 
 void object3d_test_init (void);
+void object3d_draw (object3d *object);
 void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index af391dd..d4127bc 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -23,6 +23,10 @@
 #include "hid/common/face3d.h"
 #include "hid/common/object3d.h"
 
+#include "hid/step/step.h" // XXX: Abstraction breaking
+#include "hid/step/model.h" // XXX: Abstraction breaking
+#include "hid/step/assembly.h" // XXX: Abstraction breaking
+
 #ifndef WIN32
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
@@ -54,6 +58,10 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 #include <dmalloc.h>
 #endif
 
+#define STEP_TO_COORD_X(pcb, x) (  MM_TO_COORD((x)))
+#define STEP_TO_COORD_Y(pcb, y) ((pcb->MaxHeight) - MM_TO_COORD((y)))
+#define STEP_TO_COORD_Z(pcb, z) ( MM_TO_COORD((z)))
+
 //#define VIEW_ORTHO
 
 extern HID ghid_hid;
@@ -123,6 +131,7 @@ static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_
 
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
+object3d *step_read_test = NULL;
 
 
 /* Coordinate conversions */
@@ -169,7 +178,7 @@ Py (int y)
 #define BOARD_THICKNESS         MM_TO_COORD(1.60)
 #define MASK_COPPER_SPACING     MM_TO_COORD(0.05)
 #define SILK_MASK_SPACING       MM_TO_COORD(0.01)
-static int
+static Coord
 compute_depth (int group)
 {
   static int last_depth_computed = 0;
@@ -191,7 +200,8 @@ compute_depth (int group)
   min_copper_group = MIN (bottom_group, top_group);
   max_copper_group = MAX (bottom_group, top_group);
   num_copper_groups = max_copper_group - min_copper_group;// + 1;
-  middle_copper_group = min_copper_group + num_copper_groups / 2;
+//  middle_copper_group = min_copper_group + num_copper_groups / 2;
+  middle_copper_group = min_copper_group;
 
   if (group >= 0 && group < max_group) {
     if (group >= min_copper_group && group <= max_copper_group) {
@@ -1102,6 +1112,7 @@ void
 ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
   render_priv *priv;
+  step_model *test_model;
 
   port->render_priv = priv = g_new0 (render_priv, 1);
 
@@ -1127,6 +1138,22 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+  test_model =
+    NULL;
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/object3d_test.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/step_interlayer_manual.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/DPAK.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Inductor_R1.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Capacitor_100V_10uF.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/shape_rep.step");
+//    step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/7446722007_handfixed.stp");
+
+  if (test_model != NULL)
+    step_read_test = test_model->object;
 }
 
 void
@@ -1653,8 +1680,8 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
     polygon.BoundingBox = *drawn_area;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-//  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
-  hid_draw_thin_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+//  hid_draw_thin_pcb_polygon (gc, &polygon, drawn_area);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -2089,10 +2116,87 @@ via_hole_cyl_callback (const BoxType * b, void *cl)
   return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, VIA_TYPE);
 }
 
+static void
+hidgl_draw_step_model_instance (struct assembly_model_instance *instance)
+{
+  render_priv *priv = gport->render_priv;
+  step_model *step_model = instance->model->step_model;
+  GLfloat m[4][4];
+  double ox, oy, oz;
+
+  if (step_model == NULL)
+    return;
+
+  hidgl_flush_triangles (priv->hidgl);
+  glPushAttrib (GL_CURRENT_BIT);
+  glPushMatrix ();
+
+  glColor4f (1.0f, 1.0f, 1.0f, 1.0f);
+
+//  /* KLUDGE */
+//  glTranslatef (0.0, 0.0, BOARD_THICKNESS / 2.0);
+
+
+  // OpenGL matrix layout (numbers are memory offsets)
+  // [ 0  4   8  12 ]
+  // [ 1  5   9  13 ]
+  // [ 2  6  10  14 ]
+  // [ 3  7  11  15 ]
+
+  glTranslatef (STEP_TO_COORD_X (PCB, instance->ox),
+                STEP_TO_COORD_Y (PCB, instance->oy),
+                STEP_TO_COORD_Z (PCB, instance->oz));
+
+  /* Undo -Y coord scaling */
+  glScalef (1.0f, -1.0f, 1.0f);
+
+  ox = instance->ay * instance->rz - instance->az * instance->ry;
+  oy = instance->az * instance->rx - instance->ax * instance->rz;
+  oz = instance->ax * instance->ry - instance->ay * instance->rx;
+  m[0][0] = instance->rx;  m[1][0] = ox;    m[2][0] = instance->ax;    m[3][0] = 0.0f;
+  m[0][1] = instance->ry;  m[1][1] = oy;    m[2][1] = instance->ay;    m[3][1] = 0.0f;
+  m[0][2] = instance->rz;  m[1][2] = oz;    m[2][2] = instance->az;    m[3][2] = 0.0f;
+  m[0][3] = 0.0f;          m[1][3] = 0.0f;  m[2][3] = 0.0f;            m[3][3] = 1.0f;
+  glMultMatrixf(&m[0][0]);
+
+  ox = step_model->ay * step_model->rz - step_model->az * step_model->ry;
+  oy = step_model->az * step_model->rx - step_model->ax * step_model->rz;
+  oz = step_model->ax * step_model->ry - step_model->ay * step_model->rx;
+  // NB: The matrix indexes below are transposed from the visual layout
+  // As the matrix is orthogonal, this should give us the inverse matrix
+  m[0][0] = step_model->rx;  m[0][1] = ox;    m[0][2] = step_model->ax;  m[0][3] = 0.0f;
+  m[1][0] = step_model->ry;  m[1][1] = oy;    m[1][2] = step_model->ay;  m[1][3] = 0.0f;
+  m[2][0] = step_model->rz;  m[2][1] = oz;    m[2][2] = step_model->az;  m[2][3] = 0.0f;
+  m[3][0] = 0.0f;            m[3][1] = 0.0f;  m[3][2] = 0.0f;            m[3][3] = 1.0f;
+  glMultMatrixf(&m[0][0]);
+
+  /* Undo -Y coord scaling */
+  glScalef (1.0f, -1.0f, 1.0f);
+
+  glTranslatef (-STEP_TO_COORD_X (PCB, step_model->ox),
+                -STEP_TO_COORD_Y (PCB, step_model->oy),
+                -STEP_TO_COORD_Z (PCB, step_model->oz));
+
+  object3d_draw (step_model->object);
+
+  hidgl_flush_triangles (priv->hidgl);
+
+  glPopMatrix ();
+  glPopAttrib ();
+}
+
 static int
-frontE_package_callback (const BoxType * b, void *cl)
+E_package_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+  Coord depth = compute_depth (layer_group);
+
+
+  if (element->assembly_model_instance != NULL)
+    {
+      hidgl_draw_step_model_instance (element->assembly_model_instance);
+    }
 
   if (FRONT (element))
     {
@@ -2100,33 +2204,27 @@ frontE_package_callback (const BoxType * b, void *cl)
         return 0;
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "ACY400") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_acy_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_acy_resistor (element, depth, BOARD_THICKNESS);
       }
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "800mil_resistor.fp") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_800mil_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_800mil_resistor (element, depth, BOARD_THICKNESS);
       }
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "2300mil_resistor.fp") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_2300mil_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_2300mil_resistor (element, depth, BOARD_THICKNESS);
       }
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "diode_700mil_surface.fp") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_700mil_diode_smd (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_700mil_diode_smd (element, depth, BOARD_THICKNESS);
       }
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "cap_100V_10uF.fp") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_1650mil_cap (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_1650mil_cap (element, depth, BOARD_THICKNESS);
       }
 
       if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "cap_15000V_2500pF.fp") == 0) {
-        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
-        hidgl_draw_350x800mil_cap (element, compute_depth (layer_group), BOARD_THICKNESS);
+        hidgl_draw_350x800mil_cap (element, depth, BOARD_THICKNESS);
       }
     }
   return 1;
@@ -2135,8 +2233,7 @@ frontE_package_callback (const BoxType * b, void *cl)
 static void
 ghid_draw_packages (BoxType *drawn_area)
 {
-  /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, drawn_area, NULL, E_package_callback, NULL);
 }
 
 void
@@ -2344,6 +2441,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     object3d_test_init ();
   }
 
+  step_load_models (BOARD_THICKNESS);
+
 //  printf ("Expose event at (%i,%i): %i x %i\n", ev->area.x, ev->area.y, ev->area.width, ev->area.height);
 //  printf ("Event type %i, send_event %i\n", ev->type, ev->send_event);
 
@@ -2670,7 +2769,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     hidgl_flush_triangles (priv->hidgl);
   }
 
-  glEnable (GL_LIGHTING);
+//  glEnable (GL_LIGHTING);
 
   glShadeModel (GL_SMOOTH);
 
@@ -2729,7 +2828,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-//  object3d_draw_debug ();
+  //object3d_draw_debug ();
+  if (step_read_test != NULL)
+    object3d_draw (step_read_test);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c9eb567..3c7eae3 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -2600,7 +2600,7 @@ idle_proc (XtPointer dummy)
 
   {
     static int c_x = -2, c_y = -2;
-    static MarkType saved_mark;
+    static _MarkType saved_mark;
     static const Unit *old_grid_unit = NULL;
     if (crosshair_x != c_x || crosshair_y != c_y
 	|| Settings.grid_unit != old_grid_unit
diff --git a/src/hid/step/assembly.cpp b/src/hid/step/assembly.cpp
index cc3fa9a..b4de7e2 100644
--- a/src/hid/step/assembly.cpp
+++ b/src/hid/step/assembly.cpp
@@ -94,6 +94,7 @@
 #include <glib.h>
 
 extern "C" {
+typedef struct step_model step_model;
 #include "assembly.h"
 }
 
diff --git a/src/hid/step/assembly.h b/src/hid/step/assembly.h
index 7a8b5df..4594824 100644
--- a/src/hid/step/assembly.h
+++ b/src/hid/step/assembly.h
@@ -1,5 +1,11 @@
+struct assembly_model {
+  const char *filename;
+  GList *instances;
+  step_model *step_model;
+};
 
 struct assembly_model_instance {
+  struct assembly_model *model;
   const char *name;
 //  double ox;
 //  double oy;
@@ -16,9 +22,4 @@ struct assembly_model_instance {
 };
 
 
-struct assembly_model {
-  const char *filename;
-  GList *instances;
-};
-
 void export_step_assembly (const char *filename, GList *assembly_models);
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
new file mode 100644
index 0000000..8ea8f56
--- /dev/null
+++ b/src/hid/step/model.cpp
@@ -0,0 +1,1378 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+#include "string.h"
+
+extern "C" {
+#include <glib.h>
+/* XXX: Sdai and PCB clash.. both define MarkType */
+#include "global.h"
+#include "../hid/common/appearance.h"
+#include "../hid/common/step_id.h"
+#include "../hid/common/quad.h"
+#include "../hid/common/edge3d.h"
+#include "../hid/common/contour3d.h"
+#include "../hid/common/face3d.h"
+#include "../hid/common/vertex3d.h"
+#include "../hid/common/object3d.h"
+}
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 1
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#if 1
+#  define DEBUG_NOT_IMPLEMENTED
+#else
+#  undef DEBUG_NOT_IMPLEMENTED
+#endif
+
+#include <glib.h>
+
+extern "C" {
+#include "model.h"
+}
+
+
+typedef std::list<SDAI_Application_instance *> ai_list;
+typedef std::list<SdaiManifold_solid_brep *> msb_list;
+typedef std::list<SdaiMapped_item *> mi_list;
+
+
+SdaiProduct_definition *
+read_model_from_file (Registry *registry,
+                        InstMgr *instance_list,
+                        const char *filename)
+{
+  STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+
+  try
+    {
+      sfile.ReadExchangeFile (filename);
+    }
+  catch (...)
+    {
+      std::cout << "ERROR: Caught exception when attempting to read from file '" << filename << "' (does the file exist?)" << std::endl;
+      return NULL;
+    }
+
+  Severity severity = sfile.Error().severity();
+  if (severity != SEVERITY_NULL)
+    {
+      sfile.Error().PrintContents (std::cout);
+      std::cout << "WARNING: Error reading from file '" << filename << "'" << std::endl;
+//      return NULL;
+// XXX: HANDLE OTHER ERRORS BETTER?
+    }
+
+  pd_list pd_list;
+
+  // Find all PRODUCT_DEFINITION entities with a SHAPE_DEFINITION_REPRESETNATION
+  find_all_pd_with_sdr (instance_list, &pd_list, 0);
+
+  /*  Try to determine the root product */
+  find_and_remove_child_pd (instance_list, &pd_list, 0, "Next_assembly_usage_occurrence"); // Remove any PD which are children of another via NAUO
+  find_and_remove_child_pd (instance_list, &pd_list, 0, "Assembly_component_usage");       // Remove any PD which are children of another via ACU
+  find_and_remove_child_pd_mi_rm_sr (instance_list, &pd_list, 0); // Remove any PD which are children of another via MAPPED_ITEM->REPRESENTATION_MAP->SHAPE_REPRESENTATION
+
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+  std::cout << "Hopefully left with the root product definition" << std::endl;
+  for (pd_list::iterator iter = pd_list.begin(); iter != pd_list.end(); iter++)
+    std::cout << "Product definition list item #" << (*iter)->StepFileId () << std::endl;
+  std::cout << std::endl;
+#endif
+
+  // If we didn't find a suitable PD, give up now
+  if (pd_list.size() == 0)
+    {
+      std::cout << "ERROR: Did not find a PRODUCT_DEFINITION (with associated SHAPE_DEFINITION_REPRESENTATION)" << std::endl;
+      return NULL;
+    }
+
+  if (pd_list.size() > 1)
+    std::cout << "WARNING: Found more than one PRODUCT_DEFINITION that might be the root" << std::endl;
+
+  // Use the first PD meeting the criterion. Hopefully there should just be one, but if not, we pick the first.
+  return *pd_list.begin();
+}
+
+static void
+find_manifold_solid_brep_possible_voids (SdaiShape_representation *sr,
+                                         msb_list *msb_list)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Manifold_Solid_Brep") == 0 ||
+          strcmp (node->EntityName (), "Brep_With_Voids") == 0)
+
+        msb_list->push_back ((SdaiManifold_solid_brep *)node);
+
+      iter = iter->NextNode ();
+    }
+}
+
+static void
+find_mapped_item (SdaiShape_representation *sr,
+                  mi_list *mi_list)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Mapped_Item") == 0)
+        mi_list->push_back ((SdaiMapped_item *)node);
+
+      iter = iter->NextNode ();
+    }
+}
+
+typedef struct process_step_info {
+  /* Hash / list of SR -> step_model */
+  object3d *object;
+  double current_transform[4][4];
+
+} process_step_info;
+
+void
+copy_4x4 (double from[4][4],
+          double to[4][4])
+{
+  memcpy (to, from, sizeof(double[4][4]));
+}
+
+void
+identity_4x4 (double m[4][4])
+{
+  int i, j;
+
+  for (i = 0; i < 4; i++)
+    for (j = 0; j < 4; j++)
+      m[i][j] = 0.0;
+
+  m[0][0] = 1.0;
+  m[1][1] = 1.0;
+  m[2][2] = 1.0;
+  m[3][3] = 1.0;
+}
+
+/* NB: Column major */
+/* matrix[column][row] */
+void
+mult_4x4 (double a[4][4], double b[4][4], double to[4][4])
+{
+  int i, j;
+
+  for (i = 0; i < 4; i++)
+    for (j = 0; j < 4; j++)
+      to[i][j] = a[0][j] * b[i][0] +
+                 a[1][j] * b[i][1] +
+                 a[2][j] * b[i][2] +
+                 a[3][j] * b[i][3];
+}
+
+/* NB: Column major */
+void
+translate_origin (double m[4][4], double x, double y, double z)
+{
+  m[3][0] += x;
+  m[3][1] += y;
+  m[3][2] += z;
+}
+
+/* NB: Column major */
+void
+rotate_basis (double m[4][4], double ax, double ay, double az,
+                              double rx, double ry, double rz)
+{
+  double basis[4][4];
+  double old[4][4];
+  double ox, oy, oz;
+
+  ox = ay * rz - az * ry;
+  oy = az * rx - ax * rz;
+  oz = ax * ry - ay * rx;
+
+  basis[0][0] = rx;  basis[1][0] = ox;  basis[2][0] = ax;  basis[3][0] = 0.0;
+  basis[0][1] = ry;  basis[1][1] = oy;  basis[2][1] = ay;  basis[3][1] = 0.0;
+  basis[0][2] = rz;  basis[1][2] = oz;  basis[2][2] = az;  basis[3][2] = 0.0;
+  basis[0][3] = 0.0; basis[1][3] = 0.0; basis[2][3] = 0.0; basis[3][3] = 1.0;
+
+  copy_4x4 (m, old);
+  //mult_4x4 (old, basis, m);
+  mult_4x4 (basis, old, m);
+}
+
+/* NB: Row major, or transosed column major. Since Matrix will be orthogonal, this is equal to its inverse */
+void
+rotate_basis_inverted (double m[4][4], double ax, double ay, double az,
+                                       double rx, double ry, double rz)
+{
+  double basis[4][4];
+  double old[4][4];
+  double ox, oy, oz;
+
+  ox = ay * rz - az * ry;
+  oy = az * rx - ax * rz;
+  oz = ax * ry - ay * rx;
+
+  basis[0][0] = rx;  basis[0][1] = ox;  basis[0][2] = ax;  basis[0][3] = 0.0;
+  basis[1][0] = ry;  basis[1][1] = oy;  basis[1][2] = ay;  basis[1][3] = 0.0;
+  basis[2][0] = rz;  basis[2][1] = oz;  basis[2][2] = az;  basis[2][3] = 0.0;
+  basis[3][0] = 0.0; basis[3][1] = 0.0; basis[3][2] = 0.0; basis[3][3] = 1.0;
+
+  copy_4x4 (m, old);
+  //mult_4x4 (old, basis, m);
+  mult_4x4 (basis, old, m);
+}
+
+/* NB: Column major */
+void
+transform_vertex (double m[4][4], double *x, double *y, double *z)
+{
+  double new_x, new_y, new_z, new_w;
+
+  new_x = m[0][0] * *x +
+          m[1][0] * *y +
+          m[2][0] * *z +
+          m[3][0] * 1.0;
+
+  new_y = m[0][1] * *x +
+          m[1][1] * *y +
+          m[2][1] * *z +
+          m[3][1] * 1.0;
+
+  new_z = m[0][2] * *x +
+          m[1][2] * *y +
+          m[2][2] * *z +
+          m[3][2] * 1.0;
+
+#if 0
+  new_w = m[0][3] * *x +
+          m[1][3] * *y +
+          m[2][3] * *z +
+          m[3][3] * 1.0;
+
+  new_x /= new_w;
+  new_y /= new_w;
+  new_z /= new_w;
+#endif
+
+  *x = new_x;
+  *y = new_y;
+  *z = new_z;
+}
+
+/* NB: Column major */
+void
+transform_vector (double m[4][4], double *x, double *y, double *z)
+{
+  double new_x, new_y, new_z, new_w;
+
+  new_x = m[0][0] * *x +
+          m[1][0] * *y +
+          m[2][0] * *z;
+
+  new_y = m[0][1] * *x +
+          m[1][1] * *y +
+          m[2][1] * *z;
+
+  new_z = m[0][2] * *x +
+          m[1][2] * *y +
+          m[2][2] * *z;
+
+#if 0
+  new_w = m[0][3] * *x +
+          m[1][3] * *y +
+          m[2][3] * *z +
+          m[3][3] * 1.0;
+
+  new_x /= new_w;
+  new_y /= new_w;
+  new_z /= new_w;
+#endif
+
+  *x = new_x;
+  *y = new_y;
+  *z = new_z;
+}
+
+static void
+process_bscwk (SDAI_Application_instance *start_entity, edge_ref our_edge, process_step_info *info)
+{
+  /* Code using lazy binding approach, since many of the B_SPLINE_* types we will encounter
+   * are used in complex entities.. no sense witing code to handle them twice
+   */
+
+  edge_info *our_edge_info = (edge_info *)UNDIR_DATA(our_edge);
+
+  SDAI_Application_instance *entity = start_entity;
+  STEPcomplex *stepcomplex = NULL;
+  STEPattribute *attr;
+
+  bool is_complex;
+  bool found_bounded_curve = false;
+  bool found_b_spline_curve = false;
+  bool found_b_spline_curve_with_knots = false;
+  bool found_curve = false;
+  bool found_geometric_representation_item = false;
+  bool found_rational_b_spline_curve = false;
+  bool found_representation_item = false;
+
+  /* Potential Complex pieces:
+   *
+   * BOUNDED_CURVE
+   * B_SPLINE_CURVE
+   * B_SPLINE_CURVE_WITH_KNOTS
+   * CURVE
+   * GEOMETRIC_REPRESENTATION_ITEM
+   * RATIONAL_B_SPLINE_CURVE
+   * REPRESENTATION_ITEM
+   */
+
+  /* Things we take note of for futher processing.. */
+
+  /* B_SPLINE_CURVE */
+  SDAI_Integer b_spline_curve_degree;
+  EntityAggregate *control_points = NULL;
+
+  /* B_SPLINE_CURVE_WITH_KNOTS */
+  IntAggregate *knot_multiplicities = NULL;
+  RealAggregate *knots = NULL;
+
+  /* RATIONAL_B_SPLINE_CURVE */
+  RealAggregate *weights = NULL;
+
+  is_complex = entity->IsComplex();
+
+  if (is_complex)
+    {
+      stepcomplex = dynamic_cast<STEPcomplex *>(entity)->head;
+      entity = stepcomplex;
+    }
+
+  while (entity)
+    {
+      if (entity->EntityName() == NULL)
+        {
+          std::cout << "ERROR: NULL whilst traversing complex / entity" << std::endl;
+          return;
+        }
+      else if (!strcmp (entity->EntityName (), "Bounded_Curve"))
+        {
+          found_bounded_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "B_Spline_Curve"))
+        {
+          found_b_spline_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "B_Spline_Curve_With_Knots"))
+        {
+          found_b_spline_curve_with_knots = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Curve"))
+        {
+          found_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Geometric_Representation_Item"))
+        {
+          found_geometric_representation_item = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Rational_B_Spline_Curve"))
+        {
+          found_rational_b_spline_curve = true;
+        }
+      else if (!strcmp (entity->EntityName (), "Representation_Item"))
+        {
+          found_representation_item = true;
+        }
+      else
+        {
+          printf ("INFO: Unchecked entity name in complex, \"%s\"\n", entity->EntityName ());
+        }
+
+      entity->ResetAttributes ();
+      while ((attr = entity->NextAttribute()) != NULL)
+        {
+          if (!strcmp (attr->Name (), "name"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "degree"))
+            {
+              b_spline_curve_degree = *attr->Integer ();
+            }
+          else if (!strcmp (attr->Name (), "control_points_list"))
+            {
+              control_points = dynamic_cast<EntityAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "curve_form"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "closed_curve"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "self_intersect"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "knot_multiplicities"))
+            {
+              knot_multiplicities = dynamic_cast<IntAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "knots"))
+            {
+              knots = dynamic_cast<RealAggregate *>(attr->Aggregate ());
+            }
+          else if (!strcmp (attr->Name (), "knot_spec"))
+            {
+            }
+          else if (!strcmp (attr->Name (), "weights_data"))
+            {
+              weights = dynamic_cast<RealAggregate *>(attr->Aggregate ());
+            }
+          else
+            {
+              printf ("INFO: Unchecked attribute name in entity, \"%s\"\n", attr->Name ());
+            }
+        }
+
+      if (stepcomplex != NULL)
+        stepcomplex = stepcomplex->sc;
+
+      entity = stepcomplex;
+    }
+
+  /* Now we see what we found .... */
+
+  printf ("------\n");
+  printf ("b_spline_curve_degree = %i\n",b_spline_curve_degree);
+  printf ("control_points = %p\n",control_points);
+  printf ("knot_multiplicities = %p\n", knot_multiplicities);
+  printf ("knots = %p\n", knots);
+  printf ("weights = %p\n", weights);
+  printf ("is_complex = %s\n",                          is_complex                          ? "true" : "false");
+  printf ("found_bounded_curve = %s\n",                 found_bounded_curve                 ? "true" : "false");
+  printf ("found_b_spline_curve = %s\n",                found_b_spline_curve                ? "true" : "false");
+  printf ("found_b_spline_curve_with_knots = %s\n",     found_b_spline_curve_with_knots     ? "true" : "false");
+  printf ("found_curve = %s\n",                         found_curve                         ? "true" : "false");
+  printf ("found_geometric_representation_item = %s\n", found_geometric_representation_item ? "true" : "false");
+  printf ("found_rational_b_spline_curve = %s\n",       found_rational_b_spline_curve       ? "true" : "false");
+  printf ("found_representation_item = %s\n",           found_representation_item           ? "true" : "false");
+
+  if (control_points != NULL)
+    printf ("Number of control points = %i\n", control_points->EntryCount ());
+
+  if (knot_multiplicities != NULL)
+    printf ("Number of knot_multiplicities = %i\n", knot_multiplicities->EntryCount ());
+
+  if (knots != NULL)
+    printf ("Number of knots = %i\n", knots->EntryCount ());
+
+  if (weights != NULL) {
+    printf ("Number of weights = %i\n", weights->EntryCount ());
+
+  printf ("------\n");
+
+    if (weights->EntryCount () != control_points->EntryCount ())
+      {
+        printf ("ERROR: Weights not null, but entry length doesn't equal the number of control points\n");
+      }
+  }
+
+  if (control_points == NULL)
+    {
+      printf ("ERROR: control points == NULL\n");
+      return;
+    }
+
+  our_edge_info->is_bspline = true;
+  our_edge_info->degree = b_spline_curve_degree;
+  our_edge_info->num_control_points = control_points->EntryCount ();
+
+  /* XXX: TODO: Iterate over control points, knots, weights etc.. filling in these details */
+}
+
+static void
+process_edges (GHashTable *edges_hash_set, process_step_info *info) //object3d *object)
+{
+  GHashTableIter iter;
+  SdaiEdge *edge;
+  edge_ref our_edge;
+  vertex3d *vertex;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  bool orientation;
+  gpointer foo;
+  int bar;
+  bool kludge;
+
+  g_hash_table_iter_init (&iter, edges_hash_set);
+  while (g_hash_table_iter_next (&iter, (void **)&edge, &foo))
+    {
+      bar = GPOINTER_TO_INT (foo);
+      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+        {
+          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+          continue;
+        }
+
+      orientation = (bar & 1) != 0;
+      kludge = (bar & 2) != 0;
+
+      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+      //     In practice, edge should point to an EDGE_CURVE sub-type
+      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+          continue;
+        }
+
+      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+          continue;
+        }
+
+      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+      x1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ())->value;
+      y1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      x2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ())->value;
+      y2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+#if 0
+      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+              edge->StepFileId (), x1, y1, z1, x2, y2, z2);
+#endif
+
+      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+        {
+          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+          SdaiCurve *curve = ec->edge_geometry_ ();
+          bool same_sense = ec->same_sense_ ();
+
+#ifdef DEBUG_NOT_IMPLEMENTED
+          if (!same_sense)
+            printf ("XXX: HAVE NOT TESTED THIS CASE.... same_sense is false\n");
+#endif
+
+#if 0
+          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+#endif
+
+          if (strcmp (curve->EntityName (), "Line") == 0)
+            {
+              transform_vertex (info->current_transform, &x1, &y1, &z1);
+              transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+              our_edge = make_edge ();
+              UNDIR_DATA (our_edge) = make_edge_info ();
+              object3d_add_edge (info->object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//              continue;
+            }
+          else if (strcmp (curve->EntityName (), "Circle") == 0)
+            {
+              SdaiCircle *circle = (SdaiCircle *)curve;
+              double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+              double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+              double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+              double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+              double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+              double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+              double radius = circle->radius_();
+
+              edge_info *edge_info;
+
+              transform_vertex (info->current_transform, &cx, &cy, &cz);
+              transform_vertex (info->current_transform, &x1, &y1, &z1);
+              transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+              transform_vector (info->current_transform, &nx, &ny, &nz);
+
+              our_edge = make_edge ();
+              edge_info = make_edge_info ();
+              if (!kludge) //(same_sense)
+                {
+                  edge_info_set_round (edge_info, cx, cy, cz, nx, ny, nz, radius);
+                }
+              else
+                {
+                  printf ("URM................\n");
+                  edge_info_set_round (edge_info, cx, cy, cz, -nx, -ny, -nz, radius);
+                }
+
+              UNDIR_DATA (our_edge) = edge_info;
+              object3d_add_edge (info->object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//              continue;
+            }
+          else if (curve->IsComplex() || /* This is a guess - assuming complex curves are likely to be B_SPLINE_* complexes */
+                   strcmp (curve->EntityName (), "B_Spline_Curve_With_Knots") == 0)
+            {
+              transform_vertex (info->current_transform, &x1, &y1, &z1);
+              transform_vertex (info->current_transform, &x2, &y2, &z2);
+
+              our_edge = make_edge ();
+              UNDIR_DATA (our_edge) = make_edge_info ();
+              object3d_add_edge (info->object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+              process_bscwk (curve, our_edge, info);
+            }
+          else
+            {
+#ifdef DEBUG_NOT_IMPLEMENTED
+              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+              if (curve->IsComplex())
+                {
+                  printf ("CURVE IS COMPLEX\n");
+                }
+#endif
+              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+              // XXX: Various derived types of the above, e.g.:
+              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+              continue;
+            }
+
+        }
+      else
+        {
+          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+          continue;
+        }
+    }
+}
+
+static step_model *
+process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, process_step_info *info);
+
+static step_model *
+process_shape_representation(InstMgr *instance_list, SdaiShape_representation *sr, process_step_info *info)
+{
+  step_model *step_model;
+//  std::cout << "INFO: Processing raw SR" << std::endl;
+
+  step_model = g_new0(struct step_model, 1);
+//  step_model->filename = g_strdup(filename);
+//  step_model->instances = NULL;    /* ??? */
+
+#if 0
+  SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+  if (part_origin == NULL)
+    std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
+
+  if (part_origin != NULL)
+    {
+      step_model->ox = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ())->value;
+      step_model->oy = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      step_model->oz = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      step_model->ax = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      step_model->ay = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      step_model->az = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      step_model->rx = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      step_model->ry = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      step_model->rz = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+    }
+#endif
+
+  /* We need to find "Shape_representation_relation" linking this SR to another.
+   * The SRR could be on its own, or (for assemblies), is likely to be in a complex with
+   * "Representation_relationship_with_transformation", in which case the
+   * "Representation_Relationship" supertype of Shape_representation_relation is also
+   * explicitly in the complex.
+   */
+
+  srr_list srr_list;
+
+  // Find all SHAPE_REPRESENTATION_RELATIONSHIP with rep_1 = sr
+  find_all_srr_with_rep_1 (instance_list, &srr_list, 0, sr);
+
+  for (srr_list::iterator iter = srr_list.begin (); iter != srr_list.end (); iter++)
+    {
+      SdaiShape_representation_relationship *srr = (*iter);
+//      std::cout << "Found SRR; processing" << std::endl;
+
+      SdaiShape_representation *child_sr = dynamic_cast<SdaiShape_representation *>(srr->rep_2_ ());
+
+      /* XXX: Actually only want to "process" the SR once per SR, then create _instances_ of it */
+      /* XXX: Do something with the result */
+      // Leave existing transformation
+      process_sr_or_subtype (instance_list, child_sr, info);
+    }
+
+
+  srr_rrwt_list srr_rrwt_list;
+
+  // Find all SHAPE_REPRESENTATION_RELATIONSHIP with rep_1 = sr
+  find_all_srr_rrwt_with_rep_1 (instance_list, &srr_rrwt_list, 0, sr);
+
+  for (srr_rrwt_list::iterator iter = srr_rrwt_list.begin (); iter != srr_rrwt_list.end (); iter++)
+    {
+      double backup_transform[4][4];
+      double ox, oy, oz;
+      double ax, ay, az;
+      double rx, ry, rz;
+      SdaiAxis2_placement_3d *parent_axis;
+      SdaiAxis2_placement_3d *child_axis;
+
+      srr_rrwt *item = (*iter);
+//      std::cout << "Found SRR + RRWT; processing" << std::endl;
+
+      SdaiShape_representation *child_sr = dynamic_cast<SdaiShape_representation *>(item->rep_2);
+      SdaiItem_defined_transformation *idt = item->idt;
+
+//      std::cout << "  child SR: #" << child_sr->StepFileId() << " IDT: #" << idt->StepFileId() << std::endl;
+
+      copy_4x4 (info->current_transform, backup_transform);
+
+      child_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_1_());
+      parent_axis = dynamic_cast<SdaiAxis2_placement_3d *>(idt->transform_item_2_());
+
+      if (parent_axis == NULL ||
+          child_axis == NULL)
+        {
+          std::cout << "ERROR: Got NULL in one of the axis placements for IDT" << std::endl;
+          continue;
+        }
+
+      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
+      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+      printf ("child axis o: (%f, %f, %f)\n"
+              "           a: (%f, %f, %f)\n"
+              "           r: (%f, %f, %f)\n",
+              ox, oy, oz,
+              ax, ay, az,
+              rx, ry, rz);
+
+      /* XXX: Looking only at the target vector.. need to find some examples where the parent transform coordinate system is not unity to get this correct */
+      rotate_basis (info->current_transform, ax, ay, az, rx, ry, rz);
+
+      /* Is this in the correct order? */
+      translate_origin (info->current_transform, ox, oy, oz);
+
+      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
+      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+      printf ("parent axis o: (%f, %f, %f)\n"
+              "            a: (%f, %f, %f)\n"
+              "            r: (%f, %f, %f)\n",
+              ox, oy, oz,
+              ax, ay, az,
+              rx, ry, rz);
+      printf ("\n");
+
+      rotate_basis_inverted (info->current_transform, ax, ay, az, rx, ry, rz);
+      translate_origin (info->current_transform, -ox, -oy, -oz);
+
+      /* XXX: Actually only want to "process" the SR once per SR, then create _instances_ of it */
+      /* XXX: Origin offset etc..? */
+      /* XXX: Do something with the result */
+      process_sr_or_subtype (instance_list, child_sr, info);
+
+      // Revert the transformation
+      copy_4x4 (backup_transform, info->current_transform);
+    }
+
+
+  // Find all SRR where RR.rep_1 = sr
+  //              let   child_sr = RR.rep_2
+
+  // If SRR node is complex, and also RRWT, extract transform as follows:
+  // SdaiTransformation(SdaiSelect) transformation = RRWT.transformation_operator
+  // Check transformation.UnderlyingTypeName () == "Item_defined_transformation" - if not, error (don't know how to do Functionally defined tranformation
+  // item1 = transform.transform_item_1_() // Axis in parent (use dynamic cast to ensure it is the correct type?)
+  // item2 = transform.transform_item_2_() // Axis in child (use dynamic cast to ensure it is the correct type?)
+  // If item1 or item2 is NULL, then drop this child?
+
+  // If SRR node was not complex, insert child with 1:1 tranformation
+
+  return step_model;
+}
+
+static step_model *
+process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, process_step_info *info)
+{
+  step_model *step_model;
+//  object3d *object;
+  GHashTable *edges_hash_set;
+  bool on_plane;
+
+  // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), call the specific hander
+  if (strcmp (sr->EntityName (), "Shape_Representation") == 0)
+    {
+      return process_shape_representation (instance_list, sr, info);
+    }
+
+  if (strcmp (sr->EntityName (), "Advanced_Brep_Shape_Representation") != 0)
+    {
+      printf ("step_model_to_shape_master: Looking for Advanced_Brep_Shape_Representation, but found %s (which we don't support yet)\n", sr->EntityName ());
+      return NULL;
+    }
+
+//  object = make_object3d ((char *)"Test");
+
+  step_model = g_new0(struct step_model, 1);
+//  step_model->filename = g_strdup(filename);
+//  step_model->instances = NULL;    /* ??? */
+
+#if 0
+  SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+  if (part_origin == NULL)
+    std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
+
+  if (part_origin != NULL)
+    {
+      step_model->ox = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ())->value;
+      step_model->oy = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      step_model->oz = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      step_model->ax = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      step_model->ay = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      step_model->az = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      step_model->rx = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      step_model->ry = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      step_model->rz = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+    }
+#endif
+
+  msb_list msb_list;
+  find_manifold_solid_brep_possible_voids (sr, &msb_list);
+
+  for (msb_list::iterator iter = msb_list.begin (); iter != msb_list.end (); iter++)
+    {
+      std::cout << "Found MANIFOLD_SOLID_BREP; processing" << std::endl;
+      SdaiClosed_shell *cs = (*iter)->outer_ ();
+
+      /* XXX: Need to check if msb is actually an instance of BREP_WITH_VOIDS, whereupon we also need to iterate over the void shell(s) */
+
+      std::cout << "Closed shell is " << cs << std::endl;
+
+      /* NB: NULLs give g_direct_hash and g_direct_equal */
+      edges_hash_set = g_hash_table_new (NULL, NULL);
+
+      for (SingleLinkNode *iter = cs->cfs_faces_ ()->GetHead ();
+           iter != NULL;
+           iter = iter->NextNode ())
+        {
+          SdaiFace *face = (SdaiFace *)((EntityNode *)iter)->node;
+
+          /* XXX: Do we look for specific types of face at this point? (Expect ADVANCED_FACE usually?) */
+          if (strcmp (face->EntityName (), "Advanced_Face") != 0)
+            {
+              printf ("WARNING: Found face of type %s (which we don't support yet)\n", face->EntityName ());
+              continue;
+            }
+
+          /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
+          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
+          SdaiFace_surface *fs = (SdaiFace_surface *) face;
+
+          SdaiSurface *surface = fs->face_geometry_ ();
+
+#if 0
+          std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
+#endif
+
+          on_plane = false;
+
+          if (surface->IsComplex ())
+            {
+#ifdef DEBUG_NOT_IMPLEMENTED
+              printf ("WARNING: Found a STEP Complex entity for our surface (which we don't support yet). Probably a B_SPLINE surface?\n");
+#endif
+            }
+          else if (strcmp (surface->EntityName (), "Plane") == 0)
+            {
+              on_plane = true;
+//              printf ("WARNING: planar surfaces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
+            {
+//              printf ("WARNING: cylindrical suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
+            {
+//              printf ("WARNING: toroidal suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
+            {
+//              printf ("WARNING: spherical surfaces are not supported yet\n");
+            }
+          else
+            {
+#ifdef DEBUG_NOT_IMPLEMENTED
+              printf ("ERROR: Found an unknown surface type (which we obviously don't support). Surface name is %s\n", surface->EntityName ());
+#endif
+            }
+
+          for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
+               iter != NULL;
+               iter = iter->NextNode ())
+            {
+              SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
+
+
+#if 0
+              bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
+
+              if (is_outer_bound)
+                std::cout << "  Outer bounds of face include ";
+              else
+                std::cout << "  Bounds of face include ";
+#endif
+
+              // NB: SdaiFace_bound has SdaiLoop *bound_ (), and Boolean orientation_ ()
+              // NB: SdaiLoop is a SdaiTopological_representation_item, which is a SdaiRepresentation_item, which has a name_ ().
+              // NB: Expect bounds_ () may return a SUBTYPE of SdaiLoop, such as, but not necessarily: SdaiEdge_loop
+              SdaiLoop *loop = fb->bound_ ();
+
+#if 0
+              std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
+#endif
+              if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
+                {
+                  SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
+
+                  // NB: EDGE_LOOP uses multiple inheritance from LOOP and PATH, thus needs special handling to
+                  //     access the elements belonging to PATH, such as edge_list ...
+                  //     (Not sure if this is a bug in STEPcode, as the SdaiEdge_loop class DOES define
+                  //     an accessor edge_list_ (), yet it appears to return an empty aggregate.
+
+                  char path_entity_name[] = "Path"; /* SDAI_Application_instance::GetMiEntity() should take const char *, but doesn't */
+                  SdaiPath *path = (SdaiPath *)el->GetMiEntity (path_entity_name);
+
+                  for (SingleLinkNode *iter = path->edge_list_ ()->GetHead ();
+                       iter != NULL;
+                       iter = iter->NextNode ())
+                    {
+                      SdaiOriented_edge *oe = (SdaiOriented_edge *)((EntityNode *)iter)->node;
+                      /* XXX: Will it _always?_ be an SdaiOriented_edge? */
+
+                      // NB: Stepcode does not compute derived attributes, so we need to look at the EDGE
+                      //     "edge_element" referred to by the ORIENTED_EDGE, to find the start and end vertices
+
+                      SdaiEdge *edge = oe->edge_element_ ();
+                      bool orientation = oe->orientation_ ();
+
+                      if (on_plane)
+                        {
+                          if (fs->same_sense_())
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                          else
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                        }
+                      else
+                        {
+                          g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                        }
+
+
+                      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+                          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+                        {
+                          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+                          continue;
+                        }
+
+                      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+                      //     In practice, edge should point to an EDGE_CURVE sub-type
+                      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+                      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+                      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+                      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+                      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+                      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+                          continue;
+                        }
+
+                      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+                          continue;
+                        }
+
+#if 0
+                      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+                      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+                      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+                              edge->StepFileId (),
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value);
+
+                      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+                        {
+                          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+                          SdaiCurve *curve = ec->edge_geometry_ ();
+                          bool same_sense = ec->same_sense_ ();
+
+                          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+
+                          if (strcmp (curve->EntityName (), "Line") == 0)
+                            {
+//                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//                              continue;
+                            }
+                          else if (strcmp (curve->EntityName (), "Circle") == 0)
+                            {
+//                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//                              continue;
+                            }
+                          else
+                            {
+                              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+                              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+                              // XXX: Various derived types of the above, e.g.:
+                              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+                              continue;
+                            }
+
+                        }
+                      else
+                        {
+                          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+                          continue;
+                        }
+#endif
+
+                    }
+
+                }
+              else
+                {
+                  printf ("WARNING: Face is bounded by an unhandled loop type (%s)\n", loop->EntityName ());
+                  continue;
+                }
+            }
+
+        }
+
+        process_edges (edges_hash_set, info); //object);
+
+        /* Deal with edges hash set */
+        g_hash_table_destroy (edges_hash_set);
+    }
+
+  mi_list mi_list;
+  find_mapped_item (sr, &mi_list);
+
+  for (mi_list::iterator iter = mi_list.begin (); iter != mi_list.end (); iter++)
+    {
+      std::cout << "Found MAPPED_ITEM; processing" << std::endl;
+      SdaiMapped_item *mi = (*iter);
+
+      SdaiRepresentation_map *rm = dynamic_cast<SdaiRepresentation_map *>(mi->mapping_source_());
+      SdaiAxis2_placement_3d *mi_axis = dynamic_cast<SdaiAxis2_placement_3d *>(mi->mapping_target_());
+
+      if (rm == NULL)
+        {
+          std::cout << "ERROR: Could not find REPRESENTATION_ITEM referred to by MAPPED_ITEM" << std::endl;
+          continue;
+        }
+
+      if (mi_axis == NULL)
+        {
+          std::cout << "ERROR: Could not find AXIS2_PLACEMENT_3D referred to by MAPPED_ITEM" << std::endl;
+          continue;
+        }
+
+      SdaiAxis2_placement_3d *rm_axis = dynamic_cast<SdaiAxis2_placement_3d *>(rm->mapping_origin_());
+      SdaiShape_representation *child_sr = dynamic_cast<SdaiShape_representation *>(rm->mapped_representation_());
+
+      if (rm_axis == NULL)
+        {
+          std::cout << "ERROR: Could not find AXIS2_PLACEMENT_3D referred to by REPRESENTATION_ITEM" << std::endl;
+          continue;
+        }
+
+      if (child_sr == NULL)
+        {
+          std::cout << "ERROR: Could not find SHAPE_REPRESENTATION referred to by MAPPED_ITEM" << std::endl;
+          continue;
+        }
+
+#if 0
+      /* XXX: Actually only want to "process" the SR once per SR, then create _instances_ of it */
+      /* XXX: Origin offset etc..? */
+      /* XXX: Do something with the result */
+      process_sr_or_subtype (instance_list, child_sr, info);
+#endif
+
+      double backup_transform[4][4];
+      double ox, oy, oz;
+      double ax, ay, az;
+      double rx, ry, rz;
+      SdaiAxis2_placement_3d *parent_axis = rm_axis;
+      SdaiAxis2_placement_3d *child_axis = mi_axis;
+
+      copy_4x4 (info->current_transform, backup_transform);
+
+      if (parent_axis == NULL ||
+          child_axis == NULL)
+        {
+          std::cout << "ERROR: Got NULL in one of the axis placements for IDT" << std::endl;
+          continue;
+        }
+
+      ox = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ())->value;
+      oy = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      oz = ((RealNode *)child_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      ax = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      ay = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      az = ((RealNode *)child_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      rx = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      ry = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      rz = ((RealNode *)child_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+      /* XXX: Looking only at the target vector.. need to find some examples where the parent transform coordinate system is not unity to get this correct */
+      rotate_basis (info->current_transform, ax, ay, az, rx, ry, rz);
+      translate_origin (info->current_transform, ox, oy, oz);
+
+      ox = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ())->value;
+      oy = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+      oz = ((RealNode *)parent_axis->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      ax = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+      ay = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      az = ((RealNode *)parent_axis->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      rx = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+      ry = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+      rz = ((RealNode *)parent_axis->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+      translate_origin (info->current_transform, -ox, -oy, -oz);
+      rotate_basis_inverted (info->current_transform, ax, ay, az, rx, ry, rz);
+
+      /* XXX: Actually only want to "process" the SR once per SR, then create _instances_ of it */
+      /* XXX: Origin offset etc..? */
+      /* XXX: Do something with the result */
+      process_sr_or_subtype (instance_list, child_sr, info);
+
+      // Revert the transformation
+      copy_4x4 (backup_transform, info->current_transform);
+    }
+
+  step_model->object = info->object;
+
+  return step_model;
+}
+
+extern "C" struct step_model *
+step_model_to_shape_master (const char *filename)
+{
+  step_model *step_model;
+  process_step_info info;
+
+  printf ("step_model_to_shape_master(\"%s\")\n", filename);
+
+  Registry * registry = new Registry (SchemaInit);
+  InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
+
+  // Increment FileId so entities start at #1 instead of #0.
+  instance_list->NextFileId();
+
+  SdaiProduct_definition *pd = read_model_from_file (registry, instance_list, filename);
+  if (pd == NULL)
+    {
+      printf ("ERROR Loading STEP model from file '%s'", filename);
+      return NULL;
+    }
+
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, pd);
+  SdaiShape_representation *sr = (SdaiShape_representation *)sdr->used_representation_ ();
+
+  info.object = make_object3d ((char *)"Test");
+  identity_4x4 (info.current_transform);
+
+  step_model = process_sr_or_subtype (instance_list, sr, &info);
+
+  if (step_model != NULL)
+    {
+      /* KLUDGE */
+      SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+      if (part_origin == NULL)
+        std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
+
+      if (part_origin != NULL)
+        {
+          step_model->ox = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ())->value;
+          step_model->oy = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+          step_model->oz = ((RealNode *)part_origin->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          step_model->ax = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+          step_model->ay = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          step_model->az = ((RealNode *)part_origin->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+          step_model->rx = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ())->value;
+          step_model->ry = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+          step_model->rz = ((RealNode *)part_origin->ref_direction_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+        }
+
+      /* KLUDGE */
+      step_model->object = info.object;
+    }
+  else
+    {
+      printf ("WARNING: Got NULL step_model.. must have been some problem loading it\n");
+    }
+
+  delete instance_list;
+  delete registry;
+
+  return step_model;
+}
+
+void step_model_free(step_model *step_model)
+{
+//  g_list_free (step_model->instances);
+//  g_free ((char *)step_model->filename);
+  destroy_object3d (step_model->object);
+  g_free (step_model);
+}
+
+/* Geometry surface and face types encountered so far..
+
+Toroidal_surface     Circle (x5)
+Toroidal_surface     Circle (x4)
+Toroidal_surface     Circle (x3) + B_Spline_Curve_With_Knots
+
+Cylindrical_surface  Circle + Line + B_Spline_Curve_With_Knots
+Cylindrical_surface  Circle + Line
+
+Plane                Circle (xn) + Line (xn) + B_Spline_Curve_With_Knots
+
+*/
diff --git a/src/hid/step/model.h b/src/hid/step/model.h
new file mode 100644
index 0000000..af67d54
--- /dev/null
+++ b/src/hid/step/model.h
@@ -0,0 +1,25 @@
+#if 0
+typedef struct step_model_instance {
+  double x;
+  double y;
+  double rotation;
+} step_model_instance;
+#endif
+
+typedef struct step_model {
+  const char *filename;
+//  GList *instances;
+  double ox;
+  double oy;
+  double oz;
+  double ax;
+  double ay;
+  double az;
+  double rx;
+  double ry;
+  double rz;
+  object3d *object;
+} step_model;
+
+step_model *step_model_to_shape_master (const char *filename);
+void step_model_free (step_model *step_model);
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 657f3ca..10a34e5 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -41,6 +41,7 @@
 #include <dmalloc.h>
 #endif
 
+#include "model.h"
 #include "assembly.h"
 
 #define CRASH fprintf(stderr, "HID error: pcb called unimplemented STEP function %s.\n", __FUNCTION__); abort()
@@ -60,7 +61,7 @@
 #endif
 
 
-static Coord board_thickness;
+static Coord board_thickness = 0;
 #define HACK_BOARD_THICKNESS board_thickness
 //#define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
 #define HACK_COPPER_THICKNESS MM_TO_COORD(0.035)
@@ -139,7 +140,7 @@ Name of the STEP output file. Can contain a path.
    %end-doc
    */
     {"thickness", N_("Board thickness"),
-         HID_Coord, 0, 0, {0, 0, 0, MM_TO_COORD (1.6)}, 0, 0},
+         HID_Coord, 0, MM_TO_COORD(100), {0, 0, 0, MM_TO_COORD (1.6)}, 0, 0}, /* XXX: Arbitrary limit of 100mm thick PCB */
 #define HA_thickness 5
 };
 
@@ -208,6 +209,229 @@ parse_numeric_attribute (ElementType *element, char *attr_name, double *res)
   *res = COORD_TO_MM (GetValueEx (attr_value, NULL, &absolute, NULL, "mm")); /* KLUDGE */
 }
 
+static GList *loaded_models = NULL;
+
+void
+step_load_models(Coord board_thickness_)
+{
+  int i;
+  const char *filename;
+  struct assembly_model *model;
+  struct assembly_model_instance *instance;
+  const char *attribute;
+
+  board_thickness = board_thickness_;
+
+  ELEMENT_LOOP (PCB->Data);
+    {
+      bool on_solder = TEST_FLAG (ONSOLDERFLAG, element);
+      double on_solder_negate = on_solder ? -1.0 : 1.0;
+      const char *model_filename;
+      double ox, oy, oz;
+      double ax, ay, az;
+      double rx, ry, rz;
+      double rotation;
+      double cos_rot;
+      double sin_rot;
+      GList *model_iter;
+
+      /* Skip if the component doesn't have a STEP-AP214 3d_model */
+      attribute = AttributeGet (element, "PCB::3d_model::type");
+      if (attribute == NULL || strcmp (attribute, "STEP-AP214") != 0)
+        continue;
+
+      attribute = AttributeGet (element, "PCB::3d_model::filename");
+      if (attribute == NULL)
+        continue;
+      model_filename = attribute;
+
+#if 0   /* Rather than write a parser for three floats in a string, separate X, Y, Z explicitly for quicker testing */
+
+      attribute = AttributeGet (element, "PCB::3d_model::origin");
+      if (attribute == NULL)
+        continue;
+      parse_cartesian_point_3d_string (attribute, &ox, &oy, &oz);
+
+      attribute = AttributeGet (element, "PCB::3d_model::axis");
+      if (attribute == NULL)
+        continue;
+      parse_direction_3d_string (attribute, &ax, &ay, &az);
+      ax = 0.0, ay = 0.0, az = 1.0;
+
+      attribute = AttributeGet (element, "PCB::3d_model::ref_dir");
+      if (attribute == NULL)
+        continue;
+      parse_direction_3d_string (attribute, &rx, &ry, &rz);
+      rx = 1.0, ry = 0.0, rz = 0.0;
+#endif
+
+      /* XXX: Should parse a unit suffix, e.g. "degrees" */
+      attribute = AttributeGet (element, "PCB::rotation");
+      if (attribute == NULL)
+        continue;
+      parse_rotation_string (attribute, &rotation);
+
+      /* XXX: QUICKER TO CODE INDIVIDULAL VALUES NOT SPACE SEPARATED */
+      parse_position_attribute (element, "PCB::3d_model::origin::X", &ox);
+      parse_position_attribute (element, "PCB::3d_model::origin::Y", &oy);
+      parse_position_attribute (element, "PCB::3d_model::origin::Z", &oz);
+      parse_numeric_attribute (element, "PCB::3d_model::axis::X", &ax);
+      parse_numeric_attribute (element, "PCB::3d_model::axis::Y", &ay);
+      parse_numeric_attribute (element, "PCB::3d_model::axis::Z", &az);
+      parse_numeric_attribute (element, "PCB::3d_model::ref_dir::X", &rx);
+      parse_numeric_attribute (element, "PCB::3d_model::ref_dir::Y", &ry);
+      parse_numeric_attribute (element, "PCB::3d_model::ref_dir::Z", &rz);
+      parse_numeric_attribute (element, "PCB::rotation", &rotation);
+
+#if 1  /* Write the intended final syntax attributes */
+      if (1)
+        {
+          GString *value = g_string_new (NULL);
+
+          attribute = AttributeGet (element, "PCB::3d_model::origin::X");
+          g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0mm");
+          attribute = AttributeGet (element, "PCB::3d_model::origin::Y");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0mm");
+          attribute = AttributeGet (element, "PCB::3d_model::origin::Z");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0mm");
+          AttributePutToList (&element->Attributes, "PCB::3d_model::origin", value->str, true);
+
+          attribute = AttributeGet (element, "PCB::3d_model::axis::X");
+          g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0");
+          attribute = AttributeGet (element, "PCB::3d_model::axis::Y");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+          attribute = AttributeGet (element, "PCB::3d_model::axis::Z");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+          AttributePutToList (&element->Attributes, "PCB::3d_model::axis", value->str, true);
+
+          attribute = AttributeGet (element, "PCB::3d_model::ref_dir::X");
+          g_string_printf (value, "%s", attribute != NULL ? attribute : "0.0");
+          attribute = AttributeGet (element, "PCB::3d_model::ref_dir::Y");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+          attribute = AttributeGet (element, "PCB::3d_model::ref_dir::Z");
+          g_string_append_printf (value, " %s", attribute != NULL ? attribute : "0.0");
+          AttributePutToList (&element->Attributes, "PCB::3d_model::ref_dir", value->str, true);
+
+          g_string_free (value, true);
+        }
+#endif
+
+      instance = element->assembly_model_instance;
+
+      if (instance != NULL)
+        {
+          if (strcmp (instance->model->filename, model_filename) == 0)
+            {
+              /* Same model */
+            }
+          else
+            {
+              /* Different model, delete the old instance */
+
+              struct assembly_model *old_model;
+
+              old_model = instance->model;
+              old_model->instances = g_list_remove (old_model->instances, instance);
+              g_free (instance);
+              instance = NULL;
+
+              /* Keep things clean, don't leave this pointers dangling - even temporarily */
+              element->assembly_model_instance = NULL;
+
+              if (old_model->instances == NULL)
+                {
+                  /* Assume unused, so unload */
+                  if (old_model->step_model != NULL)
+                    step_model_free (old_model->step_model);
+                  g_free (old_model);
+                  loaded_models = g_list_remove (loaded_models, old_model);
+                }
+            }
+        }
+
+      if (instance == NULL)
+        {
+          /* No model loaded yet */
+          model = NULL;
+
+          /* Look for prior usage of this model */
+          for (model_iter = loaded_models;
+               model_iter != NULL;
+               model_iter = g_list_next (model_iter))
+            {
+              struct assembly_model *possible_model;
+              possible_model = model_iter->data;
+              if (strcmp (possible_model->filename, model_filename) == 0)
+                {
+                  model = possible_model;
+                  break;
+                }
+            }
+
+          /* If we didn't find this model used already, add it to the list */
+          if (model == NULL)
+            {
+              model = g_new0 (struct assembly_model, 1);
+              model->filename = model_filename;
+              model->step_model = step_model_to_shape_master (model_filename);
+              loaded_models = g_list_append (loaded_models, model);
+            }
+          instance = g_new0 (struct assembly_model_instance, 1);
+          instance->model = model;
+          model->instances = g_list_append (model->instances, instance);
+          element->assembly_model_instance = instance;
+        }
+
+      cos_rot = cos (rotation * M_PI / 180.);
+      sin_rot = sin (rotation * M_PI / 180.);
+
+      // Rotation of part on board
+      // (NB: Y flipped from normal right handed convention)
+      //[cos -sin   0] [x] = [xcos - ysin]
+      //[sin  cos   0] [y]   [xsin + ycos]
+      //[  0    0   1] [z]   [z          ]
+
+      // Flip of part to backside of board
+      // [  1   0   0] [x] = [ x]
+      // [  0  -1   0] [y] = [-y]
+      // [  0   0  -1] [z] = [-z]
+
+
+      instance->name = NAMEONPCB_NAME (element);
+#ifdef REVERSED_PCB_CONTOURS
+      instance->ox =                     ( ox * cos_rot + oy * sin_rot);
+      instance->oy = -on_solder_negate * (-ox * sin_rot + oy * cos_rot);
+      instance->oz = -on_solder_negate * oz; /* <--- ????: -ve on on_solder_negative seems inconsistent w.r.t. others! */
+      instance->ax =                     ( ax * cos_rot + ay * sin_rot);
+      instance->ay = -on_solder_negate * (-ax * sin_rot + ay * cos_rot);
+      instance->az = -on_solder_negate * az;
+      instance->rx =                     ( rx * cos_rot + ry * sin_rot);
+      instance->ry = -on_solder_negate * (-rx * sin_rot + ry * cos_rot);
+      instance->rz = -on_solder_negate * rz;
+#else
+      instance->ox =                     ( ox * cos_rot + oy * sin_rot);
+      instance->oy =  on_solder_negate * (-ox * sin_rot + oy * cos_rot);
+      instance->oz =  on_solder_negate * oz;
+      instance->ax =                     ( ax * cos_rot + ay * sin_rot);
+      instance->ay =  on_solder_negate * (-ax * sin_rot + ay * cos_rot);
+      instance->az =  on_solder_negate * az;
+      instance->rx =                     ( rx * cos_rot + ry * sin_rot);
+      instance->ry =  on_solder_negate * (-rx * sin_rot + ry * cos_rot);
+      instance->rz =  on_solder_negate * rz;
+#endif
+
+      instance->ox += COORD_TO_STEP_X (PCB, element->MarkX);
+      instance->oy += COORD_TO_STEP_Y (PCB, element->MarkY);
+#ifdef REVERSED_PCB_CONTOURS
+      instance->oz += COORD_TO_STEP_Z (PCB, on_solder ? -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS : HACK_COPPER_THICKNESS);
+#else
+      instance->oz += COORD_TO_STEP_Z (PCB, on_solder_negate * (-HACK_BOARD_THICKNESS / 2 -HACK_COPPER_THICKNESS));
+#endif
+
+    }
+  END_LOOP;
+}
+
 static void
 step_do_export (HID_Attr_Val * options)
 {
@@ -328,6 +552,7 @@ step_do_export (HID_Attr_Val * options)
     models = g_list_append (models, model);
 
     instance = g_new0 (struct assembly_model_instance, 1);
+    instance->model = model;
     instance->name = "PCB";
     instance->ox = 0.0,  instance->oy = 0.0,  instance->oz = 0.0;
     instance->ax = 0.0,  instance->ay = 0.0,  instance->az = 1.0;
@@ -454,6 +679,7 @@ step_do_export (HID_Attr_Val * options)
               {
                 model = g_new0 (struct assembly_model, 1);
                 model->filename = model_filename;
+                model->step_model = NULL; /* We don't use this for assembly export */
                 models = g_list_append (models, model);
               }
 
@@ -472,6 +698,7 @@ step_do_export (HID_Attr_Val * options)
             // [  0   0  -1] [z] = [-z]
 
             instance = g_new0 (struct assembly_model_instance, 1);
+            instance->model = model;
             instance->name = NAMEONPCB_NAME (element);
 #ifdef REVERSED_PCB_CONTOURS
             instance->ox =                     ( ox * cos_rot + oy * sin_rot);
diff --git a/src/hid/step/step.h b/src/hid/step/step.h
index 50a01ab..47f3882 100644
--- a/src/hid/step/step.h
+++ b/src/hid/step/step.h
@@ -1,3 +1,4 @@
 extern HID step_hid;
 void step_init (HID *hid);
 void step_graphics_init (HID_DRAW *graphics);
+void step_load_models(Coord board_thickness);
diff --git a/src/hid/step/utils.cpp b/src/hid/step/utils.cpp
index 931bc75..caab465 100644
--- a/src/hid/step/utils.cpp
+++ b/src/hid/step/utils.cpp
@@ -49,10 +49,12 @@
 #  define DEBUG_PRODUCT_DEFINITION_SEARCH
 #  define DEBUG_CHILD_REMOVAL
 #  define DEBUG_PRODUCT_DEFINITION
+#  define DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
 #else
 #  undef DEBUG_PRODUCT_DEFINITION_SEARCH
 #  undef DEBUG_CHILD_REMOVAL
 #  undef DEBUG_PRODUCT_DEFINITION
+#  undef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
 #endif
 
 #include <glib.h>
@@ -62,7 +64,12 @@ void
 find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list, int start_after_id)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
-  int search_index = instance_list->GetIndex (mnode) + 1;
+  int search_index;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
 
   // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
   SdaiShape_definition_representation *sdr;
@@ -119,7 +126,12 @@ void
 find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, int start_after_id, const char *entityName)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
-  int search_index = instance_list->GetIndex (mnode) + 1;
+  int search_index;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
 
   SdaiAssembly_component_usage *acu;
   while (ENTITY_NULL != (acu = (SdaiAssembly_component_usage *)
@@ -152,7 +164,12 @@ static SdaiProduct_definition *
 find_pd_for_sr (InstMgr *instance_list, int start_after_id, SdaiShape_representation *target_sr)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
-  int search_index = instance_list->GetIndex (mnode) + 1;
+  int search_index;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
 
   // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
   SdaiShape_definition_representation *sdr;
@@ -178,7 +195,12 @@ void
 find_and_remove_child_pd_mi_rm_sr (InstMgr *instance_list, pd_list *pd_list, int start_after_id)
 {
   MgrNode * mnode = instance_list->FindFileId (start_after_id);
-  int search_index = instance_list->GetIndex (mnode) + 1;
+  int search_index;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
 
   SdaiMapped_item *mi;
   while (ENTITY_NULL != (mi = (SdaiMapped_item *)
@@ -268,3 +290,164 @@ find_axis2_placement_3d_in_sr (SdaiShape_representation *sr)
 
   return NULL;
 }
+
+void
+find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *rep_1)
+{
+  MgrNode * mnode = instance_list->FindFileId (start_after_id);
+  int search_index;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
+
+  // Loop over the instances of SHAPE_REPRESENTATION_RELATIONSHIP in the file
+  SdaiShape_representation_relationship *srr;
+  while (ENTITY_NULL != (srr = (SdaiShape_representation_relationship *)
+                               instance_list->GetApplication_instance ("Shape_representation_relationship", search_index)))
+    {
+      SdaiRepresentation *found_rep_1 = srr->rep_1_ ();
+#ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
+      SdaiRepresentation *found_rep_2 = srr->rep_2_ ();
+#endif
+
+      if (srr->IsComplex())
+        {
+          std::cout << "ERROR: Found a complex SRR when we were expecting a simplex" << std::endl;
+          return;
+        }
+
+      if (found_rep_1 == rep_1)
+        srr_list->push_back (srr);
+
+#ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
+      std::cout << "Got a SRR, #" << srr->StepFileId ();
+      std::cout << " rep_1 = #" << found_rep_1->StepFileId ();
+      std::cout << " rep_2 = #" << found_rep_2->StepFileId ();
+      std::cout << std::endl;
+#endif
+
+      int id = srr->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+}
+
+void
+find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *rep_1)
+{
+  MgrNode * mnode = instance_list->FindFileId (start_after_id);
+  int search_index;
+  SDAI_Application_instance *entity;
+
+  if (mnode == NULL)
+    search_index = 0;
+  else
+    search_index = instance_list->GetIndex (mnode) + 1;
+
+  while (ENTITY_NULL != (entity = instance_list->GetApplication_instance ("Representation_relationship", search_index)))
+    {
+      STEPcomplex *stepcomplex;
+      STEPattribute *attr;
+      SdaiRepresentation *found_rep_1 = NULL;
+      SdaiRepresentation *found_rep_2 = NULL;
+      SdaiTransformation *transform = NULL;
+      SdaiItem_defined_transformation *idt = NULL;
+
+      bool found_srr = false;
+      bool found_rrwt = false;
+
+      if (!entity->IsComplex())
+        {
+          std::cout << "WARNING: Found a non-complex Representation_relationship when looking for SRR + RRWT" << std::endl;
+          continue;
+        }
+
+      stepcomplex = dynamic_cast<STEPcomplex *>(entity)->head;
+
+      /* Assume the first is always the RR */
+      stepcomplex->ResetAttributes ();
+      while ((attr = stepcomplex->NextAttribute()) != NULL) {
+          if (!strcmp (attr->Name (), "rep_1"))
+            found_rep_1 = dynamic_cast<SdaiRepresentation *>(attr->Entity ());
+          if (!strcmp (attr->Name (), "rep_2"))
+            found_rep_2 = dynamic_cast<SdaiRepresentation *>(attr->Entity ());
+      }
+
+      while (stepcomplex) {
+          if (stepcomplex->EntityName() == NULL)
+            {
+              std::cout << "ERROR: NULL whilst traversing complex" << std::endl;
+              return;
+            }
+          else if (!strcmp (stepcomplex->EntityName (), "Shape_Representation_Relationship"))
+            {
+              found_srr = true;
+            }
+          else if (!strcmp (stepcomplex->EntityName (), "Representation_Relationship_With_Transformation"))
+            {
+              found_rrwt = true;
+
+              stepcomplex->ResetAttributes ();
+              while ((attr = stepcomplex->NextAttribute()) != NULL)
+                {
+                  if (!strcmp (attr->Name (), "transformation_operator"))
+                    {
+                      transform = dynamic_cast<SdaiTransformation *>(attr->Select ());
+                      idt = *transform;
+                    }
+                }
+            }
+          stepcomplex = stepcomplex->sc;
+      }
+
+#ifdef DEBUG_SHAPE_REPRESENTATION_RELATIONSHIP_SEARCH
+      std::cout << "GOT A complex, #" << entity->StepFileId () << ":" << std::endl;
+      std::cout << "    RR";
+
+      if (found_rep_1 != NULL)
+        std::cout << " rep_1 = #" << found_rep_1->StepFileId ();
+      else
+        std::cout << " rep_1 = NIL";
+
+      if (found_rep_2 != NULL)
+        std::cout << " rep_2 = #" << found_rep_2->StepFileId ();
+      else
+        std::cout << " rep_2 = NIL";
+
+      std::cout << std::endl;
+
+      if (found_srr)
+        std::cout << "    SRR" << std::endl;
+
+      if (found_rrwt)
+        {
+          std::cout << "    RRWT, transform = ";
+          if (transform != NULL)
+            std::cout << "#" << idt->StepFileId () << std::endl;
+          else
+            std::cout << "NIL" << std::endl;
+        }
+
+      std::cout << std::endl;
+#endif
+
+      if (found_rep_1 == rep_1 &&
+          found_srr &&
+          found_rrwt)
+        {
+          srr_rrwt *item = new srr_rrwt;
+
+          item->rep_2 = found_rep_2;
+          item->idt = idt;
+
+          srr_rrwt_list->push_back (item);
+        }
+
+      int id = entity->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+
+}
diff --git a/src/hid/step/utils.h b/src/hid/step/utils.h
index 06f6143..1ae2f18 100644
--- a/src/hid/step/utils.h
+++ b/src/hid/step/utils.h
@@ -26,7 +26,14 @@
  */
 
 
+typedef struct srr_rrwt {
+  SdaiRepresentation *rep_2;
+  SdaiItem_defined_transformation *idt;
+} srr_rrwt;
+
 typedef std::list<SdaiProduct_definition *> pd_list;
+typedef std::list<SdaiShape_representation_relationship *> srr_list;
+typedef std::list<srr_rrwt *> srr_rrwt_list;
 
 
 void find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list, int start_after_id);
@@ -42,3 +49,6 @@ SdaiShape_definition_representation *find_sdr_for_pd (InstMgr *instance_list, Sd
 SdaiShape_representation *find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd);
 
 SdaiAxis2_placement_3d *find_axis2_placement_3d_in_sr (SdaiShape_representation *sr);
+
+void find_all_srr_with_rep_1( InstMgr *instance_list, srr_list *srr_list, int start_after_id, SdaiRepresentation *rep_1);
+void find_all_srr_rrwt_with_rep_1( InstMgr *instance_list, srr_rrwt_list *srr_rrwt_list, int start_after_id, SdaiRepresentation *rep_1);
diff --git a/src/polygon1.c b/src/polygon1.c
index 24e9dfa..3d0615c 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -4742,7 +4742,7 @@ line_segments_can_merge (VNODE *s1, VNODE *s2)
 {
   Vector p1, p2;
 
-  assert (EDGE_FOWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
+  assert (EDGE_FORWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
   Vsub2 (p1, EDGE_BACKWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s1)->point); /* See assert above for first arg */
   Vsub2 (p2, EDGE_FORWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s2)->point);
 
diff --git a/src/set.c b/src/set.c
index 03b452a..46938eb 100644
--- a/src/set.c
+++ b/src/set.c
@@ -345,7 +345,7 @@ SetRouteStyle (char *name)
 void
 SetLocalRef (Coord X, Coord Y, bool Showing)
 {
-  static MarkType old;
+  static _MarkType old;
   static int count = 0;
 
   if (Showing)
