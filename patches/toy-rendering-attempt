Bottom: 61e2445ecfa2a5acafb6d39c09cbe02b55700dc4
Top:    27ec30fa47f5ea77fc549c375956b28e04d9f8c3
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 14:59:08 +0000

Toy rendering attempt


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c3d25a..6e3d281 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -484,6 +484,8 @@ LIBSTEP_SRCS = \
 	hid/step/step.h \
 	hid/step/assembly.cpp \
 	hid/step/assembly.h \
+	hid/step/model.cpp \
+	hid/step/model.h \
 	hid/step/utils.cpp \
 	hid/step/utils.h \
 	hid/step/step_writer.c \
diff --git a/src/action.c b/src/action.c
index 4e8ceb7..12ca76d 100644
--- a/src/action.c
+++ b/src/action.c
@@ -91,6 +91,8 @@
 #include <sys/wait.h>
 #endif
 
+#define DEBUG
+
 /* ---------------------------------------------------------------------------
  * some local types
  */
diff --git a/src/data.c b/src/data.c
index 9d6588c..99df27a 100644
--- a/src/data.c
+++ b/src/data.c
@@ -41,7 +41,7 @@
  */
 
 CrosshairType Crosshair;	/* information about cursor settings */
-MarkType Marked;		/* a cross-hair mark */
+_MarkType Marked;		/* a cross-hair mark */
 OutputType Output;		/* some widgets ... used for drawing */
 PCBType *PCB;			/* pointer to layout struct */
 
diff --git a/src/data.h b/src/data.h
index 89d9b87..1006a61 100644
--- a/src/data.h
+++ b/src/data.h
@@ -39,7 +39,7 @@
 
 extern CrosshairType Crosshair;
 
-extern MarkType Marked;
+extern _MarkType Marked;
 
 extern OutputType Output;
 
diff --git a/src/global.h b/src/global.h
index b8efc7b..2186c0f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -609,7 +609,7 @@ typedef struct
 {
   bool status;
   Coord X, Y;
-} MarkType;
+} _MarkType;
 
 /* ---------------------------------------------------------------------------
  * our resources
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index e7a2720..771e803 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -153,11 +153,14 @@ float colors[12][3] = {{1., 0., 0.},
                        {0.5, 1., 1.}};
 
 
-#define CIRC_SEGS 64
+#define CIRC_SEGS_D 64.0
 
 static void
 draw_quad_edge (edge_ref e, void *data)
 {
+  double x1, y1, z1;
+  double x2, y2, z2;
+
 #if 0
   int id = ID(e) % 12;
 
@@ -166,6 +169,14 @@ draw_quad_edge (edge_ref e, void *data)
   glColor3f (1., 1., 1.);
 #endif
 
+  x1 = ((vertex3d *)ODATA(e))->x;
+  y1 = ((vertex3d *)ODATA(e))->y;
+  z1 = ((vertex3d *)ODATA(e))->z;
+
+  x2 = ((vertex3d *)DDATA(e))->x;
+  y2 = ((vertex3d *)DDATA(e))->y;
+  z2 = ((vertex3d *)DDATA(e))->z;
+
   if (UNDIR_DATA(e) != NULL)
     {
       edge_info *info = UNDIR_DATA(e);
@@ -174,39 +185,147 @@ draw_quad_edge (edge_ref e, void *data)
       if (info->is_round)
         {
           int i;
+          double cx, cy, cz;
+          double nx, ny, nz;
+          double refx, refy, refz;
+          double endx, endy, endz;
+          double ortx, orty, ortz;
+          double cosa;
+          double sina;
+          double recip_length;
+          double da;
+          int segs;
+          double angle_step;
+
+          cx = ((edge_info *)UNDIR_DATA(e))->cx;
+          cy = ((edge_info *)UNDIR_DATA(e))->cy;
+          cz = ((edge_info *)UNDIR_DATA(e))->cz;
+
+          nx = ((edge_info *)UNDIR_DATA(e))->nx;
+          ny = ((edge_info *)UNDIR_DATA(e))->ny;
+          nz = ((edge_info *)UNDIR_DATA(e))->nz;
+
+          /* STEP MAY ACTUALLY SPECIFY A DIFFERENT REF DIRECTION, BUT FOR NOW, LETS ASSUME IT POINTS
+           * TOWARDS THE FIRST POINT. (We don't record the STEP ref direction in our data-structure at the moment).
+           */
+          refx = x1 - cx;
+          refy = y1 - cy;
+          refz = z1 - cz;
+
+          /* Normalise refx */
+          recip_length = 1. / hypot (hypot (refx, refy), refz);
+          refx *= recip_length;
+          refy *= recip_length;
+          refz *= recip_length;
+
+          endx = x2 - cx;
+          endy = y2 - cy;
+          endz = z2 - cz;
+
+          /* Normalise endx */
+          recip_length = 1. / hypot (hypot (endx, endy), endz);
+          endx *= recip_length;
+          endy *= recip_length;
+          endz *= recip_length;
+
+          /* ref cross normal */
+          /* ort will be orthogonal to normal and ref vector */
+          ortx = ny * refz - nz * refy;
+          orty = nz * refx - nx * refz;
+          ortz = nx * refy - ny * refx;
+
+          /* Cosine is dot product of ref (normalised) and end (normalised) */
+          cosa = refx * endx + refy * endy + refz * endz; // cos (phi)
+          /* Sine is dot product of ort (normalised) and end (normalised) */
+          sina = ortx * endx + orty * endy + ortz * endz; // sin (phi) = cos (phi - 90)
+
+          if (x1 == x2 &&
+              y1 == y2 &&
+              z1 == z2)
+            {
+              da = 2.0 * M_PI;
+            }
+          else
+            {
+              /* Delta angled */
+              da = atan2 (sina, cosa);
+
+              if (da < 0.0)
+                da += 2.0 * M_PI;
+            }
+
+#if 0
+          printf ("(%f, %f, %f)  (%f, %f, %f)\n", x1, y1, z1, x2, y2, z2);
+          printf ("ref (%f, %f, %f)\n", refx, refy, refz);
+          printf ("end (%f, %f, %f)\n", endx, endy, endz);
+          printf ("ort (%f, %f, %f)\n", ortx, orty, ortz);
+          printf ("n (%f, %f, %f)\n", nx, ny, nz);
+          printf ("cosa %f, sina %f\n", cosa, sina);
+          printf ("Got an arc with angle %f\n", da * 180. / M_PI);
+#endif
+
+          /* Scale up ref and ort to the actual vector length */
+          refx *= info->radius;
+          refy *= info->radius;
+          refz *= info->radius;
+
+          ortx *= info->radius;
+          orty *= info->radius;
+          ortz *= info->radius;
+
+          /* XXX: NEED TO COMPUTE WHICH SEGMENT OF THE CURVE TO ACTUALLY DRAW! */
+          segs = CIRC_SEGS_D * da / (2.0 * M_PI);
+          segs = MAX(segs, 1);
+          angle_step = da / (double)segs;
+
           glBegin (GL_LINES);
-          for (i = 0; i < CIRC_SEGS; i++)
+
+          for (i = 0; i < segs; i++)
             {
-              /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
-              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
-                          STEP_Z_TO_COORD (PCB, info->cz));
+              cosa = cos (i * angle_step);
+              sina = sin (i * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
+
+              cosa = cos ((i + 1) * angle_step);
+              sina = sin ((i + 1) * angle_step);
+              glVertex3f (STEP_X_TO_COORD (PCB, info->cx + refx * cosa + ortx * sina),
+                          STEP_Y_TO_COORD (PCB, info->cy + refy * cosa + orty * sina),
+                          STEP_Z_TO_COORD (PCB, info->cz + refz * cosa + ortz * sina));
             }
+
           glEnd ();
+
           return;
         }
     }
 
   glBegin (GL_LINES);
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
-  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
-              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
-              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, x1),
+              STEP_Y_TO_COORD (PCB, y1),
+              STEP_X_TO_COORD (PCB, z1));
+  glVertex3f (STEP_X_TO_COORD (PCB, x2),
+              STEP_Y_TO_COORD (PCB, y2),
+              STEP_X_TO_COORD (PCB, z2));
   glEnd ();
 }
 
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
+void
+object3d_draw (object3d *object)
 {
   g_return_if_fail (object->edges != NULL);
 
 //  quad_enum ((edge_ref)object->edges->data, draw_quad_edge, NULL);
+//  printf ("BEGIN DRAW...\n");
   g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
+//  printf ("....ENDED\n");
+}
+
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  object3d_draw (object);
 }
 
 void
@@ -673,7 +792,7 @@ object3d_from_contours (POLYAREA *contours,
         }
 
 #ifndef NDEBUG
-      ct = contour;
+      ct = outer_contour;
       start_of_ct = 0;
       offset_in_ct = 0;
       ct_npoints = get_contour_npoints (ct);
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index b288cf2..3d228f6 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -9,6 +9,7 @@ typedef struct {
 } object3d;
 
 void object3d_test_init (void);
+void object3d_draw (object3d *object);
 void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index af391dd..4c2d39d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -123,6 +123,7 @@ static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_
 
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
+object3d *step_read_test = NULL;
 
 
 /* Coordinate conversions */
@@ -1127,6 +1128,16 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step", &step_read_test);
+  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/object3d_test.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/step_interlayer_manual.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/DPAK.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Inductor_R1.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Capacitor_100V_10uF.step", &step_read_test);
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/", &step_read_test);
 }
 
 void
@@ -2729,7 +2740,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-//  object3d_draw_debug ();
+  //object3d_draw_debug ();
+  if (step_read_test != NULL)
+    object3d_draw (step_read_test);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c9eb567..3c7eae3 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -2600,7 +2600,7 @@ idle_proc (XtPointer dummy)
 
   {
     static int c_x = -2, c_y = -2;
-    static MarkType saved_mark;
+    static _MarkType saved_mark;
     static const Unit *old_grid_unit = NULL;
     if (crosshair_x != c_x || crosshair_y != c_y
 	|| Settings.grid_unit != old_grid_unit
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
new file mode 100644
index 0000000..7828fb9
--- /dev/null
+++ b/src/hid/step/model.cpp
@@ -0,0 +1,603 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+extern "C" {
+#include <glib.h>
+/* XXX: Sdai and PCB clash.. both define MarkType */
+#include "global.h"
+#include "../hid/common/appearance.h"
+#include "../hid/common/step_id.h"
+#include "../hid/common/quad.h"
+#include "../hid/common/edge3d.h"
+#include "../hid/common/contour3d.h"
+#include "../hid/common/face3d.h"
+#include "../hid/common/vertex3d.h"
+#include "../hid/common/object3d.h"
+}
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+extern "C" {
+#include "model.h"
+}
+
+
+typedef std::list<SDAI_Application_instance *> ai_list;
+
+
+SdaiProduct_definition *
+read_model_from_file (Registry *registry,
+                        InstMgr *instance_list,
+                        const char *filename)
+{
+  STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+
+  sfile.ReadExchangeFile (filename);
+
+  Severity severity = sfile.Error().severity();
+  if (severity != SEVERITY_NULL)
+    {
+      sfile.Error().PrintContents (std::cout);
+      std::cout << "WARNING: Error reading from file '" << filename << "'" << std::endl;
+//      return NULL;
+#warning HANDLE OTHER ERRORS BETTER?
+    }
+
+  pd_list pd_list;
+
+  // Find all PRODUCT_DEFINITION entities with a SHAPE_DEFINITION_REPRESETNATION
+  find_all_pd_with_sdr (instance_list, &pd_list, 1);
+
+  /*  Try to determine the root product */
+  find_and_remove_child_pd (instance_list, &pd_list, 1, "Next_assembly_usage_occurrence"); // Remove any PD which are children of another via NAUO
+  find_and_remove_child_pd (instance_list, &pd_list, 1, "Assembly_component_usage");       // Remove any PD which are children of another via ACU
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+  std::cout << "Hopefully left with the root product definition" << std::endl;
+  for (pd_list::iterator iter = pd_list.begin(); iter != pd_list.end(); iter++)
+    std::cout << "Product definition list item #" << (*iter)->StepFileId () << std::endl;
+  std::cout << std::endl;
+#endif
+
+  // If we didn't find a suitable PD, give up now
+  if (pd_list.size() == 0)
+    {
+      std::cout << "ERROR: Did not find a PRODUCT_DEFINITION (with associated SHAPE_DEFINITION_REPRESENTATION)" << std::endl;
+      return NULL;
+    }
+
+  if (pd_list.size() > 1)
+    std::cout << "WARNING: Found more than one PRODUCT_DEFINITION that might be the root" << std::endl;
+
+  // Use the first PD meeting the criterion. Hopefully there should just be one, but if not, we pick the first.
+  return *pd_list.begin();
+}
+
+typedef std::list<SdaiManifold_solid_brep *> msb_list;
+
+void
+find_manifold_solid_brep (Registry *registry,
+                          InstMgr *instance_list,
+                          SdaiShape_representation *sr,
+                          msb_list *msb_list)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Manifold_Solid_Brep") == 0)
+        msb_list->push_back ((SdaiManifold_solid_brep *)node);
+
+      iter = iter->NextNode ();
+    }
+}
+
+static void process_edges (GHashTable *edges_hash_set, object3d *object)
+{
+  GHashTableIter iter;
+  SdaiEdge *edge;
+  edge_ref our_edge;
+  vertex3d *vertex;
+  double x1, y1, z1;
+  double x2, y2, z2;
+  bool orientation;
+  gpointer foo;
+  int bar;
+  bool kludge;
+
+  g_hash_table_iter_init (&iter, edges_hash_set);
+  while (g_hash_table_iter_next (&iter, (void **)&edge, &foo))
+    {
+      bar = GPOINTER_TO_INT (foo);
+      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+        {
+          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+          continue;
+        }
+
+      orientation = (bar & 1) != 0;
+      kludge = (bar & 2) != 0;
+
+      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+      //     In practice, edge should point to an EDGE_CURVE sub-type
+      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+          continue;
+        }
+
+      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+        {
+          /* HAPPY WITH THIS TYPE */
+        }
+      else
+        {
+          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+          continue;
+        }
+
+      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+      x1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ())->value;
+      y1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z1 = ((RealNode *)edge_start_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+      x2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ())->value;
+      y2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ())->value;
+      z2 = ((RealNode *)edge_end_cp->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+#if 0
+      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+              edge->StepFileId (), x1, y1, z1, x2, y2, z2);
+#endif
+
+      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+        {
+          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+          SdaiCurve *curve = ec->edge_geometry_ ();
+          bool same_sense = ec->same_sense_ ();
+
+#if 0
+          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+#endif
+
+          if (strcmp (curve->EntityName (), "Line") == 0)
+            {
+              our_edge = make_edge ();
+              UNDIR_DATA (our_edge) = make_edge_info ();
+              object3d_add_edge (object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//              continue;
+            }
+          else if (strcmp (curve->EntityName (), "Circle") == 0)
+            {
+              SdaiCircle *circle = (SdaiCircle *)curve;
+              double cx = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ())->value;
+              double cy = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ())->value;
+              double cz = ((RealNode *)circle->position_ ()->location_ ()->coordinates_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+              double nx = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ())->value;
+              double ny = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ())->value;
+              double nz = ((RealNode *)circle->position_ ()->axis_ ()->direction_ratios_ ()->GetHead ()->NextNode ()->NextNode ())->value;
+
+              double radius = circle->radius_();
+
+              edge_info *info;
+
+              our_edge = make_edge ();
+              info = make_edge_info ();
+              if (!kludge) //(same_sense)
+                {
+                  edge_info_set_round (info, cx, cy, cz, nx, ny, nz, radius);
+                }
+              else
+                {
+                  printf ("URM................\n");
+                  edge_info_set_round (info, cx, cy, cz, -nx, -ny, -nz, radius);
+                }
+              UNDIR_DATA (our_edge) = info;
+              object3d_add_edge (object, our_edge);
+              vertex = make_vertex3d (x1, y1, z1);
+              ODATA(our_edge) = vertex;
+              vertex = make_vertex3d (x2, y2, z2);
+              DDATA(our_edge) = vertex;
+
+//              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//              continue;
+            }
+          else
+            {
+              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+              // XXX: Various derived types of the above, e.g.:
+              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+              continue;
+            }
+
+        }
+      else
+        {
+          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+          continue;
+        }
+    }
+}
+
+extern "C" struct step_model *
+step_model_to_shape_master (const char *filename, object3d **out_object)
+{
+  object3d *object;
+  edge_ref edge;
+  vertex3d *vertex;
+  GHashTable *edges_hash_set;
+  bool on_plane;
+
+  object = make_object3d ((char *)"Test");
+
+  Registry * registry = new Registry (SchemaInit);
+  InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
+
+  // Increment FileId so entities start at #1 instead of #0.
+  instance_list->NextFileId();
+
+  SdaiProduct_definition *pd = read_model_from_file (registry, instance_list, filename);
+  if (pd == NULL)
+    {
+      printf ("ERROR Loading STEP model from file '%s'", filename);
+      return NULL;
+    }
+
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, pd);
+  SdaiShape_representation *sr = (SdaiShape_representation *)sdr->used_representation_ ();
+
+  // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), return - we are already in the correct form
+  if (strcmp (sr->EntityName (), "Advanced_Brep_Shape_Representation") != 0)
+    {
+      printf ("step_model_to_shape_master: Looking for Advanced_Brep_Shape_Representation, but found %s (which we don't support yet)\n", sr->EntityName ());
+      return NULL;
+    }
+
+  SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+  if (part_origin == NULL)
+    std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
+
+  msb_list msb_list;
+  find_manifold_solid_brep (registry, instance_list, sr, &msb_list);
+
+  for (msb_list::iterator iter = msb_list.begin (); iter != msb_list.end (); iter++)
+    {
+      std::cout << "Found MANIFOLD_SOLID_BREP; processing" << std::endl;
+      SdaiClosed_shell *cs = (*iter)->outer_ ();
+
+      std::cout << "Closed shell is " << cs << std::endl;
+
+      /* NB: NULLs give g_direct_hash and g_direct_equal */
+      edges_hash_set = g_hash_table_new (NULL, NULL);
+
+      for (SingleLinkNode *iter = cs->cfs_faces_ ()->GetHead ();
+           iter != NULL;
+           iter = iter->NextNode ())
+        {
+          SdaiFace *face = (SdaiFace *)((EntityNode *)iter)->node;
+
+          /* XXX: Do we look for specific types of face at this point? (Expect ADVANCED_FACE usually?) */
+          if (strcmp (face->EntityName (), "Advanced_Face") != 0)
+            {
+              printf ("WARNING: Found face of type %s (which we don't support yet)\n", face->EntityName ());
+              continue;
+            }
+
+          /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
+          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
+          SdaiFace_surface *fs = (SdaiFace_surface *) face;
+
+          SdaiSurface *surface = fs->face_geometry_ ();
+
+#if 0
+          std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
+#endif
+
+          on_plane = false;
+
+          if (surface->IsComplex ())
+            {
+              printf ("WARNING: Found a STEP Complex entity for our surface (which we don't support yet). Probably a B_SPLINE surface?\n");
+            }
+          else if (strcmp (surface->EntityName (), "Plane") == 0)
+            {
+              on_plane = true;
+              printf ("WARNING: planar surfaces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
+            {
+              printf ("WARNING: cylindrical suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
+            {
+              printf ("WARNING: toroidal suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
+            {
+              printf ("WARNING: spherical surfaces are not supported yet\n");
+            }
+          else
+            {
+              printf ("ERROR: Found an unknown surface type (which we obviously don't support). Surface name is %s\n", surface->EntityName ());
+            }
+
+          for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
+               iter != NULL;
+               iter = iter->NextNode ())
+            {
+              SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
+
+
+              bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
+
+#if 0
+              if (is_outer_bound)
+                std::cout << "  Outer bounds of face include ";
+              else
+                std::cout << "  Bounds of face include ";
+#endif
+
+              // NB: SdaiFace_bound has SdaiLoop *bound_ (), and Boolean orientation_ ()
+              // NB: SdaiLoop is a SdaiTopological_representation_item, which is a SdaiRepresentation_item, which has a name_ ().
+              // NB: Expect bounds_ () may return a SUBTYPE of SdaiLoop, such as, but not necessarily: SdaiEdge_loop
+              SdaiLoop *loop = fb->bound_ ();
+
+#if 0
+              std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
+#endif
+              if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
+                {
+                  SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
+
+                  // NB: EDGE_LOOP uses multiple inheritance from LOOP and PATH, thus needs special handling to
+                  //     access the elements belonging to PATH, such as edge_list ...
+                  //     (Not sure if this is a bug in STEPcode, as the SdaiEdge_loop class DOES define
+                  //     an accessor edge_list_ (), yet it appears to return an empty aggregate.
+
+                  char path_entity_name[] = "Path"; /* SdaiApplication_instance::GetMiEntity() should take const char *, but doesn't */
+                  SdaiPath *path = (SdaiPath *)el->GetMiEntity (path_entity_name);
+
+                  for (SingleLinkNode *iter = path->edge_list_ ()->GetHead ();
+                       iter != NULL;
+                       iter = iter->NextNode ())
+                    {
+                      SdaiOriented_edge *oe = (SdaiOriented_edge *)((EntityNode *)iter)->node;
+                      /* XXX: Will it _always?_ be an SdaiOriented_edge? */
+
+                      // NB: Stepcode does not compute derived attributes, so we need to look at the EDGE
+                      //     "edge_element" referred to by the ORIENTED_EDGE, to find the start and end vertices
+
+                      SdaiEdge *edge = oe->edge_element_ ();
+                      bool orientation = oe->orientation_ ();
+
+                      if (on_plane)
+                        {
+                          if (fs->same_sense_())
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                          else
+                            {
+                              if (orientation)
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                              else
+                                g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                            }
+                        }
+                      else
+                        {
+                          g_hash_table_insert (edges_hash_set, edge, GINT_TO_POINTER(1));
+                        }
+
+
+                      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+                          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+                        {
+                          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+                          continue;
+                        }
+
+                      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+                      //     In practice, edge should point to an EDGE_CURVE sub-type
+                      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+                      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+                      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+                      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+                      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+                      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+                          continue;
+                        }
+
+                      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+                          continue;
+                        }
+
+                      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+                      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+#if 0
+                      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+                              edge->StepFileId (),
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value);
+
+                      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+                        {
+                          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+                          SdaiCurve *curve = ec->edge_geometry_ ();
+                          bool same_sense = ec->same_sense_ ();
+
+                          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+
+                          if (strcmp (curve->EntityName (), "Line") == 0)
+                            {
+//                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+//                              continue;
+                            }
+                          else if (strcmp (curve->EntityName (), "Circle") == 0)
+                            {
+//                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+//                              continue;
+                            }
+                          else
+                            {
+                              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+                              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+                              // XXX: Various derived types of the above, e.g.:
+                              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+                              continue;
+                            }
+
+                        }
+                      else
+                        {
+                          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+                          continue;
+                        }
+#endif
+
+                    }
+
+                }
+              else
+                {
+                  printf ("WARNING: Face is bounded by an unhandled loop type (%s)\n", loop->EntityName ());
+                  continue;
+                }
+            }
+
+        }
+
+        process_edges (edges_hash_set, object);
+
+        /* Deal with edges hash set */
+        g_hash_table_destroy (edges_hash_set);
+    }
+
+  delete instance_list;
+  delete registry;
+
+  *out_object = object;
+
+  return NULL;
+}
+
+/* Geometry surface and face types encountered so far..
+
+Toroidal_surface     Circle (x5)
+Toroidal_surface     Circle (x4)
+Toroidal_surface     Circle (x3) + B_Spline_Curve_With_Knots
+
+Cylindrical_surface  Circle + Line + B_Spline_Curve_With_Knots
+Cylindrical_surface  Circle + Line
+
+Plane                Circle (xn) + Line (xn) + B_Spline_Curve_With_Knots
+
+*/
diff --git a/src/hid/step/model.h b/src/hid/step/model.h
new file mode 100644
index 0000000..707c2bb
--- /dev/null
+++ b/src/hid/step/model.h
@@ -0,0 +1,23 @@
+
+struct step_model_instance {
+  double x;
+  double y;
+  double rotation;
+};
+
+
+struct step_model {
+  const char *filename;
+  GList *instances;
+  double ox;
+  double oy;
+  double oz;
+  double ax;
+  double ay;
+  double az;
+  double rx;
+  double ry;
+  double rz;
+};
+
+struct step_model *step_model_to_shape_master (const char *filename, object3d **out_object);
diff --git a/src/polygon1.c b/src/polygon1.c
index 24e9dfa..3d0615c 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -4742,7 +4742,7 @@ line_segments_can_merge (VNODE *s1, VNODE *s2)
 {
   Vector p1, p2;
 
-  assert (EDGE_FOWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
+  assert (EDGE_FORWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
   Vsub2 (p1, EDGE_BACKWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s1)->point); /* See assert above for first arg */
   Vsub2 (p2, EDGE_FORWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s2)->point);
 
diff --git a/src/set.c b/src/set.c
index 03b452a..46938eb 100644
--- a/src/set.c
+++ b/src/set.c
@@ -345,7 +345,7 @@ SetRouteStyle (char *name)
 void
 SetLocalRef (Coord X, Coord Y, bool Showing)
 {
-  static MarkType old;
+  static _MarkType old;
   static int count = 0;
 
   if (Showing)
