Bottom: cd8de61f7908ff62a72e0be2e14c3e23f8488887
Top:    a4e7034b981f40cf05cfbf74a1be2bc9cc1ca511
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-04-22 23:34:23 +0100

Toy rendering attempt


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 38992a1..d1581d6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -476,7 +476,11 @@ LIBSTEP_SRCS = \
 	hid/step/step.c \
 	hid/step/step.h \
 	hid/step/assembly.cpp \
-	hid/step/assembly.h
+	hid/step/assembly.h \
+	hid/step/model.cpp \
+	hid/step/model.h \
+	hid/step/utils.cpp \
+	hid/step/utils.h
 libstep_a_SOURCES = ${LIBSTEP_SRCS} hid/step/step_lists.h
 
 pcb_LDFLAGS = \
diff --git a/src/hid/step/assembly.cpp b/src/hid/step/assembly.cpp
index dbbbdaf..4b0e407 100644
--- a/src/hid/step/assembly.cpp
+++ b/src/hid/step/assembly.cpp
@@ -75,6 +75,8 @@
 
 #include <SdaiAUTOMOTIVE_DESIGN.h>
 
+#include "utils.h"
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
@@ -503,144 +505,6 @@ DefaultAxis (Registry *registry, InstMgr *instance_list)
 }
 
 
-typedef std::list<SdaiProduct_definition *> pd_list;
-
-
-void
-find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list)
-{
-  int search_index = 0;
-
-  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
-  SdaiShape_definition_representation *sdr;
-  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
-                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
-    {
-      SdaiRepresented_definition *sdr_definition = sdr->definition_ ();
-      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr_definition);
-      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
-
-      pd_list->push_back (pd);
-
-#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
-      STEPentity *sdr_used_representation = sdr->used_representation_ ();
-      SdaiProduct_definition_formation *pdf = pd->formation_ ();
-      SdaiProduct *p = pdf->of_product_ ();
-
-      std::cout << "Got a SDR, #" << sdr->StepFileId ();
-      std::cout << " used_representation (sr or descendant) = #" << sdr_used_representation->StepFileId ();
-      std::cout << " definition (pds) = #" << pds->StepFileId ();
-      std::cout << " pds->definition (pd) = #" << pd->StepFileId ();
-      std::cout << " pd->formation (pdf) = #" << pdf->StepFileId ();
-      std::cout << " pdf->product (p) = #" << p->StepFileId ();
-      std::cout << std::endl;
-      std::cout << "Product id = " << p->id_ ().c_str () << " name = " << p->name_ ().c_str ();
-      std::cout << std::endl;
-#endif
-
-#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
-      SdaiShape_representation *sr = (SdaiShape_representation *)sdr_used_representation;
-
-      std::cout << "SR is actually of type " << ((STEPentity *)sr)->EntityName () << std::endl;
-      std::cout << std::endl;
-#endif
-
-      int id = sdr->StepFileId ();
-      MgrNode * mnode = instance_list->FindFileId (id);
-      search_index = instance_list->GetIndex (mnode) + 1;
-    }
-}
-
-/* entityName should be the name of entity Assembly_component_usage or one of its subtypes
- * typically this will be "Assembly_component_usage" or "Next_assembly_usage_occurance"
- */
-void
-find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, const char *entityName)
-{
-  int search_index = 0;
-
-  SdaiAssembly_component_usage *acu;
-  while (ENTITY_NULL != (acu = (SdaiAssembly_component_usage *)
-                               instance_list->GetApplication_instance (entityName, search_index)))
-    {
-      SdaiProduct_definition *related_pd = acu->related_product_definition_ ();
-
-#ifdef DEBUG_CHILD_REMOVAL
-      SdaiProduct_definition *relating_pd = acu->relating_product_definition_ ();
-
-      std::cout << "Product " << related_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
-      std::cout << " is a child of " << relating_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
-      std::cout << ".. removing it from list of possible root products";
-      std::cout << std::endl;
-#endif
-
-      /* Remove related_pd from the list of viable product definitions */
-      pd_list->remove (related_pd);
-
-      int id = acu->StepFileId ();
-      MgrNode * mnode = instance_list->FindFileId (id);
-      search_index = instance_list->GetIndex (mnode) + 1;
-    }
-#ifdef DEBUG_CHILD_REMOVAL
-  std::cout << std::endl;
-#endif
-}
-
-
-SdaiShape_definition_representation *
-find_sdr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
-{
-  int search_index = 0;
-
-  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
-  SdaiShape_definition_representation *sdr;
-  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
-                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
-    {
-      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr->definition_ ());
-      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
-
-      /* Return the SHAPE_REPRESETATION (or subclass) associated with the first SHAPE_DEFINITION_REPRESENTATION for the required PRODUCT_DEFINITION */
-      if (pd == target_pd)
-        return sdr;
-//        return (SdaiShape_representation *)sdr->used_representation_ ();
-
-      int id = sdr->StepFileId ();
-      MgrNode * mnode = instance_list->FindFileId (id);
-      search_index = instance_list->GetIndex (mnode) + 1;
-    }
-
-  return NULL;
-}
-
-
-SdaiShape_representation *
-find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
-{
-  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, target_pd);
-  return (SdaiShape_representation *)sdr->used_representation_ ();
-}
-
-
-SdaiAxis2_placement_3d *
-find_axis2_placement_3d_in_sr (SdaiShape_representation *sr)
-{
-  SingleLinkNode *iter = sr->items_ ()->GetHead ();
-
-  while (iter != NULL)
-    {
-      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
-
-      if (strcmp (node->EntityName (), "Axis2_Placement_3d") == 0)
-        return (SdaiAxis2_placement_3d *)node;
-
-      iter = iter->NextNode ();
-    }
-
-  return NULL;
-}
-
-
 void
 write_ap214 (Registry *registry, InstMgr *instance_list, const char *filename)
 {
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
new file mode 100644
index 0000000..48be905
--- /dev/null
+++ b/src/hid/step/model.cpp
@@ -0,0 +1,186 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+extern "C" {
+#include "model.h"
+}
+
+
+typedef std::list<SDAI_Application_instance *> ai_list;
+
+
+SdaiProduct_definition *
+append_model_from_file (Registry *registry,
+                        InstMgr *instance_list,
+                        const char *filename)
+{
+  int max_existing_file_id = instance_list->MaxFileId ();
+
+  /* XXX: The following line is coppied from STEPfile.inline.cc, and we rely on it matching the algorithm there! */
+//  int file_increment = ( int )( ( ceil( ( max_existing_file_id + 99.0 ) / 1000.0 ) + 1.0 ) * 1000.0 ); /* XXX: RELYING ON SCL NOT CHANGING */
+//  std::cout << "INFO: Expecting a to add " << file_increment << " to entity names" << std::endl;
+
+  STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+
+  sfile.AppendExchangeFile (filename);
+
+  Severity severity = sfile.Error().severity();
+  if (severity != SEVERITY_NULL)
+    {
+      sfile.Error().PrintContents (std::cout);
+      std::cout << "WARNING: Error reading from file '" << filename << "'" << std::endl;
+//      return NULL;
+#warning HANDLE OTHER ERRORS BETTER?
+    }
+
+  pd_list all_pd_list;
+  pd_list pd_list;
+
+  // Find all PRODUCT_DEFINITION entities with a SHAPE_DEFINITION_REPRESETNATION
+  find_all_pd_with_sdr (instance_list, &all_pd_list);
+
+  // Find and copy over any PRODUCT_DEFINITION in our list which have entity numbers from the append
+  for (pd_list::iterator iter = all_pd_list.begin(); iter != all_pd_list.end(); iter++)
+    if ((*iter)->StepFileId () > max_existing_file_id)
+      pd_list.push_back (*iter);
+
+  /*  Try to determine the root product */
+  find_and_remove_child_pd (instance_list, &pd_list, "Next_assembly_usage_occurrence"); // Remove any PD which are children of another via NAUO
+  find_and_remove_child_pd (instance_list, &pd_list, "Assembly_component_usage");       // Remove any PD which are children of another via ACU
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+  std::cout << "Hopefully left with the root product definition" << std::endl;
+  for (pd_list::iterator iter = pd_list.begin(); iter != pd_list.end(); iter++)
+    std::cout << "Product definition list item #" << (*iter)->StepFileId () << std::endl;
+  std::cout << std::endl;
+#endif
+
+  // If we didn't find a suitable PD, give up now
+  if (pd_list.size() == 0)
+    {
+      std::cout << "ERROR: Did not find a PRODUCT_DEFINITION (with associated SHAPE_DEFINITION_REPRESENTATION)" << std::endl;
+      return NULL;
+    }
+
+  if (pd_list.size() > 1)
+    std::cout << "WARNING: Found more than one PRODUCT_DEFINITION that might be the root" << std::endl;
+
+  // Use the first PD meeting the criterion. Hopefully there should just be one, but if not, we pick the first.
+  return *pd_list.begin();
+}
+
+
+extern "C" struct step_model *
+step_model_to_shape_master (const char *filename)
+{
+  Registry * registry = new Registry (SchemaInit);
+  InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
+
+#if 0
+  // Increment FileId so entities start at #1 instead of #0.
+  instance_list->NextFileId();
+
+  SdaiProduct_definition *assembly_pd = create_parent_assembly (registry, instance_list);
+  if (assembly_pd == NULL)
+    {
+      printf ("ERROR creating parent assembly");
+      return;
+    }
+
+  GList *model_iter;
+  for (model_iter = models;
+       model_iter != NULL;
+       model_iter = g_list_next (model_iter))
+    {
+      struct assembly_model *model = (struct assembly_model *)model_iter->data;
+
+      SdaiProduct_definition *model_pd;
+      model_pd = append_model_from_file (registry, instance_list, model->filename);
+      if (model_pd == NULL)
+        {
+          printf ("ERROR Loading STEP model from file '%s'", model->filename);
+          continue;
+        }
+
+      GList *inst_iter;
+      for (inst_iter = model->instances;
+           inst_iter != NULL;
+           inst_iter = g_list_next (inst_iter))
+        {
+          struct assembly_model_instance *instance = (struct assembly_model_instance *)inst_iter->data;
+
+          SdaiAxis2_placement_3d *child_location;
+          child_location = MakeAxis (registry, instance_list,
+                                     instance->ox, instance->oy, instance->oz,  // POINT
+                                     instance->ax, instance->ay, instance->az,  // AXIS
+                                     instance->rx, instance->ry, instance->rz); // REF DIRECTION
+
+          assemble_instance_of_model (registry, instance_list, assembly_pd, model_pd, child_location, instance->name);
+        }
+    }
+
+  write_ap214 (registry, instance_list, filename);
+#endif
+
+  delete instance_list;
+  delete registry;
+
+  return NULL;
+}
diff --git a/src/hid/step/model.h b/src/hid/step/model.h
new file mode 100644
index 0000000..f7cdecb
--- /dev/null
+++ b/src/hid/step/model.h
@@ -0,0 +1,24 @@
+
+struct step_model_instance {
+  const char *name;
+  double x;
+  double y;
+  double rotation;
+};
+
+
+struct step_model {
+  const char *filename;
+  GList *instances;
+  double ox;
+  double oy;
+  double oz;
+  double ax;
+  double ay;
+  double az;
+  double rx;
+  double ry;
+  double rz;
+};
+
+void export_step_assembly (const char *filename, GList *assembly_models);
diff --git a/src/hid/step/utils.cpp b/src/hid/step/utils.cpp
new file mode 100644
index 0000000..ea90a52
--- /dev/null
+++ b/src/hid/step/utils.cpp
@@ -0,0 +1,193 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+
+void
+find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list)
+{
+  int search_index = 0;
+
+  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
+  SdaiShape_definition_representation *sdr;
+  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
+                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
+    {
+      SdaiRepresented_definition *sdr_definition = sdr->definition_ ();
+      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr_definition);
+      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
+
+      pd_list->push_back (pd);
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+      STEPentity *sdr_used_representation = sdr->used_representation_ ();
+      SdaiProduct_definition_formation *pdf = pd->formation_ ();
+      SdaiProduct *p = pdf->of_product_ ();
+
+      std::cout << "Got a SDR, #" << sdr->StepFileId ();
+      std::cout << " used_representation (sr or descendant) = #" << sdr_used_representation->StepFileId ();
+      std::cout << " definition (pds) = #" << pds->StepFileId ();
+      std::cout << " pds->definition (pd) = #" << pd->StepFileId ();
+      std::cout << " pd->formation (pdf) = #" << pdf->StepFileId ();
+      std::cout << " pdf->product (p) = #" << p->StepFileId ();
+      std::cout << std::endl;
+      std::cout << "Product id = " << p->id_ ().c_str () << " name = " << p->name_ ().c_str ();
+      std::cout << std::endl;
+#endif
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+      SdaiShape_representation *sr = (SdaiShape_representation *)sdr_used_representation;
+
+      std::cout << "SR is actually of type " << ((STEPentity *)sr)->EntityName () << std::endl;
+      std::cout << std::endl;
+#endif
+
+      int id = sdr->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+}
+
+/* entityName should be the name of entity Assembly_component_usage or one of its subtypes
+ * typically this will be "Assembly_component_usage" or "Next_assembly_usage_occurance"
+ */
+void
+find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, const char *entityName)
+{
+  int search_index = 0;
+
+  SdaiAssembly_component_usage *acu;
+  while (ENTITY_NULL != (acu = (SdaiAssembly_component_usage *)
+                               instance_list->GetApplication_instance (entityName, search_index)))
+    {
+      SdaiProduct_definition *related_pd = acu->related_product_definition_ ();
+
+#ifdef DEBUG_CHILD_REMOVAL
+      SdaiProduct_definition *relating_pd = acu->relating_product_definition_ ();
+
+      std::cout << "Product " << related_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
+      std::cout << " is a child of " << relating_pd->formation_ ()->of_product_ ()->id_ ().c_str ();
+      std::cout << ".. removing it from list of possible root products";
+      std::cout << std::endl;
+#endif
+
+      /* Remove related_pd from the list of viable product definitions */
+      pd_list->remove (related_pd);
+
+      int id = acu->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+#ifdef DEBUG_CHILD_REMOVAL
+  std::cout << std::endl;
+#endif
+}
+
+
+SdaiShape_definition_representation *
+find_sdr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
+{
+  int search_index = 0;
+
+  // Loop over the instances of SHAPE_DEFITION_REPRESENTATION in the file
+  SdaiShape_definition_representation *sdr;
+  while (ENTITY_NULL != (sdr = (SdaiShape_definition_representation *)
+                               instance_list->GetApplication_instance ("Shape_definition_representation", search_index)))
+    {
+      SdaiProduct_definition_shape *pds = (SdaiProduct_definition_shape *)(SdaiProperty_definition_ptr)(*sdr->definition_ ());
+      SdaiProduct_definition *pd = *(SdaiCharacterized_product_definition_ptr)(*pds->definition_ ());
+
+      /* Return the SHAPE_REPRESETATION (or subclass) associated with the first SHAPE_DEFINITION_REPRESENTATION for the required PRODUCT_DEFINITION */
+      if (pd == target_pd)
+        return sdr;
+//        return (SdaiShape_representation *)sdr->used_representation_ ();
+
+      int id = sdr->StepFileId ();
+      MgrNode * mnode = instance_list->FindFileId (id);
+      search_index = instance_list->GetIndex (mnode) + 1;
+    }
+
+  return NULL;
+}
+
+
+SdaiShape_representation *
+find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd)
+{
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, target_pd);
+  return (SdaiShape_representation *)sdr->used_representation_ ();
+}
+
+
+SdaiAxis2_placement_3d *
+find_axis2_placement_3d_in_sr (SdaiShape_representation *sr)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Axis2_Placement_3d") == 0)
+        return (SdaiAxis2_placement_3d *)node;
+
+      iter = iter->NextNode ();
+    }
+
+  return NULL;
+}
diff --git a/src/hid/step/utils.h b/src/hid/step/utils.h
new file mode 100644
index 0000000..b5dd55a
--- /dev/null
+++ b/src/hid/step/utils.h
@@ -0,0 +1,43 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+typedef std::list<SdaiProduct_definition *> pd_list;
+
+
+void find_all_pd_with_sdr (InstMgr *instance_list, pd_list *pd_list);
+
+/* entityName should be the name of entity Assembly_component_usage or one of its subtypes
+ * typically this will be "Assembly_component_usage" or "Next_assembly_usage_occurance"
+ */
+void find_and_remove_child_pd (InstMgr *instance_list, pd_list *pd_list, const char *entityName);
+
+SdaiShape_definition_representation *find_sdr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd);
+
+SdaiShape_representation *find_sr_for_pd (InstMgr *instance_list, SdaiProduct_definition *target_pd);
+
+SdaiAxis2_placement_3d *find_axis2_placement_3d_in_sr (SdaiShape_representation *sr);
