Bottom: 61e2445ecfa2a5acafb6d39c09cbe02b55700dc4
Top:    67193597f974fbfab35cfdcc13f40b6d170636f9
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-06 14:59:08 +0000

Toy rendering attempt


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 8c3d25a..6e3d281 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -484,6 +484,8 @@ LIBSTEP_SRCS = \
 	hid/step/step.h \
 	hid/step/assembly.cpp \
 	hid/step/assembly.h \
+	hid/step/model.cpp \
+	hid/step/model.h \
 	hid/step/utils.cpp \
 	hid/step/utils.h \
 	hid/step/step_writer.c \
diff --git a/src/action.c b/src/action.c
index 4e8ceb7..12ca76d 100644
--- a/src/action.c
+++ b/src/action.c
@@ -91,6 +91,8 @@
 #include <sys/wait.h>
 #endif
 
+#define DEBUG
+
 /* ---------------------------------------------------------------------------
  * some local types
  */
diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index e7a2720..eaa13dd 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -200,8 +200,8 @@ draw_quad_edge (edge_ref e, void *data)
   glEnd ();
 }
 
-static void
-object3d_draw_debug_single (object3d *object, void *user_data)
+void
+object3d_draw (obejct3d *object)
 {
   g_return_if_fail (object->edges != NULL);
 
@@ -209,6 +209,12 @@ object3d_draw_debug_single (object3d *object, void *user_data)
   g_list_foreach (object->edges, (GFunc)draw_quad_edge, NULL);
 }
 
+static void
+object3d_draw_debug_single (object3d *object, void *user_data)
+{
+  object3d_draw (object);
+}
+
 void
 object3d_draw_debug (void)
 {
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index b288cf2..3d228f6 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -9,6 +9,7 @@ typedef struct {
 } object3d;
 
 void object3d_test_init (void);
+void object3d_draw (object3d *object);
 void object3d_draw_debug (void);
 object3d *make_object3d (char *name);
 void destroy_object3d (object3d *object);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index af391dd..cdeafbb 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -123,6 +123,7 @@ static bool ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_
 
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
+object3d *step_read_test = NULL
 
 
 /* Coordinate conversions */
@@ -1127,6 +1128,11 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class.fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Resistor_vr68.step");
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Ceramite_2500z_10kV.step");
+//  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/example_step/Filament_Transformer.step");
+  step_model_to_shape_master ("/home/pcjc2/gedasrc/pcb/git/src/object3d_test.step", &step_read_test);
 }
 
 void
@@ -2729,7 +2735,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (Output.fgGC, priv);
-//  object3d_draw_debug ();
+  //object3d_draw_debug ();
+  if (step_read_test != NULL)
+    object3d_draw (step_read_test);
 
   hidgl_flush_triangles (priv->hidgl);
 
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
new file mode 100644
index 0000000..5705425
--- /dev/null
+++ b/src/hid/step/model.cpp
@@ -0,0 +1,385 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2015 Peter Clifton
+ *  Copyright (C) 2015 PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Harry Eaton, 6697 Buttonhole Ct, Columbia, MD 21044, USA
+ *  haceaton@aplcomm.jhuapl.edu
+ *
+ */
+
+
+#include <STEPfile.h>
+#include <sdai.h>
+#include <STEPattribute.h>
+#include <ExpDict.h>
+#include <Registry.h>
+#include <errordesc.h>
+
+#include <STEPcomplex.h>
+#include <SdaiHeaderSchema.h>
+
+#include "schema.h"
+
+#include <SdaiAUTOMOTIVE_DESIGN.h>
+
+#include "utils.h"
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if 0
+#  define DEBUG_PRODUCT_DEFINITION_SEARCH
+#  define DEBUG_CHILD_REMOVAL
+#  define DEBUG_PRODUCT_DEFINITION
+#else
+#  undef DEBUG_PRODUCT_DEFINITION_SEARCH
+#  undef DEBUG_CHILD_REMOVAL
+#  undef DEBUG_PRODUCT_DEFINITION
+#endif
+
+#include <glib.h>
+
+extern "C" {
+#include "model.h"
+}
+
+
+typedef std::list<SDAI_Application_instance *> ai_list;
+
+
+SdaiProduct_definition *
+read_model_from_file (Registry *registry,
+                        InstMgr *instance_list,
+                        const char *filename)
+{
+  STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+
+  sfile.ReadExchangeFile (filename);
+
+  Severity severity = sfile.Error().severity();
+  if (severity != SEVERITY_NULL)
+    {
+      sfile.Error().PrintContents (std::cout);
+      std::cout << "WARNING: Error reading from file '" << filename << "'" << std::endl;
+//      return NULL;
+#warning HANDLE OTHER ERRORS BETTER?
+    }
+
+  pd_list pd_list;
+
+  // Find all PRODUCT_DEFINITION entities with a SHAPE_DEFINITION_REPRESETNATION
+  find_all_pd_with_sdr (instance_list, &pd_list, 1);
+
+  /*  Try to determine the root product */
+  find_and_remove_child_pd (instance_list, &pd_list, 1, "Next_assembly_usage_occurrence"); // Remove any PD which are children of another via NAUO
+  find_and_remove_child_pd (instance_list, &pd_list, 1, "Assembly_component_usage");       // Remove any PD which are children of another via ACU
+
+#ifdef DEBUG_PRODUCT_DEFINITION_SEARCH
+  std::cout << "Hopefully left with the root product definition" << std::endl;
+  for (pd_list::iterator iter = pd_list.begin(); iter != pd_list.end(); iter++)
+    std::cout << "Product definition list item #" << (*iter)->StepFileId () << std::endl;
+  std::cout << std::endl;
+#endif
+
+  // If we didn't find a suitable PD, give up now
+  if (pd_list.size() == 0)
+    {
+      std::cout << "ERROR: Did not find a PRODUCT_DEFINITION (with associated SHAPE_DEFINITION_REPRESENTATION)" << std::endl;
+      return NULL;
+    }
+
+  if (pd_list.size() > 1)
+    std::cout << "WARNING: Found more than one PRODUCT_DEFINITION that might be the root" << std::endl;
+
+  // Use the first PD meeting the criterion. Hopefully there should just be one, but if not, we pick the first.
+  return *pd_list.begin();
+}
+
+typedef std::list<SdaiManifold_solid_brep *> msb_list;
+
+void
+find_manifold_solid_brep (Registry *registry,
+                          InstMgr *instance_list,
+                          SdaiShape_representation *sr,
+                          msb_list *msb_list)
+{
+  SingleLinkNode *iter = sr->items_ ()->GetHead ();
+
+  while (iter != NULL)
+    {
+      SDAI_Application_instance *node = ((EntityNode *)iter)->node;
+
+      if (strcmp (node->EntityName (), "Manifold_Solid_Brep") == 0)
+        msb_list->push_back ((SdaiManifold_solid_brep *)node);
+
+      iter = iter->NextNode ();
+    }
+}
+
+extern "C" struct step_model *
+step_model_to_shape_master (const char *filename)
+{
+  Registry * registry = new Registry (SchemaInit);
+  InstMgr * instance_list = new InstMgr (/* ownsInstance = */1);
+
+  // Increment FileId so entities start at #1 instead of #0.
+  instance_list->NextFileId();
+
+  SdaiProduct_definition *pd = read_model_from_file (registry, instance_list, filename);
+  if (pd == NULL)
+    {
+      printf ("ERROR Loading STEP model from file '%s'", filename);
+      return NULL;
+    }
+
+  SdaiShape_definition_representation *sdr = find_sdr_for_pd (instance_list, pd);
+  SdaiShape_representation *sr = (SdaiShape_representation *)sdr->used_representation_ ();
+
+  // If sr is an exact match for the step entity SHAPE_REPRESENTATION (not a subclass), return - we are already in the correct form
+  if (strcmp (sr->EntityName (), "Advanced_Brep_Shape_Representation") != 0)
+    {
+      printf ("step_model_to_shape_master: Looking for Advanced_Brep_Shape_Representation, but found %s (which we don't support yet)\n", sr->EntityName ());
+      return NULL;
+    }
+
+  SdaiAxis2_placement_3d *part_origin = find_axis2_placement_3d_in_sr (sr);
+  if (part_origin == NULL)
+    std::cout << "WARNING: Could not find AXIS2_PLACEMENT_3D entity in SHAPE_REPRESENTATION" << std::endl;
+
+  msb_list msb_list;
+  find_manifold_solid_brep (registry, instance_list, sr, &msb_list);
+
+  for (msb_list::iterator iter = msb_list.begin (); iter != msb_list.end (); iter++)
+    {
+      std::cout << "Found MANIFOLD_SOLID_BREP; processing" << std::endl;
+      SdaiClosed_shell *cs = (*iter)->outer_ ();
+
+      std::cout << "Closed shell is " << cs << std::endl;
+
+      for (SingleLinkNode *iter = cs->cfs_faces_ ()->GetHead ();
+           iter != NULL;
+           iter = iter->NextNode ())
+        {
+          SdaiFace *face = (SdaiFace *)((EntityNode *)iter)->node;
+
+          /* XXX: Do we look for specific types of face at this point? (Expect ADVANCED_FACE usually?) */
+          if (strcmp (face->EntityName (), "Advanced_Face") != 0)
+            {
+              printf ("WARNING: Found face of type %s (which we don't support yet)\n", face->EntityName ());
+              continue;
+            }
+
+          /* NB: ADVANCED_FACE is a FACE_SURFACE, which has SdaiSurface *face_geometry_ (), and Boolean same_sense_ () */
+          // SdaiAdvanced_face *af = (SdaiAdvanced_face *) face;
+          /* NB: FACE_SURFACE is a FACE, which has EntityAggreate bounds_ (), whos' members are SdaiFace_bound *  */
+          SdaiFace_surface *fs = (SdaiFace_surface *) face;
+
+          SdaiSurface *surface = fs->face_geometry_ ();
+
+          std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
+
+          if (surface->IsComplex ())
+            {
+              printf ("WARNING: Found a STEP Complex entity for our surface (which we don't support yet). Probably a B_SPLINE surface?\n");
+            }
+          else if (strcmp (surface->EntityName (), "Plane") == 0)
+            {
+              printf ("WARNING: planar surfaces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
+            {
+              printf ("WARNING: cylindrical suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
+            {
+              printf ("WARNING: toroidal suraces are not supported yet\n");
+            }
+          else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
+            {
+              printf ("WARNING: spherical surfaces are not supported yet\n");
+            }
+          else
+            {
+              printf ("ERROR: Found an unknown surface type (which we obviously don't support). Surface name is %s\n", surface->EntityName ());
+            }
+
+          for (SingleLinkNode *iter = fs->bounds_ ()->GetHead ();
+               iter != NULL;
+               iter = iter->NextNode ())
+            {
+              SdaiFace_bound *fb = (SdaiFace_bound *)((EntityNode *)iter)->node;
+
+
+              bool is_outer_bound = (strcmp (fb->EntityName (), "Face_Outer_Bound") == 0);
+
+              if (is_outer_bound)
+                std::cout << "  Outer bounds of face include ";
+              else
+                std::cout << "  Bounds of face include ";
+
+              // NB: SdaiFace_bound has SdaiLoop *bound_ (), and Boolean orientation_ ()
+              // NB: SdaiLoop is a SdaiTopological_representation_item, which is a SdaiRepresentation_item, which has a name_ ().
+              // NB: Expect bounds_ () may return a SUBTYPE of SdaiLoop, such as, but not necessarily: SdaiEdge_loop
+              SdaiLoop *loop = fb->bound_ ();
+
+              std::cout << "loop #" << loop->StepFileId () << ", of type " << loop->EntityName () << ":" << std::endl;
+              if (strcmp (loop->EntityName (), "Edge_Loop") == 0)
+                {
+                  SdaiEdge_loop *el = (SdaiEdge_loop *)loop;
+
+                  // NB: EDGE_LOOP uses multiple inheritance from LOOP and PATH, thus needs special handling to
+                  //     access the elements belonging to PATH, such as edge_list ...
+                  //     (Not sure if this is a bug in STEPcode, as the SdaiEdge_loop class DOES define
+                  //     an accessor edge_list_ (), yet it appears to return an empty aggregate.
+
+                  char path_entity_name[] = "Path"; /* SdaiApplication_instance::GetMiEntity() should take const char *, but doesn't */
+                  SdaiPath *path = (SdaiPath *)el->GetMiEntity (path_entity_name);
+
+                  for (SingleLinkNode *iter = path->edge_list_ ()->GetHead ();
+                       iter != NULL;
+                       iter = iter->NextNode ())
+                    {
+                      SdaiOriented_edge *oe = (SdaiOriented_edge *)((EntityNode *)iter)->node;
+
+                      // NB: Stepcode does not compute derived attributes, so we need to look at the EDGE
+                      //     "edge_element" referred to by the ORIENTED_EDGE, to find the start and end vertices
+
+                      SdaiEdge *edge = oe->edge_element_ ();
+                      bool orientation = oe->orientation_ ();
+
+                      if (strcmp (edge->edge_start_ ()->EntityName (), "Vertex_Point") != 0 ||
+                          strcmp (edge->edge_end_   ()->EntityName (), "Vertex_Point") != 0)
+                        {
+                          printf ("WARNING: Edge start and/or end vertices are not specified as VERTEX_POINT\n");
+                          continue;
+                        }
+
+                      // NB: Assuming edge points to an EDGE, or one of its subtypes that does not make edge_start and edge_end derived attributes.
+                      //     In practice, edge should point to an EDGE_CURVE sub-type
+                      SdaiVertex_point *edge_start = (SdaiVertex_point *) (orientation ? edge->edge_start_ () : edge->edge_end_ ());
+                      SdaiVertex_point *edge_end =  (SdaiVertex_point *) (!orientation ? edge->edge_start_ () : edge->edge_end_ ());
+
+                      // NB: XXX: SdaiVertex_point multiply inherits from vertex and geometric_representation_item
+
+                      SdaiPoint *edge_start_point = edge_start->vertex_geometry_ ();
+                      SdaiPoint *edge_end_point = edge_end->vertex_geometry_ ();
+
+                      if (strcmp (edge_start_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge start point as unhandled point type (%s)\n", edge_start_point->EntityName ());
+                          continue;
+                        }
+
+                      if (strcmp (edge_end_point->EntityName (), "Cartesian_Point") == 0)
+                        {
+                          /* HAPPY WITH THIS TYPE */
+                        }
+                      else
+                        {
+                          // XXX: point_on_curve, point_on_surface, point_replica, degenerate_pcurve
+                          printf ("WARNING: Got Edge end point as unhandled point type (%s)\n", edge_end_point->EntityName ());
+                          continue;
+                        }
+
+                      SdaiCartesian_point *edge_start_cp = (SdaiCartesian_point *)edge_start_point;
+                      SdaiCartesian_point *edge_end_cp = (SdaiCartesian_point *)edge_end_point;
+
+                      printf ("    Edge #%i starts at (%f, %f, %f) and ends at (%f, %f, %f)\n",
+                              edge->StepFileId (),
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_start_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode())->value,
+                              ((RealNode *)edge_end_cp->coordinates_ ()->GetHead()->NextNode()->NextNode())->value);
+
+                      if (strcmp (edge->EntityName (), "Edge_Curve") == 0)
+                        {
+                          SdaiEdge_curve *ec = (SdaiEdge_curve *)edge;
+
+                          SdaiCurve *curve = ec->edge_geometry_ ();
+                          bool same_sense = ec->same_sense_ ();
+
+                          printf ("         underlying curve is %s #%i, same_sense is %s\n", curve->EntityName (), curve->StepFileId(), same_sense ? "True" : "False");
+
+                          if (strcmp (curve->EntityName (), "Line") == 0)
+                            {
+                              printf ("WARNING: Underlying curve geometry type Line is not supported yet\n");
+                              continue;
+                            }
+                          else if (strcmp (curve->EntityName (), "Circle") == 0)
+                            {
+                              printf ("WARNING: Underlying curve geometry type circle is not supported yet\n");
+                              continue;
+                            }
+                          else
+                            {
+                              printf ("WARNING: Unhandled curve geometry type (%s), #%i\n", curve->EntityName (), curve->StepFileId ());
+                              // XXX: line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica
+                              // XXX: Various derived types of the above, e.g.:
+                              //      conic is a supertype of: circle, ellipse, hyperbola, parabola
+                              continue;
+                            }
+
+                        }
+                      else
+                        {
+                          printf ("WARNING: found unknown edge type (%s)\n", edge->EntityName ());
+                          continue;
+                        }
+
+                    }
+
+                }
+              else
+                {
+                  printf ("WARNING: Face is bounded by an unhandled loop type (%s)\n", loop->EntityName ());
+                  continue;
+                }
+            }
+
+        }
+    }
+
+  delete instance_list;
+  delete registry;
+
+  return NULL;
+}
+
+/* Geometry surface and face types encountered so far..
+
+Toroidal_surface     Circle (x5)
+Toroidal_surface     Circle (x4)
+Toroidal_surface     Circle (x3) + B_Spline_Curve_With_Knots
+
+Cylindrical_surface  Circle + Line + B_Spline_Curve_With_Knots
+Cylindrical_surface  Circle + Line
+
+Plane                Circle (xn) + Line (xn) + B_Spline_Curve_With_Knots
+
+*/
diff --git a/src/hid/step/model.h b/src/hid/step/model.h
new file mode 100644
index 0000000..f776512
--- /dev/null
+++ b/src/hid/step/model.h
@@ -0,0 +1,23 @@
+
+struct step_model_instance {
+  double x;
+  double y;
+  double rotation;
+};
+
+
+struct step_model {
+  const char *filename;
+  GList *instances;
+  double ox;
+  double oy;
+  double oz;
+  double ax;
+  double ay;
+  double az;
+  double rx;
+  double ry;
+  double rz;
+};
+
+struct step_model *step_model_to_shape_master (const char *filename);
