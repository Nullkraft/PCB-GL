Bottom: b47a30d8e24a50ce4b38c71b3a560a2b66a46183
Top:    85f525ec55ca0bc0234c76992d0be657dd935c44
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-03-05 13:23:32 +0000

Attempt at producing inter-layer copper with via barrels etc..!


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index 8e37f26..c4047e2 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -66,6 +66,7 @@
 
 #define HACK_BOARD_THICKNESS MM_TO_COORD(1.6)
 #define HACK_COPPER_THICKNESS MM_TO_COORD(0.035)
+#define HACK_PLATED_BARREL_THICKNESS MM_TO_COORD(0.08)
 #define HACK_MASK_THICKNESS MM_TO_COORD(0.01)
 #define HACK_SILK_THICKNESS MM_TO_COORD(0.01)
 
@@ -318,18 +319,30 @@ get_contour_edge_n_round_geometry_in_step_mm (PLINE *contour, int n, double *cx,
   *cw = (compare_ccw_cw (EDGE_BACKWARD_VERTEX (edge)->point, center, EDGE_FORWARD_VERTEX (edge)->point) > 0);
 }
 
+typedef struct
+{
+  object3d *object;
+  face3d *top_face;
+  face3d *bottom_face;
+} polygon_3d_link;
+
+/* NOTE: This function sets the user_data pointer on POLYAREA it
+ *       converts, to point at a polygon_3d_link structure
+ *       referencing the generated object and upper/lower faces
+ */
 GList *
-object3d_from_contours (const POLYAREA *contours,
+object3d_from_contours (POLYAREA *contours,
                         double zbot,
                         double ztop,
                         const appearance *master_object_appearance,
-                        const appearance *master_top_bot_appearance)
+                        const appearance *master_top_bot_appearance,
+                        bool extrude_inverted)
 {
   GList *objects = NULL;
   object3d *object;
   appearance *object_appearance = NULL;
   appearance *top_bot_appearance = NULL;
-  const POLYAREA *pa;
+  POLYAREA *pa;
   PLINE *contour;
   PLINE *ct;
   int ncontours;
@@ -341,14 +354,15 @@ object3d_from_contours (const POLYAREA *contours,
   int start_of_ct;
   int offset_in_ct;
   int ct_npoints;
+  polygon_3d_link *link;
   bool invert_face_normals;
   double length;
   double nx, ny;
 
 #ifdef REVERSED_PCB_CONTOURS
-  invert_face_normals = true;
+  invert_face_normals = extrude_inverted ? false : true;
 #else
-  invert_face_normals = false;
+  invert_face_normals = extrude_inverted ? true : false;
 #endif
 
   if (contours == NULL)
@@ -426,7 +440,10 @@ object3d_from_contours (const POLYAREA *contours,
 
       object3d_add_face (object, faces[i]);
       /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-      face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+      if (!extrude_inverted)
+        face3d_add_contour (faces[i], make_contour3d (edges[2 * npoints + i]));
+      else
+        face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
     }
 
     faces[npoints    ] = make_face3d (); /* bottom_face */
@@ -447,8 +464,16 @@ object3d_from_contours (const POLYAREA *contours,
     object3d_add_face (object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-    face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
-    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+    if (!extrude_inverted)
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (edges[0]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+      }
+    else
+      {
+        face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[0])));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+      }
 
     ct = contour;
     start_of_ct = 0;
@@ -467,8 +492,17 @@ object3d_from_contours (const POLYAREA *contours,
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-      face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+        /* XXX: Haven't properly thought through how (if) inverting works with multiple contours */
+      if (!extrude_inverted)
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (edges[i]));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+        }
+      else
+        {
+          face3d_add_contour (faces[npoints    ], make_contour3d (SYM(edges[i])));
+          face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+        }
       }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -509,17 +543,26 @@ object3d_from_contours (const POLYAREA *contours,
 
         get_contour_edge_n_round_geometry_in_step_mm (ct, offset_in_ct, &cx, &cy, &radius, &cw);
 
+        /* NOTE: Axis directon not depend on whether we invert the top/bot contour.. the edge loop is appropriate already */
         face3d_set_cylindrical (faces[i], cx, cy, 0., /* A point on the axis of the cylinder */
                                           0., 0., 1., /* Direction of the cylindrical axis */ /* XXX HAD THIS AT -1 when last testing with Solidworks? */
-                                          radius);
-
-        /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! */
-        if (ct->Flags.orient == PLF_INV)
+                                          radius);Y
+
+        /* NOTE: Surface orientation is only fixed up during emission if we flag the need here..
+         *       cylindrical surface orientation is always pointing outward from its axis, so
+         *       orientation reversed is used for holes
+         */
+        /* XXX: DEPENDS ON INSIDE / OUTSIDE CORNER!! - THIS IS NOT EXACTLY CORRECT!.. NEEDS TO TAKE ACOUNT FOR cw / ccw WHEN DEALING WITH ARC CONTOUR SEGMENTS */
+        if ((ct->Flags.orient == PLF_INV) != extrude_inverted)
           face3d_set_surface_orientation_reversed (faces[i]);
 
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
+        /* DOES NOT DEPEND ON WHETHER WE INVERT THE CONTOUR.. THE EDGE TRAVERSAL IS REVERSED DURING EMISSION.
+         * Only depends on the coordinate system transform, and what Z values it requires to create a
+         * clockwise / counterclockwise circular edge consistent with the the polygon data.
+         */
 #ifdef REVERSED_PCB_CONTOURS
         normal_z = cw ? 1. : -1.; /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
 #else
@@ -542,19 +585,38 @@ object3d_from_contours (const POLYAREA *contours,
        *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
        */
 
-      RDATA (edges[              i]) = faces[i];
-      LDATA (edges[              i]) = faces[npoints];
-      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-      LDATA (edges[1 * npoints + i]) = faces[i];
-      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-      LDATA (edges[2 * npoints + i]) = faces[i];
-
-      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-      splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
-      splice (edges[2 * npoints + i], edges[i]);
-      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-      splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
-      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+      if (extrude_inverted)
+        {
+          LDATA (edges[              i]) = faces[i];
+          RDATA (edges[              i]) = faces[npoints];
+          LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          RDATA (edges[1 * npoints + i]) = faces[i];
+          LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          RDATA (edges[2 * npoints + i]) = faces[i];
+
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[i]);
+          splice (edges[i], edges[2 * npoints + i]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+          splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+        }
+      else
+        {
+          RDATA (edges[              i]) = faces[i];
+          LDATA (edges[              i]) = faces[npoints];
+          RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+          LDATA (edges[1 * npoints + i]) = faces[i];
+          RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+          LDATA (edges[2 * npoints + i]) = faces[i];
+
+          /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+          splice (SYM(edges[prev_i_around_ct]), edges[2 * npoints + i]);
+          splice (edges[2 * npoints + i], edges[i]);
+          /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+          splice (edges[npoints + i], SYM(edges[2 * npoints + i]));
+          splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + prev_i_around_ct]));
+        }
     }
 
     if (0) {
@@ -669,28 +731,44 @@ object3d_from_contours (const POLYAREA *contours,
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
       prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
 
-      g_assert (RDATA (edges[              i]) == faces[i]);
-      g_assert (LDATA (edges[              i]) == faces[npoints]);
-      g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
-      g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
-      g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
-      g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
-
-      g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
-      g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
-      g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
-      g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
-      g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
-      g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
-
-      g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
-      g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
-      g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+      if (!extrude_inverted)
+        {
+          g_assert (RDATA (edges[              i]) == faces[i]);
+          g_assert (LDATA (edges[              i]) == faces[npoints]);
+          g_assert (RDATA (edges[1 * npoints + i]) == faces[npoints + 1]);
+          g_assert (LDATA (edges[1 * npoints + i]) == faces[i]);
+          g_assert (RDATA (edges[2 * npoints + i]) == faces[prev_i_around_ct]);
+          g_assert (LDATA (edges[2 * npoints + i]) == faces[i]);
+
+          g_assert (              ONEXT (edges[              i])   == SYM (edges[prev_i_around_ct]));
+          g_assert (       ONEXT (ONEXT (edges[              i]))  == edges[2 * npoints + i]);
+          g_assert (ONEXT (ONEXT (ONEXT (edges[              i]))) ==      edges[              i]);
+          g_assert (              ONEXT (edges[1 * npoints + i])   == SYM (edges[2 * npoints + i]));
+          g_assert (       ONEXT (ONEXT (edges[1 * npoints + i]))  == SYM (edges[1 * npoints + prev_i_around_ct]));
+          g_assert (ONEXT (ONEXT (ONEXT (edges[1 * npoints + i]))) ==      edges[1 * npoints + i]);
+
+          g_assert (LNEXT (edges[              i]) ==      edges[0 * npoints + next_i_around_ct]);
+          g_assert (LNEXT (edges[1 * npoints + i]) == SYM (edges[2 * npoints + next_i_around_ct]));
+          g_assert (LNEXT (edges[2 * npoints + i]) ==      edges[1 * npoints + i]);
+        }
+      else
+        {
+          /* XXX: No debug checks for this yet. LDATA and RDATA should be swapped from the
+           *      above case, and ONEXT order should be reversed. It works, so have not
+           *      written in the debug checks.
+           */
+        }
     }
 #endif
 
     objects = g_list_append (objects, object);
 
+    link = malloc (sizeof (polygon_3d_link));
+    pa->user_data = link;
+    link->object = object;
+    link->bottom_face = faces[npoints];
+    link->top_face = faces[npoints + 1];
+
   } while (pa = pa->f, pa != contours);
 
   return objects;
@@ -932,6 +1010,7 @@ pv_mask_callback (const BoxType * b, void *cl)
   return 1;
 }
 
+#if 1
 static int
 pv_drill_callback (const BoxType * b, void *cl)
 {
@@ -942,7 +1021,24 @@ pv_drill_callback (const BoxType * b, void *cl)
   if (!(np = CirclePoly (pv->X, pv->Y, (pv->DrillingHole + 1) / 2, NULL)))
     return 0;
 
-  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+  info->poly = res;
+
+  return 1;
+}
+#endif
+
+static int
+pv_barrel_callback (const BoxType * b, void *cl)
+{
+  PinType *pv = (PinType *)b;
+  struct mask_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = CirclePoly (pv->X, pv->Y, (pv->DrillingHole + HACK_PLATED_BARREL_THICKNESS + 1) / 2, NULL)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
   info->poly = res;
 
   return 1;
@@ -1515,19 +1611,68 @@ pv_copper_callback (const BoxType * b, void *cl)
   return 1;
 }
 
+
+static void
+steal_object_geometry (object3d *dst, object3d *src)
+{
+  g_assert (dst != src);
+
+  dst->faces    = g_list_concat (dst->faces,    src->faces);
+  dst->edges    = g_list_concat (dst->edges,    src->edges);
+  dst->vertices = g_list_concat (dst->vertices, src->vertices);
+  src->faces = NULL;
+  src->edges = NULL;
+  src->vertices = NULL;
+}
+
+static void
+update_object_pointers (POLYAREA **group_m_poly, object3d *old_object, object3d *new_object)
+{
+  int group;
+  int top_group;
+  int bottom_group;
+  int min_copper_group;
+  int max_copper_group;
+  POLYAREA *pa;
+
+  top_group =    GetLayerGroupNumberBySide (TOP_SIDE);
+  bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
+
+  min_copper_group = MIN (bottom_group, top_group);
+  max_copper_group = MAX (bottom_group, top_group);
+
+  for (group = min_copper_group; group <= max_copper_group; group++)
+    {
+      pa = group_m_poly[group];
+      do
+        {
+          polygon_3d_link *link = pa->user_data;
+
+          if (link->object == old_object)
+            link->object = new_object;
+
+        }
+      while ((pa = pa->f) != group_m_poly[group]);
+    }
+}
+
 GList *
 object3d_from_copper_layers_within_area (POLYAREA *area)
 {
   appearance *copper_appearance;
-  GList *objects;
+  GList *group_objects;
   struct copper_info info;
   BoxType bounds;
 
   int group;
   int top_group;
   int bottom_group;
-  int min_phys_group;
-  int max_phys_group;
+  int min_copper_group;
+  int max_copper_group;
+
+  POLYAREA **group_m_polyarea;
+  POLYAREA *barrel_m_polyarea;
+  POLYAREA *drill_m_polyarea;
 
 //  poly_Copy0 (&info.poly, area);
 
@@ -1544,101 +1689,433 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   top_group =    GetLayerGroupNumberBySide (TOP_SIDE);
   bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
 
-  min_phys_group = MIN (bottom_group, top_group);
-  max_phys_group = MAX (bottom_group, top_group);
+  min_copper_group = MIN (bottom_group, top_group);
+  max_copper_group = MAX (bottom_group, top_group);
+//  num_copper_groups = max_copper_group - min_copper_group;
 
-  objects = NULL;
+  group_m_polyarea = calloc (max_copper_group + 1, sizeof (POLYAREA *));
 
-  for (group = min_phys_group; group <= max_phys_group; group++) {
+  group_objects = NULL;
 
-#ifdef REVERSED_PCB_CONTOURS
-    Coord depth = compute_depth (group) - HACK_BOARD_THICKNESS;
-#else
-    Coord depth = compute_depth (group) + HACK_BOARD_THICKNESS / 2;
-#endif
-    info.poly = NULL;
+  for (group = min_copper_group; group <= max_copper_group; group++)
+    {
+      Coord depth = compute_depth (group);
 
-    fprintf (stderr, "Computing copper geometry for group %i\n", group);
+      info.poly = NULL;
+
+      fprintf (stderr, "Computing copper geometry for group %i\n", group);
 
 #if 1
-    GROUP_LOOP (PCB->Data, group);
-      {
-        fprintf (stderr, "Accumulating elements from layer %i\n", GetLayerNumber (PCB->Data, layer));
+      GROUP_LOOP (PCB->Data, group);
+        {
+          fprintf (stderr, "Accumulating elements from layer %i\n", GetLayerNumber (PCB->Data, layer));
 
-        r_search (layer->line_tree, &bounds, NULL, line_copper_callback, &info);
-        r_search (layer->arc_tree,  &bounds, NULL, arc_copper_callback, &info);
-        r_search (layer->text_tree, &bounds, NULL, text_copper_callback, &info);
-        r_search (layer->polygon_tree, &bounds, NULL, polygon_copper_callback, &info);
-      }
-    END_LOOP;
+          r_search (layer->line_tree, &bounds, NULL, line_copper_callback, &info);
+          r_search (layer->arc_tree,  &bounds, NULL, arc_copper_callback, &info);
+          r_search (layer->text_tree, &bounds, NULL, text_copper_callback, &info);
+          r_search (layer->polygon_tree, &bounds, NULL, polygon_copper_callback, &info);
+        }
+      END_LOOP;
 #endif
 
 #if 1
-    fprintf (stderr, "Accumulating pin + via pads\n");
-    r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
-    r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
+      fprintf (stderr, "Accumulating pin + via pads\n");
+      r_search (PCB->Data->pin_tree, &bounds, NULL, pv_copper_callback, &info);
+      r_search (PCB->Data->via_tree, &bounds, NULL, pv_copper_callback, &info);
 #endif
 
 #if 1
-    if (group == top_group ||
-        group == bottom_group)
+      if (group == top_group ||
+          group == bottom_group)
+        {
+          info.side = (group == top_group) ? TOP_SIDE : BOTTOM_SIDE;
+          fprintf (stderr, "Accumulating SMT pads for side %i\n", info.side);
+          r_search (PCB->Data->pad_tree, &bounds, NULL, pad_copper_callback, &info);
+        }
+#endif
+
+    /* TODO: Inter-layer features
+     *
+     * Accumulate a circular polygon for each plated hole we may cut, ensuring
+     * the finished polygon contour extends to include the via barrel extents.
+     *
+     * Subtract non-plated hole contours from the polygons.
+     *
+     * For each hole, add the via-barrel between layers... removing the Object3D
+     * from the list of objects as they become joined with some other. (The final
+     * list of objects shuold match 1:1 with resultant bodies, and contain no
+     * duplicates.
+     *
+     * To accomodate overlapping drill holes, accumulate all via-barrels into a
+     * polygon, and subtract that from the positive copper polygon. As we already
+     * added via-barrels to each copper layer, the each barrel extrusion contour
+     * should match only one body of copper on a given layer.
+     *
+     * Remove the drilled hole down each via by extruding the additional faces.
+     *
+     * To accomodate overlapping drill holes, accumulate all drills into a polygon,
+     * and subtract that from the positive copper polygon. Any subtracted contour
+     * should at this point match to one body of copper on a given layer.
+     *
+     */
+
+#if 0
+      fprintf (stderr, "Subtracting pin + via drills\n");
+      r_search (PCB->Data->pin_tree, &bounds, NULL, pv_drill_callback, &info);
+      r_search (PCB->Data->via_tree, &bounds, NULL, pv_drill_callback, &info);
+#endif
+
+    if (info.poly == NULL)
       {
-        info.side = (group == top_group) ? TOP_SIDE : BOTTOM_SIDE;
-        fprintf (stderr, "Accumulating SMT pads for side %i\n", info.side);
-        r_search (PCB->Data->pad_tree, &bounds, NULL, pad_copper_callback, &info);
+        fprintf (stderr, "Skipping layer group %i, info.poly was NULL\n", group);
+        continue;
       }
+
+      group_objects = g_list_concat (group_objects,
+        object3d_from_contours (info.poly,
+#ifdef REVERSED_PCB_CONTOURS
+                                depth,                         /* Bottom */
+                                depth + HACK_COPPER_THICKNESS, /* Top */
+#else
+                                -depth - HACK_BOARD_THICKNESS / 2,                         /* Bottom */
+                                -depth - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Top */
 #endif
+                                copper_appearance,
+                                NULL,
+                                false)); /* Don't invert */
+
+      group_m_polyarea[group] = info.poly;
+    }
 
-  /* TODO: Inter-layer features
-   *
-   * Accumulate a circular polygon for each plated hole we may cut, ensuring
-   * the finished polygon contour extends to include the via barrel extents.
-   *
-   * Subtract non-plated hole contours from the polygons.
-   *
-   * For each hole, add the via-barrel between layers... removing the Object3D
-   * from the list of objects as they become joined with some other. (The final
-   * list of objects shuold match 1:1 with resultant bodies, and contain no
-   * duplicates.
-   *
-   * To accomodate overlapping drill holes, accumulate all via-barrels into a
-   * polygon, and subtract that from the positive copper polygon. As we already
-   * added via-barrels to each copper layer, the each barrel extrusion contour
-   * should match only one body of copper on a given layer.
-   *
-   * Remove the drilled hole down each via by extruding the additional faces.
-   *
-   * To accomodate overlapping drill holes, accumulate all drills into a polygon,
-   * and subtract that from the positive copper polygon. Any subtracted contour
-   * should at this point match to one body of copper on a given layer.
-   *
+  /* Now need to punch drill-holes through the inter-layers..
+   * Ideally, we construct a polygon of drill-holes, so any overlapping are taken into account
    */
+  info.poly = NULL;
+
+  fprintf (stderr, "Accumulating pin + via barrel outers\n");
+  r_search (PCB->Data->pin_tree, &bounds, NULL, pv_barrel_callback, &info);
+  r_search (PCB->Data->via_tree, &bounds, NULL, pv_barrel_callback, &info);
+
+  barrel_m_polyarea = info.poly;
+
+  info.poly = NULL;
 
 #if 1
-    fprintf (stderr, "Subtracting pin + via drills\n");
-    r_search (PCB->Data->pin_tree, &bounds, NULL, pv_drill_callback, &info);
-    r_search (PCB->Data->via_tree, &bounds, NULL, pv_drill_callback, &info);
+  fprintf (stderr, "Accumulating pin + via barrel drills\n");
+  r_search (PCB->Data->pin_tree, &bounds, NULL, pv_drill_callback, &info);
+  r_search (PCB->Data->via_tree, &bounds, NULL, pv_drill_callback, &info);
+
+  drill_m_polyarea = info.poly;
+
+  info.poly = NULL;
 #endif
 
-  if (info.poly == NULL)
+  // Extrude barrel?
+  // Grab top-face of barrel. Delete the face, stealing its contour.. find which top-side copper Object3D to paste in into, link it up.
+  // Grab bottom-fac of barrel. Delete the face, stealing its contour.. find which next-side copper Object3D to paste it into, link it up. (Might already be the same object as in step above.. how to find it?)
+  // Repeat for each inter-layer barrel segment
+  // Repeat for each contour in the accumulated barrel M_POLYAERA
+
+
+  for (group = min_copper_group; group < max_copper_group; group++)
     {
-      fprintf (stderr, "Skipping layer group %i, info.poly was NULL\n", group);
-      continue;
+      Coord top_depth;
+      Coord bottom_depth;
+      POLYAREA *pa;
+      GList *barrel_objects;
+
+      /* HACK - LET US EMIT BLANK BOARDS.. SHOULD CHECK BEFORE WE START TO LOOP? */
+      if (barrel_m_polyarea == NULL)
+        break;
+
+      /* Extrude barrel from group to group + 1 */
+      fprintf (stderr, "Extruding barrels from layer group %i to %i\n", group, group + 1);
+
+      g_assert (group_m_polyarea[group] != NULL);
+      g_assert (group_m_polyarea[group + 1] != NULL);
+
+      /* Depth is the bottom? of the layer? */
+      top_depth = compute_depth (group);
+      bottom_depth = compute_depth (group + 1);
+
+      barrel_objects = object3d_from_contours (barrel_m_polyarea,
+#ifdef REVERSED_PCB_CONTOURS
+                                               bottom_depth + HACK_COPPER_THICKNESS, /* Bottom */
+                                               top_depth,                            /* Top */
+#else
+                                               -bottom_depth - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Bottom */
+                                               -top_depth    - HACK_BOARD_THICKNESS / 2,                         /* Top */
+#endif
+                                               copper_appearance,
+                                               NULL,
+                                               false); /* Don't invert */
+
+/* Connect the via barrels in this block of code */
+#if 1
+      /* Loop over all barrel outline pieces */
+      pa = barrel_m_polyarea;
+      do
+        {
+          /* For each barrel, we want to find the Polyarea it hits on group, and group+1.. this tracks to the objects and faces we must manipulate */
+
+          polygon_3d_link *top_link    ;
+          polygon_3d_link *barrel_link ;
+          polygon_3d_link *bottom_link ;
+
+          object3d *top_group_object    ;
+          object3d *barrel_object       ;
+          object3d *bottom_group_object ;
+
+          face3d *top_group_face     ;
+          face3d *barrel_top_face    ;
+          face3d *barrel_bottom_face ;
+          face3d *bottom_group_face  ;
+
+          edge_ref barrel_top_face_first_edge    ;
+          edge_ref barrel_bottom_face_first_edge ;
+          edge_ref e;
+
+          POLYAREA *top_pa    = cntr_in_M_POLYAREA (pa->contours, group_m_polyarea[group    ] , false);
+          POLYAREA *bottom_pa = cntr_in_M_POLYAREA (pa->contours, group_m_polyarea[group + 1] , false);
+
+          /* These conditions should not occur, and can likely only happen because some other
+           * bug in the polygon processing code has created an inconsistent m_polyarea somewhere.
+           * We need to check for them though, since sadly - bad polygon boolean operations are
+           * still far too common.
+           */
+          g_warn_if_fail (top_pa != NULL);
+          g_warn_if_fail (bottom_pa != NULL);
+          if (top_pa == NULL)
+              continue;
+
+          if (bottom_pa == NULL)
+            continue;
+
+          top_link    = top_pa->user_data;
+          barrel_link = pa->user_data;
+          bottom_link = bottom_pa->user_data;
+
+          top_group_object    = top_link->object;
+          barrel_object       = barrel_link->object;
+          bottom_group_object = bottom_link->object;
+
+          top_group_face     = top_link->bottom_face;
+          barrel_top_face    = barrel_link->top_face;
+          barrel_bottom_face = barrel_link->bottom_face;
+          bottom_group_face  = bottom_link->top_face;
+
+          barrel_top_face_first_edge = ((contour3d *)barrel_top_face->contours->data)->first_edge;
+          barrel_bottom_face_first_edge = ((contour3d *)barrel_bottom_face->contours->data)->first_edge;
+
+//          fprintf (stderr, "Extruding a barrel\n");
+
+          /* Do some magic to join the objects */
+
+          /* XXX: Need to invert the barrel object? */
+
+          g_assert (g_list_length (barrel_top_face->contours) == 1);
+          g_assert (g_list_length (barrel_bottom_face->contours) == 1);
+
+          face3d_add_contour (top_group_face,    make_contour3d (barrel_top_face_first_edge));
+          face3d_add_contour (bottom_group_face, make_contour3d (barrel_bottom_face_first_edge));
+
+          /* Need to walk around the top / bottom edge contours, and re-connect with the linked up copper groups */
+
+          e = barrel_top_face_first_edge;
+          do
+            {
+//              edge_info *info = UNDIR_DATA (e);
+//              face3d *side_face = RDATA (e);
+
+              /* Check and reassign the edge */
+              g_assert (LDATA (e) == barrel_top_face);
+              LDATA (e) = top_group_face;
+
+//              /* Only adjust from one end! */
+//              if (side_face->is_cylindrical)
+//                {
+//                  edge_face->surface_orientation_reversed = !edge_face->surface_orientation_reversed;
+//                  edge_face->az = -edge_face->az;
+//                }
+
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+
+              /* XXX: Also need to flip this edge!... CHEAT, and just flip the object3d edge bucket references...
+               * XXX: Leaves the quad-edges WRONG!
+               */
+//              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)e);
+//              object3d_add_edge (barrel_object, SYM (e));
+            }
+          while ((e = LNEXT (e)) != barrel_top_face_first_edge);
+
+          e = barrel_bottom_face_first_edge;
+          do
+            {
+//              edge_info *info = UNDIR_DATA (e);
+
+              /* Check and reassign the edge */
+              g_assert (LDATA (e) == barrel_bottom_face);
+              LDATA (e) = bottom_group_face;
+
+//              if (info->is_round)
+//                info->nz = -info->nz; /* Flip circular normal, if this contour is a circle */
+//
+              /* XXX: Also need to flip this edge!... CHEAT, and just flip the object3d edge bucket references...
+               * XXX: Leaves the quad-edges WRONG!
+               */
+//              barrel_object->edges = g_list_remove (barrel_object->edges, (void *)SYM (e));
+//              object3d_add_edge (barrel_object, e);
+            }
+          while ((e = LNEXT (e)) != barrel_bottom_face_first_edge);
+
+          /* XXX: What about destroying the barrel top / bottom face appearance (if any?) */
+
+          barrel_object->faces = g_list_remove (barrel_object->faces, barrel_top_face);
+          barrel_object->faces = g_list_remove (barrel_object->faces, barrel_bottom_face);
+          destroy_face3d (barrel_top_face);    /* This leaves the edges, vertices etc.. it only deletes the face contour list */
+          destroy_face3d (barrel_bottom_face); /* This leaves the edges, vertices etc.. it only deletes the face contour list */
+          /* No vertices should be deleted */
+          /* All edges must end up in the top object, so we leave them */
+
+          /* Steal the data from the barrel object */
+          steal_object_geometry (top_group_object, barrel_object);
+          destroy_object3d (barrel_object);
+
+          if (top_group_object != bottom_group_object)
+            { /* Top object and bottom object were previously distinct */
+
+              /* Update any remaining link pointers to the previous bottom object we are about to delete */
+              update_object_pointers (group_m_polyarea, bottom_group_object, top_group_object);
+//              bottom_link->object = top_group_object;
+//#warning THROUGH OBJECT JOINING.. CAN WE STILL REFER TO bottom_group_object from various other places??? PROBABLY YES!
+
+              /* Remove the old bottom object from the list of output objects */
+              group_objects = g_list_remove (group_objects, bottom_group_object);
+
+              /* Steal the data from the old bottom object */
+              steal_object_geometry (top_group_object, bottom_group_object);
+
+              /* Delete the old bottom object */
+              destroy_object3d (bottom_group_object);
+            }
+
+          free (pa->user_data);
+        }
+      while (pa = pa->f, pa != barrel_m_polyarea);
+
+      g_list_free (barrel_objects);
+#else
+      group_objects = g_list_concat (group_objects, barrel_objects);
+#endif
     }
 
-    objects = g_list_concat (objects,
-      object3d_from_contours (info.poly,
+  if (drill_m_polyarea != NULL) /* Drill holes */
+    {
+      Coord top_depth;
+      Coord bottom_depth;
+      POLYAREA *pa;
+      GList *drill_objects;
+
+      /* Extrude drill hole */
+      fprintf (stderr, "Extruding drill holes\n");
+
+      /* Depth is the bottom? of the layer? */
+      top_depth = compute_depth (min_copper_group);
+      bottom_depth = compute_depth (max_copper_group);
+
+      drill_objects = object3d_from_contours (drill_m_polyarea,
 #ifdef REVERSED_PCB_CONTOURS
-                              depth,                         /* Bottom */
-                              depth + HACK_COPPER_THICKNESS, /* Top */
+                                               bottom_depth,                      /* Bottom */
+                                               top_depth + HACK_COPPER_THICKNESS, /* Top */
 #else
-                              -depth,                         /* Bottom */
-                              -depth - HACK_COPPER_THICKNESS, /* Top */
+                                              -bottom_depth - HACK_BOARD_THICKNESS / 2,                         /* Bottom */
+                                              -top_depth    - HACK_BOARD_THICKNESS / 2 - HACK_COPPER_THICKNESS, /* Top */
 #endif
-                              copper_appearance,
-                              NULL));
+                                              copper_appearance,
+                                              NULL,
+                                              true); /* Invert */
 
-  }
+/* Connect the via drill holes in this block of code */
+#if 1
+      /* Loop over all barrel outline pieces */
+      pa = drill_m_polyarea;
+      do
+        {
+          /* For each drill hole, we want to find the Polyarea it hits on min_copper_group, and max_copper_group.. this tracks to the objects and faces we must manipulate */
+          polygon_3d_link *top_link    = cntr_in_M_POLYAREA (pa->contours, group_m_polyarea[min_copper_group] , false)->user_data;
+          polygon_3d_link *drill_link  = pa->user_data;
+          polygon_3d_link *bottom_link = cntr_in_M_POLYAREA (pa->contours, group_m_polyarea[max_copper_group] , false)->user_data;
+
+          object3d *top_group_object    = top_link->object;
+          object3d *drill_object        = drill_link->object;
+          object3d *bottom_group_object = bottom_link->object;
+
+          face3d *top_group_face    = top_link->top_face;
+          face3d *drill_top_face    = drill_link->top_face;
+          face3d *drill_bottom_face = drill_link->bottom_face;
+          face3d *bottom_group_face = bottom_link->bottom_face;
+
+          edge_ref drill_top_face_first_edge = ((contour3d *)drill_top_face->contours->data)->first_edge;
+          edge_ref drill_bottom_face_first_edge = ((contour3d *)drill_bottom_face->contours->data)->first_edge;
+          edge_ref e;
+
+          g_warn_if_fail (top_group_object == bottom_group_object);
+
+//          fprintf (stderr, "Extruding a drill\n");
+
+          /* Do some magic to join the objects */
+
+          /* XXX: Need to invert the barrel object? */
+
+          g_assert (g_list_length (drill_top_face->contours) == 1);
+          g_assert (g_list_length (drill_bottom_face->contours) == 1);
+
+          face3d_add_contour (top_group_face,    make_contour3d (drill_top_face_first_edge));
+          face3d_add_contour (bottom_group_face, make_contour3d (drill_bottom_face_first_edge));
+
+          /* Need to walk around the top / bottom edge contours, and re-connect with the linked up copper groups */
+
+          e = drill_top_face_first_edge;
+          do
+            {
+              /* Check and reassign the edge */
+              g_assert (LDATA (e) == drill_top_face);
+              LDATA (e) = top_group_face;
+            }
+          while ((e = LNEXT (e)) != drill_top_face_first_edge);
+
+          e = drill_bottom_face_first_edge;
+          do
+            {
+              /* Check and reassign the edge */
+              g_assert (LDATA (e) == drill_bottom_face);
+              LDATA (e) = bottom_group_face;
+            }
+          while ((e = LNEXT (e)) != drill_bottom_face_first_edge);
+
+          /* XXX: What about destroying the barrel top / bottom face appearance (if any?) */
+
+          drill_object->faces = g_list_remove (drill_object->faces, drill_top_face);
+          drill_object->faces = g_list_remove (drill_object->faces, drill_bottom_face);
+          destroy_face3d (drill_top_face);    /* This leaves the edges, vertices etc.. it only deletes the face contour list */
+          destroy_face3d (drill_bottom_face); /* This leaves the edges, vertices etc.. it only deletes the face contour list */
+          /* No vertices should be deleted */
+          /* All edges must end up in the top object, so we leave them */
+
+          /* Steal the data from the drill object */
+          steal_object_geometry (top_group_object, drill_object);
+          destroy_object3d (drill_object);
+
+          free (pa->user_data);
+        }
+      while (pa = pa->f, pa != drill_m_polyarea);
+
+      g_list_free (drill_objects);
+#else
+      group_objects = g_list_concat (group_objects, drill_objects);
+#endif
+    }
 
 
   destroy_appearance (copper_appearance);
@@ -1654,5 +2131,17 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
 
   poly_Free (&info.poly);
 
-  return objects;
+  poly_Free (&barrel_m_polyarea);
+  poly_Free (&drill_m_polyarea);
+
+  for (group = min_copper_group; group <= max_copper_group; group++)
+    {
+      if (group_m_polyarea[group] != NULL)
+        {
+          free (group_m_polyarea[group]->user_data);
+          poly_Free (&group_m_polyarea[group]);
+        }
+    }
+
+  return group_objects;
 }
diff --git a/src/hid/common/object3d.h b/src/hid/common/object3d.h
index 0e679ab..82b69fd 100644
--- a/src/hid/common/object3d.h
+++ b/src/hid/common/object3d.h
@@ -15,7 +15,7 @@ void object3d_set_appearance (object3d *object, appearance *appear);
 void object3d_add_edge (object3d *object, edge_ref edge);
 void object3d_add_vertex (object3d *object, vertex3d *vertex);
 void object3d_add_face (object3d *object, face3d *face);
-GList *object3d_from_contours (const POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance);
+GList *object3d_from_contours (POLYAREA *contours, double zbot, double ztop, const appearance *master_object_appearance, const appearance *master_top_bot_appearance, bool extrude_inverted);
 GList *object3d_from_board_outline (void);
 GList *object3d_from_soldermask_within_area (POLYAREA *area, int side);
 GList *object3d_from_copper_layers_within_area (POLYAREA *area);
