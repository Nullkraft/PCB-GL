Bottom: 91d908d3ad7ce2c9ac71c3fd2d30a162e421f42d
Top:    8c12e00e16e7ee8ecff7bb4fba7758d4112ddf25
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-01-07 00:49:54 +0000

Use calling wrappers rather than accessing HID_DRAW* vfunc tables directly


---

diff --git a/src/autoroute.c b/src/autoroute.c
index 5812371..9ca83f4 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -1490,14 +1490,14 @@ showbox (BoxType b, Dimension thickness, int group)
 
   if (ddraw != NULL)
     {
-      ddraw->set_line_width (ar_gc, thickness);
-      ddraw->set_line_cap (ar_gc, Trace_Cap);
-      ddraw->set_color (ar_gc, SLayer->Color);
-
-      ddraw->draw_line (ar_gc, b.X1, b.Y1, b.X2, b.Y1);
-      ddraw->draw_line (ar_gc, b.X1, b.Y2, b.X2, b.Y2);
-      ddraw->draw_line (ar_gc, b.X1, b.Y1, b.X1, b.Y2);
-      ddraw->draw_line (ar_gc, b.X2, b.Y1, b.X2, b.Y2);
+      hid_draw_set_line_width (ar_gc, thickness);
+      hid_draw_set_line_cap (ar_gc, Trace_Cap);
+      hid_draw_set_color (ar_gc, SLayer->Color);
+
+      hid_draw_line (ar_gc, b.X1, b.Y1, b.X2, b.Y1);
+      hid_draw_line (ar_gc, b.X1, b.Y2, b.X2, b.Y2);
+      hid_draw_line (ar_gc, b.X1, b.Y1, b.X1, b.Y2);
+      hid_draw_line (ar_gc, b.X2, b.Y1, b.X2, b.Y2);
     }
 
 #if 1
@@ -1546,23 +1546,23 @@ showedge (edge_t * e)
   if (ddraw == NULL)
     return;
 
-  ddraw->set_line_cap (ar_gc, Trace_Cap);
-  ddraw->set_line_width (ar_gc, 1);
-  ddraw->set_color (ar_gc, Settings.MaskColor);
+  hid_draw_set_line_cap (ar_gc, Trace_Cap);
+  hid_draw_set_line_width (ar_gc, 1);
+  hid_draw_set_color (ar_gc, Settings.MaskColor);
 
   switch (e->expand_dir)
     {
     case NORTH:
-      ddraw->draw_line (ar_gc, b->X1, b->Y1, b->X2, b->Y1);
+      hid_draw_line (ar_gc, b->X1, b->Y1, b->X2, b->Y1);
       break;
     case SOUTH:
-      ddraw->draw_line (ar_gc, b->X1, b->Y2, b->X2, b->Y2);
+      hid_draw_line (ar_gc, b->X1, b->Y2, b->X2, b->Y2);
       break;
     case WEST:
-      ddraw->draw_line (ar_gc, b->X1, b->Y1, b->X1, b->Y2);
+      hid_draw_line (ar_gc, b->X1, b->Y1, b->X1, b->Y2);
       break;
     case EAST:
-      ddraw->draw_line (ar_gc, b->X2, b->Y1, b->X2, b->Y2);
+      hid_draw_line (ar_gc, b->X2, b->Y1, b->X2, b->Y2);
       break;
     default:
       break;
@@ -5240,8 +5240,8 @@ AutoRoute (bool selected)
   ddraw = gui->request_debug_draw ();
   if (ddraw != NULL)
     {
-      ar_gc = ddraw->make_gc ();
-      ddraw->set_line_cap (ar_gc, Round_Cap);
+      ar_gc = hid_draw_make_gc (ddraw);
+      hid_draw_set_line_cap (ar_gc, Round_Cap);
     }
 #endif
 
@@ -5407,7 +5407,7 @@ donerouting:
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
     {
-      ddraw->destroy_gc (ar_gc);
+      hid_draw_destroy_gc (ar_gc);
       gui->finish_debug_draw ();
     }
 #endif
diff --git a/src/crosshair.c b/src/crosshair.c
index 78b8111..b74e8bb 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -66,7 +66,7 @@ thindraw_moved_pv (hidGC gc, PinType *pv, Coord x, Coord y)
   moved_pv.X += x;
   moved_pv.Y += y;
 
-  gui->graphics->thindraw_pcb_pv (gc, gc, &moved_pv, true, false);
+  hid_draw_thin_pcb_pv (gc, gc, &moved_pv, true, false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -79,11 +79,10 @@ XORPolygon (hidGC gc, PolygonType *polygon, Coord dx, Coord dy)
   for (i = 0; i < polygon->PointN; i++)
     {
       Cardinal next = next_contour_point (polygon, i);
-      gui->graphics->draw_line (gc,
-                                polygon->Points[i].X + dx,
-                                polygon->Points[i].Y + dy,
-                                polygon->Points[next].X + dx,
-                                polygon->Points[next].Y + dy);
+      hid_draw_line (gc, polygon->Points[i].X + dx,
+                         polygon->Points[i].Y + dy,
+                         polygon->Points[next].X + dx,
+                         polygon->Points[next].Y + dy);
     }
 }
 
@@ -134,12 +133,12 @@ XORDrawAttachedArc (hidGC gc, Coord thick)
   arc.Width = arc.Height = wy;
   bx = GetArcEnds (&arc);
   /*  sa = sa - 180; */
-  gui->graphics->draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
+  hid_draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
   if (wid > pixel_slop)
     {
-      gui->graphics->draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
-      gui->graphics->draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
-      gui->graphics->draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
+      hid_draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
+      hid_draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
+      hid_draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
     }
 }
 
@@ -160,13 +159,13 @@ XORDrawAttachedLine (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2, Coord thi
     h = 0.0;
   ox = dy * h + 0.5 * SGN (dy);
   oy = -(dx * h + 0.5 * SGN (dx));
-  gui->graphics->draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+  hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
   if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
     {
       Angle angle = atan2 (dx, dy) * 57.295779;
-      gui->graphics->draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-      gui->graphics->draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
-      gui->graphics->draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
+      hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+      hid_draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
+      hid_draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
     }
 }
 
@@ -179,46 +178,40 @@ XORDrawElement (hidGC gc, ElementType *Element, Coord DX, Coord DY)
   /* if no silkscreen, draw the bounding box */
   if (Element->ArcN == 0 && Element->LineN == 0)
     {
-      gui->graphics->draw_line (gc,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y1,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (gc,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y2,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (gc,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y2,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y1);
-      gui->graphics->draw_line (gc,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y1,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y1);
+      hid_draw_line (gc, DX + Element->BoundingBox.X1,
+                         DY + Element->BoundingBox.Y1,
+                         DX + Element->BoundingBox.X1,
+                         DY + Element->BoundingBox.Y2);
+      hid_draw_line (gc, DX + Element->BoundingBox.X1,
+                         DY + Element->BoundingBox.Y2,
+                         DX + Element->BoundingBox.X2,
+                         DY + Element->BoundingBox.Y2);
+      hid_draw_line (gc, DX + Element->BoundingBox.X2,
+                         DY + Element->BoundingBox.Y2,
+                         DX + Element->BoundingBox.X2,
+                         DY + Element->BoundingBox.Y1);
+      hid_draw_line (gc, DX + Element->BoundingBox.X2,
+                         DY + Element->BoundingBox.Y1,
+                         DX + Element->BoundingBox.X1,
+                         DY + Element->BoundingBox.Y1);
     }
   else
     {
       ELEMENTLINE_LOOP (Element);
       {
-        gui->graphics->draw_line (gc,
-                                  DX + line->Point1.X,
-                                  DY + line->Point1.Y,
-                                  DX + line->Point2.X,
-                                  DY + line->Point2.Y);
+        hid_draw_line (gc, DX + line->Point1.X,
+                           DY + line->Point1.Y,
+                           DX + line->Point2.X,
+                           DY + line->Point2.Y);
       }
       END_LOOP;
 
       /* arc coordinates and angles have to be converted to X11 notation */
       ARC_LOOP (Element);
       {
-        gui->graphics->draw_arc (gc,
-                                 DX + arc->X,
-                                 DY + arc->Y,
-                                 arc->Width, arc->Height, arc->StartAngle, arc->Delta);
+        hid_draw_arc (gc, DX + arc->X,
+                          DY + arc->Y,
+                          arc->Width, arc->Height, arc->StartAngle, arc->Delta);
       }
       END_LOOP;
     }
@@ -240,31 +233,27 @@ XORDrawElement (hidGC gc, ElementType *Element, Coord DX, Coord DY)
         moved_pad.Point1.X += DX; moved_pad.Point1.Y += DY;
         moved_pad.Point2.X += DX; moved_pad.Point2.Y += DY;
 
-        gui->graphics->thindraw_pcb_pad (gc, &moved_pad, false, false);
+        hid_draw_thin_pcb_pad (gc, &moved_pad, false, false);
       }
   }
   END_LOOP;
   /* mark */
-  gui->graphics->draw_line (gc,
-                            Element->MarkX + DX - EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (gc,
-                            Element->MarkX + DX + EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (gc,
-                            Element->MarkX + DX - EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY + EMARK_SIZE);
-  gui->graphics->draw_line (gc,
-                            Element->MarkX + DX + EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY + EMARK_SIZE);
+  hid_draw_line (gc, Element->MarkX + DX - EMARK_SIZE,
+                     Element->MarkY + DY,
+                     Element->MarkX + DX,
+                     Element->MarkY + DY - EMARK_SIZE);
+  hid_draw_line (gc, Element->MarkX + DX + EMARK_SIZE,
+                     Element->MarkY + DY,
+                     Element->MarkX + DX,
+                     Element->MarkY + DY - EMARK_SIZE);
+  hid_draw_line (gc, Element->MarkX + DX - EMARK_SIZE,
+                     Element->MarkY + DY,
+                     Element->MarkX + DX,
+                     Element->MarkY + DY + EMARK_SIZE);
+  hid_draw_line (gc, Element->MarkX + DX + EMARK_SIZE,
+                     Element->MarkY + DY,
+                     Element->MarkX + DX,
+                     Element->MarkY + DY + EMARK_SIZE);
 }
 
 /* ---------------------------------------------------------------------------
@@ -293,25 +282,21 @@ XORDrawBuffer (hidGC gc, BufferType *Buffer)
 					y +line->Point1.Y, x +line->Point2.X,
 					y +line->Point2.Y, line->Thickness);
 */
-	gui->graphics->draw_line (gc,
-	                          x + line->Point1.X, y + line->Point1.Y,
-	                          x + line->Point2.X, y + line->Point2.Y);
+	hid_draw_line (gc, x + line->Point1.X, y + line->Point1.Y,
+	                   x + line->Point2.X, y + line->Point2.Y);
 	}
 	END_LOOP;
 	ARC_LOOP (layer);
 	{
-	  gui->graphics->draw_arc (gc,
-	                           x + arc->X,
-	                           y + arc->Y,
-	                           arc->Width,
-	                           arc->Height, arc->StartAngle, arc->Delta);
+	  hid_draw_arc (gc, x + arc->X,
+	                    y + arc->Y,
+	                    arc->Width, arc->Height, arc->StartAngle, arc->Delta);
 	}
 	END_LOOP;
 	TEXT_LOOP (layer);
 	{
 	  BoxType *box = &text->BoundingBox;
-	  gui->graphics->draw_rect (gc,
-	                            x + box->X1, y + box->Y1, x + box->X2, y + box->Y2);
+	  hid_draw_rect (gc, x + box->X1, y + box->Y1, x + box->X2, y + box->Y2);
 	}
 	END_LOOP;
 	/* the tmp polygon has n+1 points because the first
@@ -353,8 +338,8 @@ XORDrawInsertPointObject (hidGC gc)
 
   if (Crosshair.AttachedObject.Type != NO_TYPE)
     {
-      gui->graphics->draw_line (gc, point->X, point->Y, line->Point1.X, line->Point1.Y);
-      gui->graphics->draw_line (gc, point->X, point->Y, line->Point2.X, line->Point2.Y);
+      hid_draw_line (gc, point->X, point->Y, line->Point1.X, line->Point1.Y);
+      hid_draw_line (gc, point->X, point->Y, line->Point2.X, line->Point2.Y);
     }
 }
 
@@ -392,10 +377,9 @@ XORDrawMoveOrCopyObject (hidGC gc)
       {
 	ArcType *Arc = (ArcType *) Crosshair.AttachedObject.Ptr2;
 
-	gui->graphics->draw_arc (gc,
-	                         Arc->X + dx,
-	                         Arc->Y + dy,
-	                         Arc->Width, Arc->Height, Arc->StartAngle, Arc->Delta);
+	hid_draw_arc (gc, Arc->X + dx,
+	                  Arc->Y + dy,
+	                  Arc->Width, Arc->Height, Arc->StartAngle, Arc->Delta);
 	break;
       }
 
@@ -442,12 +426,10 @@ XORDrawMoveOrCopyObject (hidGC gc)
 	next = next_contour_point (polygon, point_idx);
 
 	/* draw the two segments */
-	gui->graphics->draw_line (gc,
-	                          polygon->Points[prev].X, polygon->Points[prev].Y,
-	                          point->X + dx, point->Y + dy);
-	gui->graphics->draw_line (gc,
-	                          point->X + dx, point->Y + dy,
-	                          polygon->Points[next].X, polygon->Points[next].Y);
+	hid_draw_line (gc, polygon->Points[prev].X, polygon->Points[prev].Y,
+	                   point->X + dx, point->Y + dy);
+	hid_draw_line (gc, point->X + dx, point->Y + dy,
+	                   polygon->Points[next].X, polygon->Points[next].Y);
 	break;
       }
 
@@ -457,18 +439,15 @@ XORDrawMoveOrCopyObject (hidGC gc)
 	ElementType *element =
 	  (ElementType *) Crosshair.AttachedObject.Ptr1;
 
-	gui->graphics->draw_line (gc,
-	                          element->MarkX,
-	                          element->MarkY, Crosshair.X, Crosshair.Y);
+	hid_draw_line (gc, element->MarkX, element->MarkY,
+	                   Crosshair.X, Crosshair.Y);
 	/* fall through to move the text as a box outline */
       }
     case TEXT_TYPE:
       {
 	TextType *text = (TextType *) Crosshair.AttachedObject.Ptr2;
 	BoxType *box = &text->BoundingBox;
-	gui->graphics->draw_rect (gc,
-	                          box->X1 + dx,
-	                          box->Y1 + dy, box->X2 + dx, box->Y2 + dy);
+	hid_draw_rect (gc, box->X1 + dx, box->Y1 + dy, box->X2 + dx, box->Y2 + dy);
 	break;
       }
 
@@ -526,10 +505,10 @@ XORDrawMoveOrCopyObject (hidGC gc)
 void
 DrawAttached (hidGC gc)
 {
-  gui->graphics->set_color (gc, Settings.CrosshairColor);
-  gui->graphics->set_draw_xor (gc, 1);
-  gui->graphics->set_line_cap (gc, Trace_Cap);
-  gui->graphics->set_line_width (gc, 1);
+  hid_draw_set_color (gc, Settings.CrosshairColor);
+  hid_draw_set_draw_xor (gc, 1);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 1);
 
   switch (Settings.Mode)
     {
@@ -545,16 +524,16 @@ DrawAttached (hidGC gc)
         via.Mask = 0;
         via.Flags = NoFlags ();
 
-        gui->graphics->thindraw_pcb_pv (gc, gc, &via, true, false);
+        hid_draw_thin_pcb_pv (gc, gc, &via, true, false);
 
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             Coord mask_r = Settings.ViaThickness / 2 + PCB->Bloat;
-            gui->graphics->set_color (gc, Settings.CrossColor);
-            gui->graphics->set_line_cap (gc, Round_Cap);
-            gui->graphics->set_line_width (gc, 0);
-            gui->graphics->draw_arc (gc, via.X, via.Y, mask_r, mask_r, 0, 360);
-            gui->graphics->set_color (gc, Settings.CrosshairColor);
+            hid_draw_set_color (gc, Settings.CrossColor);
+            hid_draw_set_line_cap (gc, Round_Cap);
+            hid_draw_set_line_width (gc, 0);
+            hid_draw_arc (gc, via.X, via.Y, mask_r, mask_r, 0, 360);
+            hid_draw_set_color (gc, Settings.CrosshairColor);
           }
         break;
       }
@@ -564,11 +543,10 @@ DrawAttached (hidGC gc)
     case POLYGONHOLE_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
-        gui->graphics->draw_line (gc,
-                                  Crosshair.AttachedLine.Point1.X,
-                                  Crosshair.AttachedLine.Point1.Y,
-                                  Crosshair.AttachedLine.Point2.X,
-                                  Crosshair.AttachedLine.Point2.Y);
+        hid_draw_line (gc, Crosshair.AttachedLine.Point1.X,
+                           Crosshair.AttachedLine.Point1.Y,
+                           Crosshair.AttachedLine.Point2.X,
+                           Crosshair.AttachedLine.Point2.Y);
 
       /* draw attached polygon only if in POLYGON_MODE or POLYGONHOLE_MODE */
       if (Crosshair.AttachedPolygon.PointN > 1)
@@ -583,9 +561,9 @@ DrawAttached (hidGC gc)
 	  XORDrawAttachedArc (gc, Settings.LineThickness);
 	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
 	    {
-	      gui->graphics->set_color (gc, Settings.CrossColor);
+	      hid_draw_set_color (gc, Settings.CrossColor);
 	      XORDrawAttachedArc (gc, Settings.LineThickness + 2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (gc, Settings.CrosshairColor);
+	      hid_draw_set_color (gc, Settings.CrosshairColor);
 	    }
 
 	}
@@ -609,7 +587,7 @@ DrawAttached (hidGC gc)
 	                         PCB->RatDraw ? 10 : Settings.LineThickness);
 	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
 	    {
-	      gui->graphics->set_color (gc, Settings.CrossColor);
+	      hid_draw_set_color (gc, Settings.CrossColor);
 	      XORDrawAttachedLine (gc, Crosshair.AttachedLine.Point1.X,
 	                               Crosshair.AttachedLine.Point1.Y,
 	                           Crosshair.AttachedLine.Point2.X,
@@ -622,7 +600,7 @@ DrawAttached (hidGC gc)
 		                     Crosshair.X, Crosshair.Y,
 		                     PCB->RatDraw ? 10 : Settings.
 		                     LineThickness + 2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (gc, Settings.CrosshairColor);
+	      hid_draw_set_color (gc, Settings.CrosshairColor);
 	    }
 	}
       break;
@@ -651,7 +629,7 @@ DrawAttached (hidGC gc)
       y1 = Crosshair.AttachedBox.Point1.Y;
       x2 = Crosshair.AttachedBox.Point2.X;
       y2 = Crosshair.AttachedBox.Point2.Y;
-      gui->graphics->draw_rect (gc, x1, y1, x2, y2);
+      hid_draw_rect (gc, x1, y1, x2, y2);
     }
 }
 
@@ -662,23 +640,19 @@ DrawAttached (hidGC gc)
 void
 DrawMark (hidGC gc)
 {
-  gui->graphics->set_color (gc, Settings.CrosshairColor);
-  gui->graphics->set_draw_xor (gc, 1);
-  gui->graphics->set_line_cap (gc, Trace_Cap);
-  gui->graphics->set_line_width (gc, 1);
+  hid_draw_set_color (gc, Settings.CrosshairColor);
+  hid_draw_set_draw_xor (gc, 1);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 1);
 
   /* Mark is not drawn when it is not set */
   if (!Marked.status)
     return;
 
-  gui->graphics->draw_line (gc,
-                  Marked.X - MARK_SIZE,
-                  Marked.Y - MARK_SIZE,
-                  Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
-  gui->graphics->draw_line (gc,
-                  Marked.X + MARK_SIZE,
-                  Marked.Y - MARK_SIZE,
-                  Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
+  hid_draw_line (gc, Marked.X - MARK_SIZE, Marked.Y - MARK_SIZE,
+                     Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
+  hid_draw_line (gc, Marked.X + MARK_SIZE, Marked.Y - MARK_SIZE,
+                     Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/draw.c b/src/draw.c
index a87adb4..3083038 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -96,7 +96,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  gui->graphics->set_color (Output.fgGC, color);
+  hid_draw_set_color (Output.fgGC, color);
 }
 
 static void
@@ -167,7 +167,7 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
+  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -178,7 +178,7 @@ _draw_pv_name (PinType *pv)
 
   if (gui->gui)
     doing_pinout++;
-  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (Output.fgGC, &text, 0);
   if (gui->gui)
     doing_pinout--;
 }
@@ -187,9 +187,9 @@ static void
 _draw_pv (PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+    hid_draw_thin_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
   else
-    gui->graphics->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+    hid_draw_fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
 
   if ((!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv)) || doing_pinout)
     _draw_pv_name (pv);
@@ -199,7 +199,7 @@ static void
 draw_pin (PinType *pin, bool draw_hole)
 {
   if (doing_pinout)
-    gui->graphics->set_color (Output.fgGC, PCB->PinColor);
+    hid_draw_set_color (Output.fgGC, PCB->PinColor);
   else
     set_object_color ((AnyObjectType *)pin,
                       PCB->WarnColor, PCB->PinSelectedColor,
@@ -219,7 +219,7 @@ static void
 draw_via (PinType *via, bool draw_hole)
 {
   if (doing_pinout)
-    gui->graphics->set_color (Output.fgGC, PCB->ViaColor);
+    hid_draw_set_color (Output.fgGC, PCB->ViaColor);
   else
     set_object_color ((AnyObjectType *)via,
                       PCB->WarnColor, PCB->ViaSelectedColor,
@@ -265,7 +265,7 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
+  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pin thickness */
@@ -274,7 +274,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (Output.fgGC, &text, 0);
 }
 
 static void
@@ -285,16 +285,16 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) ||
       (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
-    gui->graphics->thindraw_pcb_pad (gc, pad, clear, mask);
+    hid_draw_thin_pcb_pad (gc, pad, clear, mask);
   else
-    gui->graphics->fill_pcb_pad (gc, pad, clear, mask);
+    hid_draw_fill_pcb_pad (gc, pad, clear, mask);
 }
 
 static void
 draw_pad (PadType *pad)
 {
   if (doing_pinout)
-    gui->graphics->set_color (Output.fgGC, PCB->PinColor);
+    hid_draw_set_color (Output.fgGC, PCB->PinColor);
   else
     set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
                       PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
@@ -324,14 +324,14 @@ draw_element_name (ElementType *element)
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
   if (doing_pinout || doing_assy)
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   else
-    gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  gui->graphics->draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+  hid_draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -388,15 +388,14 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          gui->graphics->set_line_cap (Output.fgGC, Round_Cap);
-          gui->graphics->set_line_width (Output.fgGC, 0);
-          gui->graphics->draw_arc (Output.fgGC,
-                                   pv->X, pv->Y, pv->DrillingHole / 2,
-                                   pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
+          hid_draw_set_line_width (Output.fgGC, 0);
+          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
+                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
-    gui->graphics->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+    hid_draw_fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
@@ -404,11 +403,10 @@ hole_callback (const BoxType * b, void *cl)
                         PCB->WarnColor, PCB->ViaSelectedColor,
                         NULL, NULL, Settings.BlackColor);
 
-      gui->graphics->set_line_cap (Output.fgGC, Round_Cap);
-      gui->graphics->set_line_width (Output.fgGC, 0);
-      gui->graphics->draw_arc (Output.fgGC,
-                               pv->X, pv->Y, pv->DrillingHole / 2,
-                               pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
+      hid_draw_set_line_width (Output.fgGC, 0);
+      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
+                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -432,7 +430,7 @@ line_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
 
   set_layer_object_color (layer, (AnyObjectType *) line);
-  gui->graphics->draw_pcb_line (Output.fgGC, line);
+  hid_draw_pcb_line (Output.fgGC, line);
 
   return 1;
 }
@@ -453,14 +451,13 @@ rat_callback (const BoxType * b, void *cl)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        gui->graphics->set_line_width (Output.fgGC, 0);
+        hid_draw_set_line_width (Output.fgGC, 0);
       else
-        gui->graphics->set_line_width (Output.fgGC, w);
-      gui->graphics->draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y,
-                               w * 2, w * 2, 0, 360);
+        hid_draw_set_line_width (Output.fgGC, w);
+      hid_draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    gui->graphics->draw_pcb_line (Output.fgGC, (LineType *) rat);
+    hid_draw_pcb_line (Output.fgGC, (LineType *) rat);
   return 1;
 }
 
@@ -471,7 +468,7 @@ arc_callback (const BoxType * b, void *cl)
   ArcType *arc =  (ArcType *) b;
 
   set_layer_object_color (layer, (AnyObjectType *) arc);
-  gui->graphics->draw_pcb_arc (Output.fgGC, arc);
+  hid_draw_pcb_arc (Output.fgGC, arc);
 
   return 1;
 }
@@ -481,23 +478,23 @@ draw_element_package (ElementType *element)
 {
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   else
-    gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    gui->graphics->draw_pcb_line (Output.fgGC, line);
+    hid_draw_pcb_line (Output.fgGC, line);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    gui->graphics->draw_pcb_arc (Output.fgGC, arc);
+    hid_draw_pcb_arc (Output.fgGC, arc);
   }
   END_LOOP;
 }
@@ -523,9 +520,9 @@ PrintAssembly (int side, const BoxType * drawn_area)
   int side_group = GetLayerGroupNumberBySide (side);
 
   doing_assy = true;
-  gui->graphics->set_draw_faded (Output.fgGC, 1);
+  hid_draw_set_draw_faded (Output.fgGC, 1);
   DrawLayerGroup (side_group, drawn_area);
-  gui->graphics->set_draw_faded (Output.fgGC, 0);
+  hid_draw_set_draw_faded (Output.fgGC, 0);
 
   /* draw package */
   DrawSilk (side, drawn_area);
@@ -711,14 +708,14 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  gui->graphics->set_color (Output.fgGC,
-		  invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  gui->graphics->set_line_cap (Output.fgGC, Trace_Cap);
-  gui->graphics->set_line_width (Output.fgGC, 0);
-  gui->graphics->draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  gui->graphics->draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  gui->graphics->draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  gui->graphics->draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  hid_draw_set_color (Output.fgGC,
+                      invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
+  hid_draw_set_line_width (Output.fgGC, 0);
+  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
+  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
+  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
+  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -727,8 +724,8 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      gui->graphics->draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      gui->graphics->draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      hid_draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
+      hid_draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
     }
 }
 
@@ -777,9 +774,9 @@ clearPin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    gui->graphics->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+    hid_draw_thin_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
   else
-    gui->graphics->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+    hid_draw_fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
   return 1;
 }
 
@@ -796,7 +793,7 @@ poly_callback (const BoxType * b, void *cl)
 
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
 
-  gui->graphics->draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
 
   return 1;
 }
@@ -827,7 +824,7 @@ DrawSilk (int side, const BoxType * drawn_area)
 #if 0
   if (gui->poly_before)
     {
-      gui->graphics->use_mask (HID_MASK_BEFORE);
+      hid_draw_use_mask (gui->graphics, HID_MASK_BEFORE);
 #endif
       DrawLayer (LAYER_PTR (max_copper_layer + side), drawn_area);
       /* draw package */
@@ -836,20 +833,20 @@ DrawSilk (int side, const BoxType * drawn_area)
 #if 0
     }
 
-  gui->graphics->use_mask (HID_MASK_CLEAR);
+  hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
   r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, NULL);
   r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, NULL);
   r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &side);
 
   if (gui->poly_after)
     {
-      gui->graphics->use_mask (HID_MASK_AFTER);
+      hid_draw_use_mask (gui->graphics, HID_MASK_AFTER);
       DrawLayer (LAYER_PTR (max_copper_layer + layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
     }
-  gui->graphics->use_mask (HID_MASK_OFF);
+  hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
 #endif
 }
 
@@ -862,13 +859,13 @@ DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
       (mask_type == HID_MASK_AFTER  && !gui->poly_after))
     return;
 
-  gui->graphics->use_mask (mask_type);
-  gui->graphics->set_color (Output.fgGC, PCB->MaskColor);
+  hid_draw_use_mask (gui->graphics, mask_type);
+  hid_draw_set_color (Output.fgGC, PCB->MaskColor);
   if (drawn_area == NULL)
-    gui->graphics->fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+    hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    gui->graphics->fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                           drawn_area->X2, drawn_area->Y2);
+    hid_draw_fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
+                                     drawn_area->X2, drawn_area->Y2);
 }
 
 /* ---------------------------------------------------------------------------
@@ -880,11 +877,11 @@ DrawMask (int side, const BoxType *screen)
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
 
   if (thin)
-    gui->graphics->set_color (Output.pmGC, PCB->MaskColor);
+    hid_draw_set_color (Output.pmGC, PCB->MaskColor);
   else
     {
       DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      gui->graphics->use_mask (HID_MASK_CLEAR);
+      hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
     }
 
   r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
@@ -892,11 +889,11 @@ DrawMask (int side, const BoxType *screen)
   r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
 
   if (thin)
-    gui->graphics->set_color (Output.pmGC, "erase");
+    hid_draw_set_color (Output.pmGC, "erase");
   else
     {
       DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      gui->graphics->use_mask (HID_MASK_OFF);
+      hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
     }
 }
 
@@ -906,7 +903,7 @@ DrawMask (int side, const BoxType *screen)
 void
 DrawPaste (int side, const BoxType *drawn_area)
 {
-  gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+  hid_draw_set_color (Output.fgGC, PCB->ElementColor);
   ALLPAD_LOOP (PCB->Data);
   {
     if (ON_SIDE (pad, side) && !TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
@@ -931,10 +928,10 @@ DrawRats (const BoxType *drawn_area)
   int can_mask = strcmp(gui->name, "lesstif") == 0;
 
   if (can_mask)
-    gui->graphics->use_mask (HID_MASK_CLEAR);
+    hid_draw_use_mask (gui->graphics, HID_MASK_CLEAR);
   r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
   if (can_mask)
-    gui->graphics->use_mask (HID_MASK_OFF);
+    hid_draw_use_mask (gui->graphics, HID_MASK_OFF);
 }
 
 static int
@@ -945,15 +942,15 @@ text_callback (const BoxType * b, void *cl)
   int min_silk_line;
 
   if (TEST_FLAG (SELECTEDFLAG, text))
-    gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
   else
-    gui->graphics->set_color (Output.fgGC, layer->Color);
+    hid_draw_set_color (Output.fgGC, layer->Color);
   if (layer == &PCB->Data->SILKLAYER ||
       layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  gui->graphics->draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
   return 1;
 }
 
@@ -984,11 +981,9 @@ DrawLayer (LayerType *Layer, const BoxType *screen)
       && (strcmp (Layer->Name, "outline") == 0
 	  || strcmp (Layer->Name, "route") == 0))
     {
-      gui->graphics->set_color (Output.fgGC, Layer->Color);
-      gui->graphics->set_line_width (Output.fgGC, PCB->minWid);
-      gui->graphics->draw_rect (Output.fgGC,
-                                0, 0,
-                                PCB->MaxWidth, PCB->MaxHeight);
+      hid_draw_set_color (Output.fgGC, Layer->Color);
+      hid_draw_set_line_width (Output.fgGC, PCB->minWid);
+      hid_draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
     }
 }
 
@@ -1543,12 +1538,12 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   HID *old_gui = gui;
 
   gui = hid;
-  Output.fgGC = gui->graphics->make_gc ();
-  Output.bgGC = gui->graphics->make_gc ();
-  Output.pmGC = gui->graphics->make_gc ();
+  Output.fgGC = hid_draw_make_gc (hid->graphics);
+  Output.bgGC = hid_draw_make_gc (hid->graphics);
+  Output.pmGC = hid_draw_make_gc (hid->graphics);
 
-  hid->graphics->set_color (Output.pmGC, "erase");
-  hid->graphics->set_color (Output.bgGC, "drill");
+  hid_draw_set_color (Output.pmGC, "erase");
+  hid_draw_set_color (Output.bgGC, "drill");
 
   if (item)
     {
@@ -1559,8 +1554,8 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   else
     DrawEverything (region);
 
-  gui->graphics->destroy_gc (Output.fgGC);
-  gui->graphics->destroy_gc (Output.bgGC);
-  gui->graphics->destroy_gc (Output.pmGC);
+  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (Output.bgGC);
+  hid_draw_destroy_gc (Output.pmGC);
   gui = old_gui;
 }
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index dbd1042..663bdf3 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -10,15 +10,14 @@
 static void
 common_draw_pcb_line (hidGC gc, LineType *line)
 {
-  gui->graphics->set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_cap (gc, Trace_Cap);
   if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (gc, 0);
+    hid_draw_set_line_width (gc, 0);
   else
-    gui->graphics->set_line_width (gc, line->Thickness);
+    hid_draw_set_line_width (gc, line->Thickness);
 
-  gui->graphics->draw_line (gc,
-                            line->Point1.X, line->Point1.Y,
-                            line->Point2.X, line->Point2.Y);
+  hid_draw_line (gc, line->Point1.X, line->Point1.Y,
+                     line->Point2.X, line->Point2.Y);
 }
 
 static void
@@ -28,12 +27,12 @@ common_draw_pcb_arc (hidGC gc, ArcType *arc)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (gc, 0);
+    hid_draw_set_line_width (gc, 0);
   else
-    gui->graphics->set_line_width (gc, arc->Thickness);
-  gui->graphics->set_line_cap (gc, Trace_Cap);
+    hid_draw_set_line_width (gc, arc->Thickness);
+  hid_draw_set_line_cap (gc, Trace_Cap);
 
-  gui->graphics->draw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta);
+  hid_draw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta);
 }
 
 /* ---------------------------------------------------------------------------
@@ -84,7 +83,7 @@ common_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
               newline.Point1.Y += Text->Y;
               newline.Point2.X += Text->X;
               newline.Point2.Y += Text->Y;
-              gui->graphics->draw_pcb_line (gc, &newline);
+              hid_draw_pcb_line (gc, &newline);
             }
 
           /* move on to next cursor position */
@@ -108,9 +107,8 @@ common_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
           defaultsymbol.Y1 += Text->Y;
           defaultsymbol.X2 += Text->X;
           defaultsymbol.Y2 += Text->Y;
-          gui->graphics->fill_rect (gc,
-                                    defaultsymbol.X1, defaultsymbol.Y1,
-                                    defaultsymbol.X2, defaultsymbol.Y2);
+          hid_draw_fill_rect (gc, defaultsymbol.X1, defaultsymbol.Y1,
+                                  defaultsymbol.X2, defaultsymbol.Y2);
 
           /* move on to next cursor position */
           x += size;
@@ -135,7 +133,7 @@ fill_contour (hidGC gc, PLINE *pl)
       y[i++] = v->point[1];
     }
 
-  gui->graphics->fill_polygon (gc, n, x, y);
+  hid_draw_fill_polygon (gc, n, x, y);
 
   free (x);
   free (y);
@@ -148,13 +146,13 @@ thindraw_contour (hidGC gc, PLINE *pl)
   Coord last_x, last_y;
   Coord this_x, this_y;
 
-  gui->graphics->set_line_width (gc, 0);
-  gui->graphics->set_line_cap (gc, Round_Cap);
+  hid_draw_set_line_width (gc, 0);
+  hid_draw_set_line_cap (gc, Round_Cap);
 
   /* If the contour is round, use an arc drawing routine. */
   if (pl->is_round)
     {
-      gui->graphics->draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
+      hid_draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
       return;
     }
 
@@ -171,8 +169,8 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      gui->graphics->draw_line (gc, last_x, last_y, this_x, this_y);
-      // gui->graphics->fill_circle (gc, this_x, this_y, 30);
+      hid_draw_line (gc, last_x, last_y, this_x, this_y);
+      // hid_draw_fill_circle (gc, this_x, this_y, 30);
 
       last_x = this_x;
       last_y = this_y;
@@ -263,9 +261,9 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    gui->graphics->thindraw_pcb_polygon (gc, polygon, clip_box);
+    hid_draw_thin_pcb_polygon (gc, polygon, clip_box);
   else
-    gui->graphics->fill_pcb_polygon (gc, polygon, clip_box);
+    hid_draw_fill_pcb_polygon (gc, polygon, clip_box);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
@@ -275,7 +273,7 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        gui->graphics->thindraw_pcb_polygon (gc, &poly, clip_box);
+        hid_draw_thin_pcb_polygon (gc, &poly, clip_box);
     }
 }
 
@@ -374,8 +372,8 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       x1 = x2; x2 = temp_x;
       y1 = y2; y2 = temp_y;
     }
-  gui->graphics->set_line_cap (gc, Round_Cap);
-  gui->graphics->set_line_width (gc, 0);
+  hid_draw_set_line_cap (gc, Round_Cap);
+  hid_draw_set_line_width (gc, 0);
   if (TEST_FLAG (SQUAREFLAG, pad))
     {
       /* slanted square pad */
@@ -391,14 +389,14 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       tx = t * cos (theta + M_PI / 4) * sqrt (2.0);
       ty = t * sin (theta + M_PI / 4) * sqrt (2.0);
 
-      gui->graphics->draw_line (gc, x1 - tx, y1 - ty, x2 + ty, y2 - tx);
-      gui->graphics->draw_line (gc, x2 + ty, y2 - tx, x2 + tx, y2 + ty);
-      gui->graphics->draw_line (gc, x2 + tx, y2 + ty, x1 - ty, y1 + tx);
-      gui->graphics->draw_line (gc, x1 - ty, y1 + tx, x1 - tx, y1 - ty);
+      hid_draw_line (gc, x1 - tx, y1 - ty, x2 + ty, y2 - tx);
+      hid_draw_line (gc, x2 + ty, y2 - tx, x2 + tx, y2 + ty);
+      hid_draw_line (gc, x2 + tx, y2 + ty, x1 - ty, y1 + tx);
+      hid_draw_line (gc, x1 - ty, y1 + tx, x1 - tx, y1 - ty);
     }
   else if (x1 == x2 && y1 == y2)
     {
-      gui->graphics->draw_arc (gc, x1, y1, t, t, 0, 360);
+      hid_draw_arc (gc, x1, y1, t, t, 0, 360);
     }
   else
     {
@@ -412,14 +410,14 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       ox = dy * h + 0.5 * SGN (dy);
       oy = -(dx * h + 0.5 * SGN (dx));
 
-      gui->graphics->draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+      hid_draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
 
       if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
         {
           Angle angle = atan2 (dx, dy) * 57.295779;
-          gui->graphics->draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-          gui->graphics->draw_arc (gc, x1, y1, t, t, angle - 180, 180);
-          gui->graphics->draw_arc (gc, x2, y2, t, t, angle, 180);
+          hid_draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+          hid_draw_arc (gc, x1, y1, t, t, angle - 180, 180);
+          hid_draw_arc (gc, x2, y2, t, t, angle, 180);
         }
     }
 }
@@ -483,28 +481,27 @@ common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
           b = pad->Point1.Y - w / 2;
           r = l + w;
           t = b + w;
-          gui->graphics->fill_rect (gc, l, b, r, t);
+          hid_draw_fill_rect (gc, l, b, r, t);
         }
       else
         {
-          gui->graphics->fill_circle (gc, pad->Point1.X, pad->Point1.Y, w / 2);
+          hid_draw_fill_circle (gc, pad->Point1.X, pad->Point1.Y, w / 2);
         }
     }
   else
     {
-      gui->graphics->set_line_cap (gc, TEST_FLAG (SQUAREFLAG, pad) ?
-                               Square_Cap : Round_Cap);
-      gui->graphics->set_line_width (gc, w);
+      hid_draw_set_line_cap (gc, TEST_FLAG (SQUAREFLAG, pad) ? Square_Cap : Round_Cap);
+      hid_draw_set_line_width (gc, w);
 
       if (TEST_FLAG (SQUAREFLAG, pad))
         {
           Coord x[4], y[4];
           common_get_pad_polygon (x, y, pad, w);
-          gui->graphics->fill_polygon (gc, 4, x, y);
+          hid_fill_polygon (gc, 4, x, y);
         }
       else
-        gui->graphics->draw_line (gc, pad->Point1.X, pad->Point1.Y,
-                                  pad->Point2.X, pad->Point2.Y);
+        hid_draw_line (gc, pad->Point1.X, pad->Point1.Y,
+                           pad->Point2.X, pad->Point2.Y);
     }
 }
 
@@ -568,16 +565,16 @@ draw_octagon_poly (hidGC gc, Coord X, Coord Y,
   if (thin_draw)
     {
       int i;
-      gui->graphics->set_line_cap (gc, Round_Cap);
-      gui->graphics->set_line_width (gc, 0);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
       polygon_x[8] = X + scaled_x[0];
       polygon_y[8] = Y + scaled_y[0];
       for (i = 0; i < 8; i++)
-        gui->graphics->draw_line (gc, polygon_x[i    ], polygon_y[i    ],
-                            polygon_x[i + 1], polygon_y[i + 1]);
+        hid_draw_line (gc, polygon_x[i    ], polygon_y[i    ],
+                           polygon_x[i + 1], polygon_y[i + 1]);
     }
   else
-    gui->graphics->fill_polygon (gc, 8, polygon_x, polygon_y);
+    hid_draw_fill_polygon (gc, 8, polygon_x, polygon_y);
 }
 
 void
@@ -589,13 +586,13 @@ common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool m
   if (TEST_FLAG (HOLEFLAG, pv))
     {
       if (mask)
-	gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, r);
+	hid_draw_fill_circle (bg_gc, pv->X, pv->Y, r);
       if (drawHole)
         {
-          gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, r);
-          gui->graphics->set_line_cap (fg_gc, Round_Cap);
-          gui->graphics->set_line_width (fg_gc, 0);
-          gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
+          hid_draw_fill_circle (bg_gc, pv->X, pv->Y, r);
+          hid_draw_set_line_cap (fg_gc, Round_Cap);
+          hid_draw_set_line_width (fg_gc, 0);
+          hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
         }
       return;
     }
@@ -607,16 +604,16 @@ common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool m
       Coord r = l + w;
       Coord t = b + w;
 
-      gui->graphics->fill_rect (fg_gc, l, b, r, t);
+      hid_draw_fill_rect (fg_gc, l, b, r, t);
     }
   else if (TEST_FLAG (OCTAGONFLAG, pv))
     draw_octagon_poly (fg_gc, pv->X, pv->Y, w, false);
   else /* draw a round pin or via */
-    gui->graphics->fill_circle (fg_gc, pv->X, pv->Y, r);
+    hid_draw_fill_circle (fg_gc, pv->X, pv->Y, r);
 
   /* and the drilling hole  (which is always round) */
   if (drawHole)
-    gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
+    hid_draw_fill_circle (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
 }
 
 void
@@ -628,13 +625,13 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
   if (TEST_FLAG (HOLEFLAG, pv))
     {
       if (mask)
-	gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
+	hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
       if (drawHole)
         {
 	  r = pv->DrillingHole / 2;
-          gui->graphics->set_line_cap (bg_gc, Round_Cap);
-          gui->graphics->set_line_width (bg_gc, 0);
-          gui->graphics->draw_arc (bg_gc, pv->X, pv->Y, r, r, 0, 360);
+          hid_draw_set_line_cap (bg_gc, Round_Cap);
+          hid_draw_set_line_width (bg_gc, 0);
+          hid_draw_arc (bg_gc, pv->X, pv->Y, r, r, 0, 360);
         }
       return;
     }
@@ -646,12 +643,12 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
       Coord r = l + w;
       Coord t = b + w;
 
-      gui->graphics->set_line_cap (fg_gc, Round_Cap);
-      gui->graphics->set_line_width (fg_gc, 0);
-      gui->graphics->draw_line (fg_gc, r, t, r, b);
-      gui->graphics->draw_line (fg_gc, l, t, l, b);
-      gui->graphics->draw_line (fg_gc, r, t, l, t);
-      gui->graphics->draw_line (fg_gc, r, b, l, b);
+      hid_draw_set_line_cap (fg_gc, Round_Cap);
+      hid_draw_set_line_width (fg_gc, 0);
+      hid_draw_line (fg_gc, r, t, r, b);
+      hid_draw_line (fg_gc, l, t, l, b);
+      hid_draw_line (fg_gc, r, t, l, t);
+      hid_draw_line (fg_gc, r, b, l, b);
 
     }
   else if (TEST_FLAG (OCTAGONFLAG, pv))
@@ -660,18 +657,18 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
     }
   else /* draw a round pin or via */
     {
-      gui->graphics->set_line_cap (fg_gc, Round_Cap);
-      gui->graphics->set_line_width (fg_gc, 0);
-      gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
+      hid_draw_set_line_cap (fg_gc, Round_Cap);
+      hid_draw_set_line_width (fg_gc, 0);
+      hid_draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
     }
 
   /* and the drilling hole  (which is always round */
   if (drawHole)
     {
-      gui->graphics->set_line_cap (bg_gc, Round_Cap);
-      gui->graphics->set_line_width (bg_gc, 0);
-      gui->graphics->draw_arc (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2,
-                     pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (bg_gc, Round_Cap);
+      hid_draw_set_line_width (bg_gc, 0);
+      hid_draw_arc (bg_gc, pv->X, pv->Y,
+                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
 }
 
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 3a1575a..153b2e4 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -915,19 +915,19 @@ gerber_set_layer (const char *name, int group, int empty)
 	DrawLayer (outline_layer, &region);
       else if (!outline_layer)
 	{
-	  hidGC gc = gui->graphics->make_gc ();
+	  hidGC gc = hid_draw_make_gc (&gerber_graphics);
 	  printf("name %s idx %d\n", name, idx);
 	  if (SL_TYPE (idx) == SL_SILK)
-	    gui->graphics->set_line_width (gc, PCB->minSlk);
+	    hid_draw_set_line_width (gc, PCB->minSlk);
 	  else if (group >= 0)
-	    gui->graphics->set_line_width (gc, PCB->minWid);
+	    hid_draw_set_line_width (gc, PCB->minWid);
 	  else
-	    gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
-	  gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-	  gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->destroy_gc (gc);
+	    hid_draw_set_line_width (gc, AUTO_OUTLINE_WIDTH);
+	  hid_draw_line (gc, 0, 0, PCB->MaxWidth, 0);
+	  hid_draw_line (gc, 0, 0, 0, PCB->MaxHeight);
+	  hid_draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+	  hid_draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
+	  hid_draw_destroy_gc (gc);
 	}
     }
 
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index d3fd3ff..e3396e5 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -1054,7 +1054,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
   /* Init any GC's required */
   port->render_priv = g_new0 (render_priv, 1);
-  port->render_priv->crosshair_gc = gui->graphics->make_gc ();
+  port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
 }
 
 void
@@ -1062,7 +1062,7 @@ ghid_shutdown_renderer (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
 
-  gui->graphics->destroy_gc (priv->crosshair_gc);
+  hid_draw_destroy_gc (priv->crosshair_gc);
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
   port->render_priv = NULL;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 68cdd3d..3cd7e92 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -600,7 +600,7 @@ ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   common_thindraw_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, 0.25);
-  gui->graphics->fill_pcb_polygon (gc, poly, clip_box);
+  hid_draw_fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, 1.0);
 }
 
@@ -785,7 +785,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   render_priv *priv;
 
   port->render_priv = priv = g_new0 (render_priv, 1);
-  port->render_priv->crosshair_gc = gui->graphics->make_gc ();
+  port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
 
   priv->time_since_expose = g_timer_new ();
 
@@ -812,7 +812,7 @@ ghid_shutdown_renderer (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
 
-  gui->graphics->destroy_gc (priv->crosshair_gc);
+  hid_draw_destroy_gc (priv->crosshair_gc);
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
   port->render_priv = NULL;
diff --git a/src/print.c b/src/print.c
index bf92dee..5646217 100644
--- a/src/print.c
+++ b/src/print.c
@@ -76,14 +76,14 @@
 static void
 fab_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gui->graphics->draw_line (gc, x1, y1, x2, y2);
+  hid_draw_line (gc, x1, y1, x2, y2);
 }
 
 static void
 fab_circle (hidGC gc, int x, int y, int r)
 {
-  gui->graphics->draw_arc (gc, x, y, r, r, 0, 180);
-  gui->graphics->draw_arc (gc, x, y, r, r, 180, 180);
+  hid_draw_arc (gc, x, y, r, r, 0, 180);
+  hid_draw_arc (gc, x, y, r, r, 180, 180);
 }
 
 /* align is 0=left, 1=center, 2=right, add 8 for underline */
@@ -111,7 +111,7 @@ text_at (hidGC gc, int x, int y, int align, char *fmt, ...)
   t.X -= w * (align & 3) / 2;
   if (t.X < 0)
     t.X = 0;
-  gui->graphics->draw_pcb_text (gc, &t, 0);
+  hid_draw_pcb_text (gc, &t, 0);
   if (align & 8)
     fab_line (gc, t.X,
               t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10),
@@ -238,7 +238,7 @@ PrintFab (hidGC gc)
       yoff -= (4 - ds) * TEXT_LINE;
     }
 
-  gui->graphics->set_line_width (gc, FAB_LINE_W);
+  hid_draw_set_line_width (gc, FAB_LINE_W);
 
   for (n = AllDrills->DrillN - 1; n >= 0; n--)
     {
@@ -248,7 +248,7 @@ PrintFab (hidGC gc)
 	plated_sym = --ds;
       if (drill->UnplatedCount)
 	unplated_sym = --ds;
-      gui->graphics->set_color (gc, PCB->PinColor);
+      hid_draw_set_color (gc, PCB->PinColor);
       for (i = 0; i < drill->PinN; i++)
 	drill_sym (gc, TEST_FLAG (HOLEFLAG, drill->Pin[i]) ?
 		   unplated_sym : plated_sym, drill->Pin[i]->X,
@@ -269,7 +269,7 @@ PrintFab (hidGC gc)
 	  text_at (gc, MIL_TO_COORD(1400), yoff, MIL_TO_COORD(2), "NO");
 	  text_at (gc, MIL_TO_COORD(980), yoff, MIL_TO_COORD(2), "%d", drill->UnplatedCount);
 	}
-      gui->graphics->set_color (gc, PCB->ElementColor);
+      hid_draw_set_color (gc, PCB->ElementColor);
       text_at (gc, MIL_TO_COORD(450), yoff, MIL_TO_COORD(2), "%0.3f",
 	       COORD_TO_INCH(drill->DrillSize));
       if (plated_sym != -1 && unplated_sym != -1)
@@ -280,7 +280,7 @@ PrintFab (hidGC gc)
       total_drills += drill->ViaCount;
     }
 
-  gui->graphics->set_color (gc, PCB->ElementColor);
+  hid_draw_set_color (gc, PCB->ElementColor);
   text_at (gc, 0, yoff, MIL_TO_COORD(9), "Symbol");
   text_at (gc, MIL_TO_COORD(410), yoff, MIL_TO_COORD(9), "Diam. (Inch)");
   text_at (gc, MIL_TO_COORD(950), yoff, MIL_TO_COORD(9), "Count");
@@ -310,15 +310,13 @@ PrintFab (hidGC gc)
     }
   if (i == max_copper_layer)
     {
-      gui->graphics->set_line_width (gc,  MIL_TO_COORD(10));
-      gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-      gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-      gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth,
-		      PCB->MaxHeight);
-      gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth,
-		      PCB->MaxHeight);
+      hid_draw_set_line_width (gc,  MIL_TO_COORD(10));
+      hid_draw_line (gc, 0, 0, PCB->MaxWidth, 0);
+      hid_draw_line (gc, 0, 0, 0, PCB->MaxHeight);
+      hid_draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+      hid_draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
       /*FPrintOutline (); */
-      gui->graphics->set_line_width (gc, FAB_LINE_W);
+      hid_draw_set_line_width (gc, FAB_LINE_W);
       text_at (gc, MIL_TO_COORD(2000), yoff, 0,
 	       "Maximum Dimensions: %f mils wide, %f mils high",
 	       COORD_TO_MIL(PCB->MaxWidth), COORD_TO_MIL(PCB->MaxHeight));
@@ -330,25 +328,25 @@ PrintFab (hidGC gc)
   else
     {
       LayerType *layer = LAYER_PTR (i);
-      gui->graphics->set_line_width (gc, MIL_TO_COORD(10));
+      hid_draw_set_line_width (gc, MIL_TO_COORD(10));
       LINE_LOOP (layer);
       {
-	gui->graphics->draw_line (gc, line->Point1.X, line->Point1.Y,
-			line->Point2.X, line->Point2.Y);
+        hid_draw_line (gc, line->Point1.X, line->Point1.Y,
+                           line->Point2.X, line->Point2.Y);
       }
       END_LOOP;
       ARC_LOOP (layer);
       {
-	gui->graphics->draw_arc (gc, arc->X, arc->Y, arc->Width,
-		       arc->Height, arc->StartAngle, arc->Delta);
+        hid_draw_arc (gc, arc->X, arc->Y,
+                      arc->Width, arc->Height, arc->StartAngle, arc->Delta);
       }
       END_LOOP;
       TEXT_LOOP (layer);
       {
-	gui->graphics->draw_pcb_text (gc, text, 0);
+        hid_draw_pcb_text (gc, text, 0);
       }
       END_LOOP;
-      gui->graphics->set_line_width (gc, FAB_LINE_W);
+      hid_draw_set_line_width (gc, FAB_LINE_W);
       text_at (gc, PCB->MaxWidth / 2, PCB->MaxHeight + MIL_TO_COORD(20), 1,
 	       "Board outline is the centerline of this path");
     }
