Bottom: 41a22104874dc6feac22cc5465eda5e878e9a01c
Top:    47291a78c6d17a653033126ba51d8f49fb65e14f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-07 10:16:11 +0000

Profile NoHoles dicer, and add some warnings about longjmp badness


---

diff --git a/src/polygon.c b/src/polygon.c
index 10445ad..0f2d430 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -81,6 +81,7 @@ dicer output is used for HIDs which cannot render things with holes
 #include <memory.h>
 #include <setjmp.h>
 #include <glib.h>
+#include <time.h>
 
 #include "global.h"
 #include "box.h"
@@ -203,12 +204,21 @@ add_noholes_polyarea (PLINE *pline, void *user_data)
 void
 ComputeNoHoles (PolygonType *poly)
 {
+  clock_t start, end;
+  double elapsed;
+
+  start = clock();
+
   poly_FreeContours (&poly->NoHoles);
   if (poly->Clipped)
     NoHolesPolygonDicer (poly, NULL, add_noholes_polyarea, poly);
   else
     printf ("Compute_noholes caught poly->Clipped = NULL\n");
   poly->NoHolesValid = 1;
+
+  end = clock();
+  elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
+  printf ("Computing NoHoles polygons took %f\n", elapsed);
 }
 
 static POLYAREA *
diff --git a/src/polygon1.c b/src/polygon1.c
index e3e9c6b..1a17f03 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -867,6 +867,7 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.X2 = pa->xmax + 1;
       sb.Y2 = pa->ymax + 1;
 
+//      printf ("Searching B's contours using an rtree\n");
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
       if (c_info.need_restart)
 	need_restart = 1;
@@ -2231,7 +2232,7 @@ Touching (POLYAREA * a, POLYAREA * b)
 	return -1;
 #endif
       M_POLYAREA_intersect (&e, a, b, false);
-
+#warning Do we end up leaving uncleared labels on our polygons? (Does this mess up the new clipping code?)
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
       if (M_POLYAREA_label (b, a, TRUE))
@@ -2374,6 +2375,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
       InsertHoles (&e, *res, &holes);
     }
+#warning holes may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   /* delete holes if any left */
   while ((p = holes) != NULL)
     {
@@ -2479,6 +2481,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       poly_Free (&b);
       assert (poly_Valid (*aminusb));
     }
+#warning holes may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   /* delete holes if any left */
   while ((p = holes) != NULL)
     {
@@ -2486,7 +2489,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       poly_DelContour (&p);
     }
 
-
+#warning aand, aminsus may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   if (code)
     {
       poly_Free (aandb);
