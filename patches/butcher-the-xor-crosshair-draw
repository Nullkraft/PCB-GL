Bottom: b97da33cc37ade9f9a0b4989df5d99959859493d
Top:    794a7ccd18fea22a0006c5b1e8a9c8d11e7e13b3
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-20 03:20:45 +0000

Butcher the XOR / Crosshair drawing code


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 269ee78..3649c17 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -61,6 +61,9 @@ PCB_SRCS = \
 	dolists.h \
 	draw.c \
 	draw.h \
+	draw_api.h \
+	outline_draw.c \
+	outline_draw.h \
 	drill.c \
 	drill.h \
 	edif.y \
diff --git a/src/crosshair.c b/src/crosshair.c
index 1f4eb3f..90eb5f2 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -52,444 +52,206 @@
 #include <dmalloc.h>
 #endif
 
-typedef struct
-{
-  int x, y;
-} point;
-
-/* ---------------------------------------------------------------------------
- * some local prototypes
- */
-static void XORPolygon (PolygonType *, Coord, Coord);
-static void XORDrawElement (ElementType *, Coord, Coord);
-static void XORDrawBuffer (BufferType *);
-static void XORDrawInsertPointObject (void);
-static void XORDrawMoveOrCopyObject (void);
-static void XORDrawAttachedLine (Coord, Coord, Coord, Coord, Coord);
-static void XORDrawAttachedArc (Coord);
-
-static void
-thindraw_moved_pv (PinType *pv, Coord x, Coord y)
-{
-  /* Make a copy of the pin structure, moved to the correct position */
-  PinType moved_pv = *pv;
-  moved_pv.X += x;
-  moved_pv.Y += y;
 
-  gui->graphics->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &moved_pv, true, false);
-}
-
-/* ---------------------------------------------------------------------------
- * creates a tmp polygon with coordinates converted to screen system
- */
-static void
-XORPolygon (PolygonType *polygon, Coord dx, Coord dy)
-{
-  Cardinal i;
-  for (i = 0; i < polygon->PointN; i++)
-    {
-      Cardinal next = next_contour_point (polygon, i);
-      gui->graphics->draw_line (Crosshair.GC,
-                                polygon->Points[i].X + dx,
-                                polygon->Points[i].Y + dy,
-                                polygon->Points[next].X + dx,
-                                polygon->Points[next].Y + dy);
-    }
-}
-
-/*-----------------------------------------------------------
- * Draws the outline of an arc
- */
-static void
-XORDrawAttachedArc (Coord thick)
+static bool
+make_arc_from_crosshair (ArcType *arc, Coord thick)
 {
-  ArcType arc;
-  BoxType *bx;
   Coord wx, wy;
   Angle sa, dir;
-  Coord wid = thick / 2;
 
   wx = Crosshair.X - Crosshair.AttachedBox.Point1.X;
   wy = Crosshair.Y - Crosshair.AttachedBox.Point1.Y;
+
   if (wx == 0 && wy == 0)
-    return;
-  arc.X = Crosshair.AttachedBox.Point1.X;
-  arc.Y = Crosshair.AttachedBox.Point1.Y;
+    return false;
+
+  memset (arc, 0, sizeof (*arc));
+
+  arc->X = Crosshair.AttachedBox.Point1.X;
+  arc->Y = Crosshair.AttachedBox.Point1.Y;
+
   if (XOR (Crosshair.AttachedBox.otherway, abs (wy) > abs (wx)))
     {
-      arc.X = Crosshair.AttachedBox.Point1.X + abs (wy) * SGNZ (wx);
+      arc->X = Crosshair.AttachedBox.Point1.X + abs (wy) * SGNZ (wx);
       sa = (wx >= 0) ? 0 : 180;
 #ifdef ARC45
       if (abs (wy) >= 2 * abs (wx))
-	dir = (SGNZ (wx) == SGNZ (wy)) ? 45 : -45;
+        dir = (SGNZ (wx) == SGNZ (wy)) ? 45 : -45;
       else
 #endif
-	dir = (SGNZ (wx) == SGNZ (wy)) ? 90 : -90;
+        dir = (SGNZ (wx) == SGNZ (wy)) ? 90 : -90;
     }
   else
     {
-      arc.Y = Crosshair.AttachedBox.Point1.Y + abs (wx) * SGNZ (wy);
+      arc->Y = Crosshair.AttachedBox.Point1.Y + abs (wx) * SGNZ (wy);
       sa = (wy >= 0) ? -90 : 90;
 #ifdef ARC45
       if (abs (wx) >= 2 * abs (wy))
-	dir = (SGNZ (wx) == SGNZ (wy)) ? -45 : 45;
+        dir = (SGNZ (wx) == SGNZ (wy)) ? -45 : 45;
       else
 #endif
-	dir = (SGNZ (wx) == SGNZ (wy)) ? -90 : 90;
+        dir = (SGNZ (wx) == SGNZ (wy)) ? -90 : 90;
       wy = wx;
     }
-  wy = abs (wy);
-  arc.StartAngle = sa;
-  arc.Delta = dir;
-  arc.Width = arc.Height = wy;
-  bx = GetArcEnds (&arc);
-  /*  sa = sa - 180; */
-  gui->graphics->draw_arc (Crosshair.GC, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
-  if (wid > pixel_slop)
-    {
-      gui->graphics->draw_arc (Crosshair.GC, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
-      gui->graphics->draw_arc (Crosshair.GC, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
-      gui->graphics->draw_arc (Crosshair.GC, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
-    }
-}
-
-/*-----------------------------------------------------------
- * Draws the outline of a line
- */
-static void
-XORDrawAttachedLine (Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
-{
-  Coord dx, dy, ox, oy;
-  double h;
-
-  dx = x2 - x1;
-  dy = y2 - y1;
-  if (dx != 0 || dy != 0)
-    h = 0.5 * thick / sqrt (SQUARE (dx) + SQUARE (dy));
-  else
-    h = 0.0;
-  ox = dy * h + 0.5 * SGN (dy);
-  oy = -(dx * h + 0.5 * SGN (dx));
-  gui->graphics->draw_line (Crosshair.GC, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
-  if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
-    {
-      Angle angle = atan2 (dx, dy) * 57.295779;
-      gui->graphics->draw_line (Crosshair.GC, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-      gui->graphics->draw_arc (Crosshair.GC, x1, y1, thick / 2, thick / 2, angle - 180, 180);
-      gui->graphics->draw_arc (Crosshair.GC, x2, y2, thick / 2, thick / 2, angle, 180);
-    }
-}
 
-/* ---------------------------------------------------------------------------
- * draws the elements of a loaded circuit which is to be merged in
- */
-static void
-XORDrawElement (ElementType *Element, Coord DX, Coord DY)
-{
-  /* if no silkscreen, draw the bounding box */
-  if (Element->ArcN == 0 && Element->LineN == 0)
-    {
-      gui->graphics->draw_line (Crosshair.GC,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y1,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (Crosshair.GC,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y2,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (Crosshair.GC,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y2,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y1);
-      gui->graphics->draw_line (Crosshair.GC,
-                                DX + Element->BoundingBox.X2,
-                                DY + Element->BoundingBox.Y1,
-                                DX + Element->BoundingBox.X1,
-                                DY + Element->BoundingBox.Y1);
-    }
-  else
-    {
-      ELEMENTLINE_LOOP (Element);
-      {
-        gui->graphics->draw_line (Crosshair.GC,
-                                  DX + line->Point1.X,
-                                  DY + line->Point1.Y,
-                                  DX + line->Point2.X,
-                                  DY + line->Point2.Y);
-      }
-      END_LOOP;
-
-      /* arc coordinates and angles have to be converted to X11 notation */
-      ARC_LOOP (Element);
-      {
-        gui->graphics->draw_arc (Crosshair.GC,
-                                 DX + arc->X,
-                                 DY + arc->Y,
-                                 arc->Width, arc->Height, arc->StartAngle, arc->Delta);
-      }
-      END_LOOP;
-    }
-  /* pin coordinates and angles have to be converted to X11 notation */
-  PIN_LOOP (Element);
-  {
-    thindraw_moved_pv (pin, DX, DY);
-  }
-  END_LOOP;
-
-  /* pads */
-  PAD_LOOP (Element);
-  {
-    if (PCB->InvisibleObjectsOn ||
-        (TEST_FLAG (ONSOLDERFLAG, pad) != 0) == Settings.ShowSolderSide)
-      {
-        /* Make a copy of the pad structure, moved to the correct position */
-        PadType moved_pad = *pad;
-        moved_pad.Point1.X += DX; moved_pad.Point1.Y += DY;
-        moved_pad.Point2.X += DX; moved_pad.Point2.Y += DY;
+  wy = abs (wy);
+  arc->StartAngle = sa;
+  arc->Delta = dir;
+  arc->Width = arc->Height = wy;
+  arc->Thickness = thick;
 
-        gui->graphics->thindraw_pcb_pad (Crosshair.GC, &moved_pad, false, false);
-      }
-  }
-  END_LOOP;
-  /* mark */
-  gui->graphics->draw_line (Crosshair.GC,
-                            Element->MarkX + DX - EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
-                            Element->MarkX + DX + EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
-                            Element->MarkX + DX - EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY + EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
-                            Element->MarkX + DX + EMARK_SIZE,
-                            Element->MarkY + DY,
-                            Element->MarkX + DX,
-                            Element->MarkY + DY + EMARK_SIZE);
+  return true;
 }
 
 /* ---------------------------------------------------------------------------
- * draws all visible and attached objects of the pastebuffer
+ * draws the rubberband to insert points into polygons/lines/...
  */
 static void
-XORDrawBuffer (BufferType *Buffer)
+XORDrawInsertPointObject (DrawAPI *dapi)
 {
-  Cardinal i;
-  Coord x, y;
-
-  /* set offset */
-  x = Crosshair.X - Buffer->X;
-  y = Crosshair.Y - Buffer->Y;
-
-  /* draw all visible layers */
-  for (i = 0; i < max_copper_layer + 2; i++)
-    if (PCB->Data->Layer[i].On)
-      {
-	LayerType *layer = &Buffer->Data->Layer[i];
+  LineType *line;
+  PointType *point;
 
-	LINE_LOOP (layer);
-	{
-/*
-				XORDrawAttachedLine(x +line->Point1.X,
-					y +line->Point1.Y, x +line->Point2.X,
-					y +line->Point2.Y, line->Thickness);
-*/
-	gui->graphics->draw_line (Crosshair.GC,
-	                          x + line->Point1.X, y + line->Point1.Y,
-	                          x + line->Point2.X, y + line->Point2.Y);
-	}
-	END_LOOP;
-	ARC_LOOP (layer);
-	{
-	  gui->graphics->draw_arc (Crosshair.GC,
-	                           x + arc->X,
-	                           y + arc->Y,
-	                           arc->Width,
-	                           arc->Height, arc->StartAngle, arc->Delta);
-	}
-	END_LOOP;
-	TEXT_LOOP (layer);
-	{
-	  BoxType *box = &text->BoundingBox;
-	  gui->graphics->draw_rect (Crosshair.GC,
-	                            x + box->X1, y + box->Y1, x + box->X2, y + box->Y2);
-	}
-	END_LOOP;
-	/* the tmp polygon has n+1 points because the first
-	 * and the last one are set to the same coordinates
-	 */
-	POLYGON_LOOP (layer);
-	{
-	  XORPolygon (polygon, x, y);
-	}
-	END_LOOP;
-      }
+  line  = (LineType  *)Crosshair.AttachedObject.Ptr2;
+  point = (PointType *)Crosshair.AttachedObject.Ptr3;
 
-  /* draw elements if visible */
-  if (PCB->PinOn && PCB->ElementOn)
-    ELEMENT_LOOP (Buffer->Data);
-  {
-    if (FRONT (element) || PCB->InvisibleObjectsOn)
-      XORDrawElement (element, x, y);
-  }
-  END_LOOP;
-
-  /* and the vias */
-  if (PCB->ViaOn)
-    VIA_LOOP (Buffer->Data);
-  {
-    thindraw_moved_pv (via, x, y);
-  }
-  END_LOOP;
-}
-
-/* ---------------------------------------------------------------------------
- * draws the rubberband to insert points into polygons/lines/...
- */
-static void
-XORDrawInsertPointObject (void)
-{
-  LineType *line = (LineType *) Crosshair.AttachedObject.Ptr2;
-  PointType *point = (PointType *) Crosshair.AttachedObject.Ptr3;
+  if (Crosshair.AttachedObject.Type == NO_TYPE)
+    return;
 
-  if (Crosshair.AttachedObject.Type != NO_TYPE)
-    {
-      gui->graphics->draw_line (Crosshair.GC, point->X, point->Y, line->Point1.X, line->Point1.Y);
-      gui->graphics->draw_line (Crosshair.GC, point->X, point->Y, line->Point2.X, line->Point2.Y);
-    }
+  dapi->graphics->draw_line (dapi->gc, point->X, point->Y, line->Point1.X, line->Point1.Y);
+  dapi->graphics->draw_line (dapi->gc, point->X, point->Y, line->Point2.X, line->Point2.Y);
 }
 
 /* ---------------------------------------------------------------------------
  * draws the attached object while in MOVE_MODE or COPY_MODE
  */
 static void
-XORDrawMoveOrCopyObject (void)
+draw_move_or_copy_object (DrawAPI *dapi)
 {
   RubberbandType *ptr;
   Cardinal i;
-  Coord dx = Crosshair.X - Crosshair.AttachedObject.X,
-    dy = Crosshair.Y - Crosshair.AttachedObject.Y;
+  Coord dx, dy;
+
+  dx = Crosshair.X - Crosshair.AttachedObject.X;
+  dy = Crosshair.Y - Crosshair.AttachedObject.Y;
+
+  /* NB: We don't reset this.. other rendering routines are expected to do so before
+   *     they draw, so we will have to make some distinction as to which routines may
+   *     set this (and not call them from inside one another!)
+   */
+  // dapi->set_draw_offset (dapi, dx, dy);
 
   switch (Crosshair.AttachedObject.Type)
     {
     case VIA_TYPE:
       {
-        PinType *via = (PinType *) Crosshair.AttachedObject.Ptr1;
-        thindraw_moved_pv (via, dx, dy);
+        PinType *via = (PinType *)Crosshair.AttachedObject.Ptr1;
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_via (dapi, via);
         break;
       }
 
     case LINE_TYPE:
       {
-	LineType *line = (LineType *) Crosshair.AttachedObject.Ptr2;
-
-	XORDrawAttachedLine (line->Point1.X + dx, line->Point1.Y + dy,
-			     line->Point2.X + dx, line->Point2.Y + dy,
-			     line->Thickness);
-	break;
+        LineType *line = (LineType *)Crosshair.AttachedObject.Ptr2;
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_line (dapi, NULL, line);
+        break;
       }
 
     case ARC_TYPE:
       {
-	ArcType *Arc = (ArcType *) Crosshair.AttachedObject.Ptr2;
-
-	gui->graphics->draw_arc (Crosshair.GC,
-	                         Arc->X + dx,
-	                         Arc->Y + dy,
-	                         Arc->Width, Arc->Height, Arc->StartAngle, Arc->Delta);
-	break;
+        ArcType *arc = (ArcType *)Crosshair.AttachedObject.Ptr2;
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_arc (dapi, NULL, arc);
+        break;
       }
 
     case POLYGON_TYPE:
       {
-	PolygonType *polygon =
-	  (PolygonType *) Crosshair.AttachedObject.Ptr2;
-
-	/* the tmp polygon has n+1 points because the first
-	 * and the last one are set to the same coordinates
-	 */
-	XORPolygon (polygon, dx, dy);
-	break;
+        PolygonType *poly = (PolygonType *)Crosshair.AttachedObject.Ptr2;
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_polygon (dapi, NULL, poly);
+        break;
       }
 
     case LINEPOINT_TYPE:
       {
-	LineType *line;
-	PointType *point;
-
-	line = (LineType *) Crosshair.AttachedObject.Ptr2;
-	point = (PointType *) Crosshair.AttachedObject.Ptr3;
-	if (point == &line->Point1)
-	  XORDrawAttachedLine (point->X + dx,
-			       point->Y + dy, line->Point2.X,
-			       line->Point2.Y, line->Thickness);
-	else
-	  XORDrawAttachedLine (point->X + dx,
-			       point->Y + dy, line->Point1.X,
-			       line->Point1.Y, line->Thickness);
-	break;
+        PointType *point   = (PointType *) Crosshair.AttachedObject.Ptr3;
+        LineType *old_line = (LineType  *) Crosshair.AttachedObject.Ptr2;
+        LineType draw_line = *old_line;
+
+        if (point == &old_line->Point1)
+          {
+            draw_line.Point1.X += dx;
+            draw_line.Point1.Y += dy;
+          }
+        else
+          {
+            draw_line.Point2.X += dx;
+            draw_line.Point2.Y += dy;
+          }
+
+        dapi->draw_pcb_line (dapi, NULL, &draw_line);
+        break;
       }
 
     case POLYGONPOINT_TYPE:
       {
-	PolygonType *polygon;
-	PointType *point;
-	Cardinal point_idx, prev, next;
-
-	polygon = (PolygonType *) Crosshair.AttachedObject.Ptr2;
-	point = (PointType *) Crosshair.AttachedObject.Ptr3;
-	point_idx = polygon_point_idx (polygon, point);
-
-	/* get previous and following point */
-	prev = prev_contour_point (polygon, point_idx);
-	next = next_contour_point (polygon, point_idx);
-
-	/* draw the two segments */
-	gui->graphics->draw_line (Crosshair.GC,
-	                          polygon->Points[prev].X, polygon->Points[prev].Y,
-	                          point->X + dx, point->Y + dy);
-	gui->graphics->draw_line (Crosshair.GC,
-	                          point->X + dx, point->Y + dy,
-	                          polygon->Points[next].X, polygon->Points[next].Y);
-	break;
+        PolygonType *polygon;
+        PointType *point;
+        Cardinal point_idx, prev, next;
+
+        polygon = (PolygonType *) Crosshair.AttachedObject.Ptr2;
+        point = (PointType *) Crosshair.AttachedObject.Ptr3;
+        point_idx = polygon_point_idx (polygon, point);
+
+        /* get previous and following point */
+        prev = prev_contour_point (polygon, point_idx);
+        next = next_contour_point (polygon, point_idx);
+
+        /* XXX: Could do this by adjusting a copy polygon and drawing the entirity of that */
+
+        /* draw the two segments */
+        dapi->graphics->draw_line (dapi->gc,
+                                   polygon->Points[prev].X, polygon->Points[prev].Y,
+                                   point->X + dx, point->Y + dy);
+        dapi->graphics->draw_line (dapi->gc,
+                                   point->X + dx, point->Y + dy,
+                                   polygon->Points[next].X, polygon->Points[next].Y);
+        break;
       }
 
     case ELEMENTNAME_TYPE:
       {
-	/* locate the element "mark" and draw an association line from crosshair to it */
-	ElementType *element =
-	  (ElementType *) Crosshair.AttachedObject.Ptr1;
-
-	gui->graphics->draw_line (Crosshair.GC,
-	                          element->MarkX,
-	                          element->MarkY, Crosshair.X, Crosshair.Y);
-	/* fall through to move the text as a box outline */
+        /* locate the element "mark" and draw an association line from crosshair to it */
+        ElementType *element = (ElementType *) Crosshair.AttachedObject.Ptr1;
+
+        dapi->graphics->draw_line (dapi->gc, element->MarkX, element->MarkY, Crosshair.X, Crosshair.Y);
+        /* fall through to move the text as a box outline */
       }
     case TEXT_TYPE:
       {
-	TextType *text = (TextType *) Crosshair.AttachedObject.Ptr2;
-	BoxType *box = &text->BoundingBox;
-	gui->graphics->draw_rect (Crosshair.GC,
-	                          box->X1 + dx,
-	                          box->Y1 + dy, box->X2 + dx, box->Y2 + dy);
-	break;
+        TextType *text = (TextType *) Crosshair.AttachedObject.Ptr2;
+        BoxType *box = &text->BoundingBox;
+
+        dapi->set_draw_offset (dapi, dx, dy);
+        /* XXX: DOES THIS WORK IN CONJUNCTION WITH THE ABOVE? */
+        dapi->graphics->draw_rect (dapi->gc, box->X1, box->Y1, box->X2, box->Y2);
+        break;
       }
 
       /* pin/pad movements result in moving an element */
     case PAD_TYPE:
     case PIN_TYPE:
     case ELEMENT_TYPE:
-      XORDrawElement ((ElementType *) Crosshair.AttachedObject.Ptr2, dx, dy);
-      break;
+      {
+        ElementType *element = (ElementType *) Crosshair.AttachedObject.Ptr2;
+
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_element (dapi, element);
+        break;
+      }
     }
 
   /* draw the attached rubberband lines too */
@@ -497,34 +259,32 @@ XORDrawMoveOrCopyObject (void)
   ptr = Crosshair.AttachedObject.Rubberband;
   while (i)
     {
-      PointType *point1, *point2;
-
+      /* If this rat going to a polygon, do not draw for rubberband */
       if (TEST_FLAG (VIAFLAG, ptr->Line))
-	{
-	  /* this is a rat going to a polygon.  do not draw for rubberband */;
-	}
-      else if (TEST_FLAG (RUBBERENDFLAG, ptr->Line))
-	{
-	  /* 'point1' is always the fix-point */
-	  if (ptr->MovedPoint == &ptr->Line->Point1)
-	    {
-	      point1 = &ptr->Line->Point2;
-	      point2 = &ptr->Line->Point1;
-	    }
-	  else
-	    {
-	      point1 = &ptr->Line->Point1;
-	      point2 = &ptr->Line->Point2;
-	    }
-	  XORDrawAttachedLine (point1->X,
-			       point1->Y, point2->X + dx,
-			       point2->Y + dy, ptr->Line->Thickness);
-	}
-      else if (ptr->MovedPoint == &ptr->Line->Point1)
-	XORDrawAttachedLine (ptr->Line->Point1.X + dx,
-			     ptr->Line->Point1.Y + dy,
-			     ptr->Line->Point2.X + dx,
-			     ptr->Line->Point2.Y + dy, ptr->Line->Thickness);
+        continue;
+
+      if (TEST_FLAG (RUBBERENDFLAG, ptr->Line))
+        {
+          LineType draw_line = *ptr->Line;
+
+          if (ptr->MovedPoint == &ptr->Line->Point1)
+            {
+              draw_line.Point1.X += dx;
+              draw_line.Point1.Y += dy;
+            }
+          else
+            {
+              draw_line.Point2.X += dx;
+              draw_line.Point2.Y += dy;
+            }
+
+          dapi->draw_pcb_line (dapi, NULL, &draw_line);
+        }
+      else if (ptr->MovedPoint == &ptr->Line->Point1) /* XXX: What is this conditional for ?? */
+        {
+          dapi->set_draw_offset (dapi, dx, dy);
+          dapi->draw_pcb_line (dapi, NULL, ptr->Line);
+        }
 
       ptr++;
       i--;
@@ -535,8 +295,19 @@ XORDrawMoveOrCopyObject (void)
  * draws additional stuff that follows the crosshair
  */
 void
-DrawAttached (void)
+DrawAttached (DrawAPI *dapi)
 {
+  /* DEBUG ONLY */
+  if (dapi == NULL)
+    return;
+
+  dapi->gc = dapi->graphics->make_gc ();
+
+  dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
+//  dapi->graphics->set_draw_xor (dapi->gc, 1);
+  dapi->graphics->set_line_cap (dapi->gc, Trace_Cap);
+  dapi->graphics->set_line_width (dapi->gc, 1);
+
   switch (Settings.Mode)
     {
     case VIA_MODE:
@@ -551,15 +322,15 @@ DrawAttached (void)
         via.Mask = 0;
         via.Flags = NoFlags ();
 
-        gui->graphics->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, true, false);
+        dapi->draw_pcb_via (dapi, &via);
 
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             /* XXX: Naughty cheat - use the mask to draw DRC clearance! */
             via.Mask = Settings.ViaThickness + PCB->Bloat * 2;
-            gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-            gui->graphics->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, false, true);
-            gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
+            dapi->graphics->set_color (dapi->gc, Settings.CrossColor);
+            dapi->draw_pcb_via_mask (dapi, &via);
+            dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
           }
         break;
       }
@@ -569,81 +340,100 @@ DrawAttached (void)
     case POLYGONHOLE_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
-        gui->graphics->draw_line (Crosshair.GC,
-                                  Crosshair.AttachedLine.Point1.X,
-                                  Crosshair.AttachedLine.Point1.Y,
-                                  Crosshair.AttachedLine.Point2.X,
-                                  Crosshair.AttachedLine.Point2.Y);
+        dapi->graphics->draw_line (dapi->gc,
+                                   Crosshair.AttachedLine.Point1.X, Crosshair.AttachedLine.Point1.Y,
+                                   Crosshair.AttachedLine.Point2.X, Crosshair.AttachedLine.Point2.Y);
 
       /* draw attached polygon only if in POLYGON_MODE or POLYGONHOLE_MODE */
       if (Crosshair.AttachedPolygon.PointN > 1)
-	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
-	}
+        dapi->draw_pcb_polygon (dapi, NULL, &Crosshair.AttachedPolygon);
       break;
 
     case ARC_MODE:
-      if (Crosshair.AttachedBox.State != STATE_FIRST)
-	{
-	  XORDrawAttachedArc (Settings.LineThickness);
-	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
-	    {
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-	      XORDrawAttachedArc (Settings.LineThickness +
-				  2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
-	    }
+      {
+        ArcType arc;
 
-	}
-      break;
+        if (Crosshair.AttachedBox.State == STATE_FIRST)
+          break;
+
+        if (!make_arc_from_crosshair (&arc, Settings.LineThickness))
+          break;
+
+        dapi->draw_pcb_arc (dapi, NULL, &arc);
+        if (TEST_FLAG (SHOWDRCFLAG, PCB))
+          {
+            if (!make_arc_from_crosshair (&arc, Settings.LineThickness + 2 * (PCB->Bloat + 1)))
+              break;
+            dapi->graphics->set_color (dapi->gc, Settings.CrossColor);
+            dapi->draw_pcb_arc (dapi, NULL, &arc);
+            dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
+          }
+
+        break;
+      }
 
     case LINE_MODE:
       /* draw only if starting point exists and the line has length */
       if (Crosshair.AttachedLine.State != STATE_FIRST &&
-	  Crosshair.AttachedLine.draw)
-	{
-	  XORDrawAttachedLine (Crosshair.AttachedLine.Point1.X,
-			       Crosshair.AttachedLine.Point1.Y,
-			       Crosshair.AttachedLine.Point2.X,
-			       Crosshair.AttachedLine.Point2.Y,
-			       PCB->RatDraw ? 10 : Settings.LineThickness);
-	  /* draw two lines ? */
-	  if (PCB->Clipping)
-	    XORDrawAttachedLine (Crosshair.AttachedLine.Point2.X,
-				 Crosshair.AttachedLine.Point2.Y,
-				 Crosshair.X, Crosshair.Y,
-				 PCB->RatDraw ? 10 : Settings.LineThickness);
-	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
-	    {
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-	      XORDrawAttachedLine (Crosshair.AttachedLine.Point1.X,
-				   Crosshair.AttachedLine.Point1.Y,
-				   Crosshair.AttachedLine.Point2.X,
-				   Crosshair.AttachedLine.Point2.Y,
-				   PCB->RatDraw ? 10 : Settings.LineThickness
-				   + 2 * (PCB->Bloat + 1));
-	      if (PCB->Clipping)
-		XORDrawAttachedLine (Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y,
-				     Crosshair.X, Crosshair.Y,
-				     PCB->RatDraw ? 10 : Settings.
-				     LineThickness + 2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
-	    }
-	}
+          Crosshair.AttachedLine.draw)
+        {
+          /* Make a dummy line structure to draw from */
+          LineType draw_line;
+
+          draw_line.Point1 = Crosshair.AttachedLine.Point1;
+          draw_line.Point2 = Crosshair.AttachedLine.Point2;
+          draw_line.Thickness = Settings.LineThickness;
+          draw_line.Clearance = 2 * Settings.Keepaway;
+          draw_line.Flags = NoFlags ();
+
+          draw_line.Thickness = PCB->RatDraw ? 10 : Settings.LineThickness;
+          dapi->draw_pcb_line (dapi, NULL, &draw_line);
+
+          if (PCB->Clipping)
+            {
+              draw_line.Point1.X = Crosshair.X;
+              draw_line.Point1.Y = Crosshair.Y;
+              dapi->draw_pcb_line (dapi, NULL, &draw_line);
+            }
+
+          if (TEST_FLAG (SHOWDRCFLAG, PCB))
+            {
+              dapi->graphics->set_color (dapi->gc, Settings.CrossColor);
+
+              draw_line.Point1 = Crosshair.AttachedLine.Point1;
+              draw_line.Point2 = Crosshair.AttachedLine.Point2;
+              draw_line.Thickness = PCB->RatDraw ? 10 : Settings.LineThickness + 2 * (PCB->Bloat + 1);
+              dapi->draw_pcb_line (dapi, NULL, &draw_line);
+
+              if (PCB->Clipping)
+                {
+                  draw_line.Point1.X = Crosshair.X;
+                  draw_line.Point1.Y = Crosshair.Y;
+                  dapi->draw_pcb_line (dapi, NULL, &draw_line);
+                }
+
+              dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
+            }
+        }
       break;
 
     case PASTEBUFFER_MODE:
-      XORDrawBuffer (PASTEBUFFER);
+      /* NB: We don't reset this.. other rendering routines are expected to do so before
+       *     they draw, so we will have to make some distinction as to which routines may
+       *     set this (and not call them from inside one another!)
+       */
+      dapi->set_draw_offset (dapi, Crosshair.X - PASTEBUFFER->X,
+                             Crosshair.Y - PASTEBUFFER->Y);
+      dapi->draw_pcb_buffer (dapi, PASTEBUFFER);
       break;
 
     case COPY_MODE:
     case MOVE_MODE:
-      XORDrawMoveOrCopyObject ();
+      draw_move_or_copy_object (dapi);
       break;
 
     case INSERTPOINT_MODE:
-      XORDrawInsertPointObject ();
+      XORDrawInsertPointObject (dapi);
       break;
     }
 
@@ -657,8 +447,10 @@ DrawAttached (void)
       y1 = Crosshair.AttachedBox.Point1.Y;
       x2 = Crosshair.AttachedBox.Point2.X;
       y2 = Crosshair.AttachedBox.Point2.Y;
-      gui->graphics->draw_rect (Crosshair.GC, x1, y1, x2, y2);
+      dapi->graphics->draw_rect (dapi->gc, x1, y1, x2, y2);
     }
+
+  dapi->graphics->destroy_gc (dapi->gc);
 }
 
 
@@ -666,20 +458,29 @@ DrawAttached (void)
  * draw the marker position
  */
 void
-DrawMark (void)
+DrawMark (DrawAPI *dapi)
 {
+  /* DEBUG ONLY */
+  if (dapi == NULL)
+    return;
+
   /* Mark is not drawn when it is not set */
   if (!Marked.status)
     return;
 
-  gui->graphics->draw_line (Crosshair.GC,
-                  Marked.X - MARK_SIZE,
-                  Marked.Y - MARK_SIZE,
-                  Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
-                  Marked.X + MARK_SIZE,
-                  Marked.Y - MARK_SIZE,
-                  Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->gc = dapi->graphics->make_gc ();
+
+  dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
+//  dapi->graphics->set_draw_xor (dapi->gc, 1);
+  dapi->graphics->set_line_cap (dapi->gc, Trace_Cap);
+  dapi->graphics->set_line_width (dapi->gc, 1);
+
+  dapi->graphics->draw_line (dapi->gc, Marked.X - MARK_SIZE, Marked.Y - MARK_SIZE,
+                                       Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->graphics->draw_line (dapi->gc, Marked.X + MARK_SIZE, Marked.Y - MARK_SIZE,
+                                       Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->graphics->destroy_gc (dapi->gc);
+
 }
 
 /* ---------------------------------------------------------------------------
@@ -1172,12 +973,6 @@ SetCrosshairRange (Coord MinX, Coord MinY, Coord MaxX, Coord MaxY)
 void
 InitCrosshair (void)
 {
-  Crosshair.GC = gui->graphics->make_gc ();
-
-  gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
-  gui->graphics->set_line_cap (Crosshair.GC, Trace_Cap);
-  gui->graphics->set_line_width (Crosshair.GC, 1);
-
   /* set initial shape */
   Crosshair.shape = Basic_Crosshair_Shape;
 
@@ -1197,5 +992,4 @@ void
 DestroyCrosshair (void)
 {
   FreePolygonMemory (&Crosshair.AttachedPolygon);
-  gui->graphics->destroy_gc (Crosshair.GC);
 }
diff --git a/src/crosshair.h b/src/crosshair.h
index 2dd5e7e..3825057 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -30,7 +30,9 @@
 #ifndef	PCB_CROSSHAIR_H
 #define	PCB_CROSSHAIR_H
 
+/* Naughty */
 #include "global.h"
+#include "draw_api.h"
 
 /* ---------------------------------------------------------------------------
  * all possible states of an attached object
@@ -44,8 +46,8 @@ void notify_crosshair_change (bool changes_complete);
 void notify_mark_change (bool changes_complete);
 void HideCrosshair (void);
 void RestoreCrosshair (void);
-void DrawAttached (void);
-void DrawMark (void);
+void DrawAttached (DrawAPI *);
+void DrawMark (DrawAPI *);
 void MoveCrosshairRelative (Coord, Coord);
 bool MoveCrosshairAbsolute (Coord, Coord);
 void SetCrosshairRange (Coord, Coord, Coord, Coord);
diff --git a/src/draw_api.h b/src/draw_api.h
new file mode 100644
index 0000000..7fadd9f
--- /dev/null
+++ b/src/draw_api.h
@@ -0,0 +1,126 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2012 PCB Contributors (See ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef PCB_DRAW_API_H
+#define PCB_DRAW_API_H
+
+typedef struct DrawAPI DrawAPI;
+typedef struct GraphicsAPI GraphicsAPI;
+
+struct DrawAPI {
+  /* Virtual functions */
+  void (*draw_pcb_pin)         (DrawAPI *, PinType *);
+  void (*draw_pcb_pin_mask)    (DrawAPI *, PinType *);
+  void (*draw_pcb_pin_hole)    (DrawAPI *, PinType *);
+  void (*draw_pcb_via)         (DrawAPI *, PinType *);
+  void (*draw_pcb_via_mask)    (DrawAPI *, PinType *);
+  void (*draw_pcb_via_hole)    (DrawAPI *, PinType *);
+  void (*draw_pcb_pad)         (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_pad_mask)    (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_pad_paste)   (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_line)        (DrawAPI *, LayerType *, LineType *);
+//  void (*draw_rat)         (DrawAPI *,              RatType *);
+  void (*draw_pcb_arc)         (DrawAPI *, LayerType *, ArcType *);
+  void (*draw_pcb_text)        (DrawAPI *, LayerType *, TextType *);
+  void (*draw_pcb_polygon)     (DrawAPI *, LayerType *, PolygonType *);
+
+//  void (*draw_ppv)         (DrawAPI *, LayerType *, int);
+//  void (*draw_holes)       (DrawAPI *,              int);
+  void (*draw_pcb_element)     (DrawAPI *, ElementType *);
+  void (*draw_pcb_layer)       (DrawAPI *, LayerType *,                const BoxType *, void *);
+  void (*draw_pcb_layer_group) (DrawAPI *, LayerType *,                const BoxType *, void *);
+  void (*draw_pcb_buffer)      (DrawAPI *, BufferType *);
+  void (*set_draw_offset)      (DrawAPI *, Coord, Coord);
+  void (*set_clip_box)         (DrawAPI *, const BoxType *);
+
+  /* Member variables */
+//  GraphicsAPI *graphics;
+  HID_DRAW *graphics;
+  hidGC gc;
+  hidGC fg_gc;
+  hidGC bg_gc;
+  hidGC pm_gc;
+  BoxType *clip_box;
+};
+
+#if 0
+enum mask_mode {
+  HID_MASK_OFF    = 0, /* Flush the buffer and return to non-mask operation. */
+  HID_MASK_BEFORE = 1, /* Polygons being drawn before clears.                */
+  HID_MASK_CLEAR  = 2, /* Clearances being drawn.                            */
+  HID_MASK_AFTER  = 3, /* Polygons being drawn after clears.                 */
+};
+#endif
+
+#if 0
+struct GraphicsAPI {
+  /* Make an empty graphics context. */
+  hidGC (*make_gc) (void);
+  void (*destroy_gc) (hidGC gc);
+  void (*use_mask) (enum mask_mode mode);
+
+  /* Set a color.  Names can be like "red" or "#rrggbb" or special
+   * names like "erase".  *Always* use the "erase" color for removing
+   * ink (like polygon reliefs or thermals), as you cannot rely on
+   * knowing the background color or special needs of the HID.  Always
+   * use the "drill" color to draw holes.  You may assume this is
+   * cheap enough to call inside the redraw callback, but not cheap
+   * enough to call for each item drawn.
+   */
+  void (*set_color) (hidGC gc, const char *name);
+
+  /* Set the line style.  While calling this is cheap, calling it with
+   * different values each time may be expensive, so grouping items by
+   * line style is helpful.
+   */
+  void (*set_line_cap) (hidGC gc, EndCapStyle style);
+  void (*set_line_width) (hidGC gc, Coord width);
+  void (*set_draw_xor) (hidGC gc, int xor);
+
+  /* Blends 20% or so color with 80% background.  Only used for
+   * assembly drawings so far.
+   */
+  void (*set_draw_faded) (hidGC gc, int faded);
+
+  /* The usual drawing functions.  "draw" means to use segments of the
+   * given width, whereas "fill" means to fill to a zero-width
+   * outline.
+   */
+  void (*draw_line)            (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
+  void (*draw_arc)             (hidGC gc, Coord cx, Coord cy, Coord rx, Coord ry, Angle sa, Angle da);
+  void (*draw_rect)            (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
+  void (*fill_circle)          (hidGC gc, Coord cx, Coord cy, Coord radius);
+  void (*fill_polygon)         (hidGC gc, int n_coords, Coord *x, Coord *y);
+  void (*fill_rect)            (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
+};
+#endif
+
+#if 0
+  void (*fill_pcb_polygon)     (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*fill_pcb_pad)         (hidGC gc, PadType *pad, bool clip, bool mask);
+  void (*thindraw_pcb_pad)     (hidGC gc, PadType *pad, bool clip, bool mask);
+  void (*fill_pcb_pv)          (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+  void (*thindraw_pcb_pv)      (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+#endif
+
+#endif
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5affe9a..cf2c072 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -9,6 +9,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "gui-pinout-preview.h"
+#include "outline_draw.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
@@ -847,6 +848,12 @@ ghid_screen_update (void)
 {
 }
 
+static void
+hidgl_set_draw_offset (DrawAPI *dapi, Coord x, Coord y)
+{
+  /* TODO: Fiddle with transformation matrix! */
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -1000,8 +1007,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_invalidate_current_gc ();
 
-  DrawAttached ();
-  DrawMark ();
+  {
+    DrawAPI *dapi;
+    dapi = outline_draw_new (gui->graphics);
+    dapi->set_draw_offset = hidgl_set_draw_offset;
+
+    DrawAttached (dapi);
+    DrawMark (dapi);
+  }
   hidgl_flush_triangles (&buffer);
 
   draw_crosshair (priv);
diff --git a/src/outline_draw.c b/src/outline_draw.c
new file mode 100644
index 0000000..e8731a0
--- /dev/null
+++ b/src/outline_draw.c
@@ -0,0 +1,288 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *  Copyright (C) 2012 PCB Contributors (See ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <memory.h>
+#include <math.h>
+
+#include "global.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "line.h"
+#include "misc.h"
+#include "polygon.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* FIXME: I THINK THIS IS THE SAME AS THE COMMON THINDRAW ROUTINE:
+ *        OK, NO.. IT ISN'T, THAT ONE RENDERS THE CLIPPED POLYGON.
+ *        SPEAKING OF WHICH.. I WONDER IF THIS ONE SHOULD TO!
+ */
+static void
+outline_draw_pcb_polygon (DrawAPI *dapi, LayerType *layer, PolygonType *polygon)
+{
+  Cardinal i;
+  for (i = 0; i < polygon->PointN; i++)
+    {
+      Cardinal next = next_contour_point (polygon, i);
+      dapi->graphics->draw_line (dapi->gc,
+                                 polygon->Points[   i].X, polygon->Points[   i].Y,
+                                 polygon->Points[next].X, polygon->Points[next].Y);
+    }
+}
+
+static void
+outline_draw_pcb_line (DrawAPI *dapi, LayerType *layer, LineType *line)
+{
+  Coord dx, dy, ox, oy;
+  Coord thick;
+  double h;
+
+  dx = line->Point2.X - line->Point1.X;
+  dy = line->Point2.Y - line->Point1.Y;
+  thick = line->Thickness;
+
+  if (dx != 0 || dy != 0)
+    h = 0.5 * thick / sqrt (SQUARE (dx) + SQUARE (dy));
+  else
+    h = 0.0;
+
+  ox =   dy * h + 0.5 * SGN (dy);
+  oy = -(dx * h + 0.5 * SGN (dx));
+  dapi->graphics->draw_line (dapi->gc, line->Point1.X + ox, line->Point1.Y + oy,
+                                       line->Point2.X + ox, line->Point2.Y + oy);
+
+  if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
+    {
+      Angle angle = atan2 (dx, dy) * 57.295779;
+      dapi->graphics->draw_line (dapi->gc, line->Point1.X - ox, line->Point1.Y - oy,
+                                           line->Point2.X - ox, line->Point2.Y - oy);
+      dapi->graphics->draw_arc (dapi->gc, line->Point1.X, line->Point1.Y,
+                                          thick / 2, thick / 2, angle - 180, 180);
+      dapi->graphics->draw_arc (dapi->gc, line->Point2.X, line->Point2.Y,
+                                          thick / 2, thick / 2, angle, 180);
+    }
+}
+
+static void
+outline_draw_pcb_arc (DrawAPI *dapi, LayerType *layer, ArcType *arc)
+{
+  if (arc->Width > pixel_slop)
+    {
+      BoxType *bx = GetArcEnds (arc);
+      dapi->graphics->draw_arc (dapi->gc, arc->X, arc->Y,
+                                arc->Width + arc->Thickness, arc->Height + arc->Thickness,
+                                arc->StartAngle, arc->Delta);
+
+      dapi->graphics->draw_arc (dapi->gc, arc->X, arc->Y,
+                                arc->Width - arc->Thickness, arc->Height - arc->Thickness,
+                                arc->StartAngle, arc->Delta);
+
+      dapi->graphics->draw_arc (dapi->gc, bx->X1, bx->Y1,
+                                arc->Thickness, arc->Thickness,
+                                arc->StartAngle, -180 * SGN (arc->Delta));
+
+      dapi->graphics->draw_arc (dapi->gc, bx->X2, bx->Y2,
+                                arc->Thickness, arc->Thickness,
+                                arc->StartAngle + arc->Delta, 180 * SGN (arc->Delta));
+    }
+  else
+    dapi->graphics->draw_arc (dapi->gc, arc->X, arc->Y,
+                              arc->Width, arc->Height, arc->StartAngle, arc->Delta);
+}
+
+/* ---------------------------------------------------------------------------
+ * draws the elements of a loaded circuit which is to be merged in
+ */
+static void
+outline_draw_pcb_element (DrawAPI *dapi, ElementType *Element)
+{
+  /* if no silkscreen, draw the bounding box */
+  if (Element->ArcN == 0 && Element->LineN == 0)
+    {
+      dapi->graphics->draw_line (dapi->gc, Element->BoundingBox.X1, Element->BoundingBox.Y1,
+                                           Element->BoundingBox.X1, Element->BoundingBox.Y2);
+      dapi->graphics->draw_line (dapi->gc, Element->BoundingBox.X1, Element->BoundingBox.Y2,
+                                           Element->BoundingBox.X2, Element->BoundingBox.Y2);
+      dapi->graphics->draw_line (dapi->gc, Element->BoundingBox.X2, Element->BoundingBox.Y2,
+                                           Element->BoundingBox.X2, Element->BoundingBox.Y1);
+      dapi->graphics->draw_line (dapi->gc, Element->BoundingBox.X2, Element->BoundingBox.Y1,
+                                           Element->BoundingBox.X1, Element->BoundingBox.Y1);
+    }
+  else
+    {
+      ELEMENTLINE_LOOP (Element);
+      {
+        dapi->draw_pcb_line (dapi, NULL, line);
+      }
+      END_LOOP;
+      ARC_LOOP (Element);
+      {
+        dapi->draw_pcb_arc (dapi, NULL, arc);
+      }
+      END_LOOP;
+    }
+
+  PIN_LOOP (Element);
+  {
+    dapi->draw_pcb_pin (dapi, pin);
+  }
+  END_LOOP;
+
+  /* pads */
+  PAD_LOOP (Element);
+  {
+    if (PCB->InvisibleObjectsOn ||
+        (TEST_FLAG (ONSOLDERFLAG, pad) != 0) == Settings.ShowSolderSide)
+      {
+        dapi->draw_pcb_pad (dapi, NULL, pad);
+      }
+  }
+  END_LOOP;
+
+  /* Element mark */
+  dapi->graphics->draw_line (dapi->gc, Element->MarkX - EMARK_SIZE, Element->MarkY,
+                                       Element->MarkX,              Element->MarkY - EMARK_SIZE);
+  dapi->graphics->draw_line (dapi->gc, Element->MarkX + EMARK_SIZE, Element->MarkY,
+                                       Element->MarkX,              Element->MarkY - EMARK_SIZE);
+  dapi->graphics->draw_line (dapi->gc, Element->MarkX - EMARK_SIZE, Element->MarkY,
+                                       Element->MarkX,              Element->MarkY + EMARK_SIZE);
+  dapi->graphics->draw_line (dapi->gc, Element->MarkX + EMARK_SIZE, Element->MarkY,
+                                       Element->MarkX,              Element->MarkY + EMARK_SIZE);
+}
+
+/* ---------------------------------------------------------------------------
+ * draws all visible and attached objects of the pastebuffer
+ */
+static void
+outline_draw_pcb_buffer (DrawAPI *dapi, BufferType *Buffer)
+{
+  Cardinal i;
+
+  /* draw all visible layers */
+  for (i = 0; i < max_copper_layer + 2; i++)
+    if (PCB->Data->Layer[i].On)
+      {
+        LayerType *layer = &Buffer->Data->Layer[i];
+
+        LINE_LOOP (layer);
+        {
+          dapi->draw_pcb_line (dapi, layer, line);
+        }
+        END_LOOP;
+        ARC_LOOP (layer);
+        {
+          dapi->draw_pcb_arc (dapi, layer, arc);
+        }
+        END_LOOP;
+        TEXT_LOOP (layer);
+        {
+          dapi->draw_pcb_text (dapi, layer, text);
+        }
+        END_LOOP;
+        POLYGON_LOOP (layer);
+        {
+          dapi->draw_pcb_polygon (dapi, layer, polygon);
+        }
+        END_LOOP;
+      }
+
+  /* draw elements if visible */
+  if (PCB->PinOn && PCB->ElementOn)
+    {
+      ELEMENT_LOOP (Buffer->Data);
+      {
+        if (FRONT (element) || PCB->InvisibleObjectsOn)
+          dapi->draw_pcb_element (dapi, element);
+      }
+      END_LOOP;
+    }
+
+  /* and the vias */
+  if (PCB->ViaOn)
+    {
+      VIA_LOOP (Buffer->Data);
+      {
+        dapi->draw_pcb_via (dapi, via);
+      }
+      END_LOOP;
+    }
+}
+
+static void
+outline_draw_pcb_pv (DrawAPI *dapi, PinType *pin)
+{
+  dapi->graphics->thindraw_pcb_pv (dapi->gc, dapi->gc, pin, true, false);
+}
+
+static void
+outline_draw_pcb_pv_mask (DrawAPI *dapi, PinType *pin)
+{
+  dapi->graphics->thindraw_pcb_pv (dapi->gc, dapi->gc, pin, true, true);
+}
+
+static void
+outline_draw_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  dapi->graphics->thindraw_pcb_pad (dapi->gc, pad, false, false);
+}
+
+DrawAPI *outline_draw_new (HID_DRAW_API *graphics)
+{
+  DrawAPI *dapi;
+
+  dapi = g_new0 (DrawAPI, 1);
+  dapi->graphics = graphics;
+
+  dapi->draw_pcb_pin          = outline_draw_pcb_pv;
+  dapi->draw_pcb_pin_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_pin_hole     = NULL;
+  dapi->draw_pcb_via          = outline_draw_pcb_pv;
+  dapi->draw_pcb_via_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_via_hole     = NULL;
+  dapi->draw_pcb_pad          = outline_draw_pcb_pad;
+  dapi->draw_pcb_pad_mask     = NULL;
+  dapi->draw_pcb_pad_paste    = NULL;
+  dapi->draw_pcb_line         = outline_draw_pcb_line;
+  dapi->draw_pcb_arc          = outline_draw_pcb_arc;
+  dapi->draw_pcb_polygon      = outline_draw_pcb_polygon;
+
+  dapi->draw_pcb_element      = outline_draw_pcb_element;
+  dapi->draw_pcb_layer        = NULL;
+  dapi->draw_pcb_layer_group  = NULL;
+  dapi->draw_pcb_buffer       = outline_draw_pcb_buffer;
+  dapi->set_draw_offset       = NULL;
+  dapi->set_clip_box          = NULL;
+
+  return dapi;
+}
