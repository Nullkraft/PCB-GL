Bottom: f33a4c4481ef4b16821ca167b262980694629e62
Top:    5998db868430c61817cac4480b1c224045ca7a61
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-29 13:31:25 +0000

Use surface_orientation_reversed for planes

This keeps implementations for various surface types more similar,
and helps to ensure the same parameterisation of planes is used
as in the original model. (No current reason this helps, but it
feels like it might be a good idea in the long run).


---

diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index eb8b736..8b148d2 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -1931,9 +1931,9 @@ plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
 {
   double ortx, orty, ortz;
 
-  ortx = face->ny * face->rz - face->nz * face->ry;
-  orty = face->nz * face->rx - face->nx * face->rz;
-  ortz = face->nx * face->ry - face->ny * face->rx;
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
 
   *u = (x - face->ox) * face->rx +
        (y - face->oy) * face->ry +
@@ -1945,17 +1945,29 @@ plane_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
 }
 
 static void
-plane_uv_to_xyz (face3d *face, float u, float v, float *x, float *y, float *z)
+plane_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z,
+                            float *nx, float *ny, float *nz)
 {
   float ortx, orty, ortz;
 
-  ortx = face->ny * face->rz - face->nz * face->ry;
-  orty = face->nz * face->rx - face->nx * face->rz;
-  ortz = face->nx * face->ry - face->ny * face->rx;
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
 
   *x = STEP_X_TO_COORD(PCB, face->ox + u * face->rx + v * ortx);
   *y = STEP_Y_TO_COORD(PCB, face->oy + u * face->ry + v * orty);
   *z = STEP_Z_TO_COORD(PCB, face->oz + u * face->rz + v * ortz);
+
+  *nx =  face->ax;
+  *ny = -face->ay; /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+  *nz =  face->az;
+
+  if (face->surface_orientation_reversed)
+    {
+      *nx = -*nx;
+      *ny = -*ny;
+      *nz = -*nz;
+    }
 }
 
 static void
@@ -2054,7 +2066,8 @@ plane_ensure_tristrip (face3d *face)
 
       /* make sure it is a positive contour (outer) or negative (hole) */
 //      if (p_contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
-//      poly_InvContour (p_contour);
+      if (face->surface_orientation_reversed)
+        poly_InvContour (p_contour);
 
       if (p_contour->Flags.orient == PLF_DIR)
         {
@@ -2191,17 +2204,16 @@ plane_ensure_tristrip (face3d *face)
   vertex_comp = 0;
   for (i = 0; i < num_uv_points; i++)
     {
-      plane_uv_to_xyz(face,
-                      COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
-                      COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
-                      &face->tristrip_vertices[vertex_comp + 0],
-                      &face->tristrip_vertices[vertex_comp + 1],
-                      &face->tristrip_vertices[vertex_comp + 2]);
-
-      /* Vertex normal */
-      face->tristrip_vertices[vertex_comp + 3] = face->nx;
-      face->tristrip_vertices[vertex_comp + 4] = -face->ny; /* XXX: -ny */
-      face->tristrip_vertices[vertex_comp + 5] = face->nz;
+      plane_uv_to_xyz_and_normal (face,
+                                  COORD_TO_MM (uv_points[2 * i + 0]),
+                                  COORD_TO_MM (uv_points[2 * i + 1]),
+                                  &face->tristrip_vertices[vertex_comp + 0],
+                                  &face->tristrip_vertices[vertex_comp + 1],
+                                  &face->tristrip_vertices[vertex_comp + 2],
+                                  /* Vertex normal */
+                                  &face->tristrip_vertices[vertex_comp + 3],
+                                  &face->tristrip_vertices[vertex_comp + 4],
+                                  &face->tristrip_vertices[vertex_comp + 5]);
 
       vertex_comp += BUFFER_STRIDE;
     }
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 5c35f1e..6af4534 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -1615,17 +1615,22 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
               info->current_face->ny = info->current_face->ay;
               info->current_face->nz = info->current_face->az;
 
-              if (!fs->same_sense_ ())
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
                 {
+                  /* XXX: Should we bother flipping the display normal, as we now set surface_orientation_reversed */
                   info->current_face->nx = -info->current_face->nx;
                   info->current_face->ny = -info->current_face->ny;
                   info->current_face->nz = -info->current_face->nz;
 
                   /* XXX: Could use face->surface_orientation_reversed ? */
 //                  printf ("Not same sense, flipping normal\n");
+                  info->current_face->surface_orientation_reversed = true;
                 }
 
-              info->current_face->surface_orientation_reversed = false;
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
