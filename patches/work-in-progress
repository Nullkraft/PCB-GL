Bottom: dc0e9f312d8f0fa14d3bbb806a1ee532c488a99d
Top:    a7a29e7328d72c667dcd30def75b2c9850fff5dc
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-19 17:48:53 +0000

Work in progress


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 5a871d0..e844f86 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2502,9 +2502,9 @@ PLINE_check_hairline_edges (PLINE *contour)
   CVCList *l, *first_l, *n, *nn;
   int test_count;
 
-  /* Lets just try this for now */
-  if (poly_ChkContour (contour))
-    g_critical ("Wonky contour - oops\n");
+//  /* Lets just try this for now */
+//  if (poly_ChkContour (contour))
+//    g_critical ("Wonky contour - oops\n");
 
   /* Scan the PLINE and check for naughty shared edge segments */
   v = &contour->head;
@@ -2531,18 +2531,24 @@ PLINE_check_hairline_edges (PLINE *contour)
         {
           n = l->next;
 
+          if (l->parent == NULL) /* Deleted node we were too lazy to remove during this early development phase */
+            continue;
+
           /* Skip edges from the other polygon */
           if (l->poly != first_l->poly)
             continue;
 
           /* Find the next edge from this polygon */
-          while (n->poly != first_l->poly && n != first_l)
+          while ((n->poly != first_l->poly || n->parent == NULL) && n != first_l)
             n = n->next;
 
           /* Skip testing if we wrapped around, and only had one pair to test */
           if (n == first_l && test_count == 1)
             break;
 
+          if (n->parent == NULL) /* Wrap-around to a node we deleted */
+            break;
+
           /* Check for hairline pairs of edges in the CVCList, they may be sorted in incorrect order,
            * and would thus mislead as to whether we are inside or outside a given contour. It is a
            * bug if such edges are present, so test for it here where we may detect it. We compare
@@ -2564,30 +2570,9 @@ PLINE_check_hairline_edges (PLINE *contour)
                   if (vect_equal (l->parent->point, l_otherend->point))
                     g_error ("Edges are zero length");
 
-                  /* TODO: Remove the two offending edges, stitching up the contour as necessary, and
-                   *       potentially inserting the isolated contour piece into our list of other
-                   *       contours to scan. Remove the CVC status and entries if for whatever reason
-                   *       removing this edge leaves the node without being cross-connected. (Or does it matter?)
-                   *       Probably need to take care of removing the CVC status if we remove its last edge!
-                   */
-
-                  // XXX: Check if incoming and outgoing edges from hairline pair are linked by forward and next?
-                  // XXX: What if they are not? - Can this happen?
-                  // XXX: 
-                  // XXX: 
-                  // XXX: Note that the hairline edge pairs might well be sorted out of order.. need to explicitly get the incoming and outgoing??
-                  // Set incoming edge of outgoing hairline edge to point next at outgoing edge of incoming hairline edge.
-                  // XXX: Assert that the other end of our hairline edge pair is also CVC connected? -- NO, IT MIGHT NOT BE! CVC only applies for A-B vertex touching
-                  // Find other ends of hairline edge pair, and interconnect their from/to vertices (?)
-                  // Delete hairline edges
-                  // Delete any CVC entries associated with them
-                  // Delete the CVC node if it is empty. (Can probably allow a CVC node to have just one polygon present, IFF we update the labeling code to not assert
-
-                  /* TODO: Ensure that our shared edges land on a cross-connected vertex (even if it is just a dummy that only touches our polygon) */
-
                   /* Simple approach - just mark the edges as visited, so we don't traverse them!
                    * Doing it this way ensures that both pieces of the contour are reachable if
-                   * the hairline edge pair splits this PLINE into two pieces. Since we ensured
+                   * the hairline edge pair splits this PLINE into two pieces. Since we will ensure
                    * that both ends of the edges land on a cross-connected vertex, we should
                    * successfully skip over the pre-marked gap in the contour.
                    */
@@ -2613,18 +2598,15 @@ PLINE_check_hairline_edges (PLINE *contour)
                    */
                   nn = n->next;
                   /* Find the next edge from this polygon */
-                  while (nn->poly != first_l->poly && nn != first_l)
+                  //while (nn->poly != first_l->poly && nn != first_l)
+                  while ((nn->poly != first_l->poly || nn->parent == NULL) && nn != first_l)
                     nn = nn->next;
 
-                  remove_cvc_list_entry ((l->side == 'P') ? l->parent->cvc_prev : l->parent->cvc_next);
-                  remove_cvc_list_entry ((n->side == 'P') ? n->parent->cvc_prev : n->parent->cvc_next);
+                  remove_cvc_list_entry (l);
+                  remove_cvc_list_entry (n);
 
                   n = nn;
 
-                  /* Skip testing if we wrapped around */
-                  if (n == first_l)
-                    break;
-
                 }
               else
                 {
@@ -2637,11 +2619,36 @@ PLINE_check_hairline_edges (PLINE *contour)
                   // XXX: What if we delete the last cross-connected vertex?? Probably the labelling code fails, as it won't know if the
                   //      contours are entirely INSIDE / OUTSIDE eachother.... may require fix-up later on in the process, as the
                   //      conntours are actually no longer interected.
+
+#warning THIS IS ALMOST CERTAINLY VERY VERY WRONG
+
+                  VERTEX_SIDE_DIR_EDGE (l->parent, l->side)->Flags.mark = true;
+                  VERTEX_SIDE_DIR_EDGE (n->parent, n->side)->Flags.mark = true;
+
+                  add_dummy_descriptors_at_point (l_otherend->point, contour, first_l->poly, l); /* Picking 'l' for an arbitrary start CVCList */
+                  add_dummy_descriptors_at_point (n_otherend->point, contour, first_l->poly, l); /* Picking 'l' for an arbitrary start CVCList */
+
+                  /* NOTE: 'P' at this node means 'N' at otherend */
+                  remove_cvc_list_entry ((l->side == 'P') ? l_otherend->cvc_next : l_otherend->cvc_prev);
+                  remove_cvc_list_entry ((n->side == 'P') ? n_otherend->cvc_next : n_otherend->cvc_prev);
+
+                  nn = n->next;
+                  /* Find the next edge from this polygon */
+                  while (nn->poly != first_l->poly && nn != first_l)
+                    nn = nn->next;
+
+                  remove_cvc_list_entry (l);
+                  remove_cvc_list_entry (n);
+
+                  n = nn;
                 }
             }
 
           test_count++;
 
+          if (n->parent == NULL) /* Wrap-around to a node we deleted */
+            break;
+
           /* Stop if we wrapped around to the end of the list */
           if (n == first_l)
             break;
