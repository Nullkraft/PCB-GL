Bottom: b14e0d1bdfa6d35c402847632b5273fd48bc9b29
Top:    c5c3378989c37e3ac077dfc97ce2563972c58212
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-03 13:47:41 +0000

hid/gtk (GL): Add hacky code to render outline of board, and mask cutout geometry


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 9979a3b..721f371 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1571,6 +1571,106 @@ clearPad_callback_solid (const BoxType * b, void *cl)
 }
 
 static void
+ensure_board_outline (void)
+{
+  if (!PCB->Data->outline_valid) {
+
+    if (PCB->Data->outline != NULL)
+      poly_Free (&PCB->Data->outline);
+
+    PCB->Data->outline = board_outline_poly ();
+    PCB->Data->outline_valid = true;
+  }
+}
+
+static void
+fill_board_outline (hidGC gc, const BoxType *drawn_area)
+{
+  PolygonType polygon;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+  gui->graphics->fill_pcb_polygon (gc, &polygon, drawn_area);
+  poly_FreeContours (&polygon.NoHoles);
+}
+
+struct outline_info {
+  hidGC gc;
+  float z1;
+  float z2;
+};
+
+static int
+fill_outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+  PolygonType polygon;
+  PLINE *pl_copy = NULL;
+
+  poly_CopyContour (&pl_copy, pl);
+  poly_InvContour (pl_copy);
+  polygon.Clipped = poly_Create ();
+  poly_InclContour (polygon.Clipped, pl_copy);
+
+//  if (polygon.Clipped->contours == NULL)
+//    return 0;
+
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
+//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
+  gui->graphics->fill_pcb_polygon (info->gc, &polygon, NULL);
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  poly_Free (&polygon.Clipped);
+
+  return 0;
+}
+
+static void
+fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+{
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = gc;
+
+  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+
+  p = polygon;
+  for (p.Clipped = polygon.Clipped->f;
+       p.Clipped != polygon.Clipped;
+       p.Clipped = p.Clipped->f) {
+    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+  }
+
+//  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (&buffer);
+}
+
+static void
 GhidDrawMask (int side, BoxType * screen)
 {
   static bool first_run = true;
@@ -1578,7 +1678,7 @@ GhidDrawMask (int side, BoxType * screen)
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct poly_info info;
-  PolygonType polygon;
+//  PolygonType polygon;
 
   OutputType *out = &Output;
 
@@ -1639,14 +1739,8 @@ GhidDrawMask (int side, BoxType * screen)
   glEnable (GL_TEXTURE_2D);
 #endif
 
-  if (!PCB->Data->outline_valid) {
-
-    if (PCB->Data->outline != NULL)
-      poly_Free (&PCB->Data->outline);
-
-    PCB->Data->outline = board_outline_poly ();
-    PCB->Data->outline_valid = true;
-  }
+#if 0
+  ensure_board_outline ();
 
   polygon.Clipped = PCB->Data->outline;
   polygon.NoHoles = NULL;
@@ -1657,8 +1751,12 @@ GhidDrawMask (int side, BoxType * screen)
   SET_FLAG (FULLPOLYFLAG, &polygon);
   gui->graphics->fill_pcb_polygon (out->fgGC, &polygon, screen);
   poly_FreeContours (&polygon.NoHoles);
+#endif
+
+  fill_board_outline (out->fgGC, screen);
+
   ghid_set_alpha_mult (out->fgGC, 1.0);
-  hidgl_flush_triangles (&buffer);
+//  hidgl_flush_triangles (&buffer);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1672,6 +1770,84 @@ GhidDrawMask (int side, BoxType * screen)
   first_run = false;
 }
 
+static void
+draw_outline_contour (hidGC gc, PLINE *pl, float z1, float z2)
+{
+  VNODE *v;
+  GLfloat x, y;
+
+  hidgl_ensure_vertex_space (&buffer, 2 * pl->Count + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+
+  x = pl->head.point[0];
+  y = pl->head.point[1];
+
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+
+  v = pl->head.next;
+
+  do
+    {
+      x = v->point[0];
+      y = v->point[1];
+
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+    }
+  while ((v = v->next) != pl->head.next);
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+}
+
+static int
+outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+
+  draw_outline_contour (info->gc, pl, info->z1, info->z2);
+  return 0;
+}
+
+static void
+ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+{
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = Output.fgGC;
+  info.z1 = compute_depth (from_layer);
+  info.z2 = compute_depth (to_layer);
+
+  draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
+  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+
+  p = polygon;
+  for (p.Clipped = polygon.Clipped->f;
+       p.Clipped != polygon.Clipped;
+       p.Clipped = p.Clipped->f) {
+    draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
+    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+  }
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (&buffer);
+}
+
 static int
 GhidDrawLayerGroup (int group, const BoxType * screen)
 {
@@ -1714,6 +1890,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         gui->graphics->set_color (Output.bgGC, PCB->MaskColor);
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        fill_board_outline_holes (Output.bgGC, screen);
         hidgl_flush_triangles (&buffer);
         glPopAttrib ();
       }
@@ -1738,6 +1915,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
           /* Mask out drilled holes on this layer */
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          fill_board_outline_holes (Output.bgGC, screen);
           hidgl_flush_triangles (&buffer);
           glPopAttrib ();
         }
@@ -2024,6 +2202,7 @@ ghid_draw_everything (BoxType *drawn_area)
       cyl_info.scale = gport->view.coord_per_px;
       gui->graphics->set_color (Output.fgGC, "drill");
       ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
     }
@@ -2050,6 +2229,7 @@ ghid_draw_everything (BoxType *drawn_area)
       glDepthMask (GL_FALSE);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      fill_board_outline_holes (Output.bgGC, drawn_area);
       hidgl_flush_triangles (&buffer);
       glPopAttrib ();
     }
