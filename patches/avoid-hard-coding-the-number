Bottom: 51d80a58302c3a6ba21b21d245c1becae7e86bf7
Top:    3b4628f0f7d3ca97ee8dbdedcf71dc298e6a7ee7
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-12-27 18:09:34 +0000

Avoid hard-coding the number of extra layers in use (for 2x silkscreen)

We will shorty add support for soldermask layers, so this will need changing


NOTE....... IF THE parse_y.y patch in the stg series before this gets
dropped, there is one more case where + 2 needs to be replaced with EXTRA_LAYERS


---

diff --git a/src/buffer.c b/src/buffer.c
index 7067b8d..3b51ba1 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -1405,7 +1405,7 @@ MirrorBuffer (BufferType *Buffer)
       Message (_("You can't mirror a buffer that has elements!\n"));
       return;
     }
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       LayerType *layer = Buffer->Data->Layer + i;
       if (layer->TextN)
diff --git a/src/const.h b/src/const.h
index 08fe253..67eb72d 100644
--- a/src/const.h
+++ b/src/const.h
@@ -42,6 +42,8 @@
 #define TOP_SIDE                1
 
 
+#define EXTRA_LAYERS 2 /* 2x silkscreen layers */
+
 /* ---------------------------------------------------------------------------
  * the layer-numbers of the two additional special (silkscreen) layers
  * 'bottom' and 'top'. The offset of MAX_LAYER is not added
diff --git a/src/copy.c b/src/copy.c
index b0cd9c8..a0385db 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -326,7 +326,7 @@ CopyPastebufferToLayout (Coord X, Coord Y)
   DeltaX = X - PASTEBUFFER->X, DeltaY = Y - PASTEBUFFER->Y;
 
   /* paste all layers */
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       LayerType *sourcelayer = &PASTEBUFFER->Data->Layer[i];
       LayerType *destlayer = LAYER_PTR (i);
diff --git a/src/crosshair.c b/src/crosshair.c
index 9cece49..7d8c540 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -291,7 +291,7 @@ XORDrawBuffer (BufferType *Buffer)
   y = Crosshair.Y - Buffer->Y;
 
   /* draw all visible layers */
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     if (PCB->Data->Layer[i].On)
       {
 	LayerType *layer = &Buffer->Data->Layer[i];
diff --git a/src/file.c b/src/file.c
index 0772139..11ab7c3 100644
--- a/src/file.c
+++ b/src/file.c
@@ -849,7 +849,7 @@ WriteBuffer (FILE * FP)
 
   WriteViaData (FP, PASTEBUFFER->Data);
   WriteElementData (FP, PASTEBUFFER->Data);
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     WriteLayerData (FP, i, &(PASTEBUFFER->Data->Layer[i]));
   return (STATUS_OK);
 }
@@ -873,7 +873,7 @@ WritePCB (FILE * FP)
   WriteViaData (FP, PCB->Data);
   WriteElementData (FP, PCB->Data);
   WritePCBRatData (FP);
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     WriteLayerData (FP, i, &(PCB->Data->Layer[i]));
   WritePCBNetlistData (FP);
 
diff --git a/src/global.h b/src/global.h
index d858bec..5137739 100644
--- a/src/global.h
+++ b/src/global.h
@@ -195,7 +195,7 @@ OutputType;
 typedef struct
 {
   Cardinal Number[MAX_GROUP],	/* number of entries per groups */
-    Entries[MAX_GROUP][MAX_LAYER + 2];
+    Entries[MAX_GROUP][MAX_LAYER + EXTRA_LAYERS];
 } LayerGroupType;
 
 struct BoxType		/* a bounding box */
@@ -397,7 +397,7 @@ typedef struct			/* holds all objects */
   rtree_t *via_tree, *element_tree, *pin_tree, *pad_tree, *name_tree[3],	/* for element names */
    *rat_tree;
   struct PCBType *pcb;
-  LayerType Layer[MAX_LAYER + 2];	/* add 2 silkscreen layers */
+  LayerType Layer[MAX_LAYER + EXTRA_LAYERS];
   int polyClip;
 } DataType;
 
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 432e374..14572bc 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -34,7 +34,7 @@ extents_set_layer (const char *name, int group, int empty)
     {
       idx = PCB->LayerGroups.Entries[idx][0];
     }
-  if (idx >= 0 && idx < max_copper_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + EXTRA_LAYERS)
     return 1;
   if (idx < 0)
     {
diff --git a/src/hid/common/flags.c b/src/hid/common/flags.c
index 1229d67..83d4df4 100644
--- a/src/hid/common/flags.c
+++ b/src/hid/common/flags.c
@@ -129,7 +129,7 @@ void
 hid_save_and_show_layer_ons (int *save_array)
 {
   int i;
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       save_array[i] = PCB->Data->Layer[i].On;
       PCB->Data->Layer[i].On = 1;
@@ -140,7 +140,7 @@ void
 hid_restore_layer_ons (int *save_array)
 {
   int i;
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     PCB->Data->Layer[i].On = save_array[i];
 }
 
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 2030fe8..fadb356 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -504,7 +504,7 @@ gcode_start_gcode (const char *layername, bool metric)
 static void
 gcode_do_export (HID_Attr_Val * options)
 {
-  int save_ons[MAX_LAYER + 2];
+  int save_ons[MAX_LAYER + EXTRA_LAYERS];
   int i, idx;
   const Unit *unit;
   double scale = 0, d = 0;
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 31b8c90..2ec2836 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -587,7 +587,7 @@ gerber_do_export (HID_Attr_Val * options)
   const char *fnbase;
   int i;
   static int saved_layer_stack[MAX_LAYER];
-  int save_ons[MAX_LAYER + 2];
+  int save_ons[MAX_LAYER + EXTRA_LAYERS];
   FlagType save_thindraw;
 
   save_thindraw = PCB->Flags;
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 54e5598..ba242e2 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -72,14 +72,14 @@ ghid_set_layer (const char *name, int group, int empty)
       for (idx = 0; idx < n-1; idx ++)
 	{
 	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_copper_layer + 2
+	  if (ni >= 0 && ni < max_copper_layer + EXTRA_LAYERS
 	      && PCB->Data->Layer[ni].On)
 	    break;
 	}
       idx = PCB->LayerGroups.Entries[group][idx];
     }
 
-  if (idx >= 0 && idx < max_copper_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + EXTRA_LAYERS)
     return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
   if (idx < 0)
     {
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index ac695e8..9b4c6dd 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -137,7 +137,7 @@ ghid_set_layer (const char *name, int group, int empty)
       for (idx = 0; idx < n-1; idx ++)
 	{
 	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_copper_layer + 2
+	  if (ni >= 0 && ni < max_copper_layer + EXTRA_LAYERS
 	      && PCB->Data->Layer[ni].On)
 	    break;
 	}
@@ -147,7 +147,7 @@ ghid_set_layer (const char *name, int group, int empty)
   end_subcomposite ();
   start_subcomposite ();
 
-  if (idx >= 0 && idx < max_copper_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + EXTRA_LAYERS)
     {
       priv->trans_lines = true;
       return PCB->Data->Layer[idx].On;
diff --git a/src/hid/hidint.h b/src/hid/hidint.h
index 8d62d6b..3031607 100644
--- a/src/hid/hidint.h
+++ b/src/hid/hidint.h
@@ -44,7 +44,7 @@ void hid_parse_command_line (int *argc, char ***argv);
 
 /* Use this to temporarily enable all layers, so that they can be
    exported even if they're not currently visible.  save_array must be
-   MAX_LAYER+2 big. */
+   MAX_LAYER + EXTRA_LAYERS big. */
 void hid_save_and_show_layer_ons (int *save_array);
 /* Use this to restore them.  */
 void hid_restore_layer_ons (int *save_array);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index f3f16c8..68dee02 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -3004,7 +3004,7 @@ lesstif_set_layer (const char *name, int group, int empty)
       for (idx = 0; idx < n-1; idx ++)
 	{
 	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_copper_layer + 2
+	  if (ni >= 0 && ni < max_copper_layer + EXTRA_LAYERS
 	      && PCB->Data->Layer[ni].On)
 	    break;
 	}
@@ -3022,7 +3022,7 @@ lesstif_set_layer (const char *name, int group, int empty)
   else
     autofade = 0;
 #endif
-  if (idx >= 0 && idx < max_copper_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + EXTRA_LAYERS)
     return pinout ? 1 : PCB->Data->Layer[idx].On;
   if (idx < 0)
     {
diff --git a/src/hid/lesstif/menu.c b/src/hid/lesstif/menu.c
index ddaddcb..bee7a17 100644
--- a/src/hid/lesstif/menu.c
+++ b/src/hid/lesstif/menu.c
@@ -499,7 +499,7 @@ ToggleView (int argc, char **argv, Coord x, Coord y)
   else
     {
       l = -1;
-      for (i = 0; i < max_copper_layer + 2; i++)
+      for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
 	if (strcmp (argv[0], PCB->Data->Layer[i].Name) == 0)
 	  {
 	    l = i;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 2e814de..e31cbe5 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -653,7 +653,7 @@ nelma_start_png_export()
 static void 
 nelma_do_export(HID_Attr_Val * options)
 {
-	int             save_ons[MAX_LAYER + 2];
+	int             save_ons[MAX_LAYER + EXTRA_LAYERS];
 	int             i, idx;
 	FILE           *nelma_config;
 	char           *buf;
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 2f1590b..3950c0d 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -127,10 +127,10 @@ static int print_layer[MAX_LAYER];
 #define PHOTO_FLIP_Y	2
 
 static int photo_mode, photo_flip;
-static gdImagePtr photo_copper[MAX_LAYER+2];
+static gdImagePtr photo_copper[MAX_LAYER + EXTRA_LAYERS];
 static gdImagePtr photo_silk, photo_mask, photo_drill, *photo_im;
 static gdImagePtr photo_outline;
-static int photo_groups[MAX_LAYER+2], photo_ngroups;
+static int photo_groups[MAX_LAYER + EXTRA_LAYERS], photo_ngroups;
 static int photo_has_inners;
 
 static int doing_outline, have_outline;
@@ -783,7 +783,7 @@ ts_bs_sm (gdImagePtr im)
 static void
 png_do_export (HID_Attr_Val * options)
 {
-  int save_ons[MAX_LAYER + 2];
+  int save_ons[MAX_LAYER + EXTRA_LAYERS];
   int i;
   BoxType *bbox;
   Coord w, h;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index cff21e3..a8822be 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -317,7 +317,7 @@ static void
 eps_do_export (HID_Attr_Val * options)
 {
   int i;
-  int save_ons[MAX_LAYER + 2];
+  int save_ons[MAX_LAYER + EXTRA_LAYERS];
 
   if (!options)
     {
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 690697a..79807a1 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -707,7 +707,7 @@ static void
 ps_do_export (HID_Attr_Val * options)
 {
   FILE *fh;
-  int save_ons[MAX_LAYER + 2];
+  int save_ons[MAX_LAYER + EXTRA_LAYERS];
   int i;
 
   if (!options)
diff --git a/src/macro.h b/src/macro.h
index 2f24077..8ef45bc 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -327,21 +327,21 @@ extern int mem_any_set (unsigned char *, int);
 #define	ALLLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		LINE_LOOP(layer)
 
 #define ALLARC_LOOP(top) do {		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l =0; l < max_copper_layer + 2; l++, layer++)		\
+	for (l =0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)		\
 	{ \
 		ARC_LOOP(layer)
 
 #define	ALLPOLYGON_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
 
@@ -393,14 +393,14 @@ extern int mem_any_set (unsigned char *, int);
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		TEXT_LOOP(layer)
 
 #define	VISIBLELINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			LINE_LOOP(layer)
@@ -408,7 +408,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLEARC_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			ARC_LOOP(layer)
@@ -416,7 +416,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLETEXT_LOOP(board) do	{		\
 	Cardinal		l;			\
 	LayerType *layer = (board)->Data->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
@@ -424,7 +424,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLEPOLYGON_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerType *layer = (top)->Layer;		\
-	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			POLYGON_LOOP(layer)
diff --git a/src/misc.c b/src/misc.c
index 9a4d9ce..a05d785 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -619,7 +619,7 @@ IsDataEmpty (DataType *Data)
 
   hasNoObjects = (Data->ViaN == 0);
   hasNoObjects &= (Data->ElementN == 0);
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
@@ -993,7 +993,7 @@ ParseGroupString (char *group_string, LayerGroupType *LayerGroup, int *LayerN)
   int group, member, layer;
   bool c_set = false,        /* flags for the two special layers to */
     s_set = false;              /* provide a default setting for old formats */
-  int groupnum[MAX_LAYER + 2];
+  int groupnum[MAX_LAYER + EXTRA_LAYERS];
 
   *LayerN = 0;
 
@@ -1039,7 +1039,7 @@ ParseGroupString (char *group_string, LayerGroupType *LayerGroup, int *LayerN)
   memset (LayerGroup, 0, sizeof (LayerGroupType));
 
   /* Clear assignments */
-  for (layer = 0; layer < MAX_LAYER + 2; layer++)
+  for (layer = 0; layer < MAX_LAYER + EXTRA_LAYERS; layer++)
     groupnum[layer] = -1;
 
   /* loop over all groups */
@@ -1254,7 +1254,7 @@ GetLayerNumber (DataType *Data, LayerType *Layer)
 {
   int i;
 
-  for (i = 0; i < MAX_LAYER + 2; i++)
+  for (i = 0; i < MAX_LAYER + EXTRA_LAYERS; i++)
     if (Layer == &Data->Layer[i])
       break;
   return (i);
@@ -1367,7 +1367,7 @@ LayerStringToLayerStack (char *s)
 	}
     }
 
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       if (i < max_copper_layer)
         LayerStack[i] = i;
@@ -1581,7 +1581,7 @@ ResetStackAndVisibility (void)
   int top_group;
   Cardinal i;
 
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       if (i < max_copper_layer)
         LayerStack[i] = i;
@@ -1620,7 +1620,7 @@ SaveStackAndVisibility (void)
                "yet restored.  cnt = %d\n", SavedStack.cnt);
     }
 
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       if (i < max_copper_layer)
         SavedStack.LayerStack[i] = LayerStack[i];
@@ -1654,7 +1654,7 @@ RestoreStackAndVisibility (void)
                " wrong.  cnt = %d\n", SavedStack.cnt);
     }
 
-  for (i = 0; i < max_copper_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + EXTRA_LAYERS; i++)
     {
       if (i < max_copper_layer)
         LayerStack[i] = SavedStack.LayerStack[i];
diff --git a/src/move.c b/src/move.c
index 9dcba90..b9a180d 100644
--- a/src/move.c
+++ b/src/move.c
@@ -921,7 +921,7 @@ LastNormalLayerInSideGroup (int side, int layer)
 int
 MoveLayer (int old_index, int new_index)
 {
-  int group_of_layer[MAX_LAYER + 2], l, g, i;
+  int group_of_layer[MAX_LAYER + EXTRA_LAYERS], l, g, i;
   LayerType saved_layer;
   int saved_group;
 
@@ -957,7 +957,7 @@ MoveLayer (int old_index, int new_index)
       return 1;
     }
 
-  for (l = 0; l < MAX_LAYER+2; l++)
+  for (l = 0; l < MAX_LAYER + EXTRA_LAYERS; l++)
     group_of_layer[l] = -1;
 
   for (g = 0; g < MAX_GROUP; g++)
@@ -976,10 +976,10 @@ MoveLayer (int old_index, int new_index)
       lp = &PCB->Data->Layer[new_index];
       memmove (&PCB->Data->Layer[new_index + 1],
 	       &PCB->Data->Layer[new_index],
-	       (max_copper_layer + 2 - new_index) * sizeof (LayerType));
+	       (max_copper_layer + EXTRA_LAYERS - new_index) * sizeof (LayerType));
       memmove (&group_of_layer[new_index + 1],
 	       &group_of_layer[new_index],
-	       (max_copper_layer + 2 - new_index) * sizeof (int));
+	       (max_copper_layer + EXTRA_LAYERS - new_index) * sizeof (int));
       max_copper_layer++;
       memset (lp, 0, sizeof (LayerType));
       lp->On = 1;
@@ -996,11 +996,11 @@ MoveLayer (int old_index, int new_index)
       /* Delete the layer at old_index */
       memmove (&PCB->Data->Layer[old_index],
 	       &PCB->Data->Layer[old_index + 1],
-	       (max_copper_layer + 2 - old_index - 1) * sizeof (LayerType));
-      memset (&PCB->Data->Layer[max_copper_layer + 2 - 1], 0, sizeof (LayerType));
+	       (max_copper_layer + EXTRA_LAYERS - old_index - 1) * sizeof (LayerType));
+      memset (&PCB->Data->Layer[max_copper_layer + EXTRA_LAYERS - 1], 0, sizeof (LayerType));
       memmove (&group_of_layer[old_index],
 	       &group_of_layer[old_index + 1],
-	       (max_copper_layer + 2 - old_index - 1) * sizeof (int));
+	       (max_copper_layer + EXTRA_LAYERS - old_index - 1) * sizeof (int));
       for (l = 0; l < max_copper_layer; l++)
 	if (LayerStack[l] == old_index)
 	  memmove (LayerStack + l,
@@ -1042,7 +1042,7 @@ MoveLayer (int old_index, int new_index)
 
   for (g = 0; g < MAX_GROUP; g++)
     PCB->LayerGroups.Number[g] = 0;
-  for (l = 0; l < max_copper_layer + 2; l++)
+  for (l = 0; l < max_copper_layer + EXTRA_LAYERS; l++)
     {
       g = group_of_layer[l];
 
diff --git a/src/mymem.c b/src/mymem.c
index b6b3c30..a402f63 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -713,7 +713,7 @@ FreeDataMemory (DataType *data)
   g_list_free_full (data->Element, (GDestroyNotify)FreeElement);
   g_list_free_full (data->Rat, (GDestroyNotify)FreeRat);
 
-  for (layer = data->Layer, i = 0; i < MAX_LAYER + 2; layer++, i++)
+  for (layer = data->Layer, i = 0; i < MAX_LAYER + EXTRA_LAYERS; layer++, i++)
     {
       FreeAttributeListMemory (&layer->Attributes);
       TEXT_LOOP (layer);
diff --git a/src/parse_y.y b/src/parse_y.y
index 62fcc4b..629ccd6 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -65,7 +65,7 @@ static	PolygonType	*Polygon;
 static	SymbolType	*Symbol;
 static	int		pin_num;
 static	LibraryMenuType	*Menu;
-static	bool			LayerFlag[MAX_LAYER + 2];
+static	bool			LayerFlag[MAX_LAYER + EXTRA_LAYERS];
 
 extern	char		*yytext;		/* defined by LEX */
 extern	PCBType		*yyPCB;
@@ -167,7 +167,7 @@ parsepcb
 					Message(_("illegal fileformat\n"));
 					YYABORT;
 				}
-				for (i = 0; i < MAX_LAYER + 2; i++)
+				for (i = 0; i < MAX_LAYER + EXTRA_LAYERS; i++)
 					LayerFlag[i] = false;
 				yyFont = &yyPCB->Font;
 				yyData = yyPCB->Data;
@@ -844,7 +844,7 @@ layer
 			/* name */
 		: T_LAYER '(' INTEGER STRING opt_string ')' '('
 			{
-				if ($3 <= 0 || $3 > MAX_LAYER + 2)
+				if ($3 <= 0 || $3 > MAX_LAYER + EXTRA_LAYERS)
 				{
 					yyerror("Layernumber out of range");
 					YYABORT;
diff --git a/src/select.c b/src/select.c
index 1762c76..021453f 100644
--- a/src/select.c
+++ b/src/select.c
@@ -233,7 +233,7 @@ SelectBlock (BoxType *Box, bool select)
   END_LOOP;
 
   /* check layers */
-  LAYER_LOOP(PCB->Data, max_copper_layer + 2);
+  LAYER_LOOP(PCB->Data, max_copper_layer + EXTRA_LAYERS);
   {
     if (layer == & PCB->Data->SILKLAYER)
       {
