Bottom: dcf41b858a60da5945795546a87b0cfca44a36a3
Top:    4681cfa1e37bb0c0291148a59bc9e3660b706361
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 20:31:11 +0000

Add routine for simplifying polygon contours


---

diff --git a/src/hid/common/object3d.c b/src/hid/common/object3d.c
index d38cdb3..277d99f 100644
--- a/src/hid/common/object3d.c
+++ b/src/hid/common/object3d.c
@@ -406,7 +406,7 @@ object3d_from_contours (POLYAREA *contours,
   do
     {
 
-      outer_contour = pa->contours;
+      outer_contour = pa->simple_contours;
       ncontours = 0;
       npoints = 0;
 
@@ -417,7 +417,7 @@ object3d_from_contours (POLYAREA *contours,
         ct = ct->next;
       }
 
-      object_name = make_object_name (base_name, pa->contours->name);
+      object_name = make_object_name (base_name, pa->simple_contours->name);
       object = make_object3d (object_name);
       g_free (object_name);
 
@@ -766,6 +766,8 @@ object3d_from_board_outline (void)
   top_bot_appearance = NULL;
   appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
 
+  poly_Simplify (board_outline);
+
   objects = object3d_from_contours (board_outline,
 #ifdef REVERSED_PCB_CONTOURS
                                     -HACK_BOARD_THICKNESS, /* Bottom */
@@ -1029,6 +1031,8 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
   LayerType *layer;
   POLYAREA *pa;
 
+  return NULL;
+
   poly_Copy0 (&info.poly, area);
   info.side = side;
 
@@ -1064,6 +1068,8 @@ object3d_from_soldermask_within_area (POLYAREA *area, int side)
   mask_appearance = make_appearance ();
   appearance_set_color (mask_appearance, 0.2, 0.8, 0.2);
 
+  poly_Simplify (info.poly);
+
   objects = object3d_from_contours (info.poly,
 #ifdef REVERSED_PCB_CONTOURS
                                     (side == TOP_SIDE) ? 0                   + HACK_COPPER_THICKNESS : -HACK_BOARD_THICKNESS - HACK_COPPER_THICKNESS - HACK_MASK_THICKNESS, /* Bottom */
@@ -1550,8 +1556,11 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
           while ((pa = pa->f) != info.poly);
         }
 
+      group_m_polyarea[group] = info.poly;
+      poly_Simplify (group_m_polyarea[group]);
+
       group_objects = g_list_concat (group_objects,
-        object3d_from_contours (info.poly,
+        object3d_from_contours (group_m_polyarea[group],
 #ifdef REVERSED_PCB_CONTOURS
                                 depth,                         /* Bottom */
                                 depth + HACK_COPPER_THICKNESS, /* Top */
@@ -1563,8 +1572,6 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
                                 NULL,  /* top_bot_appearance */
                                 false, /* Don't invert */
                                 "Net")); /* Name */
-
-      group_m_polyarea[group] = info.poly;
     }
 
   /* Now need to punch drill-holes through the inter-layers..
@@ -1577,6 +1584,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   r_search (PCB->Data->via_tree, &bounds, NULL, pv_barrel_callback, &info);
 
   barrel_m_polyarea = info.poly;
+  poly_Simplify (barrel_m_polyarea);
 
   info.poly = NULL;
 
@@ -1585,6 +1593,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
   r_search (PCB->Data->via_tree, &bounds, NULL, pv_drill_callback, &info);
 
   drill_m_polyarea = info.poly;
+  poly_Simplify (drill_m_polyarea);
 
   info.poly = NULL;
 
@@ -1739,7 +1748,7 @@ object3d_from_copper_layers_within_area (POLYAREA *area)
               /* Steal the data from the old bottom object */
               steal_object_geometry (top_group_object, bottom_group_object);
 
-              printf ("Merging object with name %s and %s\n", top_group_object->name, bottom_group_object->name);
+//              printf ("Merging object with name %s and %s\n", top_group_object->name, bottom_group_object->name);
               top_group_object->name = merge_contour_name (top_group_object->name, bottom_group_object->name);
 
               /* Delete the old bottom object */
diff --git a/src/polyarea.h b/src/polyarea.h
index 2d9d868..acdbf1f 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -158,6 +158,7 @@ struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
+    PLINE *simple_contours;
     rtree_t *contour_tree;
     POLYPARENTAGE parentage;
     void *user_data; /* To be used at will by the owner of this polygon */
@@ -209,6 +210,7 @@ int poly_Boolean(const POLYAREA * a, const POLYAREA * b, POLYAREA ** res, int ac
 int poly_Boolean_free(POLYAREA * a, POLYAREA * b, POLYAREA ** res, int action);
 int poly_AndSubtract_free(POLYAREA * a, POLYAREA * b, POLYAREA ** aandb, POLYAREA ** aminusb);
 int SavePOLYAREA( POLYAREA *PA, char * fname);
+void poly_Simplify(POLYAREA *poly);
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/polygon.h b/src/polygon.h
index 13e23ad..0847e8a 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,7 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 8 //40
+#define POLY_CIRC_SEGS 20 //8 //40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index a084876..e3c7227 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -51,6 +51,7 @@
 #include "rtree.h"
 #include "heap.h"
 #include "pcb-printf.h"
+#include "polygon.h" // FOR POLY_CIRC_SEGS
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
@@ -3017,7 +3018,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
   *res = NULL;
 
-#if 1
+#if 0
   /* Make copies for tracking polygon parentage (DEBUG) */
   if (!poly_M_Copy0 (&a_copy, a) || !poly_M_Copy0 (&b_copy, b))
       return err_no_memory;
@@ -3352,6 +3353,10 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 
   if (optimize)
     {
+      /* XXX: Looks like this loop misses an iteration? IE.. no test between head->prev ------- head ------- head->next
+       *      in any case, if we remove the head vertex, we need to adjust the polygon...
+       *      does poly_ExclVertex cope with that? - NO!
+       */
       for (c = NEXT_VERTEX ((p = &C->head)); c != &C->head; c = NEXT_VERTEX (p = c))
 	{
 	  /* if the previous node is on the same line with this one, we should remove it */
@@ -3376,8 +3381,8 @@ poly_PreContour (PLINE * C, BOOLp optimize)
   C->ymin = C->ymax = C->head.point[1];
 
   p = PREV_VERTEX ((c = &C->head));
-  if (c != p)
-    {
+//  if (c != p) /* WTF?? */
+//    {
       do
 	{
 	  /* calculate area for orientation */
@@ -3388,7 +3393,7 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 	  C->Count++;
 	}
       while ((c = NEXT_VERTEX (p = c)) != &C->head);
-    }
+//    }
   C->area = ABS (area);
   if (C->Count > 2)
     C->Flags.orient = ((area < 0) ? PLF_INV : PLF_DIR);
@@ -3915,6 +3920,7 @@ poly_Init (POLYAREA * p)
 {
   p->f = p->b = p;
   p->contours = NULL;
+  p->simple_contours = NULL;
   p->contour_tree = r_create_tree (NULL, 0, 0);
   p->parentage = no_parentage;
   p->user_data = NULL;
@@ -3952,12 +3958,14 @@ poly_Free (POLYAREA ** p)
   for (cur = (*p)->f; cur != *p; cur = (*p)->f)
     {
       poly_FreeContours (&cur->contours);
+      poly_FreeContours (&cur->simple_contours);
       r_destroy_tree (&cur->contour_tree);
       cur->f->b = cur->b;
       cur->b->f = cur->f;
       free (cur);
     }
   poly_FreeContours (&cur->contours);
+  poly_FreeContours (&cur->simple_contours);
   r_destroy_tree (&cur->contour_tree);
 
   /* Free parentage information - assume all linked polygons share this, so only need to do it for the past polygon */
@@ -4368,3 +4376,115 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
  * perhaps reverse tracing the arc would require look-ahead to check
  * for arcs
  */
+
+
+/* s1 and s2 are treated as edges */
+static bool
+line_segments_can_merge (VNODE *s1, VNODE *s2)
+{
+  Vector p1, p2;
+
+  assert (EDGE_FOWARD_VERTEX (s1) == EDGE_BACKWARD_VERTEX (s2));
+  Vsub2 (p1, EDGE_BACKWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s1)->point); /* See assert above for first arg */
+  Vsub2 (p2, EDGE_FORWARD_VERTEX (s2)->point, EDGE_BACKWARD_VERTEX (s2)->point);
+
+  /* If the product below is zero then segments are on the same line */
+  return (vect_det2 (p1, p2) == 0);
+}
+
+/* s1 and s2 are treated as edges */
+static bool
+arc_segments_can_merge (VNODE *s1, VNODE *s2)
+{
+  return (s1->cx        == s2->cx &&
+          s1->cy        == s2->cy &&
+          s1->radius    == s2->radius);
+}
+
+
+/* NB: Operates on a single contour, does not follow links */
+/* XXX: Does not update the segment r-tree, so no further
+ *      boolean operations should be attempted on this polygon!
+ */
+static void
+simplify_contour (PLINE *contour)
+{
+  VNODE *p, *c;
+  int count = 0;
+
+  /* XXX: Looks like this loop misses an iteration? IE.. no test between head->prev ------- head ------- head->next
+   *      in any case, if we remove the head vertex, we need to adjust the polygon...
+   *      does poly_ExclVertex cope with that? - NO!
+   */
+  for (c = NEXT_VERTEX ((p = &contour->head)); c != &contour->head; c = NEXT_VERTEX (p = c))
+    {
+      bool delete_vertex_c;
+
+      if (VERTEX_FORWARD_EDGE (c)->is_round == false)
+        count = 0;
+
+      if (!VERTEX_FORWARD_EDGE (p)->is_round && !VERTEX_FORWARD_EDGE (c)->is_round)
+        {
+          delete_vertex_c = line_segments_can_merge (VERTEX_FORWARD_EDGE (p), VERTEX_FORWARD_EDGE (c));
+          if (delete_vertex_c)
+            fprintf (stderr, "Merging adjacent line segments\n");
+        }
+      else if (VERTEX_FORWARD_EDGE (p)->is_round && VERTEX_FORWARD_EDGE (c)->is_round)
+        {
+          delete_vertex_c = arc_segments_can_merge (VERTEX_FORWARD_EDGE (p), VERTEX_FORWARD_EDGE (c));
+          /* XXX: If we merge too many arc segments, they become more than 180 degrees span, and cw/ccw determination fails */
+          if (count == POLY_CIRC_SEGS / 2 - 2) /* Thought -1 should work, but then appear to get bad polygon cutouts */
+            {
+              delete_vertex_c = false;
+              count = 0;
+            }
+          if (delete_vertex_c)
+            {
+              fprintf (stderr, "Merging adjacent arc segments\n");
+              count++;
+            }
+        }
+      else
+        {
+          /* LINE-ARC and ARC-LINE segments cannot merge */
+          delete_vertex_c = false;
+          count = 0;
+        }
+
+      if (delete_vertex_c)
+        {
+          assert (c != &contour->head);
+          poly_ExclVertex (c);
+          g_slice_free (VNODE, c);
+          c = p;
+          contour->Count --;
+        }
+
+    }
+}
+
+void
+poly_Simplify (POLYAREA *poly)
+{
+  POLYAREA *pa = poly;
+  PLINE *curc;
+  PLINE **last;
+
+  if (poly == NULL)
+    return;
+
+  do
+    {
+      assert (pa->simple_contours == NULL);
+      last = &pa->simple_contours;
+      for (curc = pa->contours; curc != NULL; curc = curc->next)
+        {
+          if (!poly_CopyContour (last, curc))
+            g_assert_not_reached ();
+          if (!(*last)->is_round) /* Don't worry about simplifying round contours, since those get special cased on output anyway */
+            simplify_contour (*last);
+          last = &(*last)->next;
+        }
+    }
+  while ((pa = pa->f) != poly);
+}
