Bottom: 993300918b270789b365c7221997a8e92591574b
Top:    e1f095305e47d0dab3dbcc406ac5ef2fdfc0e88a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2016-12-04 19:24:05 +0000

Bentley-Ottann test implementation


---

diff --git a/configure.ac b/configure.ac
index f98192b..f557c37 100644
--- a/configure.ac
+++ b/configure.ac
@@ -7,6 +7,8 @@ AM_INIT_AUTOMAKE([1.9])
 AC_GNU_SOURCE
 AC_CONFIG_HEADERS([config.h])
 
+m4_include(configure.ac.system)	dnl checks for system functions, headers, libs
+
 ##########################################################################
 #
 # Try to figure out if we are building from git sources.
diff --git a/configure.ac.system b/configure.ac.system
new file mode 100644
index 0000000..3f6ab7e
--- /dev/null
+++ b/configure.ac.system
@@ -0,0 +1,164 @@
+dnl
+dnl Non-failing checks for functions, headers, libraries, etc go here
+dnl
+
+dnl ====================================================================
+dnl Feature checks
+dnl ====================================================================
+
+AM_CONDITIONAL(CROSS_COMPILING, test "x$cross_compiling" = "xyes")
+CAIRO_BIGENDIAN
+AC_ARG_ENABLE(atomic,
+	      [AS_HELP_STRING([--disable-atomic],
+			      [disable use of native atomic operations])],
+	      [use_atomic=$enableval], [use_atomic=yes])
+AS_IF([test "x$use_atomic" = "xyes"], [
+  CAIRO_CHECK_NATIVE_ATOMIC_PRIMITIVES
+  CAIRO_CHECK_ATOMIC_OP_NEEDS_MEMORY_BARRIER
+])
+AC_CHECK_SIZEOF(void *)
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(long long)
+AC_CHECK_SIZEOF(size_t)
+
+AC_MSG_CHECKING([for native Win32])
+case "$host" in
+  *-*-mingw*)
+    cairo_os_win32=yes
+    ;;
+  *)
+    cairo_os_win32=no
+    ;;
+esac
+AC_MSG_RESULT([$cairo_os_win32])
+AM_CONDITIONAL(OS_WIN32, test "$cairo_os_win32" = "yes")
+
+AC_MSG_CHECKING([for Sun Solaris (non-POSIX ctime_r)])
+case "$host" in
+    *-*-solaris*)
+	CFLAGS="$CFLAGS -D_POSIX_PTHREAD_SEMANTICS"
+	solaris_posix_pthread=yes
+	;;
+    *)
+	solaris_posix_pthread=no
+	;;
+esac
+AC_MSG_RESULT([$solaris_posix_pthread])
+
+dnl ====================================================================
+dnl Library checks
+dnl ====================================================================
+
+AC_CHECK_LIBM
+LIBS="$LIBS $LIBM"
+
+AC_CHECK_LIB(rt, sched_yield, [RT_LIBS=-lrt], [RT_LIBS=])
+CAIROPERF_LIBS=$RT_LIBS
+AC_SUBST(CAIROPERF_LIBS)
+
+has_shm_open=
+AC_CHECK_LIB(rt, shm_open, [
+	     SHM_LIBS=-lrt
+	     has_shm_open=yes
+	     ], [SHM_LIBS=])
+AM_CONDITIONAL(HAVE_SHM, test "x$has_shm_open" = "xyes")
+AC_SUBST(SHM_LIBS)
+
+AC_CHECK_LIB(socket, connect, [SOCKET_LIBS=-lsocket], [SOCKET_LIBS=])
+CAIROBOILERPLATE_LIBS=$SOCKET_LIBS
+AC_SUBST(CAIROBOILERPLATE_LIBS)
+
+dnl ====================================================================
+dnl Header/function checks
+dnl ====================================================================
+
+dnl check if we have a __builtin_return_address for the cairo-trace
+dnl utility.
+AC_MSG_CHECKING([for __builtin_return_address(0)])
+AC_TRY_COMPILE([],[__builtin_return_address(0);],
+		[have_builtin_return_address=yes],
+		[have_builtin_return_address=no])
+AC_MSG_RESULT($have_builtin_return_address)
+if test "x$have_builtin_return_address" = "xyes"; then
+    AC_DEFINE(HAVE_BUILTIN_RETURN_ADDRESS, 1,
+	[Define to 1 if your compiler supports the __builtin_return_address() intrinsic.])
+fi
+
+dnl Checks for precise integer types
+AC_CHECK_HEADERS([stdint.h inttypes.h sys/int_types.h])
+AC_CHECK_TYPES([uint64_t, uint128_t, __uint128_t])
+
+dnl Check for socket support for any2ppm daemon
+AC_CHECK_HEADERS([fcntl.h unistd.h signal.h sys/stat.h sys/socket.h sys/poll.h sys/un.h])
+
+dnl Check for infinite loops
+AC_CHECK_FUNCS([alarm])
+
+dnl check for CPU affinity support
+AC_CHECK_HEADERS([sched.h], [AC_CHECK_FUNCS([sched_getaffinity])])
+
+dnl check for mmap support
+AC_CHECK_HEADERS([sys/mman.h], [AC_CHECK_FUNCS([mmap])])
+
+dnl check for clock_gettime() support
+save_LIBS="$LIBS"
+LIBS="$LIBS $RT_LIBS"
+AC_CHECK_HEADERS([time.h], [AC_CHECK_FUNCS([clock_gettime])])
+LIBS="$save_LIBS"
+
+dnl check for GNU-extensions to fenv
+AC_CHECK_HEADER(fenv.h,
+	[AC_CHECK_FUNCS(feenableexcept fedisableexcept feclearexcept)])
+
+dnl check for misc headers and functions
+AC_CHECK_HEADERS([libgen.h byteswap.h signal.h setjmp.h fenv.h])
+AC_CHECK_FUNCS([vasnprintf link ctime_r drand48 flockfile ffs])
+
+dnl check for win32 headers (this detects mingw as well)
+AC_CHECK_HEADERS([windows.h], have_windows=yes, have_windows=no)
+
+
+dnl Possible headers for mkdir
+AC_CHECK_HEADERS([sys/stat.h io.h])
+AC_CHECK_FUNC(mkdir,
+	      [AC_MSG_CHECKING([mkdir variant])
+	      mkdir_variant="unknown"
+	      save_CFLAGS="$CFLAGS"
+	      CFLAGS=$WARN_CFLAGS
+	      AC_TRY_COMPILE([
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+		      ],
+		      [mkdir ("hello.world", 0777)],
+		      mkdir_variant="mkdir(path, mode)",
+		      [AC_TRY_COMPILE([
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+			      ],
+			      [mkdir ("hello.world")],
+			      mkdir_variant="mkdir(path)")])
+	      AC_MSG_RESULT([$mkdir_variant])
+	      CFLAGS="$save_CFLAGS"
+	      if test "x$mkdir_variant" = "xmkdir(path, mode)"; then
+		  AC_DEFINE(HAVE_MKDIR, 2,
+			    [Define to non-zero if your system has mkdir, and to 2 if your version of mkdir requires a mode parameter])
+	      else
+		  AC_DEFINE(HAVE_MKDIR, 1,
+			    [Define to non-zero if your system has mkdir, and to 2 if your version of mkdir requires a mode parameter])
+	      fi])
+
+dnl ===========================================================================
+dnl
+dnl Test for the tools required for building one big test binary
+dnl
+
+AC_CHECK_FUNCS(fork waitpid raise)
diff --git a/src/Makefile.am b/src/Makefile.am
index 717be1a..b7b45e3 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -38,6 +38,33 @@ PCB_SRCS = \
 	box.h \
 	buffer.c \
 	buffer.h \
+	cairo/cairoint.h \
+	cairo/cairo-atomic-private.h \
+	cairo/cairo-bentley-ottmann.c \
+	cairo/cairo-cache-private.h \
+	cairo/cairo-clip-private.h \
+	cairo/cairo-combsort-private.h \
+	cairo/cairo-compiler-private.h \
+	cairo/cairo-fixed-private.h \
+	cairo/cairo-fixed-type-private.h \
+	cairo/cairo-freelist.c \
+	cairo/cairo-freelist-private.h \
+	cairo/cairo-hash-private.h \
+	cairo/cairo-list-private.h \
+	cairo/cairo-malloc-private.h \
+	cairo/cairo-mutex-impl-private.h \
+	cairo/cairo-mutex-list-private.h \
+	cairo/cairo-mutex-private.h \
+	cairo/cairo-mutex-type-private.h \
+	cairo/cairo-path-fixed-private.h \
+	cairo/cairo-reference-count-private.h \
+	cairo/cairo-scaled-font-private.h \
+	cairo/cairo-spans-private.h \
+	cairo/cairo-surface-private.h \
+	cairo/cairo-types-private.h \
+	cairo/cairo-wideint.c \
+	cairo/cairo-wideint-private.h \
+	cairo/cairo-wideint-type-private.h \
 	change.c \
 	change.h \
 	clip.c \
@@ -74,6 +101,8 @@ PCB_SRCS = \
 	free_atexit.h \
 	gettext.h \
 	global.h \
+	gpqueue/gpqueue.c \
+	gpqueue/gpqueue.h \
 	heap.c \
 	heap.h \
 	hid.h \
@@ -134,6 +163,8 @@ PCB_SRCS = \
 	set.h \
 	strflags.c \
 	strflags.h \
+	sweep.c \
+	sweep.h \
 	thermal.c \
 	thermal.h \
 	undo.c \
diff --git a/src/cairo/cairo-atomic-private.h b/src/cairo/cairo-atomic-private.h
new file mode 100644
index 0000000..8532f62
--- /dev/null
+++ b/src/cairo/cairo-atomic-private.h
@@ -0,0 +1,160 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ */
+
+#ifndef CAIRO_ATOMIC_PRIVATE_H
+#define CAIRO_ATOMIC_PRIVATE_H
+
+# include "cairo-compiler-private.h"
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/* The autoconf on OpenBSD 4.5 produces the malformed constant name
+ * SIZEOF_VOID__ rather than SIZEOF_VOID_P.  Work around that here. */
+#if !defined(SIZEOF_VOID_P) && defined(SIZEOF_VOID__)
+# define SIZEOF_VOID_P SIZEOF_VOID__
+#endif
+
+CAIRO_BEGIN_DECLS
+
+#if HAVE_INTEL_ATOMIC_PRIMITIVES
+
+#define HAS_ATOMIC_OPS 1
+
+typedef int cairo_atomic_int_t;
+
+# define _cairo_atomic_int_get(x) (*x)
+# define _cairo_atomic_int_set(x, value) ((*x) = value)
+
+# define _cairo_atomic_int_inc(x) ((void) __sync_fetch_and_add(x, 1))
+# define _cairo_atomic_int_dec_and_test(x) (__sync_fetch_and_add(x, -1) == 1)
+# define _cairo_atomic_int_cmpxchg(x, oldv, newv) __sync_val_compare_and_swap (x, oldv, newv)
+
+#if SIZEOF_VOID_P==SIZEOF_INT
+typedef int cairo_atomic_intptr_t;
+#elif SIZEOF_VOID_P==SIZEOF_LONG
+typedef long cairo_atomic_intptr_t;
+#elif SIZEOF_VOID_P==SIZEOF_LONG_LONG
+typedef long long cairo_atomic_intptr_t;
+#else
+#error No matching integer pointer type
+#endif
+
+# define _cairo_atomic_ptr_cmpxchg(x, oldv, newv) \
+    (void*)__sync_val_compare_and_swap ((cairo_atomic_intptr_t*)x, (cairo_atomic_intptr_t)oldv, (cairo_atomic_intptr_t)newv)
+
+#endif
+
+#if HAVE_LIB_ATOMIC_OPS
+#include <atomic_ops.h>
+
+#define HAS_ATOMIC_OPS 1
+
+typedef  AO_t cairo_atomic_int_t;
+
+# define _cairo_atomic_int_get(x) (AO_load_full (x))
+# define _cairo_atomic_int_set(x, value) (AO_store_full (x))
+
+# define _cairo_atomic_int_inc(x) ((void) AO_fetch_and_add1_full(x))
+# define _cairo_atomic_int_dec_and_test(x) (AO_fetch_and_sub1_full(x) == 1)
+# define _cairo_atomic_int_cmpxchg(x, oldv, newv) ((cairo_atomic_int_t) AO_compare_and_swap_full(x, oldv, newv) ? oldv : *x)
+
+#if SIZEOF_VOID_P==SIZEOF_INT
+typedef unsigned int cairo_atomic_intptr_t;
+#elif SIZEOF_VOID_P==SIZEOF_LONG
+typedef unsigned long cairo_atomic_intptr_t;
+#elif SIZEOF_VOID_P==SIZEOF_LONG_LONG
+typedef unsigned long long cairo_atomic_intptr_t;
+#else
+#error No matching integer pointer type
+#endif
+
+# define _cairo_atomic_ptr_cmpxchg(x, oldv, newv) \
+    (void*) (cairo_atomic_intptr_t) _cairo_atomic_int_cmpxchg ((cairo_atomic_intptr_t*)(x), (cairo_atomic_intptr_t)oldv, (cairo_atomic_intptr_t)newv)
+
+#endif
+
+
+#ifndef HAS_ATOMIC_OPS
+
+typedef int cairo_atomic_int_t;
+
+cairo_private void
+_cairo_atomic_int_inc (int *x);
+
+cairo_private cairo_bool_t
+_cairo_atomic_int_dec_and_test (int *x);
+
+cairo_private int
+_cairo_atomic_int_cmpxchg (int *x, int oldv, int newv);
+
+cairo_private void *
+_cairo_atomic_ptr_cmpxchg (void **x, void *oldv, void *newv);
+
+#ifdef ATOMIC_OP_NEEDS_MEMORY_BARRIER
+
+# include "cairo-compiler-private.h"
+
+cairo_private int
+_cairo_atomic_int_get (int *x);
+
+cairo_private void
+_cairo_atomic_int_set (int *x, int value);
+
+#else
+
+# define _cairo_atomic_int_get(x) (*x)
+# define _cairo_atomic_int_set(x, value) ((*x) = value)
+
+#endif
+
+#endif
+
+#define _cairo_atomic_uint_get(x) _cairo_atomic_int_get(x)
+#define _cairo_atomic_uint_cmpxchg(x, oldv, newv) \
+    _cairo_atomic_int_cmpxchg((cairo_atomic_int_t *)x, oldv, newv)
+
+#define _cairo_status_set_error(status, err) do { \
+    /* hide compiler warnings about cairo_status_t != int (gcc treats its as \
+     * an unsigned integer instead, and about ignoring the return value. */  \
+    int ret__ = _cairo_atomic_int_cmpxchg ((cairo_atomic_int_t *) status, CAIRO_STATUS_SUCCESS, err); \
+    (void) ret__; \
+} while (0)
+
+CAIRO_END_DECLS
+
+#endif
diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
new file mode 100644
index 0000000..3835399
--- /dev/null
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -0,0 +1,2240 @@
+/*
+ * Copyright © 2004 Carl Worth
+ * Copyright © 2006 Red Hat, Inc.
+ * Copyright © 2008 Chris Wilson
+ * Copyright © 2009 Peter Clifton
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Carl Worth
+ *
+ * Contributor(s):
+ *        Carl D. Worth <cworth@cworth.org>
+ *        Chris Wilson <chris@chris-wilson.co.uk>
+ *        Peter Clifton <pcjc2@cam.ac.uk> (Adaptation to PCB use)
+ */
+
+/* Provide definitions for standalone compilation */
+#include "cairoint.h"
+
+#include "cairo-freelist-private.h"
+#include "cairo-combsort-private.h"
+
+#include <glib.h>
+
+#define _cairo_error(x) (x)
+
+#define DEBUG_PRINT_STATE 1
+#define DEBUG_EVENTS 1
+#define DEBUG_TRAPS 0
+
+typedef cairo_point_t cairo_bo_point32_t;
+
+typedef struct _cairo_bo_intersect_ordinate {
+    int32_t ordinate;
+    enum { EXACT, INEXACT } exactness;
+} cairo_bo_intersect_ordinate_t;
+
+typedef struct _cairo_bo_intersect_point {
+    cairo_bo_intersect_ordinate_t x;
+    cairo_bo_intersect_ordinate_t y;
+} cairo_bo_intersect_point_t;
+
+typedef struct _cairo_bo_edge cairo_bo_edge_t;
+typedef struct _cairo_bo_trap cairo_bo_trap_t;
+
+/* A deferred trapezoid of an edge */
+struct _cairo_bo_trap {
+    cairo_bo_edge_t *right;
+    int32_t top;
+};
+
+struct _cairo_bo_edge {
+    cairo_edge_t edge;
+    cairo_bo_edge_t *prev;
+    cairo_bo_edge_t *next;
+    cairo_bo_trap_t deferred_trap;
+};
+
+/* the parent is always given by index/2 */
+#define PQ_PARENT_INDEX(i) ((i) >> 1)
+#define PQ_FIRST_ENTRY 1
+
+/* left and right children are index * 2 and (index * 2) +1 respectively */
+#define PQ_LEFT_CHILD_INDEX(i) ((i) << 1)
+
+typedef enum {
+    CAIRO_BO_EVENT_TYPE_STOP,
+    CAIRO_BO_EVENT_TYPE_INTERSECTION,
+    CAIRO_BO_EVENT_TYPE_START
+} cairo_bo_event_type_t;
+
+typedef struct _cairo_bo_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+} cairo_bo_event_t;
+
+typedef struct _cairo_bo_start_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+    cairo_bo_edge_t edge;
+} cairo_bo_start_event_t;
+
+typedef struct _cairo_bo_queue_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+    cairo_bo_edge_t *e1;
+    cairo_bo_edge_t *e2;
+} cairo_bo_queue_event_t;
+
+typedef struct _pqueue {
+    int size, max_size;
+
+    cairo_bo_event_t **elements;
+    cairo_bo_event_t *elements_embedded[1024];
+} pqueue_t;
+
+typedef struct _cairo_bo_event_queue {
+    cairo_freepool_t pool;
+    pqueue_t pqueue;
+    cairo_bo_event_t **start_events;
+} cairo_bo_event_queue_t;
+
+typedef struct _cairo_bo_sweep_line {
+    cairo_bo_edge_t *head;
+    cairo_bo_edge_t *stopped;
+    int32_t current_y;
+    cairo_bo_edge_t *current_edge;
+} cairo_bo_sweep_line_t;
+
+#if DEBUG_TRAPS
+static void
+dump_traps (cairo_traps_t *traps, const char *filename)
+{
+    FILE *file;
+    int n;
+
+    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
+        return;
+
+    if (traps->has_limits) {
+        printf ("%s: limits=(%d, %d, %d, %d)\n",
+                filename,
+                traps->limits.p1.x, traps->limits.p1.y,
+                traps->limits.p2.x, traps->limits.p2.y);
+    }
+    printf ("%s: extents=(%d, %d, %d, %d)\n",
+            filename,
+            traps->extents.p1.x, traps->extents.p1.y,
+            traps->extents.p2.x, traps->extents.p2.y);
+
+    file = fopen (filename, "a");
+    if (file != NULL) {
+        for (n = 0; n < traps->num_traps; n++) {
+            fprintf (file, "%d %d L:(%d, %d), (%d, %d) R:(%d, %d), (%d, %d)\n",
+                     traps->traps[n].top,
+                     traps->traps[n].bottom,
+                     traps->traps[n].left.p1.x,
+                     traps->traps[n].left.p1.y,
+                     traps->traps[n].left.p2.x,
+                     traps->traps[n].left.p2.y,
+                     traps->traps[n].right.p1.x,
+                     traps->traps[n].right.p1.y,
+                     traps->traps[n].right.p2.x,
+                     traps->traps[n].right.p2.y);
+        }
+        fprintf (file, "\n");
+        fclose (file);
+    }
+}
+
+static void
+dump_edges (cairo_bo_start_event_t *events,
+            int num_edges,
+            const char *filename)
+{
+    FILE *file;
+    int n;
+
+    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
+        return;
+
+    file = fopen (filename, "a");
+    if (file != NULL) {
+        for (n = 0; n < num_edges; n++) {
+            fprintf (file, "(%d, %d), (%d, %d) %d %d %d\n",
+                     events[n].edge.edge.line.p1.x,
+                     events[n].edge.edge.line.p1.y,
+                     events[n].edge.edge.line.p2.x,
+                     events[n].edge.edge.line.p2.y,
+                     events[n].edge.edge.top,
+                     events[n].edge.edge.bottom,
+                     events[n].edge.edge.dir);
+        }
+        fprintf (file, "\n");
+        fclose (file);
+    }
+}
+#endif
+
+static cairo_fixed_t
+_line_compute_intersection_x_for_y (const cairo_line_t *line,
+                                    cairo_fixed_t y)
+{
+    cairo_fixed_t x, dy;
+
+    if (y == line->p1.y)
+        return line->p1.x;
+    if (y == line->p2.y)
+        return line->p2.x;
+
+    x = line->p1.x;
+    dy = line->p2.y - line->p1.y;
+    if (dy != 0) {
+        x += _cairo_fixed_mul_div_floor (y - line->p1.y,
+                                         line->p2.x - line->p1.x,
+                                         dy);
+    }
+
+    return x;
+}
+
+static inline int
+_cairo_bo_point32_compare (cairo_bo_point32_t const *a,
+                           cairo_bo_point32_t const *b)
+{
+    int cmp;
+
+    cmp = a->y - b->y;
+    if (cmp)
+        return cmp;
+
+    return a->x - b->x;
+}
+
+/* Compare the slope of a to the slope of b, returning 1, 0, -1 if the
+ * slope a is respectively greater than, equal to, or less than the
+ * slope of b.
+ *
+ * For each edge, consider the direction vector formed from:
+ *
+ *        top -> bottom
+ *
+ * which is:
+ *
+ *        (dx, dy) = (line.p2.x - line.p1.x, line.p2.y - line.p1.y)
+ *
+ * We then define the slope of each edge as dx/dy, (which is the
+ * inverse of the slope typically used in math instruction). We never
+ * compute a slope directly as the value approaches infinity, but we
+ * can derive a slope comparison without division as follows, (where
+ * the ? represents our compare operator).
+ *
+ * 1.           slope(a) ? slope(b)
+ * 2.            adx/ady ? bdx/bdy
+ * 3.        (adx * bdy) ? (bdx * ady)
+ *
+ * Note that from step 2 to step 3 there is no change needed in the
+ * sign of the result since both ady and bdy are guaranteed to be
+ * greater than or equal to 0.
+ *
+ * When using this slope comparison to sort edges, some care is needed
+ * when interpreting the results. Since the slope compare operates on
+ * distance vectors from top to bottom it gives a correct left to
+ * right sort for edges that have a common top point, (such as two
+ * edges with start events at the same location). On the other hand,
+ * the sense of the result will be exactly reversed for two edges that
+ * have a common stop point.
+ */
+static inline int
+_slope_compare (const cairo_bo_edge_t *a,
+                const cairo_bo_edge_t *b)
+{
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm
+     * begins.
+     */
+    int32_t adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    int32_t bdx = b->edge.line.p2.x - b->edge.line.p1.x;
+
+    /* Since the dy's are all positive by construction we can fast
+     * path several common cases.
+     */
+
+    /* First check for vertical lines. */
+    if (adx == 0)
+        return -bdx;
+    if (bdx == 0)
+        return adx;
+
+    /* Then where the two edges point in different directions wrt x. */
+    if ((adx ^ bdx) < 0)
+        return adx;
+
+    /* Finally we actually need to do the general comparison. */
+    {
+        int32_t ady = a->edge.line.p2.y - a->edge.line.p1.y;
+        int32_t bdy = b->edge.line.p2.y - b->edge.line.p1.y;
+        cairo_int64_t adx_bdy = _cairo_int32x32_64_mul (adx, bdy);
+        cairo_int64_t bdx_ady = _cairo_int32x32_64_mul (bdx, ady);
+
+        return _cairo_int64_cmp (adx_bdy, bdx_ady);
+    }
+}
+
+/*
+ * We need to compare the x-coordinates of a pair of lines for a particular y,
+ * without loss of precision.
+ *
+ * The x-coordinate along an edge for a given y is:
+ *   X = A_x + (Y - A_y) * A_dx / A_dy
+ *
+ * So the inequality we wish to test is:
+ *   A_x + (Y - A_y) * A_dx / A_dy ∘ B_x + (Y - B_y) * B_dx / B_dy,
+ * where ∘ is our inequality operator.
+ *
+ * By construction, we know that A_dy and B_dy (and (Y - A_y), (Y - B_y)) are
+ * all positive, so we can rearrange it thus without causing a sign change:
+ *   A_dy * B_dy * (A_x - B_x) ∘ (Y - B_y) * B_dx * A_dy
+ *                                 - (Y - A_y) * A_dx * B_dy
+ *
+ * Given the assumption that all the deltas fit within 32 bits, we can compute
+ * this comparison directly using 128 bit arithmetic. For certain, but common,
+ * input we can reduce this down to a single 32 bit compare by inspecting the
+ * deltas.
+ *
+ * (And put the burden of the work on developing fast 128 bit ops, which are
+ * required throughout the tessellator.)
+ *
+ * See the similar discussion for _slope_compare().
+ */
+static int
+edges_compare_x_for_y_general (const cairo_bo_edge_t *a,
+                               const cairo_bo_edge_t *b,
+                               int32_t y)
+{
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm
+     * begins.
+     */
+    int32_t dx;
+    int32_t adx, ady;
+    int32_t bdx, bdy;
+    enum {
+       HAVE_NONE    = 0x0,
+       HAVE_DX      = 0x1,
+       HAVE_ADX     = 0x2,
+       HAVE_DX_ADX  = HAVE_DX | HAVE_ADX,
+       HAVE_BDX     = 0x4,
+       HAVE_DX_BDX  = HAVE_DX | HAVE_BDX,
+       HAVE_ADX_BDX = HAVE_ADX | HAVE_BDX,
+       HAVE_ALL     = HAVE_DX | HAVE_ADX | HAVE_BDX
+    } have_dx_adx_bdx = HAVE_ALL;
+
+    /* don't bother solving for abscissa if the edges' bounding boxes
+     * can be used to order them. */
+    {
+           int32_t amin, amax;
+           int32_t bmin, bmax;
+           if (a->edge.line.p1.x < a->edge.line.p2.x) {
+                   amin = a->edge.line.p1.x;
+                   amax = a->edge.line.p2.x;
+           } else {
+                   amin = a->edge.line.p2.x;
+                   amax = a->edge.line.p1.x;
+           }
+           if (b->edge.line.p1.x < b->edge.line.p2.x) {
+                   bmin = b->edge.line.p1.x;
+                   bmax = b->edge.line.p2.x;
+           } else {
+                   bmin = b->edge.line.p2.x;
+                   bmax = b->edge.line.p1.x;
+           }
+           if (amax < bmin) return -1;
+           if (amin > bmax) return +1;
+    }
+
+    ady = a->edge.line.p2.y - a->edge.line.p1.y;
+    adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    if (adx == 0)
+        have_dx_adx_bdx &= ~HAVE_ADX;
+
+    bdy = b->edge.line.p2.y - b->edge.line.p1.y;
+    bdx = b->edge.line.p2.x - b->edge.line.p1.x;
+    if (bdx == 0)
+        have_dx_adx_bdx &= ~HAVE_BDX;
+
+    dx = a->edge.line.p1.x - b->edge.line.p1.x;
+    if (dx == 0)
+        have_dx_adx_bdx &= ~HAVE_DX;
+
+#define L _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (ady, bdy), dx)
+#define A _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (adx, bdy), y - a->edge.line.p1.y)
+#define B _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (bdx, ady), y - b->edge.line.p1.y)
+    switch (have_dx_adx_bdx) {
+    default:
+    case HAVE_NONE:
+        return 0;
+    case HAVE_DX:
+        /* A_dy * B_dy * (A_x - B_x) ∘ 0 */
+        return dx; /* ady * bdy is positive definite */
+    case HAVE_ADX:
+        /* 0 ∘  - (Y - A_y) * A_dx * B_dy */
+        return adx; /* bdy * (y - a->top.y) is positive definite */
+    case HAVE_BDX:
+        /* 0 ∘ (Y - B_y) * B_dx * A_dy */
+        return -bdx; /* ady * (y - b->top.y) is positive definite */
+    case HAVE_ADX_BDX:
+        /*  0 ∘ (Y - B_y) * B_dx * A_dy - (Y - A_y) * A_dx * B_dy */
+        if ((adx ^ bdx) < 0) {
+            return adx;
+        } else if (a->edge.line.p1.y == b->edge.line.p1.y) { /* common origin */
+            cairo_int64_t adx_bdy, bdx_ady;
+
+            /* ∴ A_dx * B_dy ∘ B_dx * A_dy */
+
+            adx_bdy = _cairo_int32x32_64_mul (adx, bdy);
+            bdx_ady = _cairo_int32x32_64_mul (bdx, ady);
+
+            return _cairo_int64_cmp (adx_bdy, bdx_ady);
+        } else
+            return _cairo_int128_cmp (A, B);
+    case HAVE_DX_ADX:
+        /* A_dy * (A_x - B_x) ∘ - (Y - A_y) * A_dx */
+        if ((-adx ^ dx) < 0) {
+            return dx;
+        } else {
+            cairo_int64_t ady_dx, dy_adx;
+
+            ady_dx = _cairo_int32x32_64_mul (ady, dx);
+            dy_adx = _cairo_int32x32_64_mul (a->edge.line.p1.y - y, adx);
+
+            return _cairo_int64_cmp (ady_dx, dy_adx);
+        }
+    case HAVE_DX_BDX:
+        /* B_dy * (A_x - B_x) ∘ (Y - B_y) * B_dx */
+        if ((bdx ^ dx) < 0) {
+            return dx;
+        } else {
+            cairo_int64_t bdy_dx, dy_bdx;
+
+            bdy_dx = _cairo_int32x32_64_mul (bdy, dx);
+            dy_bdx = _cairo_int32x32_64_mul (y - b->edge.line.p1.y, bdx);
+
+            return _cairo_int64_cmp (bdy_dx, dy_bdx);
+        }
+    case HAVE_ALL:
+        /* XXX try comparing (a->edge.line.p2.x - b->edge.line.p2.x) et al */
+        return _cairo_int128_cmp (L, _cairo_int128_sub (B, A));
+    }
+#undef B
+#undef A
+#undef L
+}
+
+/*
+ * We need to compare the x-coordinate of a line for a particular y wrt to a
+ * given x, without loss of precision.
+ *
+ * The x-coordinate along an edge for a given y is:
+ *   X = A_x + (Y - A_y) * A_dx / A_dy
+ *
+ * So the inequality we wish to test is:
+ *   A_x + (Y - A_y) * A_dx / A_dy ∘ X
+ * where ∘ is our inequality operator.
+ *
+ * By construction, we know that A_dy (and (Y - A_y)) are
+ * all positive, so we can rearrange it thus without causing a sign change:
+ *   (Y - A_y) * A_dx ∘ (X - A_x) * A_dy
+ *
+ * Given the assumption that all the deltas fit within 32 bits, we can compute
+ * this comparison directly using 64 bit arithmetic.
+ *
+ * See the similar discussion for _slope_compare() and
+ * edges_compare_x_for_y_general().
+ */
+static int
+edge_compare_for_y_against_x (const cairo_bo_edge_t *a,
+                              int32_t y,
+                              int32_t x)
+{
+    int32_t adx, ady;
+    int32_t dx, dy;
+    cairo_int64_t L, R;
+
+    if (x < a->edge.line.p1.x && x < a->edge.line.p2.x)
+        return 1;
+    if (x > a->edge.line.p1.x && x > a->edge.line.p2.x)
+        return -1;
+
+    adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    dx = x - a->edge.line.p1.x;
+
+    if (adx == 0)
+        return -dx;
+    if (dx == 0 || (adx ^ dx) < 0)
+        return adx;
+
+    dy = y - a->edge.line.p1.y;
+    ady = a->edge.line.p2.y - a->edge.line.p1.y;
+
+    L = _cairo_int32x32_64_mul (dy, adx);
+    R = _cairo_int32x32_64_mul (dx, ady);
+
+    return _cairo_int64_cmp (L, R);
+}
+
+static int
+edges_compare_x_for_y (const cairo_bo_edge_t *a,
+                       const cairo_bo_edge_t *b,
+                       int32_t y)
+{
+    /* If the sweep-line is currently on an end-point of a line,
+     * then we know its precise x value (and considering that we often need to
+     * compare events at end-points, this happens frequently enough to warrant
+     * special casing).
+     */
+    enum {
+       HAVE_NEITHER = 0x0,
+       HAVE_AX      = 0x1,
+       HAVE_BX      = 0x2,
+       HAVE_BOTH    = HAVE_AX | HAVE_BX
+    } have_ax_bx = HAVE_BOTH;
+    int32_t ax, bx;
+
+    if (y == a->edge.line.p1.y)
+        ax = a->edge.line.p1.x;
+    else if (y == a->edge.line.p2.y)
+        ax = a->edge.line.p2.x;
+    else
+        have_ax_bx &= ~HAVE_AX;
+
+    if (y == b->edge.line.p1.y)
+        bx = b->edge.line.p1.x;
+    else if (y == b->edge.line.p2.y)
+        bx = b->edge.line.p2.x;
+    else
+        have_ax_bx &= ~HAVE_BX;
+
+    switch (have_ax_bx) {
+    default:
+    case HAVE_NEITHER:
+        return edges_compare_x_for_y_general (a, b, y);
+    case HAVE_AX:
+        return -edge_compare_for_y_against_x (b, y, ax);
+    case HAVE_BX:
+        return edge_compare_for_y_against_x (a, y, bx);
+    case HAVE_BOTH:
+        return ax - bx;
+    }
+}
+
+static inline int
+_line_equal (const cairo_line_t *a, const cairo_line_t *b)
+{
+    return a->p1.x == b->p1.x && a->p1.y == b->p1.y &&
+           a->p2.x == b->p2.x && a->p2.y == b->p2.y;
+}
+
+static int
+_cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t        *sweep_line,
+                                    const cairo_bo_edge_t        *a,
+                                    const cairo_bo_edge_t        *b)
+{
+    int cmp;
+
+    /* compare the edges if not identical */
+    if (! _line_equal (&a->edge.line, &b->edge.line)) {
+        cmp = edges_compare_x_for_y (a, b, sweep_line->current_y);
+        if (cmp)
+            return cmp;
+
+        /* The two edges intersect exactly at y, so fall back on slope
+         * comparison. We know that this compare_edges function will be
+         * called only when starting a new edge, (not when stopping an
+         * edge), so we don't have to worry about conditionally inverting
+         * the sense of _slope_compare. */
+        cmp = _slope_compare (a, b);
+        if (cmp)
+            return cmp;
+    }
+
+    /* We've got two collinear edges now. */
+    return b->edge.bottom - a->edge.bottom;
+}
+
+static inline cairo_int64_t
+det32_64 (int32_t a, int32_t b,
+          int32_t c, int32_t d)
+{
+    /* det = a * d - b * c */
+    return _cairo_int64_sub (_cairo_int32x32_64_mul (a, d),
+                             _cairo_int32x32_64_mul (b, c));
+}
+
+static inline cairo_int128_t
+det64x32_128 (cairo_int64_t a, int32_t       b,
+              cairo_int64_t c, int32_t       d)
+{
+    /* det = a * d - b * c */
+    return _cairo_int128_sub (_cairo_int64x32_128_mul (a, d),
+                              _cairo_int64x32_128_mul (c, b));
+}
+
+/* Compute the intersection of two lines as defined by two edges. The
+ * result is provided as a coordinate pair of 128-bit integers.
+ *
+ * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection or
+ * %CAIRO_BO_STATUS_PARALLEL if the two lines are exactly parallel.
+ */
+static cairo_bool_t
+intersect_lines (cairo_bo_edge_t                *a,
+                 cairo_bo_edge_t                *b,
+                 cairo_bo_intersect_point_t        *intersection)
+{
+    cairo_int64_t a_det, b_det;
+
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm begins.
+     * What we're doing to mitigate this is to perform clamping in
+     * cairo_bo_tessellate_polygon().
+     */
+    int32_t dx1 = a->edge.line.p1.x - a->edge.line.p2.x;
+    int32_t dy1 = a->edge.line.p1.y - a->edge.line.p2.y;
+
+    int32_t dx2 = b->edge.line.p1.x - b->edge.line.p2.x;
+    int32_t dy2 = b->edge.line.p1.y - b->edge.line.p2.y;
+
+    cairo_int64_t den_det;
+    cairo_int64_t R;
+    cairo_quorem64_t qr;
+
+    den_det = det32_64 (dx1, dy1, dx2, dy2);
+
+     /* Q: Can we determine that the lines do not intersect (within range)
+      * much more cheaply than computing the intersection point i.e. by
+      * avoiding the division?
+      *
+      *   X = ax + t * adx = bx + s * bdx;
+      *   Y = ay + t * ady = by + s * bdy;
+      *   ∴ t * (ady*bdx - bdy*adx) = bdx * (by - ay) + bdy * (ax - bx)
+      *   => t * L = R
+      *
+      * Therefore we can reject any intersection (under the criteria for
+      * valid intersection events) if:
+      *   L^R < 0 => t < 0, or
+      *   L<R => t > 1
+      *
+      * (where top/bottom must at least extend to the line endpoints).
+      *
+      * A similar substitution can be performed for s, yielding:
+      *   s * (ady*bdx - bdy*adx) = ady * (ax - bx) - adx * (ay - by)
+      */
+    R = det32_64 (dx2, dy2,
+                  b->edge.line.p1.x - a->edge.line.p1.x,
+                  b->edge.line.p1.y - a->edge.line.p1.y);
+    if (_cairo_int64_negative (den_det)) {
+        if (_cairo_int64_ge (den_det, R))
+            return FALSE;
+    } else {
+        if (_cairo_int64_le (den_det, R))
+            return FALSE;
+    }
+
+    R = det32_64 (dy1, dx1,
+                  a->edge.line.p1.y - b->edge.line.p1.y,
+                  a->edge.line.p1.x - b->edge.line.p1.x);
+    if (_cairo_int64_negative (den_det)) {
+        if (_cairo_int64_ge (den_det, R))
+            return FALSE;
+    } else {
+        if (_cairo_int64_le (den_det, R))
+            return FALSE;
+    }
+
+    /* We now know that the two lines should intersect within range. */
+
+    a_det = det32_64 (a->edge.line.p1.x, a->edge.line.p1.y,
+                      a->edge.line.p2.x, a->edge.line.p2.y);
+    b_det = det32_64 (b->edge.line.p1.x, b->edge.line.p1.y,
+                      b->edge.line.p2.x, b->edge.line.p2.y);
+
+    /* x = det (a_det, dx1, b_det, dx2) / den_det */
+    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dx1,
+                                                       b_det, dx2),
+                                         den_det);
+    if (_cairo_int64_eq (qr.rem, den_det))
+        return FALSE;
+#if 0
+    intersection->x.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
+#else
+    intersection->x.exactness = EXACT;
+    if (! _cairo_int64_is_zero (qr.rem)) {
+        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
+            qr.rem = _cairo_int64_negate (qr.rem);
+        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
+        if (_cairo_int64_ge (qr.rem, den_det)) {
+            qr.quo = _cairo_int64_add (qr.quo,
+                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
+        } else
+            intersection->x.exactness = INEXACT;
+    }
+#endif
+    intersection->x.ordinate = _cairo_int64_to_int32 (qr.quo);
+
+    /* y = det (a_det, dy1, b_det, dy2) / den_det */
+    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dy1,
+                                                       b_det, dy2),
+                                         den_det);
+    if (_cairo_int64_eq (qr.rem, den_det))
+        return FALSE;
+#if 0
+    intersection->y.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
+#else
+    intersection->y.exactness = EXACT;
+    if (! _cairo_int64_is_zero (qr.rem)) {
+        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
+            qr.rem = _cairo_int64_negate (qr.rem);
+        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
+        if (_cairo_int64_ge (qr.rem, den_det)) {
+            qr.quo = _cairo_int64_add (qr.quo,
+                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
+        } else
+            intersection->y.exactness = INEXACT;
+    }
+#endif
+    intersection->y.ordinate = _cairo_int64_to_int32 (qr.quo);
+
+    return TRUE;
+}
+
+static int
+_cairo_bo_intersect_ordinate_32_compare (cairo_bo_intersect_ordinate_t        a,
+                                         int32_t                        b)
+{
+    /* First compare the quotient */
+    if (a.ordinate > b)
+        return +1;
+    if (a.ordinate < b)
+        return -1;
+    /* With quotient identical, if remainder is 0 then compare equal */
+    /* Otherwise, the non-zero remainder makes a > b */
+    return INEXACT == a.exactness;
+}
+
+/* Does the given edge contain the given point. The point must already
+ * be known to be contained within the line determined by the edge,
+ * (most likely the point results from an intersection of this edge
+ * with another).
+ *
+ * If we had exact arithmetic, then this function would simply be a
+ * matter of examining whether the y value of the point lies within
+ * the range of y values of the edge. But since intersection points
+ * are not exact due to being rounded to the nearest integer within
+ * the available precision, we must also examine the x value of the
+ * point.
+ *
+ * The definition of "contains" here is that the given intersection
+ * point will be seen by the sweep line after the start event for the
+ * given edge and before the stop event for the edge. See the comments
+ * in the implementation for more details.
+ */
+static cairo_bool_t
+_cairo_bo_edge_contains_intersect_point (cairo_bo_edge_t                *edge,
+                                         cairo_bo_intersect_point_t        *point)
+{
+    int cmp_top, cmp_bottom;
+
+    /* XXX: When running the actual algorithm, we don't actually need to
+     * compare against edge->top at all here, since any intersection above
+     * top is eliminated early via a slope comparison. We're leaving these
+     * here for now only for the sake of the quadratic-time intersection
+     * finder which needs them.
+     */
+
+    cmp_top = _cairo_bo_intersect_ordinate_32_compare (point->y,
+                                                       edge->edge.top);
+    cmp_bottom = _cairo_bo_intersect_ordinate_32_compare (point->y,
+                                                          edge->edge.bottom);
+
+    if (cmp_top < 0 || cmp_bottom > 0)
+    {
+        return FALSE;
+    }
+
+    if (cmp_top > 0 && cmp_bottom < 0)
+    {
+        return TRUE;
+    }
+
+    /* At this stage, the point lies on the same y value as either
+     * edge->top or edge->bottom, so we have to examine the x value in
+     * order to properly determine containment. */
+
+    /* If the y value of the point is the same as the y value of the
+     * top of the edge, then the x value of the point must be greater
+     * to be considered as inside the edge. Similarly, if the y value
+     * of the point is the same as the y value of the bottom of the
+     * edge, then the x value of the point must be less to be
+     * considered as inside. */
+
+    if (cmp_top == 0) {
+        cairo_fixed_t top_x;
+
+        top_x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                    edge->edge.top);
+        return _cairo_bo_intersect_ordinate_32_compare (point->x, top_x) > 0;
+    } else { /* cmp_bottom == 0 */
+        cairo_fixed_t bot_x;
+
+        bot_x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                    edge->edge.bottom);
+        return _cairo_bo_intersect_ordinate_32_compare (point->x, bot_x) < 0;
+    }
+}
+
+/* Compute the intersection of two edges. The result is provided as a
+ * coordinate pair of 128-bit integers.
+ *
+ * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection
+ * that is within both edges, %CAIRO_BO_STATUS_NO_INTERSECTION if the
+ * intersection of the lines defined by the edges occurs outside of
+ * one or both edges, and %CAIRO_BO_STATUS_PARALLEL if the two edges
+ * are exactly parallel.
+ *
+ * Note that when determining if a candidate intersection is "inside"
+ * an edge, we consider both the infinitesimal shortening and the
+ * infinitesimal tilt rules described by John Hobby. Specifically, if
+ * the intersection is exactly the same as an edge point, it is
+ * effectively outside (no intersection is returned). Also, if the
+ * intersection point has the same
+ */
+static cairo_bool_t
+_cairo_bo_edge_intersect (cairo_bo_edge_t        *a,
+                          cairo_bo_edge_t        *b,
+                          cairo_bo_point32_t        *intersection)
+{
+    cairo_bo_intersect_point_t quorem;
+
+    if (! intersect_lines (a, b, &quorem))
+        return FALSE;
+
+    if (! _cairo_bo_edge_contains_intersect_point (a, &quorem))
+        return FALSE;
+
+    if (! _cairo_bo_edge_contains_intersect_point (b, &quorem))
+        return FALSE;
+
+    /* Now that we've correctly compared the intersection point and
+     * determined that it lies within the edge, then we know that we
+     * no longer need any more bits of storage for the intersection
+     * than we do for our edge coordinates. We also no longer need the
+     * remainder from the division. */
+    intersection->x = quorem.x.ordinate;
+    intersection->y = quorem.y.ordinate;
+
+    return TRUE;
+}
+
+static inline int
+cairo_bo_event_compare (const cairo_bo_event_t *a,
+                        const cairo_bo_event_t *b)
+{
+    int cmp;
+
+    cmp = _cairo_bo_point32_compare (&a->point, &b->point);
+    if (cmp)
+        return cmp;
+
+    cmp = a->type - b->type;
+    if (cmp)
+        return cmp;
+
+    return a - b;
+}
+
+static inline void
+_pqueue_init (pqueue_t *pq)
+{
+    pq->max_size = ARRAY_LENGTH (pq->elements_embedded);
+    pq->size = 0;
+
+    pq->elements = pq->elements_embedded;
+}
+
+static inline void
+_pqueue_fini (pqueue_t *pq)
+{
+    if (pq->elements != pq->elements_embedded)
+        free (pq->elements);
+}
+
+static cairo_status_t
+_pqueue_grow (pqueue_t *pq)
+{
+    cairo_bo_event_t **new_elements;
+    pq->max_size *= 2;
+
+    if (pq->elements == pq->elements_embedded) {
+        new_elements = _cairo_malloc_ab (pq->max_size,
+                                         sizeof (cairo_bo_event_t *));
+        if (unlikely (new_elements == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+        memcpy (new_elements, pq->elements_embedded,
+                sizeof (pq->elements_embedded));
+    } else {
+        new_elements = _cairo_realloc_ab (pq->elements,
+                                          pq->max_size,
+                                          sizeof (cairo_bo_event_t *));
+        if (unlikely (new_elements == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    pq->elements = new_elements;
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline cairo_status_t
+_pqueue_push (pqueue_t *pq, cairo_bo_event_t *event)
+{
+    cairo_bo_event_t **elements;
+    int i, parent;
+
+    if (unlikely (pq->size + 1 == pq->max_size)) {
+        cairo_status_t status;
+
+        status = _pqueue_grow (pq);
+        if (unlikely (status))
+            return status;
+    }
+
+    elements = pq->elements;
+
+    for (i = ++pq->size;
+         i != PQ_FIRST_ENTRY &&
+         cairo_bo_event_compare (event,
+                                 elements[parent = PQ_PARENT_INDEX (i)]) < 0;
+         i = parent)
+    {
+        elements[i] = elements[parent];
+    }
+
+    elements[i] = event;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline void
+_pqueue_pop (pqueue_t *pq)
+{
+    cairo_bo_event_t **elements = pq->elements;
+    cairo_bo_event_t *tail;
+    int child, i;
+
+    tail = elements[pq->size--];
+    if (pq->size == 0) {
+        elements[PQ_FIRST_ENTRY] = NULL;
+        return;
+    }
+
+    for (i = PQ_FIRST_ENTRY;
+         (child = PQ_LEFT_CHILD_INDEX (i)) <= pq->size;
+         i = child)
+    {
+        if (child != pq->size &&
+            cairo_bo_event_compare (elements[child+1],
+                                    elements[child]) < 0)
+        {
+            child++;
+        }
+
+        if (cairo_bo_event_compare (elements[child], tail) >= 0)
+            break;
+
+        elements[i] = elements[child];
+    }
+    elements[i] = tail;
+}
+
+static inline cairo_status_t
+_cairo_bo_event_queue_insert (cairo_bo_event_queue_t        *queue,
+                              cairo_bo_event_type_t         type,
+                              cairo_bo_edge_t                *e1,
+                              cairo_bo_edge_t                *e2,
+                              const cairo_point_t         *point)
+{
+    cairo_bo_queue_event_t *event;
+
+    event = _cairo_freepool_alloc (&queue->pool);
+    if (unlikely (event == NULL))
+        return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    event->type = type;
+    event->e1 = e1;
+    event->e2 = e2;
+    event->point = *point;
+
+    return _pqueue_push (&queue->pqueue, (cairo_bo_event_t *) event);
+}
+
+static void
+_cairo_bo_event_queue_delete (cairo_bo_event_queue_t *queue,
+                              cairo_bo_event_t             *event)
+{
+    _cairo_freepool_free (&queue->pool, event);
+}
+
+static cairo_bo_event_t *
+_cairo_bo_event_dequeue (cairo_bo_event_queue_t *event_queue)
+{
+    cairo_bo_event_t *event, *cmp;
+
+    event = event_queue->pqueue.elements[PQ_FIRST_ENTRY];
+    cmp = *event_queue->start_events;
+    if (event == NULL ||
+        (cmp != NULL && cairo_bo_event_compare (cmp, event) < 0))
+    {
+        event = cmp;
+        event_queue->start_events++;
+    }
+    else
+    {
+        _pqueue_pop (&event_queue->pqueue);
+    }
+
+    return event;
+}
+
+CAIRO_COMBSORT_DECLARE (_cairo_bo_event_queue_sort,
+                        cairo_bo_event_t *,
+                        cairo_bo_event_compare)
+
+static void
+_cairo_bo_event_queue_init (cairo_bo_event_queue_t         *event_queue,
+                            cairo_bo_event_t                **start_events,
+                            int                                  num_events)
+{
+    _cairo_bo_event_queue_sort (start_events, num_events);
+    start_events[num_events] = NULL;
+
+    event_queue->start_events = start_events;
+
+    _cairo_freepool_init (&event_queue->pool,
+                          sizeof (cairo_bo_queue_event_t));
+    _pqueue_init (&event_queue->pqueue);
+    event_queue->pqueue.elements[PQ_FIRST_ENTRY] = NULL;
+}
+
+static cairo_status_t
+_cairo_bo_event_queue_insert_stop (cairo_bo_event_queue_t        *event_queue,
+                                   cairo_bo_edge_t                *edge)
+{
+    cairo_bo_point32_t point;
+
+    point.y = edge->edge.bottom;
+    point.x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                  point.y);
+    return _cairo_bo_event_queue_insert (event_queue,
+                                         CAIRO_BO_EVENT_TYPE_STOP,
+                                         edge, NULL,
+                                         &point);
+}
+
+static void
+_cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
+{
+    _pqueue_fini (&event_queue->pqueue);
+    _cairo_freepool_fini (&event_queue->pool);
+}
+
+static inline cairo_status_t
+_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t        *event_queue,
+                                                           cairo_bo_edge_t        *left,
+                                                           cairo_bo_edge_t *right)
+{
+    cairo_bo_point32_t intersection;
+
+    if (_line_equal (&left->edge.line, &right->edge.line))
+        return CAIRO_STATUS_SUCCESS;
+
+    /* The names "left" and "right" here are correct descriptions of
+     * the order of the two edges within the active edge list. So if a
+     * slope comparison also puts left less than right, then we know
+     * that the intersection of these two segments has already
+     * occurred before the current sweep line position. */
+    if (_slope_compare (left, right) <= 0)
+        return CAIRO_STATUS_SUCCESS;
+
+    if (! _cairo_bo_edge_intersect (left, right, &intersection))
+        return CAIRO_STATUS_SUCCESS;
+
+    return _cairo_bo_event_queue_insert (event_queue,
+                                         CAIRO_BO_EVENT_TYPE_INTERSECTION,
+                                         left, right,
+                                         &intersection);
+}
+
+static void
+_cairo_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line)
+{
+    sweep_line->head = NULL;
+    sweep_line->stopped = NULL;
+    sweep_line->current_y = INT32_MIN;
+    sweep_line->current_edge = NULL;
+}
+
+static cairo_status_t
+_cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t        *sweep_line,
+                             cairo_bo_edge_t                *edge)
+{
+    if (sweep_line->current_edge != NULL) {
+        cairo_bo_edge_t *prev, *next;
+        int cmp;
+
+        cmp = _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                  sweep_line->current_edge,
+                                                  edge);
+        if (cmp < 0) {
+            prev = sweep_line->current_edge;
+            next = prev->next;
+            while (next != NULL &&
+                   _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                       next, edge) < 0)
+            {
+                prev = next, next = prev->next;
+            }
+
+            prev->next = edge;
+            edge->prev = prev;
+            edge->next = next;
+            if (next != NULL)
+                next->prev = edge;
+        } else if (cmp > 0) {
+            next = sweep_line->current_edge;
+            prev = next->prev;
+            while (prev != NULL &&
+                   _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                       prev, edge) > 0)
+            {
+                next = prev, prev = next->prev;
+            }
+
+            next->prev = edge;
+            edge->next = next;
+            edge->prev = prev;
+            if (prev != NULL)
+                prev->next = edge;
+            else
+                sweep_line->head = edge;
+        } else {
+            prev = sweep_line->current_edge;
+            edge->prev = prev;
+            edge->next = prev->next;
+            if (prev->next != NULL)
+                prev->next->prev = edge;
+            prev->next = edge;
+        }
+    } else {
+        sweep_line->head = edge;
+    }
+
+    sweep_line->current_edge = edge;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static void
+_cairo_bo_sweep_line_delete (cairo_bo_sweep_line_t        *sweep_line,
+                             cairo_bo_edge_t        *edge)
+{
+    if (edge->prev != NULL)
+        edge->prev->next = edge->next;
+    else
+        sweep_line->head = edge->next;
+
+    if (edge->next != NULL)
+        edge->next->prev = edge->prev;
+
+    if (sweep_line->current_edge == edge)
+        sweep_line->current_edge = edge->prev ? edge->prev : edge->next;
+}
+
+static void
+_cairo_bo_sweep_line_swap (cairo_bo_sweep_line_t        *sweep_line,
+                           cairo_bo_edge_t                *left,
+                           cairo_bo_edge_t                *right)
+{
+    if (left->prev != NULL)
+        left->prev->next = right;
+    else
+        sweep_line->head = right;
+
+    if (right->next != NULL)
+        right->next->prev = left;
+
+    left->next = right->next;
+    right->next = left;
+
+    right->prev = left->prev;
+    left->prev = right;
+}
+
+#if DEBUG_PRINT_STATE
+static void
+_cairo_bo_edge_print (cairo_bo_edge_t *edge)
+{
+    printf ("(%d, %d)-(%d, %d)",
+            edge->edge.line.p1.x, edge->edge.line.p1.y,
+            edge->edge.line.p2.x, edge->edge.line.p2.y);
+}
+
+static void
+_cairo_bo_event_print (cairo_bo_event_t *event)
+{
+    switch (event->type) {
+    case CAIRO_BO_EVENT_TYPE_START:
+        printf ("Start: ");
+        break;
+    case CAIRO_BO_EVENT_TYPE_STOP:
+        printf ("Stop: ");
+        break;
+    case CAIRO_BO_EVENT_TYPE_INTERSECTION:
+        printf ("Intersection: ");
+        break;
+    }
+    printf ("(%d, %d)\t", event->point.x, event->point.y);
+    _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e1);
+    if (event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION) {
+        printf (" X ");
+        _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e2);
+    }
+    printf ("\n");
+}
+
+static void
+_cairo_bo_event_queue_print (cairo_bo_event_queue_t *event_queue)
+{
+    /* XXX: fixme to print the start/stop array too. */
+    printf ("Event queue:\n");
+}
+
+static void
+_cairo_bo_sweep_line_print (cairo_bo_sweep_line_t *sweep_line)
+{
+    cairo_bool_t first = TRUE;
+    cairo_bo_edge_t *edge;
+
+    printf ("Sweep line from edge list: ");
+    first = TRUE;
+    for (edge = sweep_line->head;
+         edge;
+         edge = edge->next)
+    {
+        if (!first)
+            printf (", ");
+        _cairo_bo_edge_print (edge);
+        first = FALSE;
+    }
+    printf ("\n");
+}
+
+static void
+print_state (const char                        *msg,
+             cairo_bo_event_t                *event,
+             cairo_bo_event_queue_t        *event_queue,
+             cairo_bo_sweep_line_t        *sweep_line)
+{
+    printf ("%s ", msg);
+    _cairo_bo_event_print (event);
+    _cairo_bo_event_queue_print (event_queue);
+    _cairo_bo_sweep_line_print (sweep_line);
+    printf ("\n");
+}
+#endif
+
+#if DEBUG_EVENTS
+static void CAIRO_PRINTF_FORMAT (1, 2)
+event_log (const char *fmt, ...)
+{
+    FILE *file;
+
+    if (getenv ("CAIRO_DEBUG_EVENTS") == NULL)
+        return;
+
+    file = fopen ("bo-events.txt", "a");
+    if (file != NULL) {
+        va_list ap;
+
+        va_start (ap, fmt);
+        vfprintf (file, fmt, ap);
+        va_end (ap);
+
+        fclose (file);
+    }
+}
+#endif
+
+static inline cairo_bool_t
+edges_colinear (const cairo_bo_edge_t *a, const cairo_bo_edge_t *b)
+{
+    if (_line_equal (&a->edge.line, &b->edge.line))
+        return TRUE;
+
+    if (_slope_compare (a, b))
+        return FALSE;
+
+    /* The choice of y is not truly arbitrary since we must guarantee that it
+     * is greater than the start of either line.
+     */
+    if (a->edge.line.p1.y == b->edge.line.p1.y) {
+        return a->edge.line.p1.x == b->edge.line.p1.x;
+    } else if (a->edge.line.p1.y < b->edge.line.p1.y) {
+        return edge_compare_for_y_against_x (b,
+                                             a->edge.line.p1.y,
+                                             a->edge.line.p1.x) == 0;
+    } else {
+        return edge_compare_for_y_against_x (a,
+                                             b->edge.line.p1.y,
+                                             b->edge.line.p1.x) == 0;
+    }
+}
+
+/* Adds the trapezoid, if any, of the left edge to the #cairo_traps_t */
+static cairo_status_t
+_cairo_bo_edge_end_trap (cairo_bo_edge_t        *left,
+                         int32_t                 bot,
+                         cairo_traps_t                *traps)
+{
+    cairo_bo_trap_t *trap = &left->deferred_trap;
+
+    /* Only emit (trivial) non-degenerate trapezoids with positive height. */
+    if (likely (trap->top < bot)) {
+#if 0
+        _cairo_traps_add_trap (traps,
+                               trap->top, bot,
+                               &left->edge.line, &trap->right->edge.line);
+#else
+        printf ("added trap\n");
+#endif
+
+#if DEBUG_PRINT_STATE
+        printf ("Deferred trap: left=(%d, %d)-(%d,%d) "
+                "right=(%d,%d)-(%d,%d) top=%d, bot=%d\n",
+                left->edge.line.p1.x, left->edge.line.p1.y,
+                left->edge.line.p2.x, left->edge.line.p2.y,
+                trap->right->edge.line.p1.x, trap->right->edge.line.p1.y,
+                trap->right->edge.line.p2.x, trap->right->edge.line.p2.y,
+                trap->top, bot);
+#endif
+#if DEBUG_EVENTS
+        event_log ("end trap: %lu %lu %d %d\n",
+                   (long) left,
+                   (long) trap->right,
+                   trap->top,
+                   bot);
+#endif
+    }
+
+//    trap->right = NULL;
+
+//    return _cairo_traps_status (traps);
+    return 0;
+}
+
+
+/* Start a new trapezoid at the given top y coordinate, whose edges
+ * are `edge' and `edge->next'. If `edge' already has a trapezoid,
+ * then either add it to the traps in `traps', if the trapezoid's
+ * right edge differs from `edge->next', or do nothing if the new
+ * trapezoid would be a continuation of the existing one. */
+static inline cairo_status_t
+_cairo_bo_edge_start_or_continue_trap (cairo_bo_edge_t        *left,
+                                       cairo_bo_edge_t  *right,
+                                       int               top,
+                                       cairo_traps_t        *traps)
+{
+    cairo_status_t status;
+
+    if (left->deferred_trap.right == right)
+        return CAIRO_STATUS_SUCCESS;
+
+    if (left->deferred_trap.right != NULL) {
+        if (right != NULL && edges_colinear (left->deferred_trap.right, right))
+        {
+            /* continuation on right, so just swap edges */
+            left->deferred_trap.right = right;
+            return CAIRO_STATUS_SUCCESS;
+        }
+
+        status = _cairo_bo_edge_end_trap (left, top, traps);
+        if (unlikely (status))
+            return status;
+    }
+
+    if (right != NULL && ! edges_colinear (left, right)) {
+        left->deferred_trap.top = top;
+        left->deferred_trap.right = right;
+
+#if DEBUG_EVENTS
+        event_log ("begin trap: %lu %lu %d\n",
+                   (long) left,
+                   (long) right,
+                   top);
+#endif
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline cairo_status_t
+_active_edges_to_traps (cairo_bo_edge_t                *left,
+                        int32_t                         top,
+                        cairo_traps_t                *traps)
+{
+    cairo_bo_edge_t *right;
+    cairo_status_t status;
+
+#if DEBUG_PRINT_STATE
+    printf ("Processing active edges for %d\n", top);
+#endif
+
+    while (left != NULL) {
+        int in_out;
+
+        /* Greedily search for the closing edge, so that we generate the
+         * maximal span width with the minimal number of trapezoids.
+         */
+        in_out = left->edge.dir;
+
+        /* Check if there is a co-linear edge with an existing trap */
+        right = left->next;
+        if (left->deferred_trap.right == NULL) {
+            while (right != NULL && right->deferred_trap.right == NULL)
+                right = right->next;
+
+            if (right != NULL && edges_colinear (left, right)) {
+                /* continuation on left */
+                left->deferred_trap = right->deferred_trap;
+                right->deferred_trap.right = NULL;
+            }
+        }
+
+        /* End all subsumed traps */
+        right = left->next;
+        while (right != NULL) {
+            if (right->deferred_trap.right != NULL) {
+                status = _cairo_bo_edge_end_trap (right, top, traps);
+                if (unlikely (status))
+                    return status;
+            }
+
+            in_out += right->edge.dir;
+            if (in_out == 0) {
+                cairo_bo_edge_t *next;
+                cairo_bool_t skip = FALSE;
+
+                /* skip co-linear edges */
+                next = right->next;
+                if (next != NULL)
+                    skip = edges_colinear (right, next);
+
+                if (! skip)
+                    break;
+            }
+
+            right = right->next;
+        }
+
+        status = _cairo_bo_edge_start_or_continue_trap (left, right,
+                                                        top, traps);
+        if (unlikely (status))
+            return status;
+
+        left = right;
+        if (left != NULL)
+            left = left->next;
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+
+/* Execute a single pass of the Bentley-Ottmann algorithm on edges,
+ * generating trapezoids according to the fill_rule and appending them
+ * to traps. */
+static cairo_status_t
+_cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
+                                            int                  num_events,
+                                            cairo_traps_t       *traps,
+                                            int                 *num_intersections)
+{
+    cairo_status_t status = CAIRO_STATUS_SUCCESS; /* silence compiler */
+    int intersection_count = 0;
+    cairo_bo_event_queue_t event_queue;
+    cairo_bo_sweep_line_t sweep_line;
+    cairo_bo_event_t *event;
+    cairo_bo_edge_t *left, *right;
+    cairo_bo_edge_t *e1, *e2;
+
+#if DEBUG_EVENTS
+    {
+        int i;
+
+        for (i = 0; i < num_events; i++) {
+            cairo_bo_start_event_t *event =
+                ((cairo_bo_start_event_t **) start_events)[i];
+            event_log ("edge: %lu (%d, %d) (%d, %d) (%d, %d) %d\n",
+//                       (long) &events[i].edge,
+                       (long) 666,
+                       event->edge.edge.line.p1.x,
+                       event->edge.edge.line.p1.y,
+                       event->edge.edge.line.p2.x,
+                       event->edge.edge.line.p2.y,
+                       event->edge.edge.top,
+                       event->edge.edge.bottom,
+                       event->edge.edge.dir);
+        }
+    }
+#endif
+
+    _cairo_bo_event_queue_init (&event_queue, start_events, num_events);
+    _cairo_bo_sweep_line_init (&sweep_line);
+
+    while ((event = _cairo_bo_event_dequeue (&event_queue))) {
+        if (event->point.y != sweep_line.current_y) {
+            for (e1 = sweep_line.stopped; e1; e1 = e1->next) {
+                if (e1->deferred_trap.right != NULL) {
+                    status = _cairo_bo_edge_end_trap (e1,
+                                                      e1->edge.bottom,
+                                                      traps);
+                    if (unlikely (status))
+                        goto unwind;
+                }
+            }
+            sweep_line.stopped = NULL;
+
+            status = _active_edges_to_traps (sweep_line.head,
+                                             sweep_line.current_y,
+                                             traps);
+            if (unlikely (status))
+                goto unwind;
+
+            sweep_line.current_y = event->point.y;
+        }
+
+#if DEBUG_EVENTS
+        event_log ("event: %d (%ld, %ld) %lu, %lu\n",
+                   event->type,
+                   (long) event->point.x,
+                   (long) event->point.y,
+                   (long) ((cairo_bo_queue_event_t *)event)->e1,
+                   (long) ((cairo_bo_queue_event_t *)event)->e2);
+#endif
+
+        switch (event->type) {
+        case CAIRO_BO_EVENT_TYPE_START:
+            e1 = &((cairo_bo_start_event_t *) event)->edge;
+            printf ("Start event\n");
+
+            status = _cairo_bo_sweep_line_insert (&sweep_line, e1);
+            if (unlikely (status))
+                goto unwind;
+
+            status = _cairo_bo_event_queue_insert_stop (&event_queue, e1);
+            if (unlikely (status))
+                goto unwind;
+
+            /* check to see if this is a continuation of a stopped edge */
+            /* XXX change to an infinitesimal lengthening rule */
+            for (left = sweep_line.stopped; left; left = left->next) {
+                if (e1->edge.top <= left->edge.bottom &&
+                    edges_colinear (e1, left))
+                {
+                    e1->deferred_trap = left->deferred_trap;
+                    if (left->prev != NULL)
+                        left->prev = left->next;
+                    else
+                        sweep_line.stopped = left->next;
+                    if (left->next != NULL)
+                        left->next->prev = left->prev;
+                    break;
+                }
+            }
+
+            left = e1->prev;
+            right = e1->next;
+
+            if (left != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e1);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            if (right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+
+        case CAIRO_BO_EVENT_TYPE_STOP:
+            printf ("Stop event\n");
+            e1 = ((cairo_bo_queue_event_t *) event)->e1;
+            _cairo_bo_event_queue_delete (&event_queue, event);
+
+            left = e1->prev;
+            right = e1->next;
+
+            _cairo_bo_sweep_line_delete (&sweep_line, e1);
+
+            /* first, check to see if we have a continuation via a fresh edge */
+            if (e1->deferred_trap.right != NULL) {
+                e1->next = sweep_line.stopped;
+                if (sweep_line.stopped != NULL)
+                    sweep_line.stopped->prev = e1;
+                sweep_line.stopped = e1;
+                e1->prev = NULL;
+            }
+
+            if (left != NULL && right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+
+        case CAIRO_BO_EVENT_TYPE_INTERSECTION:
+            printf ("Intersection event\n");
+            e1 = ((cairo_bo_queue_event_t *) event)->e1;
+            e2 = ((cairo_bo_queue_event_t *) event)->e2;
+            _cairo_bo_event_queue_delete (&event_queue, event);
+
+            /* skip this intersection if its edges are not adjacent */
+            if (e2 != e1->next)
+                break;
+
+            intersection_count++;
+
+            left = e1->prev;
+            right = e2->next;
+
+            _cairo_bo_sweep_line_swap (&sweep_line, e1, e2);
+
+            /* after the swap e2 is left of e1 */
+
+            if (left != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e2);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            if (right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+        }
+    }
+
+    *num_intersections = intersection_count;
+    for (e1 = sweep_line.stopped; e1; e1 = e1->next) {
+        if (e1->deferred_trap.right != NULL) {
+            status = _cairo_bo_edge_end_trap (e1, e1->edge.bottom, traps);
+            if (unlikely (status))
+                break;
+        }
+    }
+ unwind:
+    _cairo_bo_event_queue_fini (&event_queue);
+
+#if DEBUG_EVENTS
+    event_log ("\n");
+#endif
+
+    return status;
+}
+
+cairo_status_t
+_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
+                                           const cairo_polygon_t *polygon)
+{
+    int intersections;
+    cairo_status_t status;
+    cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+    cairo_bo_start_event_t *events;
+    cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+    cairo_bo_event_t **event_ptrs;
+    int num_events;
+    int i;
+
+    num_events = polygon->num_edges;
+    if (unlikely (0 == num_events))
+        return CAIRO_STATUS_SUCCESS;
+
+    events = stack_events;
+    event_ptrs = stack_event_ptrs;
+    if (num_events > ARRAY_LENGTH (stack_events)) {
+        events = _cairo_malloc_ab_plus_c (num_events,
+                                          sizeof (cairo_bo_start_event_t) +
+                                          sizeof (cairo_bo_event_t *),
+                                          sizeof (cairo_bo_event_t *));
+        if (unlikely (events == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+        event_ptrs = (cairo_bo_event_t **) (events + num_events);
+    }
+
+    for (i = 0; i < num_events; i++) {
+        event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+
+        events[i].type = CAIRO_BO_EVENT_TYPE_START;
+        events[i].point.y = polygon->edges[i].top;
+        events[i].point.x =
+            _line_compute_intersection_x_for_y (&polygon->edges[i].line,
+                                                events[i].point.y);
+
+        events[i].edge.edge = polygon->edges[i];
+        events[i].edge.deferred_trap.right = NULL;
+        events[i].edge.prev = NULL;
+        events[i].edge.next = NULL;
+    }
+
+#if DEBUG_TRAPS
+    dump_edges (events, num_events, "bo-polygon-edges.txt");
+#endif
+
+    /* XXX: This would be the convenient place to throw in multiple
+     * passes of the Bentley-Ottmann algorithm. It would merely
+     * require storing the results of each pass into a temporary
+     * cairo_traps_t. */
+    status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                         num_events,
+                                                         traps,
+                                                         &intersections);
+#if DEBUG_TRAPS
+    dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+    if (events != stack_events)
+        free (events);
+
+    return status;
+}
+
+#if 0
+cairo_status_t
+_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
+                                         cairo_fill_rule_t fill_rule)
+{
+    cairo_status_t status;
+    cairo_polygon_t polygon;
+    int i;
+
+    if (unlikely (0 == traps->num_traps))
+        return CAIRO_STATUS_SUCCESS;
+
+#if DEBUG_TRAPS
+    dump_traps (traps, "bo-traps-in.txt");
+#endif
+
+    _cairo_polygon_init (&polygon);
+    _cairo_polygon_limit (&polygon, traps->limits, traps->num_limits);
+
+    for (i = 0; i < traps->num_traps; i++) {
+        status = _cairo_polygon_add_line (&polygon,
+                                          &traps->traps[i].left,
+                                          traps->traps[i].top,
+                                          traps->traps[i].bottom,
+                                          1);
+        if (unlikely (status))
+            goto CLEANUP;
+
+        status = _cairo_polygon_add_line (&polygon,
+                                          &traps->traps[i].right,
+                                          traps->traps[i].top,
+                                          traps->traps[i].bottom,
+                                          -1);
+        if (unlikely (status))
+            goto CLEANUP;
+    }
+
+    _cairo_traps_clear (traps);
+    status = _cairo_bentley_ottmann_tessellate_polygon (traps,
+                                                        &polygon,
+                                                        fill_rule);
+
+#if DEBUG_TRAPS
+    dump_traps (traps, "bo-traps-out.txt");
+#endif
+
+  CLEANUP:
+    _cairo_polygon_fini (&polygon);
+
+    return status;
+}
+#endif
+
+#if 0
+static cairo_bool_t
+edges_have_an_intersection_quadratic (cairo_bo_edge_t        *edges,
+                                      int                 num_edges)
+
+{
+    int i, j;
+    cairo_bo_edge_t *a, *b;
+    cairo_bo_point32_t intersection;
+
+    /* We must not be given any upside-down edges. */
+    for (i = 0; i < num_edges; i++) {
+        assert (_cairo_bo_point32_compare (&edges[i].top, &edges[i].bottom) < 0);
+        edges[i].edge.line.p1.x <<= CAIRO_BO_GUARD_BITS;
+        edges[i].edge.line.p1.y <<= CAIRO_BO_GUARD_BITS;
+        edges[i].edge.line.p2.x <<= CAIRO_BO_GUARD_BITS;
+        edges[i].edge.line.p2.y <<= CAIRO_BO_GUARD_BITS;
+    }
+
+    for (i = 0; i < num_edges; i++) {
+        for (j = 0; j < num_edges; j++) {
+            if (i == j)
+                continue;
+
+            a = &edges[i];
+            b = &edges[j];
+
+            if (! _cairo_bo_edge_intersect (a, b, &intersection))
+                continue;
+
+            printf ("Found intersection (%d,%d) between (%d,%d)-(%d,%d) and (%d,%d)-(%d,%d)\n",
+                    intersection.x,
+                    intersection.y,
+                    a->edge.line.p1.x, a->edge.line.p1.y,
+                    a->edge.line.p2.x, a->edge.line.p2.y,
+                    b->edge.line.p1.x, b->edge.line.p1.y,
+                    b->edge.line.p2.x, b->edge.line.p2.y);
+
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+#define TEST_MAX_EDGES 10
+
+typedef struct test {
+    const char *name;
+    const char *description;
+    int num_edges;
+    cairo_bo_edge_t edges[TEST_MAX_EDGES];
+} test_t;
+
+static test_t
+tests[] = {
+    {
+        "3 near misses",
+        "3 edges all intersecting very close to each other",
+        3,
+        {
+            { { 4, 2}, {0, 0}, { 9, 9}, NULL, NULL },
+            { { 7, 2}, {0, 0}, { 2, 3}, NULL, NULL },
+            { { 5, 2}, {0, 0}, { 1, 7}, NULL, NULL }
+        }
+    },
+    {
+        "inconsistent data",
+        "Derived from random testing---was leading to skip list and edge list disagreeing.",
+        2,
+        {
+            { { 2, 3}, {0, 0}, { 8, 9}, NULL, NULL },
+            { { 2, 3}, {0, 0}, { 6, 7}, NULL, NULL }
+        }
+    },
+    {
+        "failed sort",
+        "A test derived from random testing that leads to an inconsistent sort --- looks like we just can't attempt to validate the sweep line with edge_compare?",
+        3,
+        {
+            { { 6, 2}, {0, 0}, { 6, 5}, NULL, NULL },
+            { { 3, 5}, {0, 0}, { 5, 6}, NULL, NULL },
+            { { 9, 2}, {0, 0}, { 5, 6}, NULL, NULL },
+        }
+    },
+    {
+        "minimal-intersection",
+        "Intersection of a two from among the smallest possible edges.",
+        2,
+        {
+            { { 0, 0}, {0, 0}, { 1, 1}, NULL, NULL },
+            { { 1, 0}, {0, 0}, { 0, 1}, NULL, NULL }
+        }
+    },
+    {
+        "simple",
+        "A simple intersection of two edges at an integer (2,2).",
+        2,
+        {
+            { { 1, 1}, {0, 0}, { 3, 3}, NULL, NULL },
+            { { 2, 1}, {0, 0}, { 2, 3}, NULL, NULL }
+        }
+    },
+    {
+        "bend-to-horizontal",
+        "With intersection truncation one edge bends to horizontal",
+        2,
+        {
+            { { 9, 1}, {0, 0}, {3, 7}, NULL, NULL },
+            { { 3, 5}, {0, 0}, {9, 9}, NULL, NULL }
+        }
+    }
+};
+
+/*
+    {
+        "endpoint",
+        "An intersection that occurs at the endpoint of a segment.",
+        {
+            { { 4, 6}, { 5, 6}, NULL, { { NULL }} },
+            { { 4, 5}, { 5, 7}, NULL, { { NULL }} },
+            { { 0, 0}, { 0, 0}, NULL, { { NULL }} },
+        }
+    }
+    {
+        name = "overlapping",
+        desc = "Parallel segments that share an endpoint, with different slopes.",
+        edges = {
+            { top = { x = 2, y = 0}, bottom = { x = 1, y = 1}},
+            { top = { x = 2, y = 0}, bottom = { x = 0, y = 2}},
+            { top = { x = 0, y = 3}, bottom = { x = 1, y = 3}},
+            { top = { x = 0, y = 3}, bottom = { x = 2, y = 3}},
+            { top = { x = 0, y = 4}, bottom = { x = 0, y = 6}},
+            { top = { x = 0, y = 5}, bottom = { x = 0, y = 6}}
+        }
+    },
+    {
+        name = "hobby_stage_3",
+        desc = "A particularly tricky part of the 3rd stage of the 'hobby' test below.",
+        edges = {
+            { top = { x = -1, y = -2}, bottom = { x =  4, y = 2}},
+            { top = { x =  5, y =  3}, bottom = { x =  9, y = 5}},
+            { top = { x =  5, y =  3}, bottom = { x =  6, y = 3}},
+        }
+    },
+    {
+        name = "hobby",
+        desc = "Example from John Hobby's paper. Requires 3 passes of the iterative algorithm.",
+        edges = {
+            { top = { x =   0, y =   0}, bottom = { x =   9, y =   5}},
+            { top = { x =   0, y =   0}, bottom = { x =  13, y =   6}},
+            { top = { x =  -1, y =  -2}, bottom = { x =   9, y =   5}}
+        }
+    },
+    {
+        name = "slope",
+        desc = "Edges with same start/stop points but different slopes",
+        edges = {
+            { top = { x = 4, y = 1}, bottom = { x = 6, y = 3}},
+            { top = { x = 4, y = 1}, bottom = { x = 2, y = 3}},
+            { top = { x = 2, y = 4}, bottom = { x = 4, y = 6}},
+            { top = { x = 6, y = 4}, bottom = { x = 4, y = 6}}
+        }
+    },
+    {
+        name = "horizontal",
+        desc = "Test of a horizontal edge",
+        edges = {
+            { top = { x = 1, y = 1}, bottom = { x = 6, y = 6}},
+            { top = { x = 2, y = 3}, bottom = { x = 5, y = 3}}
+        }
+    },
+    {
+        name = "vertical",
+        desc = "Test of a vertical edge",
+        edges = {
+            { top = { x = 5, y = 1}, bottom = { x = 5, y = 7}},
+            { top = { x = 2, y = 4}, bottom = { x = 8, y = 5}}
+        }
+    },
+    {
+        name = "congruent",
+        desc = "Two overlapping edges with the same slope",
+        edges = {
+            { top = { x = 5, y = 1}, bottom = { x = 5, y = 7}},
+            { top = { x = 5, y = 2}, bottom = { x = 5, y = 6}},
+            { top = { x = 2, y = 4}, bottom = { x = 8, y = 5}}
+        }
+    },
+    {
+        name = "multi",
+        desc = "Several segments with a common intersection point",
+        edges = {
+            { top = { x = 1, y = 2}, bottom = { x = 5, y = 4} },
+            { top = { x = 1, y = 1}, bottom = { x = 5, y = 5} },
+            { top = { x = 2, y = 1}, bottom = { x = 4, y = 5} },
+            { top = { x = 4, y = 1}, bottom = { x = 2, y = 5} },
+            { top = { x = 5, y = 1}, bottom = { x = 1, y = 5} },
+            { top = { x = 5, y = 2}, bottom = { x = 1, y = 4} }
+        }
+    }
+};
+*/
+
+static int
+run_test (const char                *test_name,
+          cairo_bo_edge_t        *test_edges,
+          int                         num_edges)
+{
+    int i, intersections, passes;
+    cairo_bo_edge_t *edges;
+    cairo_array_t intersected_edges;
+
+    printf ("Testing: %s\n", test_name);
+
+    _cairo_array_init (&intersected_edges, sizeof (cairo_bo_edge_t));
+
+//    intersections = _cairo_bentley_ottmann_intersect_edges (test_edges, num_edges, &intersected_edges);
+
+      _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
+                                            int                         num_events,
+                                            cairo_fill_rule_t         fill_rule,
+                                            cairo_traps_t        *traps,
+                                            int                        *num_intersections)
+
+    if (intersections)
+        printf ("Pass 1 found %d intersections:\n", intersections);
+
+
+    /* XXX: Multi-pass Bentley-Ottmmann. Preferable would be to add a
+     * pass of Hobby's tolerance-square algorithm instead. */
+    passes = 1;
+    while (intersections) {
+        int num_edges = _cairo_array_num_elements (&intersected_edges);
+        passes++;
+        edges = _cairo_malloc_ab (num_edges, sizeof (cairo_bo_edge_t));
+        assert (edges != NULL);
+        memcpy (edges, _cairo_array_index (&intersected_edges, 0), num_edges * sizeof (cairo_bo_edge_t));
+        _cairo_array_fini (&intersected_edges);
+        _cairo_array_init (&intersected_edges, sizeof (cairo_bo_edge_t));
+        intersections = _cairo_bentley_ottmann_intersect_edges (edges, num_edges, &intersected_edges);
+        free (edges);
+
+        if (intersections){
+            printf ("Pass %d found %d remaining intersections:\n", passes, intersections);
+        } else {
+            if (passes > 3)
+                for (i = 0; i < passes; i++)
+                    printf ("*");
+            printf ("No remainining intersections found after pass %d\n", passes);
+        }
+    }
+
+    if (edges_have_an_intersection_quadratic (_cairo_array_index (&intersected_edges, 0),
+                                              _cairo_array_num_elements (&intersected_edges)))
+        printf ("*** FAIL ***\n");
+    else
+        printf ("PASS\n");
+
+    _cairo_array_fini (&intersected_edges);
+
+    return 0;
+}
+
+#define MAX_RANDOM 300
+
+int
+main (void)
+{
+    char random_name[] = "random-XX";
+    cairo_bo_edge_t random_edges[MAX_RANDOM], *edge;
+    unsigned int i, num_random;
+    test_t *test;
+
+    for (i = 0; i < ARRAY_LENGTH (tests); i++) {
+        test = &tests[i];
+        run_test (test->name, test->edges, test->num_edges);
+    }
+
+    for (num_random = 0; num_random < MAX_RANDOM; num_random++) {
+        srand (0);
+        for (i = 0; i < num_random; i++) {
+            do {
+                edge = &random_edges[i];
+                edge->edge.line.p1.x = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
+                edge->edge.line.p1.y = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
+                edge->edge.line.p2.x = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
+                edge->edge.line.p2.y = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
+                if (edge->edge.line.p1.y > edge->edge.line.p2.y) {
+                    int32_t tmp = edge->edge.line.p1.y;
+                    edge->edge.line.p1.y = edge->edge.line.p2.y;
+                    edge->edge.line.p2.y = tmp;
+                }
+            } while (edge->edge.line.p1.y == edge->edge.line.p2.y);
+        }
+
+        sprintf (random_name, "random-%02d", num_random);
+
+        run_test (random_name, random_edges, num_random);
+    }
+
+    return 0;
+}
+#endif
+
+typedef struct {
+  int x;
+  int y;
+} bos_point;
+
+typedef struct {
+  bos_point a;
+  bos_point b;
+  int num;
+} bos_line;
+
+cairo_status_t
+bentley_ottmann_intersect_segments (GList *data)
+{
+    int intersections;
+    cairo_status_t status;
+    cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+    cairo_bo_start_event_t *events;
+    cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+    cairo_bo_event_t **event_ptrs;
+    int num_events;
+    int i;
+    cairo_traps_t *traps = NULL;
+    GList *iter;
+
+    num_events = g_list_length (data);
+    if (unlikely (0 == num_events))
+        return CAIRO_STATUS_SUCCESS;
+
+    events = stack_events;
+    event_ptrs = stack_event_ptrs;
+    if (num_events > ARRAY_LENGTH (stack_events)) {
+        events = _cairo_malloc_ab_plus_c (num_events,
+                                          sizeof (cairo_bo_start_event_t) +
+                                          sizeof (cairo_bo_event_t *),
+                                          sizeof (cairo_bo_event_t *));
+        if (unlikely (events == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+        event_ptrs = (cairo_bo_event_t **) (events + num_events);
+    }
+
+    for (i = 0, iter = data; i < num_events; i++, iter = g_list_next (iter)) {
+        bos_line *line = iter->data;
+        cairo_edge_t *cairo_edge = malloc (sizeof (cairo_edge_t));
+
+        cairo_edge->line.p1.x = line->a.x;
+        cairo_edge->line.p1.y = line->a.y;
+        cairo_edge->line.p2.x = line->b.x;
+        cairo_edge->line.p2.y = line->b.y;
+        cairo_edge->top = MIN (cairo_edge->line.p1.y, cairo_edge->line.p2.y);
+        cairo_edge->bottom = MAX (cairo_edge->line.p1.y, cairo_edge->line.p2.y);
+        cairo_edge->dir = 0;
+
+        event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+
+        events[i].type = CAIRO_BO_EVENT_TYPE_START;
+        events[i].point.y = cairo_edge->top;
+        events[i].point.x =
+            _line_compute_intersection_x_for_y (&cairo_edge->line,
+                                                events[i].point.y);
+
+        events[i].edge.edge = *cairo_edge;
+        events[i].edge.deferred_trap.right = NULL;
+        events[i].edge.prev = NULL;
+        events[i].edge.next = NULL;
+    }
+
+    /* XXX: This would be the convenient place to throw in multiple
+     * passes of the Bentley-Ottmann algorithm. It would merely
+     * require storing the results of each pass into a temporary
+     * cairo_traps_t. */
+    status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                         num_events,
+                                                         traps,
+                                                         &intersections);
+#if DEBUG_TRAPS
+    dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+    if (events != stack_events)
+        free (events);
+
+    return status;
+}
+
+void
+my_cairo_test (void)
+{
+  bos_line *points;
+  GList *data = NULL;
+  int i = 0;
+
+  printf ("Cairo bentley ottmann test\n");
+
+  points = g_new0 (bos_line, 4);
+
+  /* Line from (10,10)-(20,20) */
+  points[i].a.x = 10; points[i].a.y = 10;
+  points[i].b.x = 20; points[i].b.y = 20;
+  points[i].num = i;
+  data = g_list_prepend (data, &points[i]);
+  i++;
+
+  /* Line from (10,20)-(20,10) */
+  points[i].a.x = 20; points[i].a.y = 10;
+  points[i].b.x = 10; points[i].b.y = 20;
+  points[i].num = i;
+  data = g_list_prepend (data, &points[i]);
+  i++;
+
+#if 0
+  /* Line from (14,10)-(16,20) */
+  points[i].a.x = 14; points[i].a.y = 10;
+  points[i].b.x = 16; points[i].b.y = 20;
+  points[i].num = i;
+  data = g_list_prepend (data, &points[i]);
+  i++;
+
+  /* Line from (16,10)-(18,20) */
+  points[i].a.x = 16; points[i].a.y = 10;
+  points[i].b.x = 18; points[i].b.y = 20;
+  points[i].num = i;
+  data = g_list_prepend (data, &points[i]);
+  i++;
+#endif
+
+  bentley_ottmann_intersect_segments (data);
+}
diff --git a/src/cairo/cairo-cache-private.h b/src/cairo/cairo-cache-private.h
new file mode 100644
index 0000000..49ff69c
--- /dev/null
+++ b/src/cairo/cairo-cache-private.h
@@ -0,0 +1,145 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Red Hat, Inc.
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributor(s):
+ *      Keith Packard <keithp@keithp.com>
+ *	Graydon Hoare <graydon@redhat.com>
+ *	Carl Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_CACHE_PRIVATE_H
+#define CAIRO_CACHE_PRIVATE_H
+
+#include "cairo-compiler-private.h"
+#include "cairo-types-private.h"
+
+/**
+ * cairo_cache_entry_t:
+ *
+ * A #cairo_cache_entry_t contains both a key and a value for
+ * #cairo_cache_t. User-derived types for #cairo_cache_entry_t must
+ * have a #cairo_cache_entry_t as their first field. For example:
+ *
+ * 	typedef _my_entry {
+ *	    cairo_cache_entry_t base;
+ *	    ... Remainder of key and value fields here ..
+ *	} my_entry_t;
+ *
+ * which then allows a pointer to my_entry_t to be passed to any of
+ * the #cairo_cache_t functions as follows without requiring a cast:
+ *
+ *	_cairo_cache_insert (cache, &my_entry->base, size);
+ *
+ * IMPORTANT: The caller is responsible for initializing
+ * my_entry->base.hash with a hash code derived from the key.  The
+ * essential property of the hash code is that keys_equal must never
+ * return %TRUE for two keys that have different hashes. The best hash
+ * code will reduce the frequency of two keys with the same code for
+ * which keys_equal returns %FALSE.
+ *
+ * The user must also initialize my_entry->base.size to indicate
+ * the size of the current entry. What units to use for size is
+ * entirely up to the caller, (though the same units must be used for
+ * the max_size parameter passed to _cairo_cache_create()). If all
+ * entries are close to the same size, the simplest thing to do is to
+ * just use units of "entries", (eg. set size==1 in all entries and
+ * set max_size to the number of entries which you want to be saved
+ * in the cache).
+ *
+ * Which parts of the entry make up the "key" and which part make up
+ * the value are entirely up to the caller, (as determined by the
+ * computation going into base.hash as well as the keys_equal
+ * function). A few of the #cairo_cache_t functions accept an entry which
+ * will be used exclusively as a "key", (indicated by a parameter name
+ * of key). In these cases, the value-related fields of the entry need
+ * not be initialized if so desired.
+ **/
+typedef struct _cairo_cache_entry {
+    unsigned long hash;
+    unsigned long size;
+} cairo_cache_entry_t;
+
+typedef cairo_bool_t (*cairo_cache_predicate_func_t) (const void *entry);
+
+struct _cairo_cache {
+    cairo_hash_table_t *hash_table;
+
+    cairo_cache_predicate_func_t predicate;
+    cairo_destroy_func_t entry_destroy;
+
+    unsigned long max_size;
+    unsigned long size;
+
+    int freeze_count;
+};
+
+typedef cairo_bool_t
+(*cairo_cache_keys_equal_func_t) (const void *key_a, const void *key_b);
+
+typedef void
+(*cairo_cache_callback_func_t) (void *entry,
+				void *closure);
+
+cairo_private cairo_status_t
+_cairo_cache_init (cairo_cache_t *cache,
+	           cairo_cache_keys_equal_func_t keys_equal,
+		   cairo_cache_predicate_func_t  predicate,
+		   cairo_destroy_func_t	   entry_destroy,
+		   unsigned long		   max_size);
+
+cairo_private void
+_cairo_cache_fini (cairo_cache_t *cache);
+
+cairo_private void
+_cairo_cache_freeze (cairo_cache_t *cache);
+
+cairo_private void
+_cairo_cache_thaw (cairo_cache_t *cache);
+
+cairo_private void *
+_cairo_cache_lookup (cairo_cache_t	  *cache,
+		     cairo_cache_entry_t  *key);
+
+cairo_private cairo_status_t
+_cairo_cache_insert (cairo_cache_t	 *cache,
+		     cairo_cache_entry_t *entry);
+
+cairo_private void
+_cairo_cache_remove (cairo_cache_t	 *cache,
+		     cairo_cache_entry_t *entry);
+
+cairo_private void
+_cairo_cache_foreach (cairo_cache_t		 *cache,
+		      cairo_cache_callback_func_t cache_callback,
+		      void			 *closure);
+
+#endif
diff --git a/src/cairo/cairo-clip-private.h b/src/cairo/cairo-clip-private.h
new file mode 100644
index 0000000..6128243
--- /dev/null
+++ b/src/cairo/cairo-clip-private.h
@@ -0,0 +1,137 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributor(s):
+ *	Kristian Høgsberg <krh@redhat.com>
+ */
+
+#ifndef CAIRO_CLIP_PRIVATE_H
+#define CAIRO_CLIP_PRIVATE_H
+
+#include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
+#include "cairo-path-fixed-private.h"
+#include "cairo-reference-count-private.h"
+
+extern const cairo_private cairo_rectangle_list_t _cairo_rectangles_nil;
+
+enum {
+    CAIRO_CLIP_PATH_HAS_REGION = 0x1,
+    CAIRO_CLIP_PATH_REGION_IS_UNSUPPORTED = 0x2,
+    CAIRO_CLIP_PATH_IS_BOX = 0x4
+};
+
+struct _cairo_clip_path {
+    cairo_reference_count_t	 ref_count;
+    cairo_path_fixed_t		 path;
+    cairo_fill_rule_t		 fill_rule;
+    double			 tolerance;
+    cairo_antialias_t		 antialias;
+    cairo_clip_path_t		*prev;
+
+    cairo_rectangle_int_t extents;
+
+    /* partial caches */
+    unsigned int flags;
+    cairo_region_t *region;
+    cairo_surface_t *surface;
+};
+
+struct _cairo_clip {
+    /* can be used as a cairo_hash_entry_t for live clips */
+    cairo_clip_path_t *path;
+
+    cairo_bool_t all_clipped;
+
+};
+
+cairo_private void
+_cairo_clip_init (cairo_clip_t *clip);
+
+cairo_private cairo_status_t
+_cairo_clip_init_rectangle (cairo_clip_t *clip,
+			    const cairo_rectangle_int_t *rect);
+
+cairo_private_no_warn cairo_clip_t *
+_cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
+
+cairo_private cairo_status_t
+_cairo_clip_init_copy_transformed (cairo_clip_t    *clip,
+				   cairo_clip_t    *other,
+				   const cairo_matrix_t *matrix);
+
+cairo_private void
+_cairo_clip_reset (cairo_clip_t *clip);
+
+#define _cairo_clip_fini(clip) _cairo_clip_reset (clip)
+
+cairo_private cairo_status_t
+_cairo_clip_rectangle (cairo_clip_t       *clip,
+		       const cairo_rectangle_int_t *rectangle);
+
+cairo_private cairo_status_t
+_cairo_clip_clip (cairo_clip_t       *clip,
+		  const cairo_path_fixed_t *path,
+		  cairo_fill_rule_t   fill_rule,
+		  double              tolerance,
+		  cairo_antialias_t   antialias);
+
+cairo_private cairo_status_t
+_cairo_clip_apply_clip (cairo_clip_t *clip,
+			const cairo_clip_t *other);
+
+cairo_private const cairo_rectangle_int_t *
+_cairo_clip_get_extents (const cairo_clip_t *clip);
+
+cairo_private cairo_surface_t *
+_cairo_clip_get_surface (cairo_clip_t *clip, cairo_surface_t *dst);
+
+cairo_private cairo_status_t
+_cairo_clip_combine_with_surface (cairo_clip_t *clip,
+				  cairo_surface_t *dst,
+				  const cairo_rectangle_int_t *extents);
+
+cairo_private cairo_int_status_t
+_cairo_clip_get_region (cairo_clip_t *clip,
+			cairo_region_t **region);
+
+cairo_private cairo_int_status_t
+_cairo_clip_get_boxes (cairo_clip_t *clip,
+		       cairo_box_t **boxes,
+		       int *count);
+
+cairo_private void
+_cairo_clip_drop_cache (cairo_clip_t  *clip);
+
+cairo_private cairo_rectangle_list_t*
+_cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate);
+
+#endif /* CAIRO_CLIP_PRIVATE_H */
diff --git a/src/cairo/cairo-combsort-private.h b/src/cairo/cairo-combsort-private.h
new file mode 100644
index 0000000..ce31257
--- /dev/null
+++ b/src/cairo/cairo-combsort-private.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright © 2008 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Chris Wilson
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ */
+
+/* This fragment implements a comb sort (specifically combsort11) */
+#ifndef _HAVE_CAIRO_COMBSORT_NEWGAP
+#define _HAVE_CAIRO_COMBSORT_NEWGAP
+static inline unsigned int
+_cairo_combsort_newgap (unsigned int gap)
+{
+  gap = 10 * gap / 13;
+  if (gap == 9 || gap == 10)
+    gap = 11;
+  if (gap < 1)
+    gap = 1;
+  return gap;
+}
+#endif
+
+#define CAIRO_COMBSORT_DECLARE(NAME, TYPE, CMP) \
+static void \
+NAME (TYPE *base, unsigned int nmemb) \
+{ \
+  unsigned int gap = nmemb; \
+  unsigned int i, j; \
+  int swapped; \
+  do { \
+      gap = _cairo_combsort_newgap (gap); \
+      swapped = gap > 1; \
+      for (i = 0; i < nmemb-gap ; i++) { \
+	  j = i + gap; \
+	  if (CMP (base[i], base[j]) > 0 ) { \
+	      TYPE tmp; \
+	      tmp = base[i]; \
+	      base[i] = base[j]; \
+	      base[j] = tmp; \
+	      swapped = 1; \
+	  } \
+      } \
+  } while (swapped); \
+}
diff --git a/src/cairo/cairo-compiler-private.h b/src/cairo/cairo-compiler-private.h
new file mode 100644
index 0000000..403c3f7
--- /dev/null
+++ b/src/cairo/cairo-compiler-private.h
@@ -0,0 +1,205 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_COMPILER_PRIVATE_H
+#define CAIRO_COMPILER_PRIVATE_H
+
+#include "cairo.h"
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun)
+# define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private
+# define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private_no_warn
+# define slim_hidden_def(name)			slim_hidden_def1(name, slim_hidden_int_name(name))
+# define slim_hidden_int_name(name) INT_##name
+# define slim_hidden_proto1(name, internal)				\
+  extern __typeof (name) name						\
+	__asm__ (slim_hidden_asmname (internal))
+# define slim_hidden_def1(name, internal)				\
+  extern __typeof (name) EXT_##name __asm__(slim_hidden_asmname(name))	\
+	__attribute__((__alias__(slim_hidden_asmname(internal))))
+# define slim_hidden_ulp		slim_hidden_ulp1(__USER_LABEL_PREFIX__)
+# define slim_hidden_ulp1(x)		slim_hidden_ulp2(x)
+# define slim_hidden_ulp2(x)		#x
+# define slim_hidden_asmname(name)	slim_hidden_asmname1(name)
+# define slim_hidden_asmname1(name)	slim_hidden_ulp #name
+#else
+# define slim_hidden_proto(name)		int _cairo_dummy_prototype(void)
+# define slim_hidden_proto_no_warn(name)	int _cairo_dummy_prototype(void)
+# define slim_hidden_def(name)			int _cairo_dummy_prototype(void)
+#endif
+
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define CAIRO_PRINTF_FORMAT(fmt_index, va_index) \
+	__attribute__((__format__(__printf__, fmt_index, va_index)))
+#else
+#define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
+#endif
+
+/* slim_internal.h */
+#define CAIRO_HAS_HIDDEN_SYMBOLS 1
+#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
+#define cairo_private_no_warn	__attribute__((__visibility__("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define cairo_private_no_warn	__hidden
+#else /* not gcc >= 3.3 and not Sun Studio >= 8 */
+#define cairo_private_no_warn
+#undef CAIRO_HAS_HIDDEN_SYMBOLS
+#endif
+
+#ifndef WARN_UNUSED_RESULT
+#define WARN_UNUSED_RESULT
+#endif
+/* Add attribute(warn_unused_result) if supported */
+#define cairo_warn	    WARN_UNUSED_RESULT
+#define cairo_private	    cairo_private_no_warn cairo_warn
+
+/* This macro allow us to deprecate a function by providing an alias
+   for the old function name to the new function name. With this
+   macro, binary compatibility is preserved. The macro only works on
+   some platforms --- tough.
+
+   Meanwhile, new definitions in the public header file break the
+   source code so that it will no longer link against the old
+   symbols. Instead it will give a descriptive error message
+   indicating that the old function has been deprecated by the new
+   function.
+*/
+#if __GNUC__ >= 2 && defined(__ELF__)
+# define CAIRO_FUNCTION_ALIAS(old, new)		\
+	extern __typeof (new) old		\
+	__asm__ ("" #old)			\
+	__attribute__((__alias__("" #new)))
+#else
+# define CAIRO_FUNCTION_ALIAS(old, new)
+#endif
+
+/*
+ * Cairo uses the following function attributes in order to improve the
+ * generated code (effectively by manual inter-procedural analysis).
+ *
+ *   'cairo_pure': The function is only allowed to read from its arguments
+ *                 and global memory (i.e. following a pointer argument or
+ *                 accessing a shared variable). The return value should
+ *                 only depend on its arguments, and for an identical set of
+ *                 arguments should return the same value.
+ *
+ *   'cairo_const': The function is only allowed to read from its arguments.
+ *                  It is not allowed to access global memory. The return
+ *                  value should only depend its arguments, and for an
+ *                  identical set of arguments should return the same value.
+ *                  This is currently the most strict function attribute.
+ *
+ * Both these function attributes allow gcc to perform CSE and
+ * constant-folding, with 'cairo_const 'also guaranteeing that pointer contents
+ * do not change across the function call.
+ */
+#if __GNUC__ >= 3
+#define cairo_pure __attribute__((pure))
+#define cairo_const __attribute__((const))
+#else
+#define cairo_pure
+#define cairo_const
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _CAIRO_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _cairo_boolean_var_;                         \
+   if (expr)                                    \
+      _cairo_boolean_var_ = 1;                      \
+   else                                         \
+      _cairo_boolean_var_ = 0;                      \
+   _cairo_boolean_var_;                             \
+})
+#define likely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 1))
+#define unlikely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 0))
+#else
+#define likely(expr) (expr)
+#define unlikely(expr) (expr)
+#endif
+
+#ifndef __GNUC__
+#undef __attribute__
+#define __attribute__(x)
+#endif
+
+#if (defined(__WIN32__) && !defined(__WINE__)) || defined(_MSC_VER)
+#define snprintf _snprintf
+#define popen _popen
+#define pclose _pclose
+#define hypot _hypot
+#endif
+
+#ifdef _MSC_VER
+#undef inline
+#define inline __inline
+#endif
+
+#if defined(_MSC_VER) && defined(_M_IX86)
+/* When compiling with /Gy and /OPT:ICF identical functions will be folded in together.
+   The CAIRO_ENSURE_UNIQUE macro ensures that a function is always unique and
+   will never be folded into another one. Something like this might eventually
+   be needed for GCC but it seems fine for now. */
+#define CAIRO_ENSURE_UNIQUE                       \
+    do {                                          \
+	char func[] = __FUNCTION__;               \
+	char file[] = __FILE__;                   \
+	__asm {                                   \
+	    __asm jmp __internal_skip_line_no     \
+	    __asm _emit (__LINE__ & 0xff)         \
+	    __asm _emit ((__LINE__>>8) & 0xff)    \
+	    __asm _emit ((__LINE__>>16) & 0xff)   \
+	    __asm _emit ((__LINE__>>24) & 0xff)   \
+	    __asm lea eax, func                   \
+	    __asm lea eax, file                   \
+	    __asm __internal_skip_line_no:        \
+	};                                        \
+    } while (0)
+#else
+#define CAIRO_ENSURE_UNIQUE    do { } while (0)
+#endif
+
+#ifdef __STRICT_ANSI__
+#undef inline
+#define inline __inline__
+#endif
+
+#endif
diff --git a/src/cairo/cairo-fixed-private.h b/src/cairo/cairo-fixed-private.h
new file mode 100644
index 0000000..e3add4a
--- /dev/null
+++ b/src/cairo/cairo-fixed-private.h
@@ -0,0 +1,290 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_FIXED_PRIVATE_H
+#define CAIRO_FIXED_PRIVATE_H
+
+#include "cairo-fixed-type-private.h"
+
+#include "cairo-wideint-private.h"
+
+/* Implementation */
+
+#if (CAIRO_FIXED_BITS != 32)
+# error CAIRO_FIXED_BITS must be 32, and the type must be a 32-bit type.
+# error To remove this limitation, you will have to fix the tesselator.
+#endif
+
+#define CAIRO_FIXED_ONE        ((cairo_fixed_t)(1 << CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_ONE_DOUBLE ((double)(1 << CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_EPSILON    ((cairo_fixed_t)(1))
+
+#define CAIRO_FIXED_FRAC_MASK  (((cairo_fixed_unsigned_t)(-1)) >> (CAIRO_FIXED_BITS - CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_WHOLE_MASK (~CAIRO_FIXED_FRAC_MASK)
+
+static inline cairo_fixed_t
+_cairo_fixed_from_int (int i)
+{
+    return i << CAIRO_FIXED_FRAC_BITS;
+}
+
+/* This is the "magic number" approach to converting a double into fixed
+ * point as described here:
+ *
+ * http://www.stereopsis.com/sree/fpu2006.html (an overview)
+ * http://www.d6.com/users/checker/pdfs/gdmfp.pdf (in detail)
+ *
+ * The basic idea is to add a large enough number to the double that the
+ * literal floating point is moved up to the extent that it forces the
+ * double's value to be shifted down to the bottom of the mantissa (to make
+ * room for the large number being added in). Since the mantissa is, at a
+ * given moment in time, a fixed point integer itself, one can convert a
+ * float to various fixed point representations by moving around the point
+ * of a floating point number through arithmetic operations. This behavior
+ * is reliable on most modern platforms as it is mandated by the IEEE-754
+ * standard for floating point arithmetic.
+ *
+ * For our purposes, a "magic number" must be carefully selected that is
+ * both large enough to produce the desired point-shifting effect, and also
+ * has no lower bits in its representation that would interfere with our
+ * value at the bottom of the mantissa. The magic number is calculated as
+ * follows:
+ *
+ *          (2 ^ (MANTISSA_SIZE - FRACTIONAL_SIZE)) * 1.5
+ *
+ * where in our case:
+ *  - MANTISSA_SIZE for 64-bit doubles is 52
+ *  - FRACTIONAL_SIZE for 16.16 fixed point is 16
+ *
+ * Although this approach provides a very large speedup of this function
+ * on a wide-array of systems, it does come with two caveats:
+ *
+ * 1) It uses banker's rounding as opposed to arithmetic rounding.
+ * 2) It doesn't function properly if the FPU is in single-precision
+ *    mode.
+ */
+
+/* The 16.16 number must always be available */
+#define CAIRO_MAGIC_NUMBER_FIXED_16_16 (103079215104.0)
+
+#if CAIRO_FIXED_BITS <= 32
+#define CAIRO_MAGIC_NUMBER_FIXED ((1LL << (52 - CAIRO_FIXED_FRAC_BITS)) * 1.5)
+
+/* For 32-bit fixed point numbers */
+static inline cairo_fixed_t
+_cairo_fixed_from_double (double d)
+{
+    union {
+        double d;
+        int32_t i[2];
+    } u;
+
+    u.d = d + CAIRO_MAGIC_NUMBER_FIXED;
+#ifdef FLOAT_WORDS_BIGENDIAN
+    return u.i[1];
+#else
+    return u.i[0];
+#endif
+}
+
+#else
+# error Please define a magic number for your fixed point type!
+# error See cairo-fixed-private.h for details.
+#endif
+
+static inline cairo_fixed_t
+_cairo_fixed_from_26_6 (uint32_t i)
+{
+#if CAIRO_FIXED_FRAC_BITS > 6
+    return i << (CAIRO_FIXED_FRAC_BITS - 6);
+#else
+    return i >> (6 - CAIRO_FIXED_FRAC_BITS);
+#endif
+}
+
+static inline double
+_cairo_fixed_to_double (cairo_fixed_t f)
+{
+    return ((double) f) / CAIRO_FIXED_ONE_DOUBLE;
+}
+
+static inline int
+_cairo_fixed_is_integer (cairo_fixed_t f)
+{
+    return (f & CAIRO_FIXED_FRAC_MASK) == 0;
+}
+
+static inline int
+_cairo_fixed_integer_part (cairo_fixed_t f)
+{
+    return f >> CAIRO_FIXED_FRAC_BITS;
+}
+
+static inline int
+_cairo_fixed_integer_floor (cairo_fixed_t f)
+{
+    if (f >= 0)
+        return f >> CAIRO_FIXED_FRAC_BITS;
+    else
+        return -((-f - 1) >> CAIRO_FIXED_FRAC_BITS) - 1;
+}
+
+static inline int
+_cairo_fixed_integer_ceil (cairo_fixed_t f)
+{
+    if (f > 0)
+	return ((f - 1)>>CAIRO_FIXED_FRAC_BITS) + 1;
+    else
+	return - (-f >> CAIRO_FIXED_FRAC_BITS);
+}
+
+/* A bunch of explicit 16.16 operators; we need these
+ * to interface with pixman and other backends that require
+ * 16.16 fixed point types.
+ */
+static inline cairo_fixed_16_16_t
+_cairo_fixed_to_16_16 (cairo_fixed_t f)
+{
+#if (CAIRO_FIXED_FRAC_BITS == 16) && (CAIRO_FIXED_BITS == 32)
+    return f;
+#elif CAIRO_FIXED_FRAC_BITS > 16
+    /* We're just dropping the low bits, so we won't ever got over/underflow here */
+    return f >> (CAIRO_FIXED_FRAC_BITS - 16);
+#else
+    cairo_fixed_16_16_t x;
+
+    /* Handle overflow/underflow by clamping to the lowest/highest
+     * value representable as 16.16
+     */
+    if ((f >> CAIRO_FIXED_FRAC_BITS) < INT16_MIN) {
+	x = INT32_MIN;
+    } else if ((f >> CAIRO_FIXED_FRAC_BITS) > INT16_MAX) {
+	x = INT32_MAX;
+    } else {
+	x = f << (16 - CAIRO_FIXED_FRAC_BITS);
+    }
+
+    return x;
+#endif
+}
+
+static inline cairo_fixed_16_16_t
+_cairo_fixed_16_16_from_double (double d)
+{
+    union {
+        double d;
+        int32_t i[2];
+    } u;
+
+    u.d = d + CAIRO_MAGIC_NUMBER_FIXED_16_16;
+#ifdef FLOAT_WORDS_BIGENDIAN
+    return u.i[1];
+#else
+    return u.i[0];
+#endif
+}
+
+#if CAIRO_FIXED_BITS == 32
+
+static inline cairo_fixed_t
+_cairo_fixed_mul (cairo_fixed_t a, cairo_fixed_t b)
+{
+    cairo_int64_t temp = _cairo_int32x32_64_mul (a, b);
+    return _cairo_int64_to_int32(_cairo_int64_rsl (temp, CAIRO_FIXED_FRAC_BITS));
+}
+
+/* computes round (a * b / c) */
+static inline cairo_fixed_t
+_cairo_fixed_mul_div (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+{
+    cairo_int64_t ab  = _cairo_int32x32_64_mul (a, b);
+    cairo_int64_t c64 = _cairo_int32_to_int64 (c);
+    return _cairo_int64_to_int32 (_cairo_int64_divrem (ab, c64).quo);
+}
+
+/* computes floor (a * b / c) */
+static inline cairo_fixed_t
+_cairo_fixed_mul_div_floor (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+{
+    return _cairo_int64_32_div (_cairo_int32x32_64_mul (a, b), c);
+}
+
+
+static inline cairo_fixed_t
+_cairo_edge_compute_intersection_y_for_x (const cairo_point_t *p1,
+					  const cairo_point_t *p2,
+					  cairo_fixed_t x)
+{
+    cairo_fixed_t y, dx;
+
+    if (x == p1->x)
+	return p1->y;
+    if (x == p2->x)
+	return p2->y;
+
+    y = p1->y;
+    dx = p2->x - p1->x;
+    if (dx != 0)
+	y += _cairo_fixed_mul_div_floor (x - p1->x, p2->y - p1->y, dx);
+
+    return y;
+}
+
+static inline cairo_fixed_t
+_cairo_edge_compute_intersection_x_for_y (const cairo_point_t *p1,
+					  const cairo_point_t *p2,
+					  cairo_fixed_t y)
+{
+    cairo_fixed_t x, dy;
+
+    if (y == p1->y)
+	return p1->x;
+    if (y == p2->y)
+	return p2->x;
+
+    x = p1->x;
+    dy = p2->y - p1->y;
+    if (dy != 0)
+	x += _cairo_fixed_mul_div_floor (y - p1->y, p2->x - p1->x, dy);
+
+    return x;
+}
+
+#else
+# error Please define multiplication and other operands for your fixed-point type size
+#endif
+
+#endif /* CAIRO_FIXED_PRIVATE_H */
diff --git a/src/cairo/cairo-fixed-type-private.h b/src/cairo/cairo-fixed-type-private.h
new file mode 100644
index 0000000..730ed3e
--- /dev/null
+++ b/src/cairo/cairo-fixed-type-private.h
@@ -0,0 +1,75 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_FIXED_TYPE_PRIVATE_H
+#define CAIRO_FIXED_TYPE_PRIVATE_H
+
+#include "cairo-wideint-type-private.h"
+
+/*
+ * Fixed-point configuration
+ */
+
+typedef int32_t		cairo_fixed_16_16_t;
+typedef cairo_int64_t	cairo_fixed_32_32_t;
+typedef cairo_int64_t	cairo_fixed_48_16_t;
+typedef cairo_int128_t	cairo_fixed_64_64_t;
+typedef cairo_int128_t	cairo_fixed_96_32_t;
+
+/* Eventually, we should allow changing this, but I think
+ * there are some assumptions in the tesselator about the
+ * size of a fixed type.  For now, it must be 32.
+ */
+#define CAIRO_FIXED_BITS	32
+
+/* The number of fractional bits.  Changing this involves
+ * making sure that you compute a double-to-fixed magic number.
+ * (see below).
+ */
+#define CAIRO_FIXED_FRAC_BITS	8
+
+/* A signed type %CAIRO_FIXED_BITS in size; the main fixed point type */
+typedef int32_t cairo_fixed_t;
+
+/* An unsigned type of the same size as #cairo_fixed_t */
+typedef uint32_t cairo_fixed_unsigned_t;
+
+typedef struct _cairo_point {
+    cairo_fixed_t x;
+    cairo_fixed_t y;
+} cairo_point_t;
+
+#endif /* CAIRO_FIXED_TYPE_PRIVATE_H */
diff --git a/src/cairo/cairo-freelist-private.h b/src/cairo/cairo-freelist-private.h
new file mode 100644
index 0000000..5be22b1
--- /dev/null
+++ b/src/cairo/cairo-freelist-private.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright © 2006 Joonas Pihlaja
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+#ifndef CAIRO_FREELIST_H
+#define CAIRO_FREELIST_H
+
+#include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
+
+/* for stand-alone compilation*/
+#ifndef VG
+#define VG(x)
+#endif
+
+#ifndef NULL
+#define NULL (void *) 0
+#endif
+
+typedef struct _cairo_freelist_node cairo_freelist_node_t;
+struct _cairo_freelist_node {
+    cairo_freelist_node_t *next;
+};
+
+typedef struct _cairo_freelist {
+    cairo_freelist_node_t *first_free_node;
+    unsigned nodesize;
+} cairo_freelist_t;
+
+typedef struct _cairo_freelist_pool cairo_freelist_pool_t;
+struct _cairo_freelist_pool {
+    cairo_freelist_pool_t *next;
+    unsigned size, rem;
+    uint8_t *data;
+};
+
+typedef struct _cairo_freepool {
+    cairo_freelist_node_t *first_free_node;
+    cairo_freelist_pool_t *pools;
+    unsigned nodesize;
+    cairo_freelist_pool_t embedded_pool;
+    uint8_t embedded_data[1000];
+} cairo_freepool_t;
+
+
+/* Initialise a freelist that will be responsible for allocating
+ * nodes of size nodesize. */
+cairo_private void
+_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize);
+
+/* Deallocate any nodes in the freelist. */
+cairo_private void
+_cairo_freelist_fini (cairo_freelist_t *freelist);
+
+/* Allocate a new node from the freelist.  If the freelist contains no
+ * nodes, a new one will be allocated using malloc().  The caller is
+ * responsible for calling _cairo_freelist_free() or free() on the
+ * returned node.  Returns %NULL on memory allocation error. */
+cairo_private void *
+_cairo_freelist_alloc (cairo_freelist_t *freelist);
+
+/* Allocate a new node from the freelist.  If the freelist contains no
+ * nodes, a new one will be allocated using calloc().  The caller is
+ * responsible for calling _cairo_freelist_free() or free() on the
+ * returned node.  Returns %NULL on memory allocation error. */
+cairo_private void *
+_cairo_freelist_calloc (cairo_freelist_t *freelist);
+
+/* Return a node to the freelist. This does not deallocate the memory,
+ * but makes it available for later reuse by
+ * _cairo_freelist_alloc(). */
+cairo_private void
+_cairo_freelist_free (cairo_freelist_t *freelist, void *node);
+
+
+cairo_private void
+_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize);
+
+cairo_private void
+_cairo_freepool_fini (cairo_freepool_t *freepool);
+
+cairo_private void *
+_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool);
+
+static inline void *
+_cairo_freepool_alloc_from_pool (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool;
+    uint8_t *ptr;
+
+    pool = freepool->pools;
+    if (unlikely (freepool->nodesize > pool->rem))
+	return _cairo_freepool_alloc_from_new_pool (freepool);
+
+    ptr = pool->data;
+    pool->data += freepool->nodesize;
+    pool->rem -= freepool->nodesize;
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (ptr, freepool->nodesize));
+    return ptr;
+}
+
+static inline void *
+_cairo_freepool_alloc (cairo_freepool_t *freepool)
+{
+    cairo_freelist_node_t *node;
+
+    node = freepool->first_free_node;
+    if (unlikely (node == NULL))
+	return _cairo_freepool_alloc_from_pool (freepool);
+
+    VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+    freepool->first_free_node = node->next;
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freepool->nodesize));
+
+    return node;
+}
+
+cairo_private cairo_status_t
+_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+			     int count,
+			     void **array);
+
+static inline void
+_cairo_freepool_free (cairo_freepool_t *freepool, void *ptr)
+{
+    cairo_freelist_node_t *node = ptr;
+
+    node->next = freepool->first_free_node;
+    freepool->first_free_node = node;
+    VG (VALGRIND_MAKE_MEM_NOACCESS (node, freepool->nodesize));
+}
+
+#endif /* CAIRO_FREELIST_H */
diff --git a/src/cairo/cairo-freelist.c b/src/cairo/cairo-freelist.c
new file mode 100644
index 0000000..08514cd
--- /dev/null
+++ b/src/cairo/cairo-freelist.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright © 2006 Joonas Pihlaja
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include "cairoint.h"
+
+#include "cairo-freelist-private.h"
+
+#define _cairo_error(x) (x)
+
+void
+_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize)
+{
+    memset (freelist, 0, sizeof (cairo_freelist_t));
+    freelist->nodesize = nodesize;
+}
+
+void
+_cairo_freelist_fini (cairo_freelist_t *freelist)
+{
+    cairo_freelist_node_t *node = freelist->first_free_node;
+    while (node) {
+	cairo_freelist_node_t *next;
+
+	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	next = node->next;
+
+	free (node);
+	node = next;
+    }
+}
+
+void *
+_cairo_freelist_alloc (cairo_freelist_t *freelist)
+{
+    if (freelist->first_free_node) {
+	cairo_freelist_node_t *node;
+
+	node = freelist->first_free_node;
+	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	freelist->first_free_node = node->next;
+	VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freelist->nodesize));
+
+	return node;
+    }
+
+    return malloc (freelist->nodesize);
+}
+
+void *
+_cairo_freelist_calloc (cairo_freelist_t *freelist)
+{
+    void *node = _cairo_freelist_alloc (freelist);
+    if (node)
+	memset (node, 0, freelist->nodesize);
+    return node;
+}
+
+void
+_cairo_freelist_free (cairo_freelist_t *freelist, void *voidnode)
+{
+    cairo_freelist_node_t *node = voidnode;
+    if (node) {
+	node->next = freelist->first_free_node;
+	freelist->first_free_node = node;
+	VG (VALGRIND_MAKE_MEM_NOACCESS (node, freelist->nodesize));
+    }
+}
+
+
+void
+_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize)
+{
+    freepool->first_free_node = NULL;
+    freepool->pools = &freepool->embedded_pool;
+    freepool->nodesize = nodesize;
+
+    freepool->embedded_pool.next = NULL;
+    freepool->embedded_pool.size = sizeof (freepool->embedded_data);
+    freepool->embedded_pool.rem = sizeof (freepool->embedded_data);
+    freepool->embedded_pool.data = freepool->embedded_data;
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (freepool->embedded_data,
+				    sizeof (freepool->embedded_data)));
+}
+
+void
+_cairo_freepool_fini (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool = freepool->pools;
+    while (pool != &freepool->embedded_pool) {
+	cairo_freelist_pool_t *next = pool->next;
+	free (pool);
+	pool = next;
+    }
+    VG (VALGRIND_MAKE_MEM_NOACCESS (freepool, sizeof (freepool)));
+}
+
+void *
+_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool;
+    int poolsize;
+
+    if (freepool->pools != &freepool->embedded_pool)
+	poolsize = 2 * freepool->pools->size;
+    else
+	poolsize = (128 * freepool->nodesize + 8191) & -8192;
+    pool = malloc (sizeof (cairo_freelist_pool_t) + poolsize);
+    if (unlikely (pool == NULL))
+	return pool;
+
+    pool->next = freepool->pools;
+    freepool->pools = pool;
+
+    pool->size = poolsize;
+    pool->rem = poolsize - freepool->nodesize;
+    pool->data = (uint8_t *) (pool + 1) + freepool->nodesize;
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (pool->data, poolsize));
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (pool->data, freepool->nodesize));
+
+    return pool + 1;
+}
+
+cairo_status_t
+_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+			     int count,
+			     void **array)
+{
+    int i;
+
+    for (i = 0; i < count; i++) {
+	cairo_freelist_node_t *node;
+
+	node = freepool->first_free_node;
+	if (likely (node != NULL)) {
+	    VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	    freepool->first_free_node = node->next;
+	    VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freepool->nodesize));
+	} else {
+	    node = _cairo_freepool_alloc_from_pool (freepool);
+	    if (unlikely (node == NULL))
+		goto CLEANUP;
+	}
+
+	array[i] = node;
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+
+  CLEANUP:
+    while (i--)
+	_cairo_freepool_free (freepool, array[i]);
+
+    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+}
diff --git a/src/cairo/cairo-hash-private.h b/src/cairo/cairo-hash-private.h
new file mode 100644
index 0000000..32078bd
--- /dev/null
+++ b/src/cairo/cairo-hash-private.h
@@ -0,0 +1,87 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Red Hat, Inc.
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributor(s):
+ *      Keith Packard <keithp@keithp.com>
+ *	Graydon Hoare <graydon@redhat.com>
+ *	Carl Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_HASH_PRIVATE_H
+#define CAIRO_HASH_PRIVATE_H
+
+#include "cairo-compiler-private.h"
+#include "cairo-types-private.h"
+
+/* XXX: I'd like this file to be self-contained in terms of
+ * includeability, but that's not really possible with the current
+ * monolithic cairoint.h. So, for now, just include cairoint.h instead
+ * if you want to include this file. */
+
+typedef cairo_bool_t
+(*cairo_hash_keys_equal_func_t) (const void *key_a, const void *key_b);
+
+typedef cairo_bool_t
+(*cairo_hash_predicate_func_t) (const void *entry);
+
+typedef void
+(*cairo_hash_callback_func_t) (void *entry,
+			       void *closure);
+
+cairo_private cairo_hash_table_t *
+_cairo_hash_table_create (cairo_hash_keys_equal_func_t keys_equal);
+
+cairo_private void
+_cairo_hash_table_destroy (cairo_hash_table_t *hash_table);
+
+cairo_private void *
+_cairo_hash_table_lookup (cairo_hash_table_t  *hash_table,
+			  cairo_hash_entry_t  *key);
+
+cairo_private void *
+_cairo_hash_table_random_entry (cairo_hash_table_t	   *hash_table,
+				cairo_hash_predicate_func_t predicate);
+
+cairo_private cairo_status_t
+_cairo_hash_table_insert (cairo_hash_table_t *hash_table,
+			  cairo_hash_entry_t *entry);
+
+cairo_private void
+_cairo_hash_table_remove (cairo_hash_table_t *hash_table,
+			  cairo_hash_entry_t *key);
+
+cairo_private void
+_cairo_hash_table_foreach (cairo_hash_table_t	      *hash_table,
+			   cairo_hash_callback_func_t  hash_callback,
+			   void			      *closure);
+
+#endif
diff --git a/src/cairo/cairo-list-private.h b/src/cairo/cairo-list-private.h
new file mode 100644
index 0000000..b8254bb
--- /dev/null
+++ b/src/cairo/cairo-list-private.h
@@ -0,0 +1,189 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2009 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Chris Wilson.
+ *
+ * Contributor(s):
+ *      Chris Wilson <chris@chris-wilson.co.uk>
+ *
+ */
+
+#ifndef CAIRO_LIST_PRIVATE_H
+#define CAIRO_LIST_PRIVATE_H
+
+#include "cairo-compiler-private.h"
+
+/* Basic circular, doubly linked list implementation */
+
+typedef struct _cairo_list {
+    struct _cairo_list *next, *prev;
+} cairo_list_t;
+
+#define cairo_list_entry(ptr, type, member) \
+	cairo_container_of(ptr, type, member)
+
+#define cairo_list_first_entry(ptr, type, member) \
+	cairo_list_entry((ptr)->next, type, member)
+
+#define cairo_list_last_entry(ptr, type, member) \
+	cairo_list_entry((ptr)->prev, type, member)
+
+#define cairo_list_foreach(pos, head)			\
+	for (pos = (head)->next; pos != (head);	pos = pos->next)
+
+#define cairo_list_foreach_entry(pos, type, head, member)		\
+	for (pos = cairo_list_entry((head)->next, type, member);\
+	     &pos->member != (head);					\
+	     pos = cairo_list_entry(pos->member.next, type, member))
+
+#define cairo_list_foreach_entry_safe(pos, n, type, head, member)	\
+	for (pos = cairo_list_entry ((head)->next, type, member),\
+	     n = cairo_list_entry (pos->member.next, type, member);\
+	     &pos->member != (head);					\
+	     pos = n, n = cairo_list_entry (n->member.next, type, member))
+
+#define cairo_list_foreach_entry_reverse(pos, type, head, member)	\
+	for (pos = cairo_list_entry((head)->prev, type, member);\
+	     &pos->member != (head);					\
+	     pos = cairo_list_entry(pos->member.prev, type, member))
+
+#ifdef CAIRO_LIST_DEBUG
+static inline void
+cairo_list_validate (const cairo_list_t *head)
+{
+    cairo_list_t *link;
+
+    cairo_list_foreach (link, head) {
+	assert (link->next->prev == link);
+	assert (link->prev->next == link);
+    }
+}
+#else
+#define cairo_list_validate(head)
+#endif
+
+static inline void
+cairo_list_init (cairo_list_t *entry)
+{
+    entry->next = entry;
+    entry->prev = entry;
+}
+
+static inline void
+__cairo_list_add (cairo_list_t *entry,
+	          cairo_list_t *prev,
+		  cairo_list_t *next)
+{
+    next->prev = entry;
+    entry->next = next;
+    entry->prev = prev;
+    prev->next = entry;
+}
+
+static inline void
+cairo_list_add (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, head, head->next);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_add_tail (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, head->prev, head);
+    cairo_list_validate (head);
+}
+
+static inline void
+__cairo_list_del (cairo_list_t *prev, cairo_list_t *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+
+static inline void
+cairo_list_del (cairo_list_t *entry)
+{
+    __cairo_list_del (entry->prev, entry->next);
+    cairo_list_init (entry);
+}
+
+static inline void
+cairo_list_move (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_del (entry->prev, entry->next);
+    __cairo_list_add (entry, head, head->next);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_move_tail (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_del (entry->prev, entry->next);
+    __cairo_list_add (entry, head->prev, head);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_swap (cairo_list_t *entry, cairo_list_t *other)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, other->prev, other->next);
+    cairo_list_init (other);
+    cairo_list_validate (head);
+}
+
+static inline cairo_bool_t
+cairo_list_is_first (const cairo_list_t *entry,
+	             const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return entry->prev == head;
+}
+
+static inline cairo_bool_t
+cairo_list_is_last (const cairo_list_t *entry,
+	            const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return entry->next == head;
+}
+
+static inline cairo_bool_t
+cairo_list_is_empty (const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return head->next == head;
+}
+
+#endif /* CAIRO_LIST_PRIVATE_H */
diff --git a/src/cairo/cairo-malloc-private.h b/src/cairo/cairo-malloc-private.h
new file mode 100644
index 0000000..d812058
--- /dev/null
+++ b/src/cairo/cairo-malloc-private.h
@@ -0,0 +1,148 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_MALLOC_PRIVATE_H
+#define CAIRO_MALLOC_PRIVATE_H
+
+#include "cairo-wideint-private.h"
+
+#if HAVE_MEMFAULT
+#include <memfault.h>
+#define CAIRO_INJECT_FAULT() MEMFAULT_INJECT_FAULT()
+#else
+#define CAIRO_INJECT_FAULT() 0
+#endif
+
+/**
+ * _cairo_malloc:
+ * @size: size in bytes
+ *
+ * Allocate @size memory using malloc().
+ * The memory should be freed using free().
+ * malloc is skipped, if 0 bytes are requested, and %NULL will be returned.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or size is 0.
+ */
+
+#define _cairo_malloc(size) \
+   ((size) ? malloc((unsigned) (size)) : NULL)
+
+/**
+ * _cairo_malloc_ab:
+ * @n: number of elements to allocate
+ * @size: size of each element
+ *
+ * Allocates @n*@size memory using _cairo_malloc(), taking care to not
+ * overflow when doing the multiplication.  Behaves much like
+ * calloc(), except that the returned memory is not set to zero.
+ * The memory should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_ab(a, size) \
+  ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (a) * (unsigned) (size)))
+
+/**
+ * _cairo_realloc_ab:
+ * @ptr: original pointer to block of memory to be resized
+ * @n: number of elements to allocate
+ * @size: size of each element
+ *
+ * Reallocates @ptr a block of @n*@size memory using realloc(), taking
+ * care to not overflow when doing the multiplication.  The memory
+ * should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of realloc() failure or overflow (whereupon the original block
+ * of memory * is left untouched).
+ */
+
+#define _cairo_realloc_ab(ptr, a, size) \
+  ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   realloc(ptr, (unsigned) (a) * (unsigned) (size)))
+
+/**
+ * _cairo_malloc_abc:
+ * @n: first factor of number of elements to allocate
+ * @b: second factor of number of elements to allocate
+ * @size: size of each element
+ *
+ * Allocates @n*@b*@size memory using _cairo_malloc(), taking care to not
+ * overflow when doing the multiplication.  Behaves like
+ * _cairo_malloc_ab().  The memory should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_abc(a, b, size) \
+  ((b) && (unsigned) (a) >= INT32_MAX / (unsigned) (b) ? NULL : \
+   (size) && (unsigned) ((a)*(b)) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (a) * (unsigned) (b) * (unsigned) (size)))
+
+/**
+ * _cairo_malloc_ab_plus_c:
+ * @n: number of elements to allocate
+ * @size: size of each element
+ * @k: additional size to allocate
+ *
+ * Allocates @n*@ksize+@k memory using _cairo_malloc(), taking care to not
+ * overflow when doing the arithmetic.  Behaves like
+ * _cairo_malloc_ab().  The memory should be freed using free().
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_ab_plus_c(n, size, k) \
+  ((size) && (unsigned) (n) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   (unsigned) (k) >= INT32_MAX - (unsigned) (n) * (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (n) * (unsigned) (size) + (unsigned) (k)))
+
+#endif /* CAIRO_MALLOC_PRIVATE_H */
diff --git a/src/cairo/cairo-mutex-impl-private.h b/src/cairo/cairo-mutex-impl-private.h
new file mode 100644
index 0000000..06938b5
--- /dev/null
+++ b/src/cairo/cairo-mutex-impl-private.h
@@ -0,0 +1,250 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005,2007 Red Hat, Inc.
+ * Copyright © 2007 Mathias Hasselmann
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ *	Behdad Esfahbod <behdad@behdad.org>
+ */
+
+#ifndef CAIRO_MUTEX_IMPL_PRIVATE_H
+#define CAIRO_MUTEX_IMPL_PRIVATE_H
+
+#include "cairo.h"
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if HAVE_LOCKDEP
+#include <lockdep.h>
+#endif
+
+/* A fully qualified no-operation statement */
+#define CAIRO_MUTEX_IMPL_NOOP	do {/*no-op*/} while (0)
+/* And one that evaluates its argument once */
+#define CAIRO_MUTEX_IMPL_NOOP1(expr)        do { (void)(expr); } while (0)
+/* Note: 'if (expr) {}' is an alternative to '(void)(expr);' that will 'use' the
+ * result of __attribute__((warn_used_result)) functions. */
+
+/* Cairo mutex implementation:
+ *
+ * Any new mutex implementation needs to do the following:
+ *
+ * - Condition on the right header or feature.  Headers are
+ *   preferred as eg. you still can use win32 mutex implementation
+ *   on a win32 system even if you do not compile the win32
+ *   surface/backend.
+ *
+ * - typedef #cairo_mutex_impl_t to the proper mutex type on your target
+ *   system.  Note that you may or may not need to use a pointer,
+ *   depending on what kinds of initialization your mutex
+ *   implementation supports.  No trailing semicolon needed.
+ *   You should be able to compile the following snippet (don't try
+ *   running it):
+ *
+ *   <programlisting>
+ *	cairo_mutex_impl_t _cairo_some_mutex;
+ *   </programlisting>
+ *
+ * - #define %CAIRO_MUTEX_IMPL_<NAME> 1 with suitable name for your platform.  You
+ *   can later use this symbol in cairo-system.c.
+ *
+ * - #define CAIRO_MUTEX_IMPL_LOCK(mutex) and CAIRO_MUTEX_IMPL_UNLOCK(mutex) to
+ *   proper statement to lock/unlock the mutex object passed in.
+ *   You can (and should) assume that the mutex is already
+ *   initialized, and is-not-already-locked/is-locked,
+ *   respectively.  Use the "do { ... } while (0)" idiom if necessary.
+ *   No trailing semicolons are needed (in any macro you define here).
+ *   You should be able to compile the following snippet:
+ *
+ *   <programlisting>
+ *	cairo_mutex_impl_t _cairo_some_mutex;
+ *
+ *      if (1)
+ *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
+ *      else
+ *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
+ *   </programlisting>
+ *
+ * - #define %CAIRO_MUTEX_IMPL_NIL_INITIALIZER to something that can
+ *   initialize the #cairo_mutex_impl_t type you defined.  Most of the
+ *   time one of 0, %NULL, or {} works.  At this point
+ *   you should be able to compile the following snippet:
+ *
+ *   <programlisting>
+ *	cairo_mutex_impl_t _cairo_some_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;
+ *
+ *      if (1)
+ *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
+ *      else
+ *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
+ *   </programlisting>
+ *
+ * - If the above code is not enough to initialize a mutex on
+ *   your platform, #define CAIRO_MUTEX_IMPL_INIT(mutex) to statement
+ *   to initialize the mutex (allocate resources, etc).  Such that
+ *   you should be able to compile AND RUN the following snippet:
+ *
+ *   <programlisting>
+ *	cairo_mutex_impl_t _cairo_some_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;
+ *
+ *      CAIRO_MUTEX_IMPL_INIT (_cairo_some_mutex);
+ *
+ *      if (1)
+ *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
+ *      else
+ *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
+ *   </programlisting>
+ *
+ * - If you define CAIRO_MUTEX_IMPL_INIT(mutex), cairo will use it to
+ *   initialize all static mutex'es.  If for any reason that should
+ *   not happen (eg. %CAIRO_MUTEX_IMPL_INIT is just a faster way than
+ *   what cairo does using %CAIRO_MUTEX_IMPL_NIL_INITIALIZER), then
+ *   <programlisting>
+ *      #define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
+ *   </programlisting>
+ *
+ * - If your system supports freeing a mutex object (deallocating
+ *   resources, etc), then #define CAIRO_MUTEX_IMPL_FINI(mutex) to do
+ *   that.
+ *
+ * - If you define CAIRO_MUTEX_IMPL_FINI(mutex), cairo will use it to
+ *   define a finalizer function to finalize all static mutex'es.
+ *   However, it's up to you to call CAIRO_MUTEX_IMPL_FINALIZE() at
+ *   proper places, eg. when the system is unloading the cairo library.
+ *   So, if for any reason finalizing static mutex'es is not needed
+ *   (eg. you never call CAIRO_MUTEX_IMPL_FINALIZE()), then
+ *   <programlisting>
+ *      #define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
+ *   </programlisting>
+ *
+ * - That is all.  If for any reason you think the above API is
+ *   not enough to implement #cairo_mutex_impl_t on your system, please
+ *   stop and write to the cairo mailing list about it.  DO NOT
+ *   poke around cairo-mutex-private.h for possible solutions.
+ */
+
+#if CAIRO_NO_MUTEX
+
+/* No mutexes */
+
+  typedef int cairo_mutex_impl_t;
+
+# define CAIRO_MUTEX_IMPL_NO 1
+# define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
+# define CAIRO_MUTEX_IMPL_LOCK(mutex) CAIRO_MUTEX_IMPL_NOOP1(mutex)
+# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) CAIRO_MUTEX_IMPL_NOOP1(mutex)
+# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER 0
+
+#elif defined(_WIN32) /******************************************************/
+
+#define WIN32_LEAN_AND_MEAN
+/* We require Windows 2000 features such as ETO_PDY */
+#if !defined(WINVER) || (WINVER < 0x0500)
+# define WINVER 0x0500
+#endif
+#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
+# define _WIN32_WINNT 0x0500
+#endif
+
+# include <windows.h>
+
+  typedef CRITICAL_SECTION cairo_mutex_impl_t;
+
+# define CAIRO_MUTEX_IMPL_WIN32 1
+# define CAIRO_MUTEX_IMPL_LOCK(mutex) EnterCriticalSection (&(mutex))
+# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) LeaveCriticalSection (&(mutex))
+# define CAIRO_MUTEX_IMPL_INIT(mutex) InitializeCriticalSection (&(mutex))
+# define CAIRO_MUTEX_IMPL_FINI(mutex) DeleteCriticalSection (&(mutex))
+# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER { NULL, 0, 0, NULL, NULL, 0 }
+
+#elif defined __OS2__ /******************************************************/
+
+# define INCL_BASE
+# define INCL_PM
+# include <os2.h>
+
+  typedef HMTX cairo_mutex_impl_t;
+
+# define CAIRO_MUTEX_IMPL_OS2 1
+# define CAIRO_MUTEX_IMPL_LOCK(mutex) DosRequestMutexSem(mutex, SEM_INDEFINITE_WAIT)
+# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) DosReleaseMutexSem(mutex)
+# define CAIRO_MUTEX_IMPL_INIT(mutex) DosCreateMutexSem (NULL, &(mutex), 0L, FALSE)
+# define CAIRO_MUTEX_IMPL_FINI(mutex) DosCloseMutexSem (mutex)
+# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER 0
+
+#elif CAIRO_HAS_BEOS_SURFACE /***********************************************/
+
+  typedef BLocker* cairo_mutex_impl_t;
+
+# define CAIRO_MUTEX_IMPL_BEOS 1
+# define CAIRO_MUTEX_IMPL_LOCK(mutex) (mutex)->Lock()
+# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) (mutex)->Unlock()
+# define CAIRO_MUTEX_IMPL_INIT(mutex) (mutex) = new BLocker()
+# define CAIRO_MUTEX_IMPL_FINI(mutex) delete (mutex)
+# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER NULL
+
+#elif CAIRO_HAS_PTHREAD /* and finally if there are no native mutexes ********/
+
+# include <pthread.h>
+
+  typedef pthread_mutex_t cairo_mutex_impl_t;
+
+# define CAIRO_MUTEX_IMPL_PTHREAD 1
+#if HAVE_LOCKDEP
+/* expose all mutexes to the validator */
+# define CAIRO_MUTEX_IMPL_INIT(mutex) pthread_mutex_init (&(mutex), NULL)
+#endif
+# define CAIRO_MUTEX_IMPL_LOCK(mutex) pthread_mutex_lock (&(mutex))
+# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) pthread_mutex_unlock (&(mutex))
+#if HAVE_LOCKDEP
+# define CAIRO_MUTEX_IS_LOCKED(mutex) LOCKDEP_IS_LOCKED (&(mutex))
+# define CAIRO_MUTEX_IS_UNLOCKED(mutex) LOCKDEP_IS_UNLOCKED (&(mutex))
+#endif
+# define CAIRO_MUTEX_IMPL_FINI(mutex) pthread_mutex_destroy (&(mutex))
+#if ! HAVE_LOCKDEP
+# define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
+#endif
+# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+
+
+#else /**********************************************************************/
+
+# error "XXX: No mutex implementation found.  Cairo will not work with multiple threads.  Define CAIRO_NO_MUTEX to 1 to acknowledge and accept this limitation and compile cairo without thread-safety support."
+
+
+#endif
+
+#endif
diff --git a/src/cairo/cairo-mutex-list-private.h b/src/cairo/cairo-mutex-list-private.h
new file mode 100644
index 0000000..2f48316
--- /dev/null
+++ b/src/cairo/cairo-mutex-list-private.h
@@ -0,0 +1,67 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mathias Hasselmann
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * Contributor(s):
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ */
+
+#ifndef CAIRO_FEATURES_H
+/* This block is to just make this header file standalone */
+#define CAIRO_MUTEX_DECLARE(mutex)
+#endif
+
+CAIRO_MUTEX_DECLARE (_cairo_pattern_solid_surface_cache_lock)
+
+CAIRO_MUTEX_DECLARE (_cairo_toy_font_face_mutex)
+CAIRO_MUTEX_DECLARE (_cairo_intern_string_mutex)
+CAIRO_MUTEX_DECLARE (_cairo_scaled_font_map_mutex)
+CAIRO_MUTEX_DECLARE (_cairo_scaled_glyph_page_cache_mutex)
+CAIRO_MUTEX_DECLARE (_cairo_scaled_font_error_mutex)
+
+#if CAIRO_HAS_FT_FONT
+CAIRO_MUTEX_DECLARE (_cairo_ft_unscaled_font_map_mutex)
+#endif
+
+#if CAIRO_HAS_XLIB_SURFACE
+CAIRO_MUTEX_DECLARE (_cairo_xlib_display_mutex)
+#endif
+
+#if CAIRO_HAS_GL_SURFACE
+CAIRO_MUTEX_DECLARE (_cairo_gl_context_mutex)
+#endif
+
+#if !defined (HAS_ATOMIC_OPS) || defined (ATOMIC_OP_NEEDS_MEMORY_BARRIER)
+CAIRO_MUTEX_DECLARE (_cairo_atomic_mutex)
+#endif
+
+#if CAIRO_HAS_DRM_SURFACE
+CAIRO_MUTEX_DECLARE (_cairo_drm_device_mutex)
+#endif
+/* Undefine, to err on unintended inclusion */
+#undef   CAIRO_MUTEX_DECLARE
diff --git a/src/cairo/cairo-mutex-private.h b/src/cairo/cairo-mutex-private.h
new file mode 100644
index 0000000..a3a7271
--- /dev/null
+++ b/src/cairo/cairo-mutex-private.h
@@ -0,0 +1,67 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005,2007 Red Hat, Inc.
+ * Copyright © 2007 Mathias Hasselmann
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ *	Behdad Esfahbod <behdad@behdad.org>
+ */
+
+#ifndef CAIRO_MUTEX_PRIVATE_H
+#define CAIRO_MUTEX_PRIVATE_H
+
+#include "cairo-mutex-type-private.h"
+
+CAIRO_BEGIN_DECLS
+
+#if _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
+cairo_private void _cairo_mutex_initialize (void);
+#endif
+#if _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
+cairo_private void _cairo_mutex_finalize (void);
+#endif
+/* only if using static initializer and/or finalizer define the boolean */
+#if _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER || _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
+  cairo_private extern cairo_bool_t _cairo_mutex_initialized;
+#endif
+
+/* Finally, extern the static mutexes and undef */
+
+#define CAIRO_MUTEX_DECLARE(mutex) cairo_private extern cairo_mutex_t mutex;
+#include "cairo-mutex-list-private.h"
+#undef CAIRO_MUTEX_DECLARE
+
+CAIRO_END_DECLS
+
+#endif
diff --git a/src/cairo/cairo-mutex-type-private.h b/src/cairo/cairo-mutex-type-private.h
new file mode 100644
index 0000000..342e4f3
--- /dev/null
+++ b/src/cairo/cairo-mutex-type-private.h
@@ -0,0 +1,189 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005,2007 Red Hat, Inc.
+ * Copyright © 2007 Mathias Hasselmann
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ *	Behdad Esfahbod <behdad@behdad.org>
+ */
+
+#ifndef CAIRO_MUTEX_TYPE_PRIVATE_H
+#define CAIRO_MUTEX_TYPE_PRIVATE_H
+
+#define CAIRO_NO_MUTEX 1
+
+#include "cairo-compiler-private.h"
+#include "cairo-mutex-impl-private.h"
+
+/* Only the following three are mandatory at this point */
+#ifndef CAIRO_MUTEX_IMPL_LOCK
+# error "CAIRO_MUTEX_IMPL_LOCK not defined.  Check cairo-mutex-impl-private.h."
+#endif
+#ifndef CAIRO_MUTEX_IMPL_UNLOCK
+# error "CAIRO_MUTEX_IMPL_UNLOCK not defined.  Check cairo-mutex-impl-private.h."
+#endif
+#ifndef CAIRO_MUTEX_IMPL_NIL_INITIALIZER
+# error "CAIRO_MUTEX_IMPL_NIL_INITIALIZER not defined.  Check cairo-mutex-impl-private.h."
+#endif
+
+
+/* make sure implementations don't fool us: we decide these ourself */
+#undef _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
+#undef _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
+
+
+#ifdef CAIRO_MUTEX_IMPL_INIT
+
+/* If %CAIRO_MUTEX_IMPL_INIT is defined, we may need to initialize all
+ * static mutex'es. */
+# ifndef CAIRO_MUTEX_IMPL_INITIALIZE
+#  define CAIRO_MUTEX_IMPL_INITIALIZE() do {	\
+       if (!_cairo_mutex_initialized)	\
+           _cairo_mutex_initialize ();	\
+    } while(0)
+
+/* and make sure we implement the above */
+#  define _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER 1
+# endif /* CAIRO_MUTEX_IMPL_INITIALIZE */
+
+#else /* no CAIRO_MUTEX_IMPL_INIT */
+
+/* Otherwise we probably don't need to initialize static mutex'es, */
+# ifndef CAIRO_MUTEX_IMPL_INITIALIZE
+#  define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
+# endif /* CAIRO_MUTEX_IMPL_INITIALIZE */
+
+/* and dynamic ones can be initialized using the static initializer. */
+# define CAIRO_MUTEX_IMPL_INIT(mutex) do {				\
+      cairo_mutex_t _tmp_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;	\
+      memcpy (&(mutex), &_tmp_mutex, sizeof (_tmp_mutex));	\
+  } while (0)
+
+#endif /* CAIRO_MUTEX_IMPL_INIT */
+
+#ifdef CAIRO_MUTEX_IMPL_FINI
+
+/* If %CAIRO_MUTEX_IMPL_FINI is defined, we may need to finalize all
+ * static mutex'es. */
+# ifndef CAIRO_MUTEX_IMPL_FINALIZE
+#  define CAIRO_MUTEX_IMPL_FINALIZE() do {	\
+       if (_cairo_mutex_initialized)	\
+           _cairo_mutex_finalize ();	\
+    } while(0)
+
+/* and make sure we implement the above */
+#  define _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER 1
+# endif /* CAIRO_MUTEX_IMPL_FINALIZE */
+
+#else /* no CAIRO_MUTEX_IMPL_FINI */
+
+/* Otherwise we probably don't need to finalize static mutex'es, */
+# ifndef CAIRO_MUTEX_IMPL_FINALIZE
+#  define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
+# endif /* CAIRO_MUTEX_IMPL_FINALIZE */
+
+/* neither do the dynamic ones. */
+# define CAIRO_MUTEX_IMPL_FINI(mutex)	CAIRO_MUTEX_IMPL_NOOP1(mutex)
+
+#endif /* CAIRO_MUTEX_IMPL_FINI */
+
+
+#ifndef _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
+#define _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER 0
+#endif
+#ifndef _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
+#define _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER 0
+#endif
+
+
+/* Make sure everything we want is defined */
+#ifndef CAIRO_MUTEX_IMPL_INITIALIZE
+# error "CAIRO_MUTEX_IMPL_INITIALIZE not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_FINALIZE
+# error "CAIRO_MUTEX_IMPL_FINALIZE not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_LOCK
+# error "CAIRO_MUTEX_IMPL_LOCK not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_UNLOCK
+# error "CAIRO_MUTEX_IMPL_UNLOCK not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_INIT
+# error "CAIRO_MUTEX_IMPL_INIT not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_FINI
+# error "CAIRO_MUTEX_IMPL_FINI not defined"
+#endif
+#ifndef CAIRO_MUTEX_IMPL_NIL_INITIALIZER
+# error "CAIRO_MUTEX_IMPL_NIL_INITIALIZER not defined"
+#endif
+
+
+/* Public interface. */
+
+/* By default it simply uses the implementation provided.
+ * But we can provide for debugging features by overriding them */
+
+#ifndef CAIRO_MUTEX_DEBUG
+typedef cairo_mutex_impl_t cairo_mutex_t;
+#else
+# define cairo_mutex_t			cairo_mutex_impl_t
+#endif
+
+#define CAIRO_MUTEX_INITIALIZE		CAIRO_MUTEX_IMPL_INITIALIZE
+#define CAIRO_MUTEX_FINALIZE		CAIRO_MUTEX_IMPL_FINALIZE
+#define CAIRO_MUTEX_LOCK		CAIRO_MUTEX_IMPL_LOCK
+#define CAIRO_MUTEX_UNLOCK		CAIRO_MUTEX_IMPL_UNLOCK
+#define CAIRO_MUTEX_INIT		CAIRO_MUTEX_IMPL_INIT
+#define CAIRO_MUTEX_FINI		CAIRO_MUTEX_IMPL_FINI
+#define CAIRO_MUTEX_NIL_INITIALIZER	CAIRO_MUTEX_IMPL_NIL_INITIALIZER
+
+#ifndef CAIRO_MUTEX_IS_LOCKED
+# define CAIRO_MUTEX_IS_LOCKED(name) 1
+#endif
+#ifndef CAIRO_MUTEX_IS_UNLOCKED
+# define CAIRO_MUTEX_IS_UNLOCKED(name) 1
+#endif
+
+
+/* Debugging support */
+
+#ifdef CAIRO_MUTEX_DEBUG
+
+/* TODO add mutex debugging facilities here (eg deadlock detection) */
+
+#endif /* CAIRO_MUTEX_DEBUG */
+
+#endif
diff --git a/src/cairo/cairo-path-fixed-private.h b/src/cairo/cairo-path-fixed-private.h
new file mode 100644
index 0000000..08b7a06
--- /dev/null
+++ b/src/cairo/cairo-path-fixed-private.h
@@ -0,0 +1,162 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@redhat.com>
+ */
+
+#ifndef CAIRO_PATH_FIXED_PRIVATE_H
+#define CAIRO_PATH_FIXED_PRIVATE_H
+
+#include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
+#include "cairo-list-private.h"
+
+#define WATCH_PATH 0
+#if WATCH_PATH
+#include <stdio.h>
+#endif
+
+enum cairo_path_op {
+    CAIRO_PATH_OP_MOVE_TO = 0,
+    CAIRO_PATH_OP_LINE_TO = 1,
+    CAIRO_PATH_OP_CURVE_TO = 2,
+    CAIRO_PATH_OP_CLOSE_PATH = 3
+};
+
+/* we want to make sure a single byte is used for the enum */
+typedef char cairo_path_op_t;
+
+/* make _cairo_path_fixed fit into ~512 bytes -- about 50 items */
+#define CAIRO_PATH_BUF_SIZE ((512 - sizeof (cairo_path_buf_t)) \
+			   / (2 * sizeof (cairo_point_t) + sizeof (cairo_path_op_t)))
+
+typedef struct _cairo_path_buf {
+    cairo_list_t link;
+    unsigned int buf_size;
+    unsigned int num_ops;
+    unsigned int num_points;
+
+    cairo_path_op_t *op;
+    cairo_point_t *points;
+} cairo_path_buf_t;
+
+typedef struct _cairo_path_buf_fixed {
+    cairo_path_buf_t base;
+
+    cairo_path_op_t op[CAIRO_PATH_BUF_SIZE];
+    cairo_point_t points[2 * CAIRO_PATH_BUF_SIZE];
+} cairo_path_buf_fixed_t;
+
+struct _cairo_path_fixed {
+    cairo_point_t last_move_point;
+    cairo_point_t current_point;
+    unsigned int has_current_point	: 1;
+    unsigned int has_curve_to		: 1;
+    unsigned int is_rectilinear		: 1;
+    unsigned int maybe_fill_region	: 1;
+    unsigned int is_empty_fill		: 1;
+
+    cairo_path_buf_fixed_t  buf;
+};
+
+
+cairo_private void
+_cairo_path_fixed_translate (cairo_path_fixed_t *path,
+			     cairo_fixed_t offx,
+			     cairo_fixed_t offy);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_append (cairo_path_fixed_t		    *path,
+			  const cairo_path_fixed_t	    *other,
+			  cairo_direction_t		     dir,
+			  cairo_fixed_t			     tx,
+			  cairo_fixed_t			     ty);
+
+cairo_private unsigned long
+_cairo_path_fixed_hash (const cairo_path_fixed_t *path);
+
+cairo_private unsigned long
+_cairo_path_fixed_size (const cairo_path_fixed_t *path);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_equal (const cairo_path_fixed_t *a,
+			 const cairo_path_fixed_t *b);
+
+typedef struct _cairo_path_fixed_iter {
+    const cairo_path_buf_t *first;
+    const cairo_path_buf_t *buf;
+    unsigned int n_op;
+    unsigned int n_point;
+} cairo_path_fixed_iter_t;
+
+cairo_private void
+_cairo_path_fixed_iter_init (cairo_path_fixed_iter_t *iter,
+			     const cairo_path_fixed_t *path);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_iter_is_fill_box (cairo_path_fixed_iter_t *_iter,
+				    cairo_box_t *box);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_iter_at_end (const cairo_path_fixed_iter_t *iter);
+
+static inline cairo_bool_t
+_cairo_path_fixed_fill_is_empty (const cairo_path_fixed_t *path)
+{
+    return path->is_empty_fill;
+}
+
+static inline cairo_bool_t
+_cairo_path_fixed_is_rectilinear_fill (const cairo_path_fixed_t *path)
+{
+    if (! path->is_rectilinear)
+	return 0;
+
+    if (! path->has_current_point)
+	return 1;
+
+    /* check whether the implicit close preserves the rectilinear property */
+    return path->current_point.x == path->last_move_point.x ||
+	   path->current_point.y == path->last_move_point.y;
+}
+
+static inline cairo_bool_t
+_cairo_path_fixed_maybe_fill_region (const cairo_path_fixed_t *path)
+{
+#if WATCH_PATH
+    fprintf (stderr, "_cairo_path_fixed_maybe_fill_region () = %s\n",
+	     path->maybe_fill_region ? "true" : "false");
+#endif
+    return path->maybe_fill_region;
+}
+
+#endif /* CAIRO_PATH_FIXED_PRIVATE_H */
diff --git a/src/cairo/cairo-polygon.c b/src/cairo/cairo-polygon.c
new file mode 100644
index 0000000..9cb76e5
--- /dev/null
+++ b/src/cairo/cairo-polygon.c
@@ -0,0 +1,494 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#include "cairoint.h"
+
+#include "cairo-slope-private.h"
+
+void
+_cairo_polygon_init (cairo_polygon_t *polygon)
+{
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (polygon, sizeof (cairo_polygon_t)));
+
+    polygon->status = CAIRO_STATUS_SUCCESS;
+
+    polygon->num_edges = 0;
+
+    polygon->edges = polygon->edges_embedded;
+    polygon->edges_size = ARRAY_LENGTH (polygon->edges_embedded);
+
+    polygon->has_current_point = FALSE;
+    polygon->has_current_edge = FALSE;
+    polygon->num_limits = 0;
+
+    polygon->extents.p1.x = polygon->extents.p1.y = INT32_MAX;
+    polygon->extents.p2.x = polygon->extents.p2.y = INT32_MIN;
+}
+
+void
+_cairo_polygon_limit (cairo_polygon_t	*polygon,
+		      const cairo_box_t *limits,
+		      int num_limits)
+{
+    int n;
+
+    polygon->limits = limits;
+    polygon->num_limits = num_limits;
+
+    if (polygon->num_limits) {
+	polygon->limit = limits[0];
+	for (n = 1; n < num_limits; n++) {
+	    if (limits[n].p1.x < polygon->limit.p1.x)
+		polygon->limit.p1.x = limits[n].p1.x;
+
+	    if (limits[n].p1.y < polygon->limit.p1.y)
+		polygon->limit.p1.y = limits[n].p1.y;
+
+	    if (limits[n].p2.x > polygon->limit.p2.x)
+		polygon->limit.p2.x = limits[n].p2.x;
+
+	    if (limits[n].p2.y > polygon->limit.p2.y)
+		polygon->limit.p2.y = limits[n].p2.y;
+	}
+    }
+}
+
+void
+_cairo_polygon_fini (cairo_polygon_t *polygon)
+{
+    if (polygon->edges != polygon->edges_embedded)
+	free (polygon->edges);
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (polygon, sizeof (cairo_polygon_t)));
+}
+
+/* make room for at least one more edge */
+static cairo_bool_t
+_cairo_polygon_grow (cairo_polygon_t *polygon)
+{
+    cairo_edge_t *new_edges;
+    int old_size = polygon->edges_size;
+    int new_size = 4 * old_size;
+
+    if (CAIRO_INJECT_FAULT ()) {
+	polygon->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	return FALSE;
+    }
+
+    if (polygon->edges == polygon->edges_embedded) {
+	new_edges = _cairo_malloc_ab (new_size, sizeof (cairo_edge_t));
+	if (new_edges != NULL)
+	    memcpy (new_edges, polygon->edges, old_size * sizeof (cairo_edge_t));
+    } else {
+	new_edges = _cairo_realloc_ab (polygon->edges,
+		                       new_size, sizeof (cairo_edge_t));
+    }
+
+    if (unlikely (new_edges == NULL)) {
+	polygon->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	return FALSE;
+    }
+
+    polygon->edges = new_edges;
+    polygon->edges_size = new_size;
+
+    return TRUE;
+}
+
+static void
+_add_edge (cairo_polygon_t *polygon,
+	   const cairo_point_t *p1,
+	   const cairo_point_t *p2,
+	   int top, int bottom,
+	   int dir)
+{
+    cairo_edge_t *edge;
+
+    assert (top < bottom);
+
+    if (polygon->num_edges == polygon->edges_size) {
+	if (! _cairo_polygon_grow (polygon))
+	    return;
+    }
+
+    edge = &polygon->edges[polygon->num_edges++];
+    edge->line.p1 = *p1;
+    edge->line.p2 = *p2;
+    edge->top = top;
+    edge->bottom = bottom;
+    edge->dir = dir;
+
+    if (top < polygon->extents.p1.y)
+	polygon->extents.p1.y = top;
+    if (bottom > polygon->extents.p2.y)
+	polygon->extents.p2.y = bottom;
+
+    if (p1->x < polygon->extents.p1.x || p1->x > polygon->extents.p2.x) {
+	cairo_fixed_t x = p1->x;
+	if (top != p1->y)
+	    x = _cairo_edge_compute_intersection_x_for_y (p1, p2, top);
+	if (x < polygon->extents.p1.x)
+	    polygon->extents.p1.x = x;
+	if (x > polygon->extents.p2.x)
+	    polygon->extents.p2.x = x;
+    }
+
+    if (p2->x < polygon->extents.p1.x || p2->x > polygon->extents.p2.x) {
+	cairo_fixed_t x = p2->x;
+	if (bottom != p2->y)
+	    x = _cairo_edge_compute_intersection_x_for_y (p1, p2, bottom);
+	if (x < polygon->extents.p1.x)
+	    polygon->extents.p1.x = x;
+	if (x > polygon->extents.p2.x)
+	    polygon->extents.p2.x = x;
+    }
+}
+
+static void
+_add_clipped_edge (cairo_polygon_t *polygon,
+		   const cairo_point_t *p1,
+		   const cairo_point_t *p2,
+		   const int top, const int bottom,
+		   const int dir)
+{
+    cairo_point_t p[2];
+    int top_y, bot_y;
+    int n;
+
+    for (n = 0; n < polygon->num_limits; n++) {
+	const cairo_box_t *limits = &polygon->limits[n];
+
+	if (top >= limits->p2.y)
+	    continue;
+	if (bottom <= limits->p1.y)
+	    continue;
+
+	if (p1->x <= limits->p1.x && p2->x <= limits->p1.x)
+	{
+	    p[0].x = limits->p1.x;
+	    p[0].y = limits->p1.y;
+	    top_y = top;
+	    if (top_y < p[0].y)
+		top_y = p[0].y;
+
+	    p[1].x = limits->p1.x;
+	    p[1].y = limits->p2.y;
+	    bot_y = bottom;
+	    if (bot_y > p[1].y)
+		bot_y = p[1].y;
+
+	    _add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+	}
+	else if (p1->x >= limits->p2.x && p2->x >= limits->p2.x)
+	{
+	    p[0].x = limits->p2.x;
+	    p[0].y = limits->p1.y;
+	    top_y = top;
+	    if (top_y < p[0].y)
+		top_y = p[0].y;
+
+	    p[1].x = limits->p2.x;
+	    p[1].y = limits->p2.y;
+	    bot_y = bottom;
+	    if (bot_y > p[1].y)
+		bot_y = p[1].y;
+
+	    _add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+	}
+	else if (p1->x >= limits->p1.x && p2->x >= limits->p1.x &&
+		 p1->x <= limits->p2.x && p2->x <= limits->p2.x)
+	{
+	    top_y = top;
+	    if (top_y < limits->p1.y)
+		top_y = limits->p1.y;
+
+	    bot_y = bottom;
+	    if (bot_y > limits->p2.y)
+		bot_y = limits->p2.y;
+
+	    _add_edge (polygon, p1, p2, top_y, bot_y, dir);
+	}
+	else
+	{
+	    int left_y, right_y;
+	    int p1_y, p2_y;
+
+	    left_y = _cairo_edge_compute_intersection_y_for_x (p1, p2,
+							       limits->p1.x);
+	    right_y = _cairo_edge_compute_intersection_y_for_x (p1, p2,
+								limits->p2.x);
+
+	    if (left_y == right_y) /* horizontal within bounds */
+		continue;
+
+	    p1_y = top;
+	    p2_y = bottom;
+
+	    if (left_y < right_y) {
+		if (p1->x < limits->p1.x && left_y > limits->p1.y) {
+		    p[0].x = limits->p1.x;
+		    p[0].y = limits->p1.y;
+		    top_y = p1_y;
+		    if (top_y < p[0].y)
+			top_y = p[0].y;
+
+		    p[1].x = limits->p1.x;
+		    p[1].y = limits->p2.y;
+		    bot_y = left_y;
+		    if (bot_y > p[1].y)
+			bot_y = p[1].y;
+
+		    if (bot_y > top_y)
+			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+		    p1_y = bot_y;
+		}
+
+		if (p2->x > limits->p2.x && right_y < limits->p2.y) {
+		    p[0].x = limits->p2.x;
+		    p[0].y = limits->p1.y;
+		    top_y = right_y;
+		    if (top_y < p[0].y)
+			top_y = p[0].y;
+
+		    p[1].x = limits->p2.x;
+		    p[1].y = limits->p2.y;
+		    bot_y = p2_y;
+		    if (bot_y > p[1].y)
+			bot_y = p[1].y;
+
+		    if (bot_y > top_y)
+			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+		    p2_y = top_y;
+		}
+	    } else {
+		if (p1->x > limits->p2.x && right_y > limits->p1.y) {
+		    p[0].x = limits->p2.x;
+		    p[0].y = limits->p1.y;
+		    top_y = p1_y;
+		    if (top_y < p[0].y)
+			top_y = p[0].y;
+
+		    p[1].x = limits->p2.x;
+		    p[1].y = limits->p2.y;
+		    bot_y = right_y;
+		    if (bot_y > p[1].y)
+			bot_y = p[1].y;
+
+		    if (bot_y > top_y)
+			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+		    p1_y = bot_y;
+		}
+
+		if (p2->x < limits->p1.x && left_y < limits->p2.y) {
+		    p[0].x = limits->p1.x;
+		    p[0].y = limits->p1.y;
+		    top_y = left_y;
+		    if (top_y < p[0].y)
+			top_y = p[0].y;
+
+		    p[1].x = limits->p1.x;
+		    p[1].y = limits->p2.y;
+		    bot_y = p2_y;
+		    if (bot_y > p[1].y)
+			bot_y = p[1].y;
+
+		    if (bot_y > top_y)
+			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
+		    p2_y = top_y;
+		}
+	    }
+
+	    if (p1_y < limits->p1.y)
+		p1_y = limits->p1.y;
+	    if (p2_y > limits->p2.y)
+		p2_y = limits->p2.y;
+	    if (p2_y > p1_y)
+		_add_edge (polygon, p1, p2, p1_y, p2_y, dir);
+	}
+    }
+}
+
+static void
+_cairo_polygon_add_edge (cairo_polygon_t *polygon,
+			 const cairo_point_t *p1,
+			 const cairo_point_t *p2)
+{
+    int dir;
+
+    /* drop horizontal edges */
+    if (p1->y == p2->y)
+	return;
+
+    if (p1->y < p2->y) {
+	dir = 1;
+    } else {
+	const cairo_point_t *t;
+	t = p1, p1 = p2, p2 = t;
+	dir = -1;
+    }
+
+    if (polygon->num_limits) {
+	if (p2->y <= polygon->limit.p1.y)
+	    return;
+
+	if (p1->y >= polygon->limit.p2.y)
+	    return;
+
+	_add_clipped_edge (polygon, p1, p2, p1->y, p2->y, dir);
+    } else
+	_add_edge (polygon, p1, p2, p1->y, p2->y, dir);
+}
+
+cairo_status_t
+_cairo_polygon_add_external_edge (void *polygon,
+				  const cairo_point_t *p1,
+				  const cairo_point_t *p2)
+{
+    _cairo_polygon_add_edge (polygon, p1, p2);
+    return _cairo_polygon_status (polygon);
+}
+
+cairo_status_t
+_cairo_polygon_add_line (cairo_polygon_t *polygon,
+			 const cairo_line_t *line,
+			 int top, int bottom,
+			 int dir)
+{
+    /* drop horizontal edges */
+    if (line->p1.y == line->p2.y)
+	return CAIRO_STATUS_SUCCESS;
+
+    if (bottom <= top)
+	return CAIRO_STATUS_SUCCESS;
+
+    if (polygon->num_limits) {
+	if (line->p2.y <= polygon->limit.p1.y)
+	    return CAIRO_STATUS_SUCCESS;
+
+	if (line->p1.y >= polygon->limit.p2.y)
+	    return CAIRO_STATUS_SUCCESS;
+
+	_add_clipped_edge (polygon, &line->p1, &line->p2, top, bottom, dir);
+    } else
+	_add_edge (polygon, &line->p1, &line->p2, top, bottom, dir);
+
+    return polygon->status;
+}
+
+/* flattened path operations */
+
+cairo_status_t
+_cairo_polygon_move_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point)
+{
+    if (polygon->has_current_edge) {
+	_cairo_polygon_add_edge (polygon,
+				 &polygon->last_point,
+				 &polygon->current_point);
+	polygon->has_current_edge = FALSE;
+    }
+
+    if (! polygon->has_current_point) {
+	polygon->first_point = *point;
+	polygon->has_current_point = TRUE;
+    }
+
+    polygon->current_point = *point;
+    return polygon->status;
+}
+
+cairo_status_t
+_cairo_polygon_line_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point)
+{
+    /* squash collinear edges */
+    if (polygon->has_current_edge) {
+	if (polygon->current_point.x != point->x ||
+	    polygon->current_point.y != point->y)
+	{
+	    cairo_slope_t this;
+
+	    _cairo_slope_init (&this, &polygon->current_point, point);
+	    if (_cairo_slope_equal (&polygon->current_edge, &this)) {
+		polygon->current_point = *point;
+		return CAIRO_STATUS_SUCCESS;
+	    }
+
+	    _cairo_polygon_add_edge (polygon,
+				     &polygon->last_point,
+				     &polygon->current_point);
+
+	    polygon->last_point = polygon->current_point;
+	    polygon->current_edge = this;
+	}
+    } else if (polygon->has_current_point) {
+	if (polygon->current_point.x != point->x ||
+	    polygon->current_point.y != point->y)
+	{
+	    polygon->last_point = polygon->current_point;
+	    _cairo_slope_init (&polygon->current_edge,
+			       &polygon->last_point,
+			       point);
+	    polygon->has_current_edge = TRUE;
+	}
+    } else {
+	polygon->first_point = *point;
+	polygon->has_current_point = TRUE;
+    }
+
+    polygon->current_point = *point;
+    return polygon->status;
+}
+
+cairo_status_t
+_cairo_polygon_close (cairo_polygon_t *polygon)
+{
+    cairo_status_t status;
+
+    if (polygon->has_current_point) {
+	status = _cairo_polygon_line_to (polygon, &polygon->first_point);
+	polygon->has_current_point = FALSE;
+    }
+
+    if (polygon->has_current_edge) {
+	_cairo_polygon_add_edge (polygon,
+				 &polygon->last_point,
+				 &polygon->current_point);
+	polygon->has_current_edge = FALSE;
+    }
+
+    return polygon->status;
+}
diff --git a/src/cairo/cairo-reference-count-private.h b/src/cairo/cairo-reference-count-private.h
new file mode 100644
index 0000000..d6adaad
--- /dev/null
+++ b/src/cairo/cairo-reference-count-private.h
@@ -0,0 +1,62 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ */
+
+#ifndef CAIRO_REFRENCE_COUNT_PRIVATE_H
+#define CAIRO_REFRENCE_COUNT_PRIVATE_H
+
+#include "cairo-atomic-private.h"
+
+/* Encapsulate operations on the object's reference count */
+typedef struct {
+    cairo_atomic_int_t ref_count;
+} cairo_reference_count_t;
+
+#define _cairo_reference_count_inc(RC) _cairo_atomic_int_inc (&(RC)->ref_count)
+#define _cairo_reference_count_dec_and_test(RC) _cairo_atomic_int_dec_and_test (&(RC)->ref_count)
+
+#define CAIRO_REFERENCE_COUNT_INIT(RC, VALUE) ((RC)->ref_count = (VALUE))
+
+#define CAIRO_REFERENCE_COUNT_GET_VALUE(RC) _cairo_atomic_int_get (&(RC)->ref_count)
+#define CAIRO_REFERENCE_COUNT_SET_VALUE(RC, VALUE) _cairo_atomic_int_set (&(RC)->ref_count, (VALUE))
+
+#define CAIRO_REFERENCE_COUNT_INVALID_VALUE ((cairo_atomic_int_t) -1)
+#define CAIRO_REFERENCE_COUNT_INVALID {CAIRO_REFERENCE_COUNT_INVALID_VALUE}
+
+#define CAIRO_REFERENCE_COUNT_IS_INVALID(RC) (CAIRO_REFERENCE_COUNT_GET_VALUE (RC) == CAIRO_REFERENCE_COUNT_INVALID_VALUE)
+
+#define CAIRO_REFERENCE_COUNT_HAS_REFERENCE(RC) (CAIRO_REFERENCE_COUNT_GET_VALUE (RC) > 0)
+
+#endif
diff --git a/src/cairo/cairo-scaled-font-private.h b/src/cairo/cairo-scaled-font-private.h
new file mode 100644
index 0000000..cdc3c73
--- /dev/null
+++ b/src/cairo/cairo-scaled-font-private.h
@@ -0,0 +1,129 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_SCALED_FONT_PRIVATE_H
+#define CAIRO_SCALED_FONT_PRIVATE_H
+
+#include "cairo.h"
+
+#include "cairo-types-private.h"
+#include "cairo-mutex-type-private.h"
+#include "cairo-reference-count-private.h"
+
+typedef struct _cairo_scaled_glyph_page cairo_scaled_glyph_page_t;
+
+struct _cairo_scaled_font {
+    /* For most cairo objects, the rule for multiple threads is that
+     * the user is responsible for any locking if the same object is
+     * manipulated from multiple threads simultaneously.
+     *
+     * However, with the caching that cairo does for scaled fonts, a
+     * user can easily end up with the same cairo_scaled_font object
+     * being manipulated from multiple threads without the user ever
+     * being aware of this, (and in fact, unable to control it).
+     *
+     * So, as a special exception, the cairo implementation takes care
+     * of all locking needed for cairo_scaled_font_t. Most of what is
+     * in the scaled font is immutable, (which is what allows for the
+     * sharing in the first place). The things that are modified and
+     * the locks protecting them are as follows:
+     *
+     * 1. The reference count (scaled_font->ref_count)
+     *
+     *    Modifications to the reference count are protected by the
+     *    _cairo_scaled_font_map_mutex. This is because the reference
+     *    count of a scaled font is intimately related with the font
+     *    map itself, (and the magic holdovers array).
+     *
+     * 2. The cache of glyphs (scaled_font->glyphs)
+     * 3. The backend private data (scaled_font->surface_backend,
+     *				    scaled_font->surface_private)
+     *
+     *    Modifications to these fields are protected with locks on
+     *    scaled_font->mutex in the generic scaled_font code.
+     */
+
+    cairo_hash_entry_t hash_entry;
+
+    /* useful bits for _cairo_scaled_font_nil */
+    cairo_status_t status;
+    cairo_reference_count_t ref_count;
+    cairo_user_data_array_t user_data;
+
+    cairo_font_face_t *original_font_face; /* may be NULL */
+
+    /* hash key members */
+    cairo_font_face_t *font_face; /* may be NULL */
+    cairo_matrix_t font_matrix;	  /* font space => user space */
+    cairo_matrix_t ctm;	          /* user space => device space */
+    cairo_font_options_t options;
+
+    unsigned int placeholder : 1; /*  protected by fontmap mutex */
+    unsigned int holdover : 1;
+    unsigned int finished : 1;
+
+    /* "live" scaled_font members */
+    cairo_matrix_t scale;	     /* font space => device space */
+    cairo_matrix_t scale_inverse;    /* device space => font space */
+    double max_scale;		     /* maximum x/y expansion of scale */
+    cairo_font_extents_t extents;    /* user space */
+    cairo_font_extents_t fs_extents; /* font space */
+
+    /* The mutex protects modification to all subsequent fields. */
+    cairo_mutex_t mutex;
+
+    cairo_hash_table_t *glyphs;
+    cairo_scaled_glyph_page_t *glyph_pages;
+    cairo_bool_t cache_frozen;
+    cairo_bool_t global_cache_frozen;
+
+    /*
+     * One surface backend may store data in each glyph.
+     * Whichever surface manages to store its pointer here
+     * first gets to store data in each glyph
+     */
+    const cairo_surface_backend_t *surface_backend;
+    void *surface_private;
+
+    /* font backend managing this scaled font */
+    const cairo_scaled_font_backend_t *backend;
+};
+
+cairo_private void
+_cairo_scaled_font_revoke_ownership (cairo_scaled_font_t *scaled_font);
+
+#endif /* CAIRO_SCALED_FONT_PRIVATE_H */
diff --git a/src/cairo/cairo-spans-private.h b/src/cairo/cairo-spans-private.h
new file mode 100644
index 0000000..e29a567
--- /dev/null
+++ b/src/cairo/cairo-spans-private.h
@@ -0,0 +1,155 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright (c) 2008  M Joonas Pihlaja
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef CAIRO_SPANS_PRIVATE_H
+#define CAIRO_SPANS_PRIVATE_H
+#include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
+
+/* Number of bits of precision used for alpha. */
+#define CAIRO_SPANS_UNIT_COVERAGE_BITS 8
+#define CAIRO_SPANS_UNIT_COVERAGE ((1 << CAIRO_SPANS_UNIT_COVERAGE_BITS)-1)
+
+/* A structure representing an open-ended horizontal span of constant
+ * pixel coverage. */
+typedef struct _cairo_half_open_span {
+    /* The inclusive x-coordinate of the start of the span. */
+    int x;
+
+    /* The pixel coverage for the pixels to the right. */
+    int coverage;
+} cairo_half_open_span_t;
+
+/* Span renderer interface. Instances of renderers are provided by
+ * surfaces if they want to composite spans instead of trapezoids. */
+typedef struct _cairo_span_renderer cairo_span_renderer_t;
+struct _cairo_span_renderer {
+    /* Called to destroy the renderer. */
+    cairo_destroy_func_t	destroy;
+
+    /* Render the spans on row y of the source by whatever compositing
+     * method is required.  The function should ignore spans outside
+     * the bounding box set by the init() function. */
+    cairo_status_t (*render_row)(
+	void				*abstract_renderer,
+	int				 y,
+	const cairo_half_open_span_t	*coverages,
+	unsigned			 num_coverages);
+
+    /* Called after all rows have been rendered to perform whatever
+     * final rendering step is required.  This function is called just
+     * once before the renderer is destroyed. */
+    cairo_status_t (*finish)(
+	void		      *abstract_renderer);
+
+    /* Private status variable. */
+    cairo_status_t status;
+};
+
+/* Scan converter interface. */
+typedef struct _cairo_scan_converter cairo_scan_converter_t;
+struct _cairo_scan_converter {
+    /* Destroy this scan converter. */
+    cairo_destroy_func_t	destroy;
+
+    /* Add a single edge to the converter. */
+    cairo_status_t (*add_edge) (void		    *abstract_converter,
+				const cairo_point_t *p1,
+				const cairo_point_t *p2,
+				int top, int bottom,
+				int dir);
+
+    /* Add a polygon (set of edges) to the converter. */
+    cairo_status_t (*add_polygon) (void		    *abstract_converter,
+				   const cairo_polygon_t  *polygon);
+
+    /* Generates coverage spans for rows for the added edges and calls
+     * the renderer function for each row. After generating spans the
+     * only valid thing to do with the converter is to destroy it. */
+    cairo_status_t (*generate) (void			*abstract_converter,
+				cairo_span_renderer_t	*renderer);
+
+    /* Private status. Read with _cairo_scan_converter_status(). */
+    cairo_status_t status;
+};
+
+/* Scan converter constructors. */
+
+cairo_private cairo_scan_converter_t *
+_cairo_tor_scan_converter_create (int			xmin,
+				  int			ymin,
+				  int			xmax,
+				  int			ymax,
+				  cairo_fill_rule_t	fill_rule);
+
+/* cairo-spans.c: */
+
+cairo_private cairo_scan_converter_t *
+_cairo_scan_converter_create_in_error (cairo_status_t error);
+
+cairo_private cairo_status_t
+_cairo_scan_converter_status (void *abstract_converter);
+
+cairo_private cairo_status_t
+_cairo_scan_converter_set_error (void *abstract_converter,
+				 cairo_status_t error);
+
+cairo_private cairo_span_renderer_t *
+_cairo_span_renderer_create_in_error (cairo_status_t error);
+
+cairo_private cairo_status_t
+_cairo_span_renderer_status (void *abstract_renderer);
+
+/* Set the renderer into an error state.  This sets all the method
+ * pointers except ->destroy() of the renderer to no-op
+ * implementations that just return the error status. */
+cairo_private cairo_status_t
+_cairo_span_renderer_set_error (void *abstract_renderer,
+				cairo_status_t error);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_polygon (cairo_surface_t	*surface,
+				  cairo_operator_t	 op,
+				  const cairo_pattern_t	*pattern,
+				  cairo_fill_rule_t	fill_rule,
+				  cairo_antialias_t	antialias,
+				  const cairo_composite_rectangles_t *rects,
+				  cairo_polygon_t	*polygon,
+				  cairo_region_t	*clip_region);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_trapezoids_as_polygon (cairo_surface_t	*surface,
+						cairo_operator_t	 op,
+						const cairo_pattern_t	*pattern,
+						cairo_antialias_t	antialias,
+						int src_x, int src_y,
+						int dst_x, int dst_y,
+						int width, int height,
+						cairo_trapezoid_t	*traps,
+						int num_traps,
+						cairo_region_t	*clip_region);
+
+#endif /* CAIRO_SPANS_PRIVATE_H */
diff --git a/src/cairo/cairo-surface-private.h b/src/cairo/cairo-surface-private.h
new file mode 100644
index 0000000..994df0e
--- /dev/null
+++ b/src/cairo/cairo-surface-private.h
@@ -0,0 +1,98 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_SURFACE_PRIVATE_H
+#define CAIRO_SURFACE_PRIVATE_H
+
+#include "cairo.h"
+
+#include "cairo-types-private.h"
+#include "cairo-reference-count-private.h"
+#include "cairo-clip-private.h"
+
+typedef void (*cairo_surface_func_t) (cairo_surface_t *);
+
+struct _cairo_surface {
+    const cairo_surface_backend_t *backend;
+
+    /* We allow surfaces to override the backend->type by shoving something
+     * else into surface->type. This is for "wrapper" surfaces that want to
+     * hide their internal type from the user-level API. */
+    cairo_surface_type_t type;
+
+    cairo_content_t content;
+
+    cairo_reference_count_t ref_count;
+    cairo_status_t status;
+    unsigned int unique_id;
+
+    unsigned finished : 1;
+    unsigned is_clear : 1;
+    unsigned has_font_options : 1;
+
+    cairo_user_data_array_t user_data;
+    cairo_user_data_array_t mime_data;
+
+    cairo_matrix_t device_transform;
+    cairo_matrix_t device_transform_inverse;
+
+    /* The actual resolution of the device, in dots per inch. */
+    double x_resolution;
+    double y_resolution;
+
+    /* The resolution that should be used when generating image-based
+     * fallback; generally only used by the analysis/paginated
+     * surfaces
+     */
+    double x_fallback_resolution;
+    double y_fallback_resolution;
+
+    /* A "snapshot" surface is immutable. See _cairo_surface_snapshot. */
+    cairo_surface_t *snapshot_of;
+    cairo_surface_func_t snapshot_detach;
+    /* current snapshots of this surface */
+    cairo_array_t snapshots;
+
+    /*
+     * Surface font options, falling back to backend's default options,
+     * and set using _cairo_surface_set_font_options(), and propagated by
+     * cairo_surface_create_similar().
+     */
+    cairo_font_options_t font_options;
+};
+
+#endif /* CAIRO_SURFACE_PRIVATE_H */
diff --git a/src/cairo/cairo-types-private.h b/src/cairo/cairo-types-private.h
new file mode 100644
index 0000000..3a3b849
--- /dev/null
+++ b/src/cairo/cairo-types-private.h
@@ -0,0 +1,414 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_TYPES_PRIVATE_H
+#define CAIRO_TYPES_PRIVATE_H
+
+#include "cairo.h"
+#include "cairo-fixed-type-private.h"
+#include "cairo-list-private.h"
+#include "cairo-reference-count-private.h"
+
+typedef struct _cairo_array cairo_array_t;
+typedef struct _cairo_backend cairo_backend_t;
+typedef struct _cairo_cache cairo_cache_t;
+typedef struct _cairo_clip cairo_clip_t;
+typedef struct _cairo_clip_path cairo_clip_path_t;
+typedef struct _cairo_color cairo_color_t;
+typedef struct _cairo_font_face_backend     cairo_font_face_backend_t;
+typedef struct _cairo_gstate cairo_gstate_t;
+typedef struct _cairo_hash_entry cairo_hash_entry_t;
+typedef struct _cairo_hash_table cairo_hash_table_t;
+typedef struct _cairo_image_surface cairo_image_surface_t;
+typedef struct _cairo_mime_data cairo_mime_data_t;
+typedef struct _cairo_output_stream cairo_output_stream_t;
+typedef struct _cairo_paginated_surface_backend cairo_paginated_surface_backend_t;
+typedef struct _cairo_path_fixed cairo_path_fixed_t;
+typedef struct _cairo_rectangle_int16 cairo_glyph_size_t;
+typedef struct _cairo_scaled_font_backend   cairo_scaled_font_backend_t;
+typedef struct _cairo_scaled_font_subsets cairo_scaled_font_subsets_t;
+typedef struct _cairo_solid_pattern cairo_solid_pattern_t;
+typedef struct _cairo_surface_backend cairo_surface_backend_t;
+typedef struct _cairo_surface_wrapper cairo_surface_wrapper_t;
+typedef struct _cairo_unscaled_font_backend cairo_unscaled_font_backend_t;
+typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
+
+typedef cairo_array_t cairo_user_data_array_t;
+
+/**
+ * cairo_hash_entry_t:
+ *
+ * A #cairo_hash_entry_t contains both a key and a value for
+ * #cairo_hash_table_t. User-derived types for #cairo_hash_entry_t must
+ * be type-compatible with this structure (eg. they must have an
+ * unsigned long as the first parameter. The easiest way to get this
+ * is to use:
+ *
+ * 	typedef _my_entry {
+ *	    cairo_hash_entry_t base;
+ *	    ... Remainder of key and value fields here ..
+ *	} my_entry_t;
+ *
+ * which then allows a pointer to my_entry_t to be passed to any of
+ * the #cairo_hash_table_t functions as follows without requiring a cast:
+ *
+ *	_cairo_hash_table_insert (hash_table, &my_entry->base);
+ *
+ * IMPORTANT: The caller is reponsible for initializing
+ * my_entry->base.hash with a hash code derived from the key. The
+ * essential property of the hash code is that keys_equal must never
+ * return %TRUE for two keys that have different hashes. The best hash
+ * code will reduce the frequency of two keys with the same code for
+ * which keys_equal returns %FALSE.
+ *
+ * Which parts of the entry make up the "key" and which part make up
+ * the value are entirely up to the caller, (as determined by the
+ * computation going into base.hash as well as the keys_equal
+ * function). A few of the #cairo_hash_table_t functions accept an entry
+ * which will be used exclusively as a "key", (indicated by a
+ * parameter name of key). In these cases, the value-related fields of
+ * the entry need not be initialized if so desired.
+ **/
+struct _cairo_hash_entry {
+    unsigned long hash;
+};
+
+struct _cairo_array {
+    unsigned int size;
+    unsigned int num_elements;
+    unsigned int element_size;
+    char **elements;
+
+    cairo_bool_t is_snapshot;
+};
+
+struct _cairo_font_options {
+    cairo_antialias_t antialias;
+    cairo_subpixel_order_t subpixel_order;
+    cairo_hint_style_t hint_style;
+    cairo_hint_metrics_t hint_metrics;
+};
+
+/* XXX: Right now, the _cairo_color structure puts unpremultiplied
+   color in the doubles and premultiplied color in the shorts. Yes,
+   this is crazy insane, (but at least we don't export this
+   madness). I'm still working on a cleaner API, but in the meantime,
+   at least this does prevent precision loss in color when changing
+   alpha. */
+struct _cairo_color {
+    double red;
+    double green;
+    double blue;
+    double alpha;
+
+    unsigned short red_short;
+    unsigned short green_short;
+    unsigned short blue_short;
+    unsigned short alpha_short;
+};
+
+typedef enum _cairo_paginated_mode {
+    CAIRO_PAGINATED_MODE_ANALYZE,	/* analyze page regions */
+    CAIRO_PAGINATED_MODE_RENDER,	/* render page contents */
+    CAIRO_PAGINATED_MODE_FALLBACK 	/* paint fallback images */
+} cairo_paginated_mode_t;
+
+/* Sure wish C had a real enum type so that this would be distinct
+ * from #cairo_status_t. Oh well, without that, I'll use this bogus 100
+ * offset.  We want to keep it fit in int8_t as the compiler may choose
+ * that for #cairo_status_t */
+typedef enum _cairo_int_status {
+    CAIRO_INT_STATUS_UNSUPPORTED = 100,
+    CAIRO_INT_STATUS_DEGENERATE,
+    CAIRO_INT_STATUS_NOTHING_TO_DO,
+    CAIRO_INT_STATUS_FLATTEN_TRANSPARENCY,
+    CAIRO_INT_STATUS_IMAGE_FALLBACK,
+    CAIRO_INT_STATUS_ANALYZE_RECORDING_SURFACE_PATTERN,
+
+    CAIRO_INT_STATUS_LAST_STATUS
+} cairo_int_status_t;
+
+typedef enum _cairo_internal_surface_type {
+    CAIRO_INTERNAL_SURFACE_TYPE_PAGINATED = 0x1000,
+    CAIRO_INTERNAL_SURFACE_TYPE_ANALYSIS,
+    CAIRO_INTERNAL_SURFACE_TYPE_TEST_FALLBACK,
+    CAIRO_INTERNAL_SURFACE_TYPE_TEST_PAGINATED,
+    CAIRO_INTERNAL_SURFACE_TYPE_TEST_WRAPPING,
+    CAIRO_INTERNAL_SURFACE_TYPE_NULL,
+    CAIRO_INTERNAL_SURFACE_TYPE_TYPE3_GLYPH
+} cairo_internal_surface_type_t;
+
+#define CAIRO_HAS_TEST_PAGINATED_SURFACE 1
+#define CAIRO_HAS_TEST_NULL_SURFACE 1
+#define CAIRO_HAS_TEST_WRAPPING_SURFACE 1
+
+typedef struct _cairo_slope {
+    cairo_fixed_t dx;
+    cairo_fixed_t dy;
+} cairo_slope_t, cairo_distance_t;
+
+typedef struct _cairo_point_double {
+    double x;
+    double y;
+} cairo_point_double_t;
+
+typedef struct _cairo_distance_double {
+    double dx;
+    double dy;
+} cairo_distance_double_t;
+
+typedef struct _cairo_line {
+    cairo_point_t p1;
+    cairo_point_t p2;
+} cairo_line_t, cairo_box_t;
+
+typedef struct _cairo_trapezoid {
+    cairo_fixed_t top, bottom;
+    cairo_line_t left, right;
+} cairo_trapezoid_t;
+
+typedef struct _cairo_point_int {
+    int x, y;
+} cairo_point_int_t;
+
+#define CAIRO_RECT_INT_MIN (INT_MIN >> CAIRO_FIXED_FRAC_BITS)
+#define CAIRO_RECT_INT_MAX (INT_MAX >> CAIRO_FIXED_FRAC_BITS)
+
+/* Rectangles that take part in a composite operation.
+ *
+ * This defines four translations that define which pixels of the
+ * source pattern, mask, clip and destination surface take part in a
+ * general composite operation.  The idea is that the pixels at
+ *
+ *	(i,j)+(src.x, src.y) of the source,
+ *      (i,j)+(mask.x, mask.y) of the mask,
+ *      (i,j)+(clip.x, clip.y) of the clip and
+ *      (i,j)+(dst.x, dst.y) of the destination
+ *
+ * all combine together to form the result at (i,j)+(dst.x,dst.y),
+ * for i,j ranging in [0,width) and [0,height) respectively.
+ */
+typedef struct _cairo_composite_rectangles {
+        cairo_point_int_t src;
+        cairo_point_int_t mask;
+        cairo_point_int_t clip;
+        cairo_point_int_t dst;
+        int width;
+        int height;
+} cairo_composite_rectangles_t;
+
+typedef enum _cairo_direction {
+    CAIRO_DIRECTION_FORWARD,
+    CAIRO_DIRECTION_REVERSE
+} cairo_direction_t;
+
+typedef struct _cairo_edge {
+    cairo_line_t line;
+    int top, bottom;
+    int dir;
+} cairo_edge_t;
+
+typedef struct _cairo_polygon {
+    cairo_status_t status;
+
+    cairo_point_t first_point;
+    cairo_point_t last_point;
+    cairo_point_t current_point;
+    cairo_slope_t current_edge;
+    cairo_bool_t has_current_point;
+    cairo_bool_t has_current_edge;
+
+    cairo_box_t extents;
+    cairo_box_t limit;
+    const cairo_box_t *limits;
+    int num_limits;
+
+    int num_edges;
+    int edges_size;
+    cairo_edge_t *edges;
+    cairo_edge_t  edges_embedded[32];
+} cairo_polygon_t;
+
+typedef cairo_warn cairo_status_t
+(*cairo_spline_add_point_func_t) (void *closure,
+				  const cairo_point_t *point);
+
+typedef struct _cairo_spline_knots {
+    cairo_point_t a, b, c, d;
+} cairo_spline_knots_t;
+
+typedef struct _cairo_spline {
+    cairo_spline_add_point_func_t add_point_func;
+    void *closure;
+
+    cairo_spline_knots_t knots;
+
+    cairo_slope_t initial_slope;
+    cairo_slope_t final_slope;
+
+    cairo_bool_t has_point;
+    cairo_point_t last_point;
+} cairo_spline_t;
+
+typedef struct _cairo_pen_vertex {
+    cairo_point_t point;
+
+    cairo_slope_t slope_ccw;
+    cairo_slope_t slope_cw;
+} cairo_pen_vertex_t;
+
+typedef struct _cairo_pen {
+    double radius;
+    double tolerance;
+
+    int num_vertices;
+    cairo_pen_vertex_t *vertices;
+    cairo_pen_vertex_t  vertices_embedded[32];
+} cairo_pen_t;
+
+typedef struct _cairo_stroke_style {
+    double		 line_width;
+    cairo_line_cap_t	 line_cap;
+    cairo_line_join_t	 line_join;
+    double		 miter_limit;
+    double		*dash;
+    unsigned int	 num_dashes;
+    double		 dash_offset;
+} cairo_stroke_style_t;
+
+typedef struct _cairo_format_masks {
+    int bpp;
+    unsigned long alpha_mask;
+    unsigned long red_mask;
+    unsigned long green_mask;
+    unsigned long blue_mask;
+} cairo_format_masks_t;
+
+typedef enum {
+    CAIRO_STOCK_WHITE,
+    CAIRO_STOCK_BLACK,
+    CAIRO_STOCK_TRANSPARENT
+} cairo_stock_t;
+
+typedef enum _cairo_image_transparency {
+    CAIRO_IMAGE_IS_OPAQUE,
+    CAIRO_IMAGE_HAS_BILEVEL_ALPHA,
+    CAIRO_IMAGE_HAS_ALPHA,
+    CAIRO_IMAGE_UNKNOWN
+} cairo_image_transparency_t;
+
+struct _cairo_mime_data {
+    cairo_reference_count_t ref_count;
+    unsigned char *data;
+    unsigned int length;
+    cairo_destroy_func_t destroy;
+    void *closure;
+};
+
+struct _cairo_pattern {
+    cairo_pattern_type_t	type;
+    cairo_reference_count_t	ref_count;
+    cairo_status_t		status;
+    cairo_user_data_array_t	user_data;
+
+    cairo_matrix_t		matrix;
+    cairo_filter_t		filter;
+    cairo_extend_t		extend;
+
+    cairo_bool_t		has_component_alpha;
+};
+
+struct _cairo_solid_pattern {
+    cairo_pattern_t base;
+    cairo_color_t color;
+    cairo_content_t content;
+};
+
+typedef struct _cairo_surface_pattern {
+    cairo_pattern_t base;
+
+    cairo_surface_t *surface;
+} cairo_surface_pattern_t;
+
+typedef struct _cairo_gradient_stop {
+    double offset;
+    cairo_color_t color;
+} cairo_gradient_stop_t;
+
+typedef struct _cairo_gradient_pattern {
+    cairo_pattern_t base;
+
+    unsigned int	    n_stops;
+    unsigned int	    stops_size;
+    cairo_gradient_stop_t  *stops;
+    cairo_gradient_stop_t   stops_embedded[2];
+} cairo_gradient_pattern_t;
+
+typedef struct _cairo_linear_pattern {
+    cairo_gradient_pattern_t base;
+
+    cairo_point_t p1;
+    cairo_point_t p2;
+} cairo_linear_pattern_t;
+
+typedef struct _cairo_radial_pattern {
+    cairo_gradient_pattern_t base;
+
+    cairo_point_t c1;
+    cairo_fixed_t r1;
+    cairo_point_t c2;
+    cairo_fixed_t r2;
+} cairo_radial_pattern_t;
+
+typedef union {
+    cairo_gradient_pattern_t base;
+
+    cairo_linear_pattern_t linear;
+    cairo_radial_pattern_t radial;
+} cairo_gradient_pattern_union_t;
+
+typedef union {
+    cairo_pattern_type_t	    type;
+    cairo_pattern_t		    base;
+
+    cairo_solid_pattern_t	    solid;
+    cairo_surface_pattern_t	    surface;
+    cairo_gradient_pattern_union_t  gradient;
+} cairo_pattern_union_t;
+
+#endif /* CAIRO_TYPES_PRIVATE_H */
diff --git a/src/cairo/cairo-wideint-private.h b/src/cairo/cairo-wideint-private.h
new file mode 100644
index 0000000..303dab1
--- /dev/null
+++ b/src/cairo/cairo-wideint-private.h
@@ -0,0 +1,329 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ *
+ */
+
+#ifndef CAIRO_WIDEINT_H
+#define CAIRO_WIDEINT_H
+
+#include "cairo-wideint-type-private.h"
+
+#include "cairo-compiler-private.h"
+
+/*
+ * 64-bit datatypes.  Two separate implementations, one using
+ * built-in 64-bit signed/unsigned types another implemented
+ * as a pair of 32-bit ints
+ */
+
+#define I cairo_private cairo_const
+
+#if !HAVE_UINT64_T
+
+cairo_uquorem64_t I
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den);
+
+cairo_uint64_t I	_cairo_uint32_to_uint64 (uint32_t i);
+#define			_cairo_uint64_to_uint32(a)  ((a).lo)
+cairo_uint64_t I	_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint32x32_64_mul (uint32_t a, uint32_t b);
+cairo_uint64_t I	_cairo_uint64_lsl (cairo_uint64_t a, int shift);
+cairo_uint64_t I	_cairo_uint64_rsl (cairo_uint64_t a, int shift);
+cairo_uint64_t I	_cairo_uint64_rsa (cairo_uint64_t a, int shift);
+int	       I	_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b);
+int	       I	_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b);
+int	       I	_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_negate (cairo_uint64_t a);
+#define			_cairo_uint64_is_zero(a) ((a).hi == 0 && (a).lo == 0)
+#define			_cairo_uint64_negative(a)   (((int32_t) ((a).hi)) < 0)
+cairo_uint64_t I	_cairo_uint64_not (cairo_uint64_t a);
+
+#define			_cairo_uint64_to_int64(i)   (i)
+#define			_cairo_int64_to_uint64(i)   (i)
+
+cairo_int64_t  I	_cairo_int32_to_int64(int32_t i);
+#define			_cairo_int64_to_int32(a)    ((int32_t) _cairo_uint64_to_uint32(a))
+#define			_cairo_int64_add(a,b)	    _cairo_uint64_add (a,b)
+#define			_cairo_int64_sub(a,b)	    _cairo_uint64_sub (a,b)
+#define			_cairo_int64_mul(a,b)	    _cairo_uint64_mul (a,b)
+cairo_int64_t  I	_cairo_int32x32_64_mul (int32_t a, int32_t b);
+int	       I	_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b);
+int	       I	_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b);
+#define			_cairo_int64_is_zero(a)	    _cairo_uint64_is_zero (a)
+#define			_cairo_int64_eq(a,b)	    _cairo_uint64_eq (a,b)
+#define			_cairo_int64_lsl(a,b)	    _cairo_uint64_lsl (a,b)
+#define			_cairo_int64_rsl(a,b)	    _cairo_uint64_rsl (a,b)
+#define			_cairo_int64_rsa(a,b)	    _cairo_uint64_rsa (a,b)
+#define			_cairo_int64_negate(a)	    _cairo_uint64_negate(a)
+#define			_cairo_int64_negative(a)    (((int32_t) ((a).hi)) < 0)
+#define			_cairo_int64_not(a)	    _cairo_uint64_not(a)
+
+#else
+
+static inline cairo_uquorem64_t
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+{
+    cairo_uquorem64_t	qr;
+
+    qr.quo = num / den;
+    qr.rem = num % den;
+    return qr;
+}
+
+#define			_cairo_uint32_to_uint64(i)  ((uint64_t) (i))
+#define			_cairo_uint64_to_uint32(i)  ((uint32_t) (i))
+#define			_cairo_uint64_add(a,b)	    ((a) + (b))
+#define			_cairo_uint64_sub(a,b)	    ((a) - (b))
+#define			_cairo_uint64_mul(a,b)	    ((a) * (b))
+#define			_cairo_uint32x32_64_mul(a,b)	((uint64_t) (a) * (b))
+#define			_cairo_uint64_lsl(a,b)	    ((a) << (b))
+#define			_cairo_uint64_rsl(a,b)	    ((uint64_t) (a) >> (b))
+#define			_cairo_uint64_rsa(a,b)	    ((uint64_t) ((int64_t) (a) >> (b)))
+#define			_cairo_uint64_lt(a,b)	    ((a) < (b))
+#define                 _cairo_uint64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_uint64_is_zero(a)    ((a) == 0)
+#define			_cairo_uint64_eq(a,b)	    ((a) == (b))
+#define			_cairo_uint64_negate(a)	    ((uint64_t) -((int64_t) (a)))
+#define			_cairo_uint64_negative(a)   ((int64_t) (a) < 0)
+#define			_cairo_uint64_not(a)	    (~(a))
+
+#define			_cairo_uint64_to_int64(i)   ((int64_t) (i))
+#define			_cairo_int64_to_uint64(i)   ((uint64_t) (i))
+
+#define			_cairo_int32_to_int64(i)    ((int64_t) (i))
+#define			_cairo_int64_to_int32(i)    ((int32_t) (i))
+#define			_cairo_int64_add(a,b)	    ((a) + (b))
+#define			_cairo_int64_sub(a,b)	    ((a) - (b))
+#define			_cairo_int64_mul(a,b)	    ((a) * (b))
+#define			_cairo_int32x32_64_mul(a,b) ((int64_t) (a) * (b))
+#define			_cairo_int64_lt(a,b)	    ((a) < (b))
+#define                 _cairo_int64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_int64_is_zero(a)     ((a) == 0)
+#define			_cairo_int64_eq(a,b)	    ((a) == (b))
+#define			_cairo_int64_lsl(a,b)	    ((a) << (b))
+#define			_cairo_int64_rsl(a,b)	    ((int64_t) ((uint64_t) (a) >> (b)))
+#define			_cairo_int64_rsa(a,b)	    ((int64_t) (a) >> (b))
+#define			_cairo_int64_negate(a)	    (-(a))
+#define			_cairo_int64_negative(a)    ((a) < 0)
+#define			_cairo_int64_not(a)	    (~(a))
+
+#endif
+
+/*
+ * 64-bit comparisions derived from lt or eq
+ */
+#define			_cairo_uint64_le(a,b)	    (!_cairo_uint64_gt(a,b))
+#define			_cairo_uint64_ne(a,b)	    (!_cairo_uint64_eq(a,b))
+#define			_cairo_uint64_ge(a,b)	    (!_cairo_uint64_lt(a,b))
+#define			_cairo_uint64_gt(a,b)	    _cairo_uint64_lt(b,a)
+
+#define			_cairo_int64_le(a,b)	    (!_cairo_int64_gt(a,b))
+#define			_cairo_int64_ne(a,b)	    (!_cairo_int64_eq(a,b))
+#define			_cairo_int64_ge(a,b)	    (!_cairo_int64_lt(a,b))
+#define			_cairo_int64_gt(a,b)	    _cairo_int64_lt(b,a)
+
+/*
+ * As the C implementation always computes both, create
+ * a function which returns both for the 'native' type as well
+ */
+
+static inline cairo_quorem64_t
+_cairo_int64_divrem (cairo_int64_t num, cairo_int64_t den)
+{
+    int			num_neg = _cairo_int64_negative (num);
+    int			den_neg = _cairo_int64_negative (den);
+    cairo_uquorem64_t	uqr;
+    cairo_quorem64_t	qr;
+
+    if (num_neg)
+	num = _cairo_int64_negate (num);
+    if (den_neg)
+	den = _cairo_int64_negate (den);
+    uqr = _cairo_uint64_divrem (num, den);
+    if (num_neg)
+	qr.rem = _cairo_int64_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = (cairo_int64_t) _cairo_int64_negate (uqr.quo);
+    else
+	qr.quo = (cairo_int64_t) uqr.quo;
+    return qr;
+}
+
+#if 0
+static inline int32_t
+_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+{
+    return num / den;
+}
+#endif
+
+static inline int32_t
+_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+{
+  cairo_quorem64_t quorem;
+  cairo_int64_t den64;
+
+  den64 = _cairo_int32_to_int64 (den);
+  quorem = _cairo_int64_divrem (num, den64);
+
+  return _cairo_int64_to_int32 (quorem.quo);
+}
+
+/*
+ * 128-bit datatypes.  Again, provide two implementations in
+ * case the machine has a native 128-bit datatype.  GCC supports int128_t
+ * on ia64
+ */
+
+#if !HAVE_UINT128_T
+
+cairo_uint128_t I	_cairo_uint32_to_uint128 (uint32_t i);
+cairo_uint128_t I	_cairo_uint64_to_uint128 (cairo_uint64_t i);
+#define			_cairo_uint128_to_uint64(a)	((a).lo)
+#define			_cairo_uint128_to_uint32(a)	_cairo_uint64_to_uint32(_cairo_uint128_to_uint64(a))
+cairo_uint128_t I	_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint128_t I	_cairo_uint128_lsl (cairo_uint128_t a, int shift);
+cairo_uint128_t I	_cairo_uint128_rsl (cairo_uint128_t a, int shift);
+cairo_uint128_t I	_cairo_uint128_rsa (cairo_uint128_t a, int shift);
+int	        I	_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b);
+int	        I	_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b);
+int	        I	_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b);
+#define			_cairo_uint128_is_zero(a) (_cairo_uint64_is_zero ((a).hi) && _cairo_uint64_is_zero ((a).lo))
+cairo_uint128_t I	_cairo_uint128_negate (cairo_uint128_t a);
+#define			_cairo_uint128_negative(a)  (_cairo_uint64_negative(a.hi))
+cairo_uint128_t I	_cairo_uint128_not (cairo_uint128_t a);
+
+#define			_cairo_uint128_to_int128(i)	(i)
+#define			_cairo_int128_to_uint128(i)	(i)
+
+cairo_int128_t  I	_cairo_int32_to_int128 (int32_t i);
+cairo_int128_t  I	_cairo_int64_to_int128 (cairo_int64_t i);
+#define			_cairo_int128_to_int64(a)   ((cairo_int64_t) (a).lo)
+#define			_cairo_int128_to_int32(a)   _cairo_int64_to_int32(_cairo_int128_to_int64(a))
+#define			_cairo_int128_add(a,b)	    _cairo_uint128_add(a,b)
+#define			_cairo_int128_sub(a,b)	    _cairo_uint128_sub(a,b)
+#define			_cairo_int128_mul(a,b)	    _cairo_uint128_mul(a,b)
+cairo_int128_t I _cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b);
+#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
+#define			_cairo_int128_lsl(a,b)	    _cairo_uint128_lsl(a,b)
+#define			_cairo_int128_rsl(a,b)	    _cairo_uint128_rsl(a,b)
+#define			_cairo_int128_rsa(a,b)	    _cairo_uint128_rsa(a,b)
+int 	        I	_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b);
+int	        I	_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b);
+#define			_cairo_int128_is_zero(a)    _cairo_uint128_is_zero (a)
+#define			_cairo_int128_eq(a,b)	    _cairo_uint128_eq (a,b)
+#define			_cairo_int128_negate(a)	    _cairo_uint128_negate(a)
+#define			_cairo_int128_negative(a)   (_cairo_uint128_negative(a))
+#define			_cairo_int128_not(a)	    _cairo_uint128_not(a)
+
+#else	/* !HAVE_UINT128_T */
+
+#define			_cairo_uint32_to_uint128(i) ((uint128_t) (i))
+#define			_cairo_uint64_to_uint128(i) ((uint128_t) (i))
+#define			_cairo_uint128_to_uint64(i) ((uint64_t) (i))
+#define			_cairo_uint128_to_uint32(i) ((uint32_t) (i))
+#define			_cairo_uint128_add(a,b)	    ((a) + (b))
+#define			_cairo_uint128_sub(a,b)	    ((a) - (b))
+#define			_cairo_uint128_mul(a,b)	    ((a) * (b))
+#define			_cairo_uint64x64_128_mul(a,b)	((uint128_t) (a) * (b))
+#define			_cairo_uint128_lsl(a,b)	    ((a) << (b))
+#define			_cairo_uint128_rsl(a,b)	    ((uint128_t) (a) >> (b))
+#define			_cairo_uint128_rsa(a,b)	    ((uint128_t) ((int128_t) (a) >> (b)))
+#define			_cairo_uint128_lt(a,b)	    ((a) < (b))
+#define			_cairo_uint128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_uint128_is_zero(a)   ((a) == 0)
+#define			_cairo_uint128_eq(a,b)	    ((a) == (b))
+#define			_cairo_uint128_negate(a)    ((uint128_t) -((int128_t) (a)))
+#define			_cairo_uint128_negative(a)  ((int128_t) (a) < 0)
+#define			_cairo_uint128_not(a)	    (~(a))
+
+#define			_cairo_uint128_to_int128(i) ((int128_t) (i))
+#define			_cairo_int128_to_uint128(i) ((uint128_t) (i))
+
+#define			_cairo_int32_to_int128(i)   ((int128_t) (i))
+#define			_cairo_int64_to_int128(i)   ((int128_t) (i))
+#define			_cairo_int128_to_int64(i)   ((int64_t) (i))
+#define			_cairo_int128_to_int32(i)   ((int32_t) (i))
+#define			_cairo_int128_add(a,b)	    ((a) + (b))
+#define			_cairo_int128_sub(a,b)	    ((a) - (b))
+#define			_cairo_int128_mul(a,b)	    ((a) * (b))
+#define			_cairo_int64x64_128_mul(a,b) ((int128_t) (a) * (b))
+#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
+#define			_cairo_int128_lt(a,b)	    ((a) < (b))
+#define			_cairo_int128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_int128_is_zero(a)    ((a) == 0)
+#define			_cairo_int128_eq(a,b)	    ((a) == (b))
+#define			_cairo_int128_lsl(a,b)	    ((a) << (b))
+#define			_cairo_int128_rsl(a,b)	    ((int128_t) ((uint128_t) (a) >> (b)))
+#define			_cairo_int128_rsa(a,b)	    ((int128_t) (a) >> (b))
+#define			_cairo_int128_negate(a)	    (-(a))
+#define			_cairo_int128_negative(a)   ((a) < 0)
+#define			_cairo_int128_not(a)	    (~(a))
+
+#endif	/* HAVE_UINT128_T */
+
+cairo_uquorem128_t I
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den);
+
+cairo_quorem128_t I
+_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den);
+
+cairo_uquorem64_t I
+_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
+				 cairo_uint64_t  den);
+
+cairo_quorem64_t I
+_cairo_int_96by64_32x64_divrem (cairo_int128_t num,
+				cairo_int64_t  den);
+
+#define			_cairo_uint128_le(a,b)	    (!_cairo_uint128_gt(a,b))
+#define			_cairo_uint128_ne(a,b)	    (!_cairo_uint128_eq(a,b))
+#define			_cairo_uint128_ge(a,b)	    (!_cairo_uint128_lt(a,b))
+#define			_cairo_uint128_gt(a,b)	    _cairo_uint128_lt(b,a)
+
+#define			_cairo_int128_le(a,b)	    (!_cairo_int128_gt(a,b))
+#define			_cairo_int128_ne(a,b)	    (!_cairo_int128_eq(a,b))
+#define			_cairo_int128_ge(a,b)	    (!_cairo_int128_lt(a,b))
+#define			_cairo_int128_gt(a,b)	    _cairo_int128_lt(b,a)
+
+#undef I
+
+#endif /* CAIRO_WIDEINT_H */
diff --git a/src/cairo/cairo-wideint-type-private.h b/src/cairo/cairo-wideint-type-private.h
new file mode 100644
index 0000000..c7363c0
--- /dev/null
+++ b/src/cairo/cairo-wideint-type-private.h
@@ -0,0 +1,155 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ *
+ */
+
+#ifndef CAIRO_WIDEINT_TYPE_H
+#define CAIRO_WIDEINT_TYPE_H
+
+#include "cairo.h"
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if   HAVE_STDINT_H
+# include <stdint.h>
+#elif HAVE_INTTYPES_H
+# include <inttypes.h>
+#elif HAVE_SYS_INT_TYPES_H
+# include <sys/int_types.h>
+#elif defined(_MSC_VER)
+  typedef __int8 int8_t;
+  typedef unsigned __int8 uint8_t;
+  typedef __int16 int16_t;
+  typedef unsigned __int16 uint16_t;
+  typedef __int32 int32_t;
+  typedef unsigned __int32 uint32_t;
+  typedef __int64 int64_t;
+  typedef unsigned __int64 uint64_t;
+# ifndef HAVE_UINT64_T
+#  define HAVE_UINT64_T 1
+# endif
+#else
+#error Cannot find definitions for fixed-width integral types (uint8_t, uint32_t, etc.)
+#endif
+
+#ifndef INT16_MIN
+# define INT16_MIN	(-32767-1)
+#endif
+#ifndef INT16_MAX
+# define INT16_MAX	(32767)
+#endif
+#ifndef UINT16_MAX
+# define UINT16_MAX	(65535)
+#endif
+#ifndef INT32_MIN
+# define INT32_MIN	(-2147483647-1)
+#endif
+#ifndef INT32_MAX
+# define INT32_MAX	(2147483647)
+#endif
+
+#if HAVE_BYTESWAP_H
+# include <byteswap.h>
+#endif
+#ifndef bswap_16
+# define bswap_16(p) \
+	(((((uint16_t)(p)) & 0x00ff) << 8) | \
+	  (((uint16_t)(p))           >> 8));
+#endif
+#ifndef bswap_32
+# define bswap_32(p) \
+         (((((uint32_t)(p)) & 0x000000ff) << 24) | \
+	  ((((uint32_t)(p)) & 0x0000ff00) << 8)  | \
+	  ((((uint32_t)(p)) & 0x00ff0000) >> 8)  | \
+	  ((((uint32_t)(p)))              >> 24));
+#endif
+
+
+#if !HAVE_UINT64_T
+
+typedef struct _cairo_uint64 {
+    uint32_t	lo, hi;
+} cairo_uint64_t, cairo_int64_t;
+
+#else
+
+typedef uint64_t    cairo_uint64_t;
+typedef int64_t	    cairo_int64_t;
+
+#endif
+
+typedef struct _cairo_uquorem64 {
+    cairo_uint64_t	quo;
+    cairo_uint64_t	rem;
+} cairo_uquorem64_t;
+
+typedef struct _cairo_quorem64 {
+    cairo_int64_t	quo;
+    cairo_int64_t	rem;
+} cairo_quorem64_t;
+
+/* gcc has a non-standard name. */
+#if HAVE___UINT128_T && !HAVE_UINT128_T
+typedef __uint128_t uint128_t;
+typedef __int128_t int128_t;
+#define HAVE_UINT128_T 1
+#endif
+
+#if !HAVE_UINT128_T
+
+typedef struct cairo_uint128 {
+    cairo_uint64_t	lo, hi;
+} cairo_uint128_t, cairo_int128_t;
+
+#else
+
+typedef uint128_t	cairo_uint128_t;
+typedef int128_t	cairo_int128_t;
+
+#endif
+
+typedef struct _cairo_uquorem128 {
+    cairo_uint128_t	quo;
+    cairo_uint128_t	rem;
+} cairo_uquorem128_t;
+
+typedef struct _cairo_quorem128 {
+    cairo_int128_t	quo;
+    cairo_int128_t	rem;
+} cairo_quorem128_t;
+
+
+#endif /* CAIRO_WIDEINT_H */
diff --git a/src/cairo/cairo-wideint.c b/src/cairo/cairo-wideint.c
new file mode 100644
index 0000000..2c70d86
--- /dev/null
+++ b/src/cairo/cairo-wideint.c
@@ -0,0 +1,819 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ */
+
+#include "cairoint.h"
+
+#if HAVE_UINT64_T
+
+#define uint64_lo32(i)	((i) & 0xffffffff)
+#define uint64_hi32(i)	((i) >> 32)
+#define uint64_lo(i)	((i) & 0xffffffff)
+#define uint64_hi(i)	((i) >> 32)
+#define uint64_shift32(i)   ((i) << 32)
+#define uint64_carry32	(((uint64_t) 1) << 32)
+
+#define _cairo_uint32s_to_uint64(h,l) ((uint64_t) (h) << 32 | (l))
+
+#else
+
+#define uint64_lo32(i)	((i).lo)
+#define uint64_hi32(i)	((i).hi)
+
+static cairo_uint64_t
+uint64_lo (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = i.lo;
+    s.hi = 0;
+    return s;
+}
+
+static cairo_uint64_t
+uint64_hi (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = i.hi;
+    s.hi = 0;
+    return s;
+}
+
+static cairo_uint64_t
+uint64_shift32 (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = 0;
+    s.hi = i.lo;
+    return s;
+}
+
+static const cairo_uint64_t uint64_carry32 = { 0, 1 };
+
+cairo_uint64_t
+_cairo_uint32_to_uint64 (uint32_t i)
+{
+    cairo_uint64_t	q;
+
+    q.lo = i;
+    q.hi = 0;
+    return q;
+}
+
+cairo_int64_t
+_cairo_int32_to_int64 (int32_t i)
+{
+    cairo_uint64_t	q;
+
+    q.lo = i;
+    q.hi = i < 0 ? -1 : 0;
+    return q;
+}
+
+static cairo_uint64_t
+_cairo_uint32s_to_uint64 (uint32_t h, uint32_t l)
+{
+    cairo_uint64_t	q;
+
+    q.lo = l;
+    q.hi = h;
+    return q;
+}
+
+cairo_uint64_t
+_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s.hi = a.hi + b.hi;
+    s.lo = a.lo + b.lo;
+    if (s.lo < a.lo)
+	s.hi++;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s.hi = a.hi - b.hi;
+    s.lo = a.lo - b.lo;
+    if (s.lo > a.lo)
+	s.hi--;
+    return s;
+}
+
+#define uint32_lo(i)	((i) & 0xffff)
+#define uint32_hi(i)	((i) >> 16)
+#define uint32_carry16	((1) << 16)
+
+cairo_uint64_t
+_cairo_uint32x32_64_mul (uint32_t a, uint32_t b)
+{
+    cairo_uint64_t  s;
+
+    uint16_t	ah, al, bh, bl;
+    uint32_t	r0, r1, r2, r3;
+
+    al = uint32_lo (a);
+    ah = uint32_hi (a);
+    bl = uint32_lo (b);
+    bh = uint32_hi (b);
+
+    r0 = (uint32_t) al * bl;
+    r1 = (uint32_t) al * bh;
+    r2 = (uint32_t) ah * bl;
+    r3 = (uint32_t) ah * bh;
+
+    r1 += uint32_hi(r0);    /* no carry possible */
+    r1 += r2;		    /* but this can carry */
+    if (r1 < r2)	    /* check */
+	r3 += uint32_carry16;
+
+    s.hi = r3 + uint32_hi(r1);
+    s.lo = (uint32_lo (r1) << 16) + uint32_lo (r0);
+    return s;
+}
+
+cairo_int64_t
+_cairo_int32x32_64_mul (int32_t a, int32_t b)
+{
+    cairo_int64_t s;
+    s = _cairo_uint32x32_64_mul ((uint32_t) a, (uint32_t) b);
+    if (a < 0)
+	s.hi -= b;
+    if (b < 0)
+	s.hi -= a;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s = _cairo_uint32x32_64_mul (a.lo, b.lo);
+    s.hi += a.lo * b.hi + a.hi * b.lo;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_lsl (cairo_uint64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.hi = a.lo;
+	a.lo = 0;
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.hi = a.hi << shift | a.lo >> (32 - shift);
+	a.lo = a.lo << shift;
+    }
+    return a;
+}
+
+cairo_uint64_t
+_cairo_uint64_rsl (cairo_uint64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.lo = a.hi;
+	a.hi = 0;
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.lo = a.lo >> shift | a.hi << (32 - shift);
+	a.hi = a.hi >> shift;
+    }
+    return a;
+}
+
+#define _cairo_uint32_rsa(a,n)	((uint32_t) (((int32_t) (a)) >> (n)))
+
+cairo_int64_t
+_cairo_uint64_rsa (cairo_int64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint32_rsa (a.hi, 31);
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.lo = a.lo >> shift | a.hi << (32 - shift);
+	a.hi = _cairo_uint32_rsa (a.hi, shift);
+    }
+    return a;
+}
+
+int
+_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b)
+{
+    return (a.hi < b.hi ||
+	    (a.hi == b.hi && a.lo < b.lo));
+}
+
+int
+_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b)
+{
+    return a.hi == b.hi && a.lo == b.lo;
+}
+
+int
+_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b)
+{
+    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+	return 1;
+    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+	return 0;
+    return _cairo_uint64_lt (a, b);
+}
+
+int
+_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b)
+{
+    if (a.hi < b.hi)
+	return -1;
+    else if (a.hi > b.hi)
+	return 1;
+    else if (a.lo < b.lo)
+	return -1;
+    else if (a.lo > b.lo)
+	return 1;
+    else
+	return 0;
+}
+
+int
+_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b)
+{
+    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+	return -1;
+    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+	return 1;
+
+    return _cairo_uint64_cmp (a, b);
+}
+
+cairo_uint64_t
+_cairo_uint64_not (cairo_uint64_t a)
+{
+    a.lo = ~a.lo;
+    a.hi = ~a.hi;
+    return a;
+}
+
+cairo_uint64_t
+_cairo_uint64_negate (cairo_uint64_t a)
+{
+    a.lo = ~a.lo;
+    a.hi = ~a.hi;
+    if (++a.lo == 0)
+	++a.hi;
+    return a;
+}
+
+/*
+ * Simple bit-at-a-time divide.
+ */
+cairo_uquorem64_t
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+{
+    cairo_uquorem64_t	qr;
+    cairo_uint64_t	bit;
+    cairo_uint64_t	quo;
+
+    bit = _cairo_uint32_to_uint64 (1);
+
+    /* normalize to make den >= num, but not overflow */
+    while (_cairo_uint64_lt (den, num) && (den.hi & 0x80000000) == 0)
+    {
+	bit = _cairo_uint64_lsl (bit, 1);
+	den = _cairo_uint64_lsl (den, 1);
+    }
+    quo = _cairo_uint32_to_uint64 (0);
+
+    /* generate quotient, one bit at a time */
+    while (bit.hi | bit.lo)
+    {
+	if (_cairo_uint64_le (den, num))
+	{
+	    num = _cairo_uint64_sub (num, den);
+	    quo = _cairo_uint64_add (quo, bit);
+	}
+	bit = _cairo_uint64_rsl (bit, 1);
+	den = _cairo_uint64_rsl (den, 1);
+    }
+    qr.quo = quo;
+    qr.rem = num;
+    return qr;
+}
+
+#endif /* !HAVE_UINT64_T */
+
+#if HAVE_UINT128_T
+cairo_uquorem128_t
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+{
+    cairo_uquorem128_t	qr;
+
+    qr.quo = num / den;
+    qr.rem = num % den;
+    return qr;
+}
+
+#else
+
+cairo_uint128_t
+_cairo_uint32_to_uint128 (uint32_t i)
+{
+    cairo_uint128_t	q;
+
+    q.lo = _cairo_uint32_to_uint64 (i);
+    q.hi = _cairo_uint32_to_uint64 (0);
+    return q;
+}
+
+cairo_int128_t
+_cairo_int32_to_int128 (int32_t i)
+{
+    cairo_int128_t	q;
+
+    q.lo = _cairo_int32_to_int64 (i);
+    q.hi = _cairo_int32_to_int64 (i < 0 ? -1 : 0);
+    return q;
+}
+
+cairo_uint128_t
+_cairo_uint64_to_uint128 (cairo_uint64_t i)
+{
+    cairo_uint128_t	q;
+
+    q.lo = i;
+    q.hi = _cairo_uint32_to_uint64 (0);
+    return q;
+}
+
+cairo_int128_t
+_cairo_int64_to_int128 (cairo_int64_t i)
+{
+    cairo_int128_t	q;
+
+    q.lo = i;
+    q.hi = _cairo_int32_to_int64 (_cairo_int64_negative(i) ? -1 : 0);
+    return q;
+}
+
+cairo_uint128_t
+_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s.hi = _cairo_uint64_add (a.hi, b.hi);
+    s.lo = _cairo_uint64_add (a.lo, b.lo);
+    if (_cairo_uint64_lt (s.lo, a.lo))
+	s.hi = _cairo_uint64_add (s.hi, _cairo_uint32_to_uint64 (1));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s.hi = _cairo_uint64_sub (a.hi, b.hi);
+    s.lo = _cairo_uint64_sub (a.lo, b.lo);
+    if (_cairo_uint64_gt (s.lo, a.lo))
+	s.hi = _cairo_uint64_sub (s.hi, _cairo_uint32_to_uint64(1));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint128_t	s;
+    uint32_t		ah, al, bh, bl;
+    cairo_uint64_t	r0, r1, r2, r3;
+
+    al = uint64_lo32 (a);
+    ah = uint64_hi32 (a);
+    bl = uint64_lo32 (b);
+    bh = uint64_hi32 (b);
+
+    r0 = _cairo_uint32x32_64_mul (al, bl);
+    r1 = _cairo_uint32x32_64_mul (al, bh);
+    r2 = _cairo_uint32x32_64_mul (ah, bl);
+    r3 = _cairo_uint32x32_64_mul (ah, bh);
+
+    r1 = _cairo_uint64_add (r1, uint64_hi (r0));    /* no carry possible */
+    r1 = _cairo_uint64_add (r1, r2);	    	    /* but this can carry */
+    if (_cairo_uint64_lt (r1, r2))		    /* check */
+	r3 = _cairo_uint64_add (r3, uint64_carry32);
+
+    s.hi = _cairo_uint64_add (r3, uint64_hi(r1));
+    s.lo = _cairo_uint64_add (uint64_shift32 (r1),
+				uint64_lo (r0));
+    return s;
+}
+
+cairo_int128_t
+_cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b)
+{
+    cairo_int128_t  s;
+    s = _cairo_uint64x64_128_mul (_cairo_int64_to_uint64(a),
+				  _cairo_int64_to_uint64(b));
+    if (_cairo_int64_negative (a))
+	s.hi = _cairo_uint64_sub (s.hi,
+				  _cairo_int64_to_uint64 (b));
+    if (_cairo_int64_negative (b))
+	s.hi = _cairo_uint64_sub (s.hi,
+				  _cairo_int64_to_uint64 (a));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s = _cairo_uint64x64_128_mul (a.lo, b.lo);
+    s.hi = _cairo_uint64_add (s.hi,
+				_cairo_uint64_mul (a.lo, b.hi));
+    s.hi = _cairo_uint64_add (s.hi,
+				_cairo_uint64_mul (a.hi, b.lo));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_lsl (cairo_uint128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.hi = a.lo;
+	a.lo = _cairo_uint32_to_uint64 (0);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.hi = _cairo_uint64_add (_cairo_uint64_lsl (a.hi, shift),
+				    _cairo_uint64_rsl (a.lo, (64 - shift)));
+	a.lo = _cairo_uint64_lsl (a.lo, shift);
+    }
+    return a;
+}
+
+cairo_uint128_t
+_cairo_uint128_rsl (cairo_uint128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint32_to_uint64 (0);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
+				    _cairo_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _cairo_uint64_rsl (a.hi, shift);
+    }
+    return a;
+}
+
+cairo_uint128_t
+_cairo_uint128_rsa (cairo_int128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint64_rsa (a.hi, 64-1);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
+				    _cairo_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _cairo_uint64_rsa (a.hi, shift);
+    }
+    return a;
+}
+
+int
+_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b)
+{
+    return (_cairo_uint64_lt (a.hi, b.hi) ||
+	    (_cairo_uint64_eq (a.hi, b.hi) &&
+	     _cairo_uint64_lt (a.lo, b.lo)));
+}
+
+int
+_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b)
+{
+    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+	return 1;
+    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+	return 0;
+    return _cairo_uint128_lt (a, b);
+}
+
+int
+_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b)
+{
+    int cmp;
+
+    cmp = _cairo_uint64_cmp (a.hi, b.hi);
+    if (cmp)
+	return cmp;
+    return _cairo_uint64_cmp (a.lo, b.lo);
+}
+
+int
+_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b)
+{
+    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+	return -1;
+    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+	return 1;
+
+    return _cairo_uint128_cmp (a, b);
+}
+
+int
+_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b)
+{
+    return (_cairo_uint64_eq (a.hi, b.hi) &&
+	    _cairo_uint64_eq (a.lo, b.lo));
+}
+
+#if HAVE_UINT64_T
+#define _cairo_msbset64(q)  (q & ((uint64_t) 1 << 63))
+#else
+#define _cairo_msbset64(q)  (q.hi & ((uint32_t) 1 << 31))
+#endif
+
+cairo_uquorem128_t
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+{
+    cairo_uquorem128_t	qr;
+    cairo_uint128_t	bit;
+    cairo_uint128_t	quo;
+
+    bit = _cairo_uint32_to_uint128 (1);
+
+    /* normalize to make den >= num, but not overflow */
+    while (_cairo_uint128_lt (den, num) && !_cairo_msbset64(den.hi))
+    {
+	bit = _cairo_uint128_lsl (bit, 1);
+	den = _cairo_uint128_lsl (den, 1);
+    }
+    quo = _cairo_uint32_to_uint128 (0);
+
+    /* generate quotient, one bit at a time */
+    while (_cairo_uint128_ne (bit, _cairo_uint32_to_uint128(0)))
+    {
+	if (_cairo_uint128_le (den, num))
+	{
+	    num = _cairo_uint128_sub (num, den);
+	    quo = _cairo_uint128_add (quo, bit);
+	}
+	bit = _cairo_uint128_rsl (bit, 1);
+	den = _cairo_uint128_rsl (den, 1);
+    }
+    qr.quo = quo;
+    qr.rem = num;
+    return qr;
+}
+
+cairo_int128_t
+_cairo_int128_negate (cairo_int128_t a)
+{
+    a.lo = _cairo_uint64_not (a.lo);
+    a.hi = _cairo_uint64_not (a.hi);
+    return _cairo_uint128_add (a, _cairo_uint32_to_uint128 (1));
+}
+
+cairo_int128_t
+_cairo_int128_not (cairo_int128_t a)
+{
+    a.lo = _cairo_uint64_not (a.lo);
+    a.hi = _cairo_uint64_not (a.hi);
+    return a;
+}
+
+#endif /* !HAVE_UINT128_T */
+
+cairo_quorem128_t
+_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den)
+{
+    int			num_neg = _cairo_int128_negative (num);
+    int			den_neg = _cairo_int128_negative (den);
+    cairo_uquorem128_t	uqr;
+    cairo_quorem128_t	qr;
+
+    if (num_neg)
+	num = _cairo_int128_negate (num);
+    if (den_neg)
+	den = _cairo_int128_negate (den);
+    uqr = _cairo_uint128_divrem (num, den);
+    if (num_neg)
+	qr.rem = _cairo_int128_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = _cairo_int128_negate (uqr.quo);
+    else
+	qr.quo = uqr.quo;
+    return qr;
+}
+
+/**
+ * _cairo_uint_96by64_32x64_divrem:
+ *
+ * Compute a 32 bit quotient and 64 bit remainder of a 96 bit unsigned
+ * dividend and 64 bit divisor.  If the quotient doesn't fit into 32
+ * bits then the returned remainder is equal to the divisor, and the
+ * quotient is the largest representable 64 bit integer.  It is an
+ * error to call this function with the high 32 bits of @num being
+ * non-zero. */
+cairo_uquorem64_t
+_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
+				 cairo_uint64_t den)
+{
+    cairo_uquorem64_t result;
+    cairo_uint64_t B = _cairo_uint32s_to_uint64 (1, 0);
+
+    /* These are the high 64 bits of the *96* bit numerator.  We're
+     * going to represent the numerator as xB + y, where x is a 64,
+     * and y is a 32 bit number. */
+    cairo_uint64_t x = _cairo_uint128_to_uint64 (_cairo_uint128_rsl(num, 32));
+
+    /* Initialise the result to indicate overflow. */
+    result.quo = _cairo_uint32s_to_uint64 (-1U, -1U);
+    result.rem = den;
+
+    /* Don't bother if the quotient is going to overflow. */
+    if (_cairo_uint64_ge (x, den)) {
+	return /* overflow */ result;
+    }
+
+    if (_cairo_uint64_lt (x, B)) {
+	/* When the final quotient is known to fit in 32 bits, then
+	 * num < 2^64 if and only if den < 2^32. */
+	return _cairo_uint64_divrem (_cairo_uint128_to_uint64 (num), den);
+    }
+    else {
+	/* Denominator is >= 2^32. the numerator is >= 2^64, and the
+	 * division won't overflow: need two divrems.  Write the
+	 * numerator and denominator as
+	 *
+	 *	num = xB + y		x : 64 bits, y : 32 bits
+	 *	den = uB + v		u, v : 32 bits
+	 */
+	uint32_t y = _cairo_uint128_to_uint32 (num);
+	uint32_t u = uint64_hi32 (den);
+	uint32_t v = _cairo_uint64_to_uint32 (den);
+
+	/* Compute a lower bound approximate quotient of num/den
+	 * from x/(u+1).  Then we have
+	 *
+	 * x	= q(u+1) + r	; q : 32 bits, r <= u : 32 bits.
+	 *
+	 * xB + y	= q(u+1)B	+ (rB+y)
+	 *		= q(uB + B + v - v) + (rB+y)
+	 *		= q(uB + v)	+ qB - qv + (rB+y)
+	 *		= q(uB + v)	+ q(B-v) + (rB+y)
+	 *
+	 * The true quotient of num/den then is q plus the
+	 * contribution of q(B-v) + (rB+y).  The main contribution
+	 * comes from the term q(B-v), with the term (rB+y) only
+	 * contributing at most one part.
+	 *
+	 * The term q(B-v) must fit into 64 bits, since q fits into 32
+	 * bits on account of being a lower bound to the true
+	 * quotient, and as B-v <= 2^32, we may safely use a single
+	 * 64/64 bit division to find its contribution. */
+
+	cairo_uquorem64_t quorem;
+	cairo_uint64_t remainder; /* will contain final remainder */
+	uint32_t quotient;	/* will contain final quotient. */
+	uint32_t q;
+	uint32_t r;
+
+	/* Approximate quotient by dividing the high 64 bits of num by
+	 * u+1. Watch out for overflow of u+1. */
+	if (u+1) {
+	    quorem = _cairo_uint64_divrem (x, _cairo_uint32_to_uint64 (u+1));
+	    q = _cairo_uint64_to_uint32 (quorem.quo);
+	    r = _cairo_uint64_to_uint32 (quorem.rem);
+	}
+	else {
+	    q = uint64_hi32 (x);
+	    r = _cairo_uint64_to_uint32 (x);
+	}
+	quotient = q;
+
+	/* Add the main term's contribution to quotient.  Note B-v =
+	 * -v as an uint32 (unless v = 0) */
+	if (v)
+	    quorem = _cairo_uint64_divrem (_cairo_uint32x32_64_mul (q, -v), den);
+	else
+	    quorem = _cairo_uint64_divrem (_cairo_uint32s_to_uint64 (q, 0), den);
+	quotient += _cairo_uint64_to_uint32 (quorem.quo);
+
+	/* Add the contribution of the subterm and start computing the
+	 * true remainder. */
+	remainder = _cairo_uint32s_to_uint64 (r, y);
+	if (_cairo_uint64_ge (remainder, den)) {
+	    remainder = _cairo_uint64_sub (remainder, den);
+	    quotient++;
+	}
+
+	/* Add the contribution of the main term's remainder. The
+	 * funky test here checks that remainder + main_rem >= den,
+	 * taking into account overflow of the addition. */
+	remainder = _cairo_uint64_add (remainder, quorem.rem);
+	if (_cairo_uint64_ge (remainder, den) ||
+	    _cairo_uint64_lt (remainder, quorem.rem))
+	{
+	    remainder = _cairo_uint64_sub (remainder, den);
+	    quotient++;
+	}
+
+	result.quo = _cairo_uint32_to_uint64 (quotient);
+	result.rem = remainder;
+    }
+    return result;
+}
+
+cairo_quorem64_t
+_cairo_int_96by64_32x64_divrem (cairo_int128_t num, cairo_int64_t den)
+{
+    int			num_neg = _cairo_int128_negative (num);
+    int			den_neg = _cairo_int64_negative (den);
+    cairo_uint64_t	nonneg_den;
+    cairo_uquorem64_t	uqr;
+    cairo_quorem64_t	qr;
+
+    if (num_neg)
+	num = _cairo_int128_negate (num);
+    if (den_neg)
+	nonneg_den = _cairo_int64_negate (den);
+    else
+	nonneg_den = den;
+
+    uqr = _cairo_uint_96by64_32x64_divrem (num, nonneg_den);
+    if (_cairo_uint64_eq (uqr.rem, nonneg_den)) {
+	/* bail on overflow. */
+	qr.quo = _cairo_uint32s_to_uint64 (0x7FFFFFFF, -1U);;
+	qr.rem = den;
+	return qr;
+    }
+
+    if (num_neg)
+	qr.rem = _cairo_int64_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = _cairo_int64_negate (uqr.quo);
+    else
+	qr.quo = uqr.quo;
+    return qr;
+}
diff --git a/src/cairo/cairo.h b/src/cairo/cairo.h
new file mode 100644
index 0000000..8be8043
--- /dev/null
+++ b/src/cairo/cairo.h
@@ -0,0 +1,2558 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_H
+#define CAIRO_H
+
+#include "cairo-version.h"
+#include "cairo-features.h"
+#include "cairo-deprecated.h"
+
+#ifdef  __cplusplus
+# define CAIRO_BEGIN_DECLS  extern "C" {
+# define CAIRO_END_DECLS    }
+#else
+# define CAIRO_BEGIN_DECLS
+# define CAIRO_END_DECLS
+#endif
+
+#ifndef cairo_public
+# if defined (_MSC_VER) && ! defined (CAIRO_WIN32_STATIC_BUILD)
+#  define cairo_public __declspec(dllimport)
+# else
+#  define cairo_public
+# endif
+#endif
+
+CAIRO_BEGIN_DECLS
+
+#define CAIRO_VERSION_ENCODE(major, minor, micro) (	\
+	  ((major) * 10000)				\
+	+ ((minor) *   100)				\
+	+ ((micro) *     1))
+
+#define CAIRO_VERSION CAIRO_VERSION_ENCODE(	\
+	CAIRO_VERSION_MAJOR,			\
+	CAIRO_VERSION_MINOR,			\
+	CAIRO_VERSION_MICRO)
+
+
+#define CAIRO_VERSION_STRINGIZE_(major, minor, micro)	\
+	#major"."#minor"."#micro
+#define CAIRO_VERSION_STRINGIZE(major, minor, micro)	\
+	CAIRO_VERSION_STRINGIZE_(major, minor, micro)
+
+#define CAIRO_VERSION_STRING CAIRO_VERSION_STRINGIZE(	\
+	CAIRO_VERSION_MAJOR,				\
+	CAIRO_VERSION_MINOR,				\
+	CAIRO_VERSION_MICRO)
+
+
+cairo_public int
+cairo_version (void);
+
+cairo_public const char*
+cairo_version_string (void);
+
+/**
+ * cairo_bool_t:
+ *
+ * #cairo_bool_t is used for boolean values. Returns of type
+ * #cairo_bool_t will always be either 0 or 1, but testing against
+ * these values explicitly is not encouraged; just use the
+ * value as a boolean condition.
+ *
+ * <informalexample><programlisting>
+ *  if (cairo_in_stroke (cr, x, y)) {
+ *      /<!-- -->* do something *<!-- -->/
+ *  }
+ * </programlisting></informalexample>
+ **/
+typedef int cairo_bool_t;
+
+/**
+ * cairo_t:
+ *
+ * A #cairo_t contains the current state of the rendering device,
+ * including coordinates of yet to be drawn shapes.
+ *
+ * Cairo contexts, as #cairo_t objects are named, are central to
+ * cairo and all drawing with cairo is always done to a #cairo_t
+ * object.
+ *
+ * Memory management of #cairo_t is done with
+ * cairo_reference() and cairo_destroy().
+ **/
+typedef struct _cairo cairo_t;
+
+/**
+ * cairo_surface_t:
+ *
+ * A #cairo_surface_t represents an image, either as the destination
+ * of a drawing operation or as source when drawing onto another
+ * surface.  To draw to a #cairo_surface_t, create a cairo context
+ * with the surface as the target, using cairo_create().
+ *
+ * There are different subtypes of #cairo_surface_t for
+ * different drawing backends; for example, cairo_image_surface_create()
+ * creates a bitmap image in memory.
+ * The type of a surface can be queried with cairo_surface_get_type().
+ *
+ * The initial contents of a surface after creation depend upon the manner
+ * of its creation. If cairo creates the surface and backing storage for
+ * the user, it will be initially cleared; for example,
+ * cairo_image_surface_create() and cairo_surface_create_similar().
+ * Alternatively, if the user passes in a reference to some backing storage
+ * and asks cairo to wrap that in a #cairo_surface_t, then the contents are
+ * not modified; for example, cairo_image_surface_create_for_data() and
+ * cairo_xlib_surface_create().
+ *
+ * Memory management of #cairo_surface_t is done with
+ * cairo_surface_reference() and cairo_surface_destroy().
+ **/
+typedef struct _cairo_surface cairo_surface_t;
+
+/**
+ * cairo_matrix_t:
+ * @xx: xx component of the affine transformation
+ * @yx: yx component of the affine transformation
+ * @xy: xy component of the affine transformation
+ * @yy: yy component of the affine transformation
+ * @x0: X translation component of the affine transformation
+ * @y0: Y translation component of the affine transformation
+ *
+ * A #cairo_matrix_t holds an affine transformation, such as a scale,
+ * rotation, shear, or a combination of those. The transformation of
+ * a point (x, y) is given by:
+ * <programlisting>
+ *     x_new = xx * x + xy * y + x0;
+ *     y_new = yx * x + yy * y + y0;
+ * </programlisting>
+ **/
+typedef struct _cairo_matrix {
+    double xx; double yx;
+    double xy; double yy;
+    double x0; double y0;
+} cairo_matrix_t;
+
+/**
+ * cairo_pattern_t:
+ *
+ * A #cairo_pattern_t represents a source when drawing onto a
+ * surface. There are different subtypes of #cairo_pattern_t,
+ * for different types of sources; for example,
+ * cairo_pattern_create_rgb() creates a pattern for a solid
+ * opaque color.
+ *
+ * Other than various cairo_pattern_create_<emphasis>type</emphasis>()
+ * functions, some of the pattern types can be implicitly created
+ * using various cairo_set_source_<emphasis>type</emphasis>() functions;
+ * for example cairo_set_source_rgb().
+ *
+ * The type of a pattern can be queried with cairo_pattern_get_type().
+ *
+ * Memory management of #cairo_pattern_t is done with
+ * cairo_pattern_reference() and cairo_pattern_destroy().
+ **/
+typedef struct _cairo_pattern cairo_pattern_t;
+
+/**
+ * cairo_destroy_func_t:
+ * @data: The data element being destroyed.
+ *
+ * #cairo_destroy_func_t the type of function which is called when a
+ * data element is destroyed. It is passed the pointer to the data
+ * element and should free any memory and resources allocated for it.
+ **/
+typedef void (*cairo_destroy_func_t) (void *data);
+
+/**
+ * cairo_user_data_key_t:
+ * @unused: not used; ignore.
+ *
+ * #cairo_user_data_key_t is used for attaching user data to cairo
+ * data structures.  The actual contents of the struct is never used,
+ * and there is no need to initialize the object; only the unique
+ * address of a #cairo_data_key_t object is used.  Typically, you
+ * would just use the address of a static #cairo_data_key_t object.
+ **/
+typedef struct _cairo_user_data_key {
+    int unused;
+} cairo_user_data_key_t;
+
+/**
+ * cairo_status_t:
+ * @CAIRO_STATUS_SUCCESS: no error has occurred
+ * @CAIRO_STATUS_NO_MEMORY: out of memory
+ * @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save()
+ * @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()
+ * @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined
+ * @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible)
+ * @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t
+ * @CAIRO_STATUS_NULL_POINTER: %NULL pointer
+ * @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8
+ * @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid
+ * @CAIRO_STATUS_READ_ERROR: error while reading from input stream
+ * @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream
+ * @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished
+ * @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation
+ * @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation
+ * @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t
+ * @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t
+ * @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual*
+ * @CAIRO_STATUS_FILE_NOT_FOUND: file not found
+ * @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting
+ * @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)
+ * @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)
+ * @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)
+ * @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)
+ * @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)
+ * @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
+ * @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
+ * @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
+ * @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
+ * @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
+ * @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)
+ * @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)
+ * @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
+ * @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)
+ * @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of
+ *   status values defined in this enumeration.  When using this value, note
+ *   that the version of cairo at run-time may have additional status values
+ *   defined than the value of this symbol at compile-time. (Since 1.10)
+ *
+ * #cairo_status_t is used to indicate errors that can occur when
+ * using Cairo. In some cases it is returned directly by functions.
+ * but when using #cairo_t, the last error, if any, is stored in
+ * the context and can be retrieved with cairo_status().
+ *
+ * New entries may be added in future versions.  Use cairo_status_to_string()
+ * to get a human-readable representation of an error message.
+ **/
+typedef enum _cairo_status {
+    CAIRO_STATUS_SUCCESS = 0,
+
+    CAIRO_STATUS_NO_MEMORY,
+    CAIRO_STATUS_INVALID_RESTORE,
+    CAIRO_STATUS_INVALID_POP_GROUP,
+    CAIRO_STATUS_NO_CURRENT_POINT,
+    CAIRO_STATUS_INVALID_MATRIX,
+    CAIRO_STATUS_INVALID_STATUS,
+    CAIRO_STATUS_NULL_POINTER,
+    CAIRO_STATUS_INVALID_STRING,
+    CAIRO_STATUS_INVALID_PATH_DATA,
+    CAIRO_STATUS_READ_ERROR,
+    CAIRO_STATUS_WRITE_ERROR,
+    CAIRO_STATUS_SURFACE_FINISHED,
+    CAIRO_STATUS_SURFACE_TYPE_MISMATCH,
+    CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
+    CAIRO_STATUS_INVALID_CONTENT,
+    CAIRO_STATUS_INVALID_FORMAT,
+    CAIRO_STATUS_INVALID_VISUAL,
+    CAIRO_STATUS_FILE_NOT_FOUND,
+    CAIRO_STATUS_INVALID_DASH,
+    CAIRO_STATUS_INVALID_DSC_COMMENT,
+    CAIRO_STATUS_INVALID_INDEX,
+    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE,
+    CAIRO_STATUS_TEMP_FILE_ERROR,
+    CAIRO_STATUS_INVALID_STRIDE,
+    CAIRO_STATUS_FONT_TYPE_MISMATCH,
+    CAIRO_STATUS_USER_FONT_IMMUTABLE,
+    CAIRO_STATUS_USER_FONT_ERROR,
+    CAIRO_STATUS_NEGATIVE_COUNT,
+    CAIRO_STATUS_INVALID_CLUSTERS,
+    CAIRO_STATUS_INVALID_SLANT,
+    CAIRO_STATUS_INVALID_WEIGHT,
+    CAIRO_STATUS_INVALID_SIZE,
+    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED,
+
+    CAIRO_STATUS_LAST_STATUS
+} cairo_status_t;
+
+/**
+ * cairo_content_t:
+ * @CAIRO_CONTENT_COLOR: The surface will hold color content only.
+ * @CAIRO_CONTENT_ALPHA: The surface will hold alpha content only.
+ * @CAIRO_CONTENT_COLOR_ALPHA: The surface will hold color and alpha content.
+ *
+ * #cairo_content_t is used to describe the content that a surface will
+ * contain, whether color information, alpha information (translucence
+ * vs. opacity), or both.
+ *
+ * Note: The large values here are designed to keep #cairo_content_t
+ * values distinct from #cairo_format_t values so that the
+ * implementation can detect the error if users confuse the two types.
+ **/
+typedef enum _cairo_content {
+    CAIRO_CONTENT_COLOR		= 0x1000,
+    CAIRO_CONTENT_ALPHA		= 0x2000,
+    CAIRO_CONTENT_COLOR_ALPHA	= 0x3000
+} cairo_content_t;
+
+/**
+ * cairo_write_func_t:
+ * @closure: the output closure
+ * @data: the buffer containing the data to write
+ * @length: the amount of data to write
+ *
+ * #cairo_write_func_t is the type of function which is called when a
+ * backend needs to write data to an output stream.  It is passed the
+ * closure which was specified by the user at the time the write
+ * function was registered, the data to write and the length of the
+ * data in bytes.  The write function should return
+ * %CAIRO_STATUS_SUCCESS if all the data was successfully written,
+ * %CAIRO_STATUS_WRITE_ERROR otherwise.
+ *
+ * Returns: the status code of the write operation
+ **/
+typedef cairo_status_t (*cairo_write_func_t) (void		  *closure,
+					      const unsigned char *data,
+					      unsigned int	   length);
+
+/**
+ * cairo_read_func_t:
+ * @closure: the input closure
+ * @data: the buffer into which to read the data
+ * @length: the amount of data to read
+ *
+ * #cairo_read_func_t is the type of function which is called when a
+ * backend needs to read data from an input stream.  It is passed the
+ * closure which was specified by the user at the time the read
+ * function was registered, the buffer to read the data into and the
+ * length of the data in bytes.  The read function should return
+ * %CAIRO_STATUS_SUCCESS if all the data was successfully read,
+ * %CAIRO_STATUS_READ_ERROR otherwise.
+ *
+ * Returns: the status code of the read operation
+ **/
+typedef cairo_status_t (*cairo_read_func_t) (void		*closure,
+					     unsigned char	*data,
+					     unsigned int	length);
+
+/* Functions for manipulating state objects */
+cairo_public cairo_t *
+cairo_create (cairo_surface_t *target);
+
+cairo_public cairo_t *
+cairo_reference (cairo_t *cr);
+
+cairo_public void
+cairo_destroy (cairo_t *cr);
+
+cairo_public unsigned int
+cairo_get_reference_count (cairo_t *cr);
+
+cairo_public void *
+cairo_get_user_data (cairo_t			 *cr,
+		     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_set_user_data (cairo_t			 *cr,
+		     const cairo_user_data_key_t *key,
+		     void			 *user_data,
+		     cairo_destroy_func_t	  destroy);
+
+cairo_public void
+cairo_save (cairo_t *cr);
+
+cairo_public void
+cairo_restore (cairo_t *cr);
+
+cairo_public void
+cairo_push_group (cairo_t *cr);
+
+cairo_public void
+cairo_push_group_with_content (cairo_t *cr, cairo_content_t content);
+
+cairo_public cairo_pattern_t *
+cairo_pop_group (cairo_t *cr);
+
+cairo_public void
+cairo_pop_group_to_source (cairo_t *cr);
+
+/* Modify state */
+
+/**
+ * cairo_operator_t:
+ * @CAIRO_OPERATOR_CLEAR: clear destination layer (bounded)
+ * @CAIRO_OPERATOR_SOURCE: replace destination layer (bounded)
+ * @CAIRO_OPERATOR_OVER: draw source layer on top of destination layer
+ * (bounded)
+ * @CAIRO_OPERATOR_IN: draw source where there was destination content
+ * (unbounded)
+ * @CAIRO_OPERATOR_OUT: draw source where there was no destination
+ * content (unbounded)
+ * @CAIRO_OPERATOR_ATOP: draw source on top of destination content and
+ * only there
+ * @CAIRO_OPERATOR_DEST: ignore the source
+ * @CAIRO_OPERATOR_DEST_OVER: draw destination on top of source
+ * @CAIRO_OPERATOR_DEST_IN: leave destination only where there was
+ * source content (unbounded)
+ * @CAIRO_OPERATOR_DEST_OUT: leave destination only where there was no
+ * source content
+ * @CAIRO_OPERATOR_DEST_ATOP: leave destination on top of source content
+ * and only there (unbounded)
+ * @CAIRO_OPERATOR_XOR: source and destination are shown where there is only
+ * one of them
+ * @CAIRO_OPERATOR_ADD: source and destination layers are accumulated
+ * @CAIRO_OPERATOR_SATURATE: like over, but assuming source and dest are
+ * disjoint geometries
+ * @CAIRO_OPERATOR_MULTIPLY: source and destination layers are multiplied.
+ * This causes the result to be at least as dark as the darker inputs.
+ * @CAIRO_OPERATOR_SCREEN: source and destination are complemented and
+ * multiplied. This causes the result to be at least as light as the lighter
+ * inputs.
+ * @CAIRO_OPERATOR_OVERLAY: multiplies or screens, depending on the
+ * lightness of the destination color.
+ * @CAIRO_OPERATOR_DARKEN: replaces the destination with the source if it
+ * is darker, otherwise keeps the source.
+ * @CAIRO_OPERATOR_LIGHTEN: replaces the destination with the source if it
+ * is lighter, otherwise keeps the source.
+ * @CAIRO_OPERATOR_COLOR_DODGE: brightens the destination color to reflect
+ * the source color.
+ * @CAIRO_OPERATOR_COLOR_BURN: darkens the destination color to reflect
+ * the source color.
+ * @CAIRO_OPERATOR_HARD_LIGHT: Multiplies or screens, dependant on source
+ * color.
+ * @CAIRO_OPERATOR_SOFT_LIGHT: Darkens or lightens, dependant on source
+ * color.
+ * @CAIRO_OPERATOR_DIFFERENCE: Takes the difference of the source and
+ * destination color.
+ * @CAIRO_OPERATOR_EXCLUSION: Produces an effect similar to difference, but
+ * with lower contrast.
+ * @CAIRO_OPERATOR_HSL_HUE: Creates a color with the hue of the source
+ * and the saturation and luminosity of the target.
+ * @CAIRO_OPERATOR_HSL_SATURATION: Creates a color with the saturation
+ * of the source and the hue and luminosity of the target. Painting with
+ * this mode onto a gray area prduces no change.
+ * @CAIRO_OPERATOR_HSL_COLOR: Creates a color with the hue and saturation
+ * of the source and the luminosity of the target. This preserves the gray
+ * levels of the target and is useful for coloring monochrome images or
+ * tinting color images.
+ * @CAIRO_OPERATOR_HSL_LUMINOSITY: Creates a color with the luminosity of
+ * the source and the hue and saturation of the target. This produces an
+ * inverse effect to @CAIRO_OPERATOR_HSL_COLOR.
+ *
+ * #cairo_operator_t is used to set the compositing operator for all cairo
+ * drawing operations.
+ *
+ * The default operator is %CAIRO_OPERATOR_OVER.
+ *
+ * The operators marked as <firstterm>unbounded</firstterm> modify their
+ * destination even outside of the mask layer (that is, their effect is not
+ * bound by the mask layer).  However, their effect can still be limited by
+ * way of clipping.
+ *
+ * To keep things simple, the operator descriptions here
+ * document the behavior for when both source and destination are either fully
+ * transparent or fully opaque.  The actual implementation works for
+ * translucent layers too.
+ * For a more detailed explanation of the effects of each operator, including
+ * the mathematical definitions, see
+ * <ulink url="http://cairographics.org/operators/">http://cairographics.org/operators/</ulink>.
+ **/
+typedef enum _cairo_operator {
+    CAIRO_OPERATOR_CLEAR,
+
+    CAIRO_OPERATOR_SOURCE,
+    CAIRO_OPERATOR_OVER,
+    CAIRO_OPERATOR_IN,
+    CAIRO_OPERATOR_OUT,
+    CAIRO_OPERATOR_ATOP,
+
+    CAIRO_OPERATOR_DEST,
+    CAIRO_OPERATOR_DEST_OVER,
+    CAIRO_OPERATOR_DEST_IN,
+    CAIRO_OPERATOR_DEST_OUT,
+    CAIRO_OPERATOR_DEST_ATOP,
+
+    CAIRO_OPERATOR_XOR,
+    CAIRO_OPERATOR_ADD,
+    CAIRO_OPERATOR_SATURATE,
+
+    CAIRO_OPERATOR_MULTIPLY,
+    CAIRO_OPERATOR_SCREEN,
+    CAIRO_OPERATOR_OVERLAY,
+    CAIRO_OPERATOR_DARKEN,
+    CAIRO_OPERATOR_LIGHTEN,
+    CAIRO_OPERATOR_COLOR_DODGE,
+    CAIRO_OPERATOR_COLOR_BURN,
+    CAIRO_OPERATOR_HARD_LIGHT,
+    CAIRO_OPERATOR_SOFT_LIGHT,
+    CAIRO_OPERATOR_DIFFERENCE,
+    CAIRO_OPERATOR_EXCLUSION,
+    CAIRO_OPERATOR_HSL_HUE,
+    CAIRO_OPERATOR_HSL_SATURATION,
+    CAIRO_OPERATOR_HSL_COLOR,
+    CAIRO_OPERATOR_HSL_LUMINOSITY
+} cairo_operator_t;
+
+cairo_public void
+cairo_set_operator (cairo_t *cr, cairo_operator_t op);
+
+cairo_public void
+cairo_set_source (cairo_t *cr, cairo_pattern_t *source);
+
+cairo_public void
+cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue);
+
+cairo_public void
+cairo_set_source_rgba (cairo_t *cr,
+		       double red, double green, double blue,
+		       double alpha);
+
+cairo_public void
+cairo_set_source_surface (cairo_t	  *cr,
+			  cairo_surface_t *surface,
+			  double	   x,
+			  double	   y);
+
+cairo_public void
+cairo_set_tolerance (cairo_t *cr, double tolerance);
+
+/**
+ * cairo_antialias_t:
+ * @CAIRO_ANTIALIAS_DEFAULT: Use the default antialiasing for
+ *   the subsystem and target device
+ * @CAIRO_ANTIALIAS_NONE: Use a bilevel alpha mask
+ * @CAIRO_ANTIALIAS_GRAY: Perform single-color antialiasing (using
+ *  shades of gray for black text on a white background, for example).
+ * @CAIRO_ANTIALIAS_SUBPIXEL: Perform antialiasing by taking
+ *  advantage of the order of subpixel elements on devices
+ *  such as LCD panels
+ *
+ * Specifies the type of antialiasing to do when rendering text or shapes.
+ **/
+typedef enum _cairo_antialias {
+    CAIRO_ANTIALIAS_DEFAULT,
+    CAIRO_ANTIALIAS_NONE,
+    CAIRO_ANTIALIAS_GRAY,
+    CAIRO_ANTIALIAS_SUBPIXEL
+} cairo_antialias_t;
+
+cairo_public void
+cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias);
+
+/**
+ * cairo_fill_rule_t:
+ * @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from
+ * left-to-right, counts +1. If the path crosses the ray
+ * from right to left, counts -1. (Left and right are determined
+ * from the perspective of looking along the ray from the starting
+ * point.) If the total count is non-zero, the point will be filled.
+ * @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of
+ * intersections, without regard to the orientation of the contour. If
+ * the total number of intersections is odd, the point will be
+ * filled.
+ *
+ * #cairo_fill_rule_t is used to select how paths are filled. For both
+ * fill rules, whether or not a point is included in the fill is
+ * determined by taking a ray from that point to infinity and looking
+ * at intersections with the path. The ray can be in any direction,
+ * as long as it doesn't pass through the end point of a segment
+ * or have a tricky intersection such as intersecting tangent to the path.
+ * (Note that filling is not actually implemented in this way. This
+ * is just a description of the rule that is applied.)
+ *
+ * The default fill rule is %CAIRO_FILL_RULE_WINDING.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_fill_rule {
+    CAIRO_FILL_RULE_WINDING,
+    CAIRO_FILL_RULE_EVEN_ODD
+} cairo_fill_rule_t;
+
+cairo_public void
+cairo_set_fill_rule (cairo_t *cr, cairo_fill_rule_t fill_rule);
+
+cairo_public void
+cairo_set_line_width (cairo_t *cr, double width);
+
+/**
+ * cairo_line_cap_t:
+ * @CAIRO_LINE_CAP_BUTT: start(stop) the line exactly at the start(end) point
+ * @CAIRO_LINE_CAP_ROUND: use a round ending, the center of the circle is the end point
+ * @CAIRO_LINE_CAP_SQUARE: use squared ending, the center of the square is the end point
+ *
+ * Specifies how to render the endpoints of the path when stroking.
+ *
+ * The default line cap style is %CAIRO_LINE_CAP_BUTT.
+ **/
+typedef enum _cairo_line_cap {
+    CAIRO_LINE_CAP_BUTT,
+    CAIRO_LINE_CAP_ROUND,
+    CAIRO_LINE_CAP_SQUARE
+} cairo_line_cap_t;
+
+cairo_public void
+cairo_set_line_cap (cairo_t *cr, cairo_line_cap_t line_cap);
+
+/**
+ * cairo_line_join_t:
+ * @CAIRO_LINE_JOIN_MITER: use a sharp (angled) corner, see
+ * cairo_set_miter_limit()
+ * @CAIRO_LINE_JOIN_ROUND: use a rounded join, the center of the circle is the
+ * joint point
+ * @CAIRO_LINE_JOIN_BEVEL: use a cut-off join, the join is cut off at half
+ * the line width from the joint point
+ *
+ * Specifies how to render the junction of two lines when stroking.
+ *
+ * The default line join style is %CAIRO_LINE_JOIN_MITER.
+ **/
+typedef enum _cairo_line_join {
+    CAIRO_LINE_JOIN_MITER,
+    CAIRO_LINE_JOIN_ROUND,
+    CAIRO_LINE_JOIN_BEVEL
+} cairo_line_join_t;
+
+cairo_public void
+cairo_set_line_join (cairo_t *cr, cairo_line_join_t line_join);
+
+cairo_public void
+cairo_set_dash (cairo_t      *cr,
+		const double *dashes,
+		int	      num_dashes,
+		double	      offset);
+
+cairo_public void
+cairo_set_miter_limit (cairo_t *cr, double limit);
+
+cairo_public void
+cairo_translate (cairo_t *cr, double tx, double ty);
+
+cairo_public void
+cairo_scale (cairo_t *cr, double sx, double sy);
+
+cairo_public void
+cairo_rotate (cairo_t *cr, double angle);
+
+cairo_public void
+cairo_transform (cairo_t	      *cr,
+		 const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_set_matrix (cairo_t	       *cr,
+		  const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_identity_matrix (cairo_t *cr);
+
+cairo_public void
+cairo_user_to_device (cairo_t *cr, double *x, double *y);
+
+cairo_public void
+cairo_user_to_device_distance (cairo_t *cr, double *dx, double *dy);
+
+cairo_public void
+cairo_device_to_user (cairo_t *cr, double *x, double *y);
+
+cairo_public void
+cairo_device_to_user_distance (cairo_t *cr, double *dx, double *dy);
+
+/* Path creation functions */
+cairo_public void
+cairo_new_path (cairo_t *cr);
+
+cairo_public void
+cairo_move_to (cairo_t *cr, double x, double y);
+
+cairo_public void
+cairo_new_sub_path (cairo_t *cr);
+
+cairo_public void
+cairo_line_to (cairo_t *cr, double x, double y);
+
+cairo_public void
+cairo_curve_to (cairo_t *cr,
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3);
+
+cairo_public void
+cairo_arc (cairo_t *cr,
+	   double xc, double yc,
+	   double radius,
+	   double angle1, double angle2);
+
+cairo_public void
+cairo_arc_negative (cairo_t *cr,
+		    double xc, double yc,
+		    double radius,
+		    double angle1, double angle2);
+
+/* XXX: NYI
+cairo_public void
+cairo_arc_to (cairo_t *cr,
+	      double x1, double y1,
+	      double x2, double y2,
+	      double radius);
+*/
+
+cairo_public void
+cairo_rel_move_to (cairo_t *cr, double dx, double dy);
+
+cairo_public void
+cairo_rel_line_to (cairo_t *cr, double dx, double dy);
+
+cairo_public void
+cairo_rel_curve_to (cairo_t *cr,
+		    double dx1, double dy1,
+		    double dx2, double dy2,
+		    double dx3, double dy3);
+
+cairo_public void
+cairo_rectangle (cairo_t *cr,
+		 double x, double y,
+		 double width, double height);
+
+/* XXX: NYI
+cairo_public void
+cairo_stroke_to_path (cairo_t *cr);
+*/
+
+cairo_public void
+cairo_close_path (cairo_t *cr);
+
+cairo_public void
+cairo_path_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/* Painting functions */
+cairo_public void
+cairo_paint (cairo_t *cr);
+
+cairo_public void
+cairo_paint_with_alpha (cairo_t *cr,
+			double   alpha);
+
+cairo_public void
+cairo_mask (cairo_t         *cr,
+	    cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_mask_surface (cairo_t         *cr,
+		    cairo_surface_t *surface,
+		    double           surface_x,
+		    double           surface_y);
+
+cairo_public void
+cairo_stroke (cairo_t *cr);
+
+cairo_public void
+cairo_stroke_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_fill (cairo_t *cr);
+
+cairo_public void
+cairo_fill_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_copy_page (cairo_t *cr);
+
+cairo_public void
+cairo_show_page (cairo_t *cr);
+
+/* Insideness testing */
+cairo_public cairo_bool_t
+cairo_in_stroke (cairo_t *cr, double x, double y);
+
+cairo_public cairo_bool_t
+cairo_in_fill (cairo_t *cr, double x, double y);
+
+cairo_public cairo_bool_t
+cairo_in_clip (cairo_t *cr, double x, double y);
+
+/* Rectangular extents */
+cairo_public void
+cairo_stroke_extents (cairo_t *cr,
+		      double *x1, double *y1,
+		      double *x2, double *y2);
+
+cairo_public void
+cairo_fill_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/* Clipping */
+cairo_public void
+cairo_reset_clip (cairo_t *cr);
+
+cairo_public void
+cairo_clip (cairo_t *cr);
+
+cairo_public void
+cairo_clip_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_clip_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/**
+ * cairo_rectangle_t:
+ * @x: X coordinate of the left side of the rectangle
+ * @y: Y coordinate of the the top side of the rectangle
+ * @width: width of the rectangle
+ * @height: height of the rectangle
+ *
+ * A data structure for holding a rectangle.
+ *
+ * Since: 1.4
+ **/
+typedef struct _cairo_rectangle {
+    double x, y, width, height;
+} cairo_rectangle_t;
+
+/**
+ * cairo_rectangle_list_t:
+ * @status: Error status of the rectangle list
+ * @rectangles: Array containing the rectangles
+ * @num_rectangles: Number of rectangles in this list
+ * 
+ * A data structure for holding a dynamically allocated
+ * array of rectangles.
+ *
+ * Since: 1.4
+ **/
+typedef struct _cairo_rectangle_list {
+    cairo_status_t     status;
+    cairo_rectangle_t *rectangles;
+    int                num_rectangles;
+} cairo_rectangle_list_t;
+
+cairo_public cairo_rectangle_list_t *
+cairo_copy_clip_rectangle_list (cairo_t *cr);
+
+cairo_public void
+cairo_rectangle_list_destroy (cairo_rectangle_list_t *rectangle_list);
+
+/* Font/Text functions */
+
+/**
+ * cairo_scaled_font_t:
+ *
+ * A #cairo_scaled_font_t is a font scaled to a particular size and device
+ * resolution. A #cairo_scaled_font_t is most useful for low-level font
+ * usage where a library or application wants to cache a reference
+ * to a scaled font to speed up the computation of metrics.
+ *
+ * There are various types of scaled fonts, depending on the
+ * <firstterm>font backend</firstterm> they use. The type of a
+ * scaled font can be queried using cairo_scaled_font_get_type().
+ *
+ * Memory management of #cairo_scaled_font_t is done with
+ * cairo_scaled_font_reference() and cairo_scaled_font_destroy().
+ **/
+typedef struct _cairo_scaled_font cairo_scaled_font_t;
+
+/**
+ * cairo_font_face_t:
+ *
+ * A #cairo_font_face_t specifies all aspects of a font other
+ * than the size or font matrix (a font matrix is used to distort
+ * a font by sheering it or scaling it unequally in the two
+ * directions) . A font face can be set on a #cairo_t by using
+ * cairo_set_font_face(); the size and font matrix are set with
+ * cairo_set_font_size() and cairo_set_font_matrix().
+ *
+ * There are various types of font faces, depending on the
+ * <firstterm>font backend</firstterm> they use. The type of a
+ * font face can be queried using cairo_font_face_get_type().
+ *
+ * Memory management of #cairo_font_face_t is done with
+ * cairo_font_face_reference() and cairo_font_face_destroy().
+ **/
+typedef struct _cairo_font_face cairo_font_face_t;
+
+/**
+ * cairo_glyph_t:
+ * @index: glyph index in the font. The exact interpretation of the
+ *      glyph index depends on the font technology being used.
+ * @x: the offset in the X direction between the origin used for
+ *     drawing or measuring the string and the origin of this glyph.
+ * @y: the offset in the Y direction between the origin used for
+ *     drawing or measuring the string and the origin of this glyph.
+ *
+ * The #cairo_glyph_t structure holds information about a single glyph
+ * when drawing or measuring text. A font is (in simple terms) a
+ * collection of shapes used to draw text. A glyph is one of these
+ * shapes. There can be multiple glyphs for a single character
+ * (alternates to be used in different contexts, for example), or a
+ * glyph can be a <firstterm>ligature</firstterm> of multiple
+ * characters. Cairo doesn't expose any way of converting input text
+ * into glyphs, so in order to use the Cairo interfaces that take
+ * arrays of glyphs, you must directly access the appropriate
+ * underlying font system.
+ *
+ * Note that the offsets given by @x and @y are not cumulative. When
+ * drawing or measuring text, each glyph is individually positioned
+ * with respect to the overall origin
+ **/
+typedef struct {
+    unsigned long        index;
+    double               x;
+    double               y;
+} cairo_glyph_t;
+
+cairo_public cairo_glyph_t *
+cairo_glyph_allocate (int num_glyphs);
+
+cairo_public void
+cairo_glyph_free (cairo_glyph_t *glyphs);
+
+/**
+ * cairo_text_cluster_t:
+ * @num_bytes: the number of bytes of UTF-8 text covered by cluster
+ * @num_glyphs: the number of glyphs covered by cluster
+ *
+ * The #cairo_text_cluster_t structure holds information about a single
+ * <firstterm>text cluster</firstterm>.  A text cluster is a minimal
+ * mapping of some glyphs corresponding to some UTF-8 text.
+ *
+ * For a cluster to be valid, both @num_bytes and @num_glyphs should
+ * be non-negative, and at least one should be non-zero.
+ * Note that clusters with zero glyphs are not as well supported as
+ * normal clusters.  For example, PDF rendering applications typically
+ * ignore those clusters when PDF text is being selected.
+ *
+ * See cairo_show_text_glyphs() for how clusters are used in advanced
+ * text operations.
+ *
+ * Since: 1.8
+ **/
+typedef struct {
+    int        num_bytes;
+    int        num_glyphs;
+} cairo_text_cluster_t;
+
+cairo_public cairo_text_cluster_t *
+cairo_text_cluster_allocate (int num_clusters);
+
+cairo_public void
+cairo_text_cluster_free (cairo_text_cluster_t *clusters);
+
+/**
+ * cairo_text_cluster_flags_t:
+ * @CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: The clusters in the cluster array
+ * map to glyphs in the glyph array from end to start.
+ *
+ * Specifies properties of a text cluster mapping.
+ *
+ * Since: 1.8
+ **/
+typedef enum _cairo_text_cluster_flags {
+    CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 0x00000001
+} cairo_text_cluster_flags_t;
+
+/**
+ * cairo_text_extents_t:
+ * @x_bearing: the horizontal distance from the origin to the
+ *   leftmost part of the glyphs as drawn. Positive if the
+ *   glyphs lie entirely to the right of the origin.
+ * @y_bearing: the vertical distance from the origin to the
+ *   topmost part of the glyphs as drawn. Positive only if the
+ *   glyphs lie completely below the origin; will usually be
+ *   negative.
+ * @width: width of the glyphs as drawn
+ * @height: height of the glyphs as drawn
+ * @x_advance:distance to advance in the X direction
+ *    after drawing these glyphs
+ * @y_advance: distance to advance in the Y direction
+ *   after drawing these glyphs. Will typically be zero except
+ *   for vertical text layout as found in East-Asian languages.
+ *
+ * The #cairo_text_extents_t structure stores the extents of a single
+ * glyph or a string of glyphs in user-space coordinates. Because text
+ * extents are in user-space coordinates, they are mostly, but not
+ * entirely, independent of the current transformation matrix. If you call
+ * <literal>cairo_scale(cr, 2.0, 2.0)</literal>, text will
+ * be drawn twice as big, but the reported text extents will not be
+ * doubled. They will change slightly due to hinting (so you can't
+ * assume that metrics are independent of the transformation matrix),
+ * but otherwise will remain unchanged.
+ **/
+typedef struct {
+    double x_bearing;
+    double y_bearing;
+    double width;
+    double height;
+    double x_advance;
+    double y_advance;
+} cairo_text_extents_t;
+
+/**
+ * cairo_font_extents_t:
+ * @ascent: the distance that the font extends above the baseline.
+ *          Note that this is not always exactly equal to the maximum
+ *          of the extents of all the glyphs in the font, but rather
+ *          is picked to express the font designer's intent as to
+ *          how the font should align with elements above it.
+ * @descent: the distance that the font extends below the baseline.
+ *           This value is positive for typical fonts that include
+ *           portions below the baseline. Note that this is not always
+ *           exactly equal to the maximum of the extents of all the
+ *           glyphs in the font, but rather is picked to express the
+ *           font designer's intent as to how the the font should
+ *           align with elements below it.
+ * @height: the recommended vertical distance between baselines when
+ *          setting consecutive lines of text with the font. This
+ *          is greater than @ascent+@descent by a
+ *          quantity known as the <firstterm>line spacing</firstterm>
+ *          or <firstterm>external leading</firstterm>. When space
+ *          is at a premium, most fonts can be set with only
+ *          a distance of @ascent+@descent between lines.
+ * @max_x_advance: the maximum distance in the X direction that
+ *         the the origin is advanced for any glyph in the font.
+ * @max_y_advance: the maximum distance in the Y direction that
+ *         the the origin is advanced for any glyph in the font.
+ *         this will be zero for normal fonts used for horizontal
+ *         writing. (The scripts of East Asia are sometimes written
+ *         vertically.)
+ *
+ * The #cairo_font_extents_t structure stores metric information for
+ * a font. Values are given in the current user-space coordinate
+ * system.
+ *
+ * Because font metrics are in user-space coordinates, they are
+ * mostly, but not entirely, independent of the current transformation
+ * matrix. If you call <literal>cairo_scale(cr, 2.0, 2.0)</literal>,
+ * text will be drawn twice as big, but the reported text extents will
+ * not be doubled. They will change slightly due to hinting (so you
+ * can't assume that metrics are independent of the transformation
+ * matrix), but otherwise will remain unchanged.
+ **/
+typedef struct {
+    double ascent;
+    double descent;
+    double height;
+    double max_x_advance;
+    double max_y_advance;
+} cairo_font_extents_t;
+
+/**
+ * cairo_font_slant_t:
+ * @CAIRO_FONT_SLANT_NORMAL: Upright font style
+ * @CAIRO_FONT_SLANT_ITALIC: Italic font style
+ * @CAIRO_FONT_SLANT_OBLIQUE: Oblique font style
+ *
+ * Specifies variants of a font face based on their slant.
+ **/
+typedef enum _cairo_font_slant {
+    CAIRO_FONT_SLANT_NORMAL,
+    CAIRO_FONT_SLANT_ITALIC,
+    CAIRO_FONT_SLANT_OBLIQUE
+} cairo_font_slant_t;
+
+/**
+ * cairo_font_weight_t:
+ * @CAIRO_FONT_WEIGHT_NORMAL: Normal font weight
+ * @CAIRO_FONT_WEIGHT_BOLD: Bold font weight
+ *
+ * Specifies variants of a font face based on their weight.
+ **/
+typedef enum _cairo_font_weight {
+    CAIRO_FONT_WEIGHT_NORMAL,
+    CAIRO_FONT_WEIGHT_BOLD
+} cairo_font_weight_t;
+
+/**
+ * cairo_subpixel_order_t:
+ * @CAIRO_SUBPIXEL_ORDER_DEFAULT: Use the default subpixel order for
+ *   for the target device
+ * @CAIRO_SUBPIXEL_ORDER_RGB: Subpixel elements are arranged horizontally
+ *   with red at the left
+ * @CAIRO_SUBPIXEL_ORDER_BGR:  Subpixel elements are arranged horizontally
+ *   with blue at the left
+ * @CAIRO_SUBPIXEL_ORDER_VRGB: Subpixel elements are arranged vertically
+ *   with red at the top
+ * @CAIRO_SUBPIXEL_ORDER_VBGR: Subpixel elements are arranged vertically
+ *   with blue at the top
+ *
+ * The subpixel order specifies the order of color elements within
+ * each pixel on the display device when rendering with an
+ * antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
+ **/
+typedef enum _cairo_subpixel_order {
+    CAIRO_SUBPIXEL_ORDER_DEFAULT,
+    CAIRO_SUBPIXEL_ORDER_RGB,
+    CAIRO_SUBPIXEL_ORDER_BGR,
+    CAIRO_SUBPIXEL_ORDER_VRGB,
+    CAIRO_SUBPIXEL_ORDER_VBGR
+} cairo_subpixel_order_t;
+
+/**
+ * cairo_hint_style_t:
+ * @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for
+ *   font backend and target device
+ * @CAIRO_HINT_STYLE_NONE: Do not hint outlines
+ * @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve
+ *   contrast while retaining good fidelity to the original
+ *   shapes.
+ * @CAIRO_HINT_STYLE_MEDIUM: Hint outlines with medium strength
+ *   giving a compromise between fidelity to the original shapes
+ *   and contrast
+ * @CAIRO_HINT_STYLE_FULL: Hint outlines to maximize contrast
+ *
+ * Specifies the type of hinting to do on font outlines. Hinting
+ * is the process of fitting outlines to the pixel grid in order
+ * to improve the appearance of the result. Since hinting outlines
+ * involves distorting them, it also reduces the faithfulness
+ * to the original outline shapes. Not all of the outline hinting
+ * styles are supported by all font backends.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_hint_style {
+    CAIRO_HINT_STYLE_DEFAULT,
+    CAIRO_HINT_STYLE_NONE,
+    CAIRO_HINT_STYLE_SLIGHT,
+    CAIRO_HINT_STYLE_MEDIUM,
+    CAIRO_HINT_STYLE_FULL
+} cairo_hint_style_t;
+
+/**
+ * cairo_hint_metrics_t:
+ * @CAIRO_HINT_METRICS_DEFAULT: Hint metrics in the default
+ *  manner for the font backend and target device
+ * @CAIRO_HINT_METRICS_OFF: Do not hint font metrics
+ * @CAIRO_HINT_METRICS_ON: Hint font metrics
+ *
+ * Specifies whether to hint font metrics; hinting font metrics
+ * means quantizing them so that they are integer values in
+ * device space. Doing this improves the consistency of
+ * letter and line spacing, however it also means that text
+ * will be laid out differently at different zoom factors.
+ **/
+typedef enum _cairo_hint_metrics {
+    CAIRO_HINT_METRICS_DEFAULT,
+    CAIRO_HINT_METRICS_OFF,
+    CAIRO_HINT_METRICS_ON
+} cairo_hint_metrics_t;
+
+/**
+ * cairo_font_options_t:
+ *
+ * An opaque structure holding all options that are used when
+ * rendering fonts.
+ *
+ * Individual features of a #cairo_font_options_t can be set or
+ * accessed using functions named
+ * cairo_font_options_set_<emphasis>feature_name</emphasis> and
+ * cairo_font_options_get_<emphasis>feature_name</emphasis>, like
+ * cairo_font_options_set_antialias() and
+ * cairo_font_options_get_antialias().
+ *
+ * New features may be added to a #cairo_font_options_t in the
+ * future.  For this reason, cairo_font_options_copy(),
+ * cairo_font_options_equal(), cairo_font_options_merge(), and
+ * cairo_font_options_hash() should be used to copy, check
+ * for equality, merge, or compute a hash value of
+ * #cairo_font_options_t objects.
+ **/
+typedef struct _cairo_font_options cairo_font_options_t;
+
+cairo_public cairo_font_options_t *
+cairo_font_options_create (void);
+
+cairo_public cairo_font_options_t *
+cairo_font_options_copy (const cairo_font_options_t *original);
+
+cairo_public void
+cairo_font_options_destroy (cairo_font_options_t *options);
+
+cairo_public cairo_status_t
+cairo_font_options_status (cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_merge (cairo_font_options_t       *options,
+			  const cairo_font_options_t *other);
+cairo_public cairo_bool_t
+cairo_font_options_equal (const cairo_font_options_t *options,
+			  const cairo_font_options_t *other);
+
+cairo_public unsigned long
+cairo_font_options_hash (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_antialias (cairo_font_options_t *options,
+				  cairo_antialias_t     antialias);
+cairo_public cairo_antialias_t
+cairo_font_options_get_antialias (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_subpixel_order (cairo_font_options_t   *options,
+				       cairo_subpixel_order_t  subpixel_order);
+cairo_public cairo_subpixel_order_t
+cairo_font_options_get_subpixel_order (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_hint_style (cairo_font_options_t *options,
+				   cairo_hint_style_t     hint_style);
+cairo_public cairo_hint_style_t
+cairo_font_options_get_hint_style (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_hint_metrics (cairo_font_options_t *options,
+				     cairo_hint_metrics_t  hint_metrics);
+cairo_public cairo_hint_metrics_t
+cairo_font_options_get_hint_metrics (const cairo_font_options_t *options);
+
+/* This interface is for dealing with text as text, not caring about the
+   font object inside the the cairo_t. */
+
+cairo_public void
+cairo_select_font_face (cairo_t              *cr,
+			const char           *family,
+			cairo_font_slant_t   slant,
+			cairo_font_weight_t  weight);
+
+cairo_public void
+cairo_set_font_size (cairo_t *cr, double size);
+
+cairo_public void
+cairo_set_font_matrix (cairo_t		    *cr,
+		       const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_get_font_matrix (cairo_t *cr,
+		       cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_set_font_options (cairo_t                    *cr,
+			const cairo_font_options_t *options);
+
+cairo_public void
+cairo_get_font_options (cairo_t              *cr,
+			cairo_font_options_t *options);
+
+cairo_public void
+cairo_set_font_face (cairo_t *cr, cairo_font_face_t *font_face);
+
+cairo_public cairo_font_face_t *
+cairo_get_font_face (cairo_t *cr);
+
+cairo_public void
+cairo_set_scaled_font (cairo_t                   *cr,
+		       const cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_scaled_font_t *
+cairo_get_scaled_font (cairo_t *cr);
+
+cairo_public void
+cairo_show_text (cairo_t *cr, const char *utf8);
+
+cairo_public void
+cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
+
+cairo_public void
+cairo_show_text_glyphs (cairo_t			   *cr,
+			const char		   *utf8,
+			int			    utf8_len,
+			const cairo_glyph_t	   *glyphs,
+			int			    num_glyphs,
+			const cairo_text_cluster_t *clusters,
+			int			    num_clusters,
+			cairo_text_cluster_flags_t  cluster_flags);
+
+cairo_public void
+cairo_text_path  (cairo_t *cr, const char *utf8);
+
+cairo_public void
+cairo_glyph_path (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
+
+cairo_public void
+cairo_text_extents (cairo_t              *cr,
+		    const char    	 *utf8,
+		    cairo_text_extents_t *extents);
+
+cairo_public void
+cairo_glyph_extents (cairo_t               *cr,
+		     const cairo_glyph_t   *glyphs,
+		     int                   num_glyphs,
+		     cairo_text_extents_t  *extents);
+
+cairo_public void
+cairo_font_extents (cairo_t              *cr,
+		    cairo_font_extents_t *extents);
+
+/* Generic identifier for a font style */
+
+cairo_public cairo_font_face_t *
+cairo_font_face_reference (cairo_font_face_t *font_face);
+
+cairo_public void
+cairo_font_face_destroy (cairo_font_face_t *font_face);
+
+cairo_public unsigned int
+cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
+
+cairo_public cairo_status_t
+cairo_font_face_status (cairo_font_face_t *font_face);
+
+
+/**
+ * cairo_font_type_t:
+ * @CAIRO_FONT_TYPE_TOY: The font was created using cairo's toy font api
+ * @CAIRO_FONT_TYPE_FT: The font is of type FreeType
+ * @CAIRO_FONT_TYPE_WIN32: The font is of type Win32
+ * @CAIRO_FONT_TYPE_QUARTZ: The font is of type Quartz (Since: 1.6)
+ * @CAIRO_FONT_TYPE_USER: The font was create using cairo's user font api (Since: 1.8)
+ *
+ * #cairo_font_type_t is used to describe the type of a given font
+ * face or scaled font. The font types are also known as "font
+ * backends" within cairo.
+ *
+ * The type of a font face is determined by the function used to
+ * create it, which will generally be of the form
+ * cairo_<emphasis>type</emphasis>_font_face_create(). The font face type can be queried
+ * with cairo_font_face_get_type()
+ *
+ * The various #cairo_font_face_t functions can be used with a font face
+ * of any type.
+ *
+ * The type of a scaled font is determined by the type of the font
+ * face passed to cairo_scaled_font_create(). The scaled font type can
+ * be queried with cairo_scaled_font_get_type()
+ *
+ * The various #cairo_scaled_font_t functions can be used with scaled
+ * fonts of any type, but some font backends also provide
+ * type-specific functions that must only be called with a scaled font
+ * of the appropriate type. These functions have names that begin with
+ * cairo_<emphasis>type</emphasis>_scaled_font() such as cairo_ft_scaled_font_lock_face().
+ *
+ * The behavior of calling a type-specific function with a scaled font
+ * of the wrong type is undefined.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_font_type {
+    CAIRO_FONT_TYPE_TOY,
+    CAIRO_FONT_TYPE_FT,
+    CAIRO_FONT_TYPE_WIN32,
+    CAIRO_FONT_TYPE_QUARTZ,
+    CAIRO_FONT_TYPE_USER
+} cairo_font_type_t;
+
+cairo_public cairo_font_type_t
+cairo_font_face_get_type (cairo_font_face_t *font_face);
+
+cairo_public void *
+cairo_font_face_get_user_data (cairo_font_face_t	   *font_face,
+			       const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_font_face_set_user_data (cairo_font_face_t	   *font_face,
+			       const cairo_user_data_key_t *key,
+			       void			   *user_data,
+			       cairo_destroy_func_t	    destroy);
+
+/* Portable interface to general font features. */
+
+cairo_public cairo_scaled_font_t *
+cairo_scaled_font_create (cairo_font_face_t          *font_face,
+			  const cairo_matrix_t       *font_matrix,
+			  const cairo_matrix_t       *ctm,
+			  const cairo_font_options_t *options);
+
+cairo_public cairo_scaled_font_t *
+cairo_scaled_font_reference (cairo_scaled_font_t *scaled_font);
+
+cairo_public void
+cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
+
+cairo_public unsigned int
+cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_status_t
+cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_font_type_t
+cairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font);
+
+cairo_public void *
+cairo_scaled_font_get_user_data (cairo_scaled_font_t         *scaled_font,
+				 const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_scaled_font_set_user_data (cairo_scaled_font_t         *scaled_font,
+				 const cairo_user_data_key_t *key,
+				 void                        *user_data,
+				 cairo_destroy_func_t	      destroy);
+
+cairo_public void
+cairo_scaled_font_extents (cairo_scaled_font_t  *scaled_font,
+			   cairo_font_extents_t *extents);
+
+cairo_public void
+cairo_scaled_font_text_extents (cairo_scaled_font_t  *scaled_font,
+				const char  	     *utf8,
+				cairo_text_extents_t *extents);
+
+cairo_public void
+cairo_scaled_font_glyph_extents (cairo_scaled_font_t   *scaled_font,
+				 const cairo_glyph_t   *glyphs,
+				 int                   num_glyphs,
+				 cairo_text_extents_t  *extents);
+
+cairo_public cairo_status_t
+cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t        *scaled_font,
+				  double		      x,
+				  double		      y,
+				  const char	             *utf8,
+				  int		              utf8_len,
+				  cairo_glyph_t	            **glyphs,
+				  int		             *num_glyphs,
+				  cairo_text_cluster_t      **clusters,
+				  int		             *num_clusters,
+				  cairo_text_cluster_flags_t *cluster_flags);
+
+cairo_public cairo_font_face_t *
+cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font);
+
+cairo_public void
+cairo_scaled_font_get_font_matrix (cairo_scaled_font_t	*scaled_font,
+				   cairo_matrix_t	*font_matrix);
+
+cairo_public void
+cairo_scaled_font_get_ctm (cairo_scaled_font_t	*scaled_font,
+			   cairo_matrix_t	*ctm);
+
+cairo_public void
+cairo_scaled_font_get_scale_matrix (cairo_scaled_font_t	*scaled_font,
+				    cairo_matrix_t	*scale_matrix);
+
+cairo_public void
+cairo_scaled_font_get_font_options (cairo_scaled_font_t		*scaled_font,
+				    cairo_font_options_t	*options);
+
+
+/* Toy fonts */
+
+cairo_public cairo_font_face_t *
+cairo_toy_font_face_create (const char           *family,
+			    cairo_font_slant_t    slant,
+			    cairo_font_weight_t   weight);
+
+cairo_public const char *
+cairo_toy_font_face_get_family (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_slant_t
+cairo_toy_font_face_get_slant (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_weight_t
+cairo_toy_font_face_get_weight (cairo_font_face_t *font_face);
+
+
+/* User fonts */
+
+cairo_public cairo_font_face_t *
+cairo_user_font_face_create (void);
+
+/* User-font method signatures */
+
+/**
+ * cairo_user_scaled_font_init_func_t:
+ * @scaled_font: the scaled-font being created
+ * @cr: a cairo context, in font space
+ * @extents: font extents to fill in, in font space
+ *
+ * #cairo_user_scaled_font_init_func_t is the type of function which is
+ * called when a scaled-font needs to be created for a user font-face.
+ *
+ * The cairo context @cr is not used by the caller, but is prepared in font
+ * space, similar to what the cairo contexts passed to the render_glyph
+ * method will look like.  The callback can use this context for extents
+ * computation for example.  After the callback is called, @cr is checked
+ * for any error status.
+ *
+ * The @extents argument is where the user font sets the font extents for
+ * @scaled_font.  It is in font space, which means that for most cases its
+ * ascent and descent members should add to 1.0.  @extents is preset to
+ * hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
+ * descent and max_y_advance members.
+ *
+ * The callback is optional.  If not set, default font extents as described
+ * in the previous paragraph will be used.
+ *
+ * Note that @scaled_font is not fully initialized at this
+ * point and trying to use it for text operations in the callback will result
+ * in deadlock.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success, or an error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_init_func_t) (cairo_scaled_font_t  *scaled_font,
+							      cairo_t              *cr,
+							      cairo_font_extents_t *extents);
+
+/**
+ * cairo_user_scaled_font_render_glyph_func_t:
+ * @scaled_font: user scaled-font
+ * @glyph: glyph code to render
+ * @cr: cairo context to draw to, in font space
+ * @extents: glyph extents to fill in, in font space
+ *
+ * #cairo_user_scaled_font_render_glyph_func_t is the type of function which
+ * is called when a user scaled-font needs to render a glyph.
+ *
+ * The callback is mandatory, and expected to draw the glyph with code @glyph to
+ * the cairo context @cr.  @cr is prepared such that the glyph drawing is done in
+ * font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font,
+ * The @extents argument is where the user font sets the font extents for
+ * @scaled_font.  However, if user prefers to draw in user space, they can
+ * achieve that by changing the matrix on @cr.  All cairo rendering operations
+ * to @cr are permitted, however, the result is undefined if any source other
+ * than the default source on @cr is used.  That means, glyph bitmaps should
+ * be rendered using cairo_mask() instead of cairo_paint().
+ *
+ * Other non-default settings on @cr include a font size of 1.0 (given that
+ * it is set up to be in font space), and font options corresponding to
+ * @scaled_font.
+ *
+ * The @extents argument is preset to have <literal>x_bearing</literal>,
+ * <literal>width</literal>, and <literal>y_advance</literal> of zero,
+ * <literal>y_bearing</literal> set to <literal>-font_extents.ascent</literal>,
+ * <literal>height</literal> to <literal>font_extents.ascent+font_extents.descent</literal>,
+ * and <literal>x_advance</literal> to <literal>font_extents.max_x_advance</literal>.
+ * The only field user needs to set in majority of cases is
+ * <literal>x_advance</literal>.
+ * If the <literal>width</literal> field is zero upon the callback returning
+ * (which is its preset value), the glyph extents are automatically computed
+ * based on the drawings done to @cr.  This is in most cases exactly what the
+ * desired behavior is.  However, if for any reason the callback sets the
+ * extents, it must be ink extents, and include the extents of all drawing
+ * done to @cr in the callback.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success, or
+ * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_render_glyph_func_t) (cairo_scaled_font_t  *scaled_font,
+								      unsigned long         glyph,
+								      cairo_t              *cr,
+								      cairo_text_extents_t *extents);
+
+/**
+ * cairo_user_scaled_font_text_to_glyphs_func_t:
+ * @scaled_font: the scaled-font being created
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes
+ * @glyphs: pointer to array of glyphs to fill, in font space
+ * @num_glyphs: pointer to number of glyphs
+ * @clusters: pointer to array of cluster mapping information to fill, or %NULL
+ * @num_clusters: pointer to number of clusters
+ * @cluster_flags: pointer to location to store cluster flags corresponding to the
+ *                 output @clusters
+ *
+ * #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
+ * is called to convert input text to an array of glyphs.  This is used by the
+ * cairo_show_text() operation.
+ *
+ * Using this callback the user-font has full control on glyphs and their
+ * positions.  That means, it allows for features like ligatures and kerning,
+ * as well as complex <firstterm>shaping</firstterm> required for scripts like
+ * Arabic and Indic.
+ *
+ * The @num_glyphs argument is preset to the number of glyph entries available
+ * in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of
+ * @num_glyphs will be zero.  If the provided glyph array is too short for
+ * the conversion (or for convenience), a new glyph array may be allocated
+ * using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
+ * @num_glyphs should contain the number of generated glyphs.  If the value
+ * @glyphs points at has changed after the call, the caller will free the
+ * allocated glyph array using cairo_glyph_free().
+ * The callback should populate the glyph indices and positions (in font space)
+ * assuming that the text is to be shown at the origin.
+ *
+ * If @clusters is not %NULL, @num_clusters and @cluster_flags are also
+ * non-%NULL, and cluster mapping should be computed. The semantics of how
+ * cluster array allocation works is similar to the glyph array.  That is,
+ * if @clusters initially points to a non-%NULL value, that array may be used
+ * as a cluster buffer, and @num_clusters points to the number of cluster
+ * entries available there.  If the provided cluster array is too short for
+ * the conversion (or for convenience), a new cluster array may be allocated
+ * using cairo_text_cluster_allocate() and placed in @clusters.  Upon return,
+ * @num_clusters should contain the number of generated clusters.
+ * If the value @clusters points at has changed after the call, the caller
+ * will free the allocated cluster array using cairo_text_cluster_free().
+ *
+ * The callback is optional.  If @num_glyphs is negative upon
+ * the callback returning or if the return value
+ * is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback
+ * is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.
+ *
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success,
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
+ * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_text_to_glyphs_func_t) (cairo_scaled_font_t        *scaled_font,
+									const char	           *utf8,
+									int		            utf8_len,
+									cairo_glyph_t	          **glyphs,
+									int		           *num_glyphs,
+									cairo_text_cluster_t      **clusters,
+									int		           *num_clusters,
+									cairo_text_cluster_flags_t *cluster_flags);
+
+/**
+ * cairo_user_scaled_font_unicode_to_glyph_func_t:
+ * @scaled_font: the scaled-font being created
+ * @unicode: input unicode character code-point
+ * @glyph_index: output glyph index
+ *
+ * #cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which
+ * is called to convert an input Unicode character to a single glyph.
+ * This is used by the cairo_show_text() operation.
+ *
+ * This callback is used to provide the same functionality as the
+ * text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)
+ * but has much less control on the output,
+ * in exchange for increased ease of use.  The inherent assumption to using
+ * this callback is that each character maps to one glyph, and that the
+ * mapping is context independent.  It also assumes that glyphs are positioned
+ * according to their advance width.  These mean no ligatures, kerning, or
+ * complex scripts can be implemented using this callback.
+ *
+ * The callback is optional, and only used if text_to_glyphs callback is not
+ * set or fails to return glyphs.  If this callback is not set or if it returns
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode
+ * code-points to glyph indices is assumed.
+ *
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success,
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
+ * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_unicode_to_glyph_func_t) (cairo_scaled_font_t *scaled_font,
+									  unsigned long        unicode,
+									  unsigned long       *glyph_index);
+
+/* User-font method setters */
+
+cairo_public void
+cairo_user_font_face_set_init_func (cairo_font_face_t                  *font_face,
+				    cairo_user_scaled_font_init_func_t  init_func);
+
+cairo_public void
+cairo_user_font_face_set_render_glyph_func (cairo_font_face_t                          *font_face,
+					    cairo_user_scaled_font_render_glyph_func_t  render_glyph_func);
+
+cairo_public void
+cairo_user_font_face_set_text_to_glyphs_func (cairo_font_face_t                            *font_face,
+					      cairo_user_scaled_font_text_to_glyphs_func_t  text_to_glyphs_func);
+
+cairo_public void
+cairo_user_font_face_set_unicode_to_glyph_func (cairo_font_face_t                              *font_face,
+					        cairo_user_scaled_font_unicode_to_glyph_func_t  unicode_to_glyph_func);
+
+/* User-font method getters */
+
+cairo_public cairo_user_scaled_font_init_func_t
+cairo_user_font_face_get_init_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_render_glyph_func_t
+cairo_user_font_face_get_render_glyph_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_text_to_glyphs_func_t
+cairo_user_font_face_get_text_to_glyphs_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_unicode_to_glyph_func_t
+cairo_user_font_face_get_unicode_to_glyph_func (cairo_font_face_t *font_face);
+
+
+/* Query functions */
+
+cairo_public cairo_operator_t
+cairo_get_operator (cairo_t *cr);
+
+cairo_public cairo_pattern_t *
+cairo_get_source (cairo_t *cr);
+
+cairo_public double
+cairo_get_tolerance (cairo_t *cr);
+
+cairo_public cairo_antialias_t
+cairo_get_antialias (cairo_t *cr);
+
+cairo_public cairo_bool_t
+cairo_has_current_point (cairo_t *cr);
+
+cairo_public void
+cairo_get_current_point (cairo_t *cr, double *x, double *y);
+
+cairo_public cairo_fill_rule_t
+cairo_get_fill_rule (cairo_t *cr);
+
+cairo_public double
+cairo_get_line_width (cairo_t *cr);
+
+cairo_public cairo_line_cap_t
+cairo_get_line_cap (cairo_t *cr);
+
+cairo_public cairo_line_join_t
+cairo_get_line_join (cairo_t *cr);
+
+cairo_public double
+cairo_get_miter_limit (cairo_t *cr);
+
+cairo_public int
+cairo_get_dash_count (cairo_t *cr);
+
+cairo_public void
+cairo_get_dash (cairo_t *cr, double *dashes, double *offset);
+
+cairo_public void
+cairo_get_matrix (cairo_t *cr, cairo_matrix_t *matrix);
+
+cairo_public cairo_surface_t *
+cairo_get_target (cairo_t *cr);
+
+cairo_public cairo_surface_t *
+cairo_get_group_target (cairo_t *cr);
+
+/**
+ * cairo_path_data_type_t:
+ * @CAIRO_PATH_MOVE_TO: A move-to operation
+ * @CAIRO_PATH_LINE_TO: A line-to operation
+ * @CAIRO_PATH_CURVE_TO: A curve-to operation
+ * @CAIRO_PATH_CLOSE_PATH: A close-path operation
+ *
+ * #cairo_path_data_t is used to describe the type of one portion
+ * of a path when represented as a #cairo_path_t.
+ * See #cairo_path_data_t for details.
+ **/
+typedef enum _cairo_path_data_type {
+    CAIRO_PATH_MOVE_TO,
+    CAIRO_PATH_LINE_TO,
+    CAIRO_PATH_CURVE_TO,
+    CAIRO_PATH_CLOSE_PATH
+} cairo_path_data_type_t;
+
+/**
+ * cairo_path_data_t:
+ *
+ * #cairo_path_data_t is used to represent the path data inside a
+ * #cairo_path_t.
+ *
+ * The data structure is designed to try to balance the demands of
+ * efficiency and ease-of-use. A path is represented as an array of
+ * #cairo_path_data_t, which is a union of headers and points.
+ *
+ * Each portion of the path is represented by one or more elements in
+ * the array, (one header followed by 0 or more points). The length
+ * value of the header is the number of array elements for the current
+ * portion including the header, (ie. length == 1 + # of points), and
+ * where the number of points for each element type is as follows:
+ *
+ * <programlisting>
+ *     %CAIRO_PATH_MOVE_TO:     1 point
+ *     %CAIRO_PATH_LINE_TO:     1 point
+ *     %CAIRO_PATH_CURVE_TO:    3 points
+ *     %CAIRO_PATH_CLOSE_PATH:  0 points
+ * </programlisting>
+ *
+ * The semantics and ordering of the coordinate values are consistent
+ * with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
+ * cairo_close_path().
+ *
+ * Here is sample code for iterating through a #cairo_path_t:
+ *
+ * <informalexample><programlisting>
+ *      int i;
+ *      cairo_path_t *path;
+ *      cairo_path_data_t *data;
+ * &nbsp;
+ *      path = cairo_copy_path (cr);
+ * &nbsp;
+ *      for (i=0; i < path->num_data; i += path->data[i].header.length) {
+ *          data = &amp;path->data[i];
+ *          switch (data->header.type) {
+ *          case CAIRO_PATH_MOVE_TO:
+ *              do_move_to_things (data[1].point.x, data[1].point.y);
+ *              break;
+ *          case CAIRO_PATH_LINE_TO:
+ *              do_line_to_things (data[1].point.x, data[1].point.y);
+ *              break;
+ *          case CAIRO_PATH_CURVE_TO:
+ *              do_curve_to_things (data[1].point.x, data[1].point.y,
+ *                                  data[2].point.x, data[2].point.y,
+ *                                  data[3].point.x, data[3].point.y);
+ *              break;
+ *          case CAIRO_PATH_CLOSE_PATH:
+ *              do_close_path_things ();
+ *              break;
+ *          }
+ *      }
+ *      cairo_path_destroy (path);
+ * </programlisting></informalexample>
+ *
+ * As of cairo 1.4, cairo does not mind if there are more elements in
+ * a portion of the path than needed.  Such elements can be used by
+ * users of the cairo API to hold extra values in the path data
+ * structure.  For this reason, it is recommended that applications
+ * always use <literal>data->header.length</literal> to
+ * iterate over the path data, instead of hardcoding the number of
+ * elements for each element type.
+ **/
+typedef union _cairo_path_data_t cairo_path_data_t;
+union _cairo_path_data_t {
+    struct {
+	cairo_path_data_type_t type;
+	int length;
+    } header;
+    struct {
+	double x, y;
+    } point;
+};
+
+/**
+ * cairo_path_t:
+ * @status: the current error status
+ * @data: the elements in the path
+ * @num_data: the number of elements in the data array
+ *
+ * A data structure for holding a path. This data structure serves as
+ * the return value for cairo_copy_path() and
+ * cairo_copy_path_flat() as well the input value for
+ * cairo_append_path().
+ *
+ * See #cairo_path_data_t for hints on how to iterate over the
+ * actual data within the path.
+ *
+ * The num_data member gives the number of elements in the data
+ * array. This number is larger than the number of independent path
+ * portions (defined in #cairo_path_data_type_t), since the data
+ * includes both headers and coordinates for each portion.
+ **/
+typedef struct cairo_path {
+    cairo_status_t status;
+    cairo_path_data_t *data;
+    int num_data;
+} cairo_path_t;
+
+cairo_public cairo_path_t *
+cairo_copy_path (cairo_t *cr);
+
+cairo_public cairo_path_t *
+cairo_copy_path_flat (cairo_t *cr);
+
+cairo_public void
+cairo_append_path (cairo_t		*cr,
+		   const cairo_path_t	*path);
+
+cairo_public void
+cairo_path_destroy (cairo_path_t *path);
+
+/* Error status queries */
+
+cairo_public cairo_status_t
+cairo_status (cairo_t *cr);
+
+cairo_public const char *
+cairo_status_to_string (cairo_status_t status);
+
+/* Surface manipulation */
+
+cairo_public cairo_surface_t *
+cairo_surface_create_similar (cairo_surface_t  *other,
+			      cairo_content_t	content,
+			      int		width,
+			      int		height);
+
+cairo_public cairo_surface_t *
+cairo_surface_reference (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_finish (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_destroy (cairo_surface_t *surface);
+
+cairo_public unsigned int
+cairo_surface_get_reference_count (cairo_surface_t *surface);
+
+cairo_public cairo_status_t
+cairo_surface_status (cairo_surface_t *surface);
+
+/**
+ * cairo_surface_type_t:
+ * @CAIRO_SURFACE_TYPE_IMAGE: The surface is of type image
+ * @CAIRO_SURFACE_TYPE_PDF: The surface is of type pdf
+ * @CAIRO_SURFACE_TYPE_PS: The surface is of type ps
+ * @CAIRO_SURFACE_TYPE_XLIB: The surface is of type xlib
+ * @CAIRO_SURFACE_TYPE_XCB: The surface is of type xcb
+ * @CAIRO_SURFACE_TYPE_GLITZ: The surface is of type glitz
+ * @CAIRO_SURFACE_TYPE_QUARTZ: The surface is of type quartz
+ * @CAIRO_SURFACE_TYPE_WIN32: The surface is of type win32
+ * @CAIRO_SURFACE_TYPE_BEOS: The surface is of type beos
+ * @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb
+ * @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg
+ * @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2
+ * @CAIRO_SURFACE_TYPE_WIN32_PRINTING: The surface is a win32 printing surface
+ * @CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: The surface is of type quartz_image
+ * @CAIRO_SURFACE_TYPE_SCRIPT: The surface is of type script, since 1.10
+ * @CAIRO_SURFACE_TYPE_QT: The surface is of type Qt, since 1.10
+ * @CAIRO_SURFACE_TYPE_RECORDING: The surface is of type recording, since 1.10
+ * @CAIRO_SURFACE_TYPE_VG: The surface is a OpenVG surface, since 1.10
+ * @CAIRO_SURFACE_TYPE_GL: The surface is of type OpenGL, since 1.10
+ * @CAIRO_SURFACE_TYPE_DRM: The surface is of type Direct Render Manager, since 1.10
+ * @CAIRO_SURFACE_TYPE_TEE: The surface is of type 'tee' (a multiplexing surface), since 1.10
+ * @CAIRO_SURFACE_TYPE_XML: The surface is of type XML (for debugging), since 1.10
+ * @CAIRO_SURFACE_TYPE_SKIA: The surface is of type Skia, since 1.10
+ *
+ * #cairo_surface_type_t is used to describe the type of a given
+ * surface. The surface types are also known as "backends" or "surface
+ * backends" within cairo.
+ *
+ * The type of a surface is determined by the function used to create
+ * it, which will generally be of the form cairo_<emphasis>type</emphasis>_surface_create(),
+ * (though see cairo_surface_create_similar() as well).
+ *
+ * The surface type can be queried with cairo_surface_get_type()
+ *
+ * The various #cairo_surface_t functions can be used with surfaces of
+ * any type, but some backends also provide type-specific functions
+ * that must only be called with a surface of the appropriate
+ * type. These functions have names that begin with
+ * cairo_<emphasis>type</emphasis>_surface<!-- --> such as cairo_image_surface_get_width().
+ *
+ * The behavior of calling a type-specific function with a surface of
+ * the wrong type is undefined.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_surface_type {
+    CAIRO_SURFACE_TYPE_IMAGE,
+    CAIRO_SURFACE_TYPE_PDF,
+    CAIRO_SURFACE_TYPE_PS,
+    CAIRO_SURFACE_TYPE_XLIB,
+    CAIRO_SURFACE_TYPE_XCB,
+    CAIRO_SURFACE_TYPE_GLITZ,
+    CAIRO_SURFACE_TYPE_QUARTZ,
+    CAIRO_SURFACE_TYPE_WIN32,
+    CAIRO_SURFACE_TYPE_BEOS,
+    CAIRO_SURFACE_TYPE_DIRECTFB,
+    CAIRO_SURFACE_TYPE_SVG,
+    CAIRO_SURFACE_TYPE_OS2,
+    CAIRO_SURFACE_TYPE_WIN32_PRINTING,
+    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE,
+    CAIRO_SURFACE_TYPE_SCRIPT,
+    CAIRO_SURFACE_TYPE_QT,
+    CAIRO_SURFACE_TYPE_RECORDING,
+    CAIRO_SURFACE_TYPE_VG,
+    CAIRO_SURFACE_TYPE_GL,
+    CAIRO_SURFACE_TYPE_DRM,
+    CAIRO_SURFACE_TYPE_TEE,
+    CAIRO_SURFACE_TYPE_XML,
+    CAIRO_SURFACE_TYPE_SKIA
+} cairo_surface_type_t;
+
+cairo_public cairo_surface_type_t
+cairo_surface_get_type (cairo_surface_t *surface);
+
+cairo_public cairo_content_t
+cairo_surface_get_content (cairo_surface_t *surface);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+cairo_public cairo_status_t
+cairo_surface_write_to_png (cairo_surface_t	*surface,
+			    const char		*filename);
+
+cairo_public cairo_status_t
+cairo_surface_write_to_png_stream (cairo_surface_t	*surface,
+				   cairo_write_func_t	write_func,
+				   void			*closure);
+
+#endif
+
+cairo_public void *
+cairo_surface_get_user_data (cairo_surface_t		 *surface,
+			     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_surface_set_user_data (cairo_surface_t		 *surface,
+			     const cairo_user_data_key_t *key,
+			     void			 *user_data,
+			     cairo_destroy_func_t	 destroy);
+
+#define CAIRO_MIME_TYPE_JPEG "image/jpeg"
+#define CAIRO_MIME_TYPE_PNG "image/png"
+#define CAIRO_MIME_TYPE_JP2 "image/jp2"
+
+cairo_public void
+cairo_surface_get_mime_data (cairo_surface_t		*surface,
+                             const char			*mime_type,
+                             const unsigned char       **data,
+                             unsigned int		*length);
+
+cairo_public cairo_status_t
+cairo_surface_set_mime_data (cairo_surface_t		*surface,
+                             const char			*mime_type,
+                             const unsigned char	*data,
+                             unsigned int		 length,
+			     cairo_destroy_func_t	 destroy,
+			     void			*closure);
+
+cairo_public void
+cairo_surface_get_font_options (cairo_surface_t      *surface,
+				cairo_font_options_t *options);
+
+cairo_public void
+cairo_surface_flush (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_mark_dirty (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface,
+				    int              x,
+				    int              y,
+				    int              width,
+				    int              height);
+
+cairo_public void
+cairo_surface_set_device_offset (cairo_surface_t *surface,
+				 double           x_offset,
+				 double           y_offset);
+
+cairo_public void
+cairo_surface_get_device_offset (cairo_surface_t *surface,
+				 double          *x_offset,
+				 double          *y_offset);
+
+cairo_public void
+cairo_surface_set_fallback_resolution (cairo_surface_t	*surface,
+				       double		 x_pixels_per_inch,
+				       double		 y_pixels_per_inch);
+
+cairo_public void
+cairo_surface_get_fallback_resolution (cairo_surface_t	*surface,
+				       double		*x_pixels_per_inch,
+				       double		*y_pixels_per_inch);
+
+cairo_public void
+cairo_surface_copy_page (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_show_page (cairo_surface_t *surface);
+
+cairo_public cairo_bool_t
+cairo_surface_has_show_text_glyphs (cairo_surface_t *surface);
+
+/* Image-surface functions */
+
+/**
+ * cairo_format_t:
+ * @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with
+ *   alpha in the upper 8 bits, then red, then green, then blue.
+ *   The 32-bit quantities are stored native-endian. Pre-multiplied
+ *   alpha is used. (That is, 50% transparent red is 0x80800000,
+ *   not 0x80ff0000.)
+ * @CAIRO_FORMAT_RGB24: each pixel is a 32-bit quantity, with
+ *   the upper 8 bits unused. Red, Green, and Blue are stored
+ *   in the remaining 24 bits in that order.
+ * @CAIRO_FORMAT_A8: each pixel is a 8-bit quantity holding
+ *   an alpha value.
+ * @CAIRO_FORMAT_A1: each pixel is a 1-bit quantity holding
+ *   an alpha value. Pixels are packed together into 32-bit
+ *   quantities. The ordering of the bits matches the
+ *   endianess of the platform. On a big-endian machine, the
+ *   first pixel is in the uppermost bit, on a little-endian
+ *   machine the first pixel is in the least-significant bit.
+ * @CAIRO_FORMAT_RGB16_565: This format value is deprecated. It has
+ *   never been properly implemented in cairo and should not be used
+ *   by applications. (since 1.2)
+ *
+ * #cairo_format_t is used to identify the memory format of
+ * image data.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_format {
+    CAIRO_FORMAT_ARGB32,
+    CAIRO_FORMAT_RGB24,
+    CAIRO_FORMAT_A8,
+    CAIRO_FORMAT_A1
+    /* The value of 4 is reserved by a deprecated enum value.
+     * The next format added must have an explicit value of 5.
+    CAIRO_FORMAT_RGB16_565 = 4,
+    */
+} cairo_format_t;
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create (cairo_format_t	format,
+			    int			width,
+			    int			height);
+
+cairo_public int
+cairo_format_stride_for_width (cairo_format_t	format,
+			       int		width);
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_for_data (unsigned char	       *data,
+				     cairo_format_t		format,
+				     int			width,
+				     int			height,
+				     int			stride);
+
+cairo_public unsigned char *
+cairo_image_surface_get_data (cairo_surface_t *surface);
+
+cairo_public cairo_format_t
+cairo_image_surface_get_format (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_width (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_height (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_stride (cairo_surface_t *surface);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_from_png (const char	*filename);
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_from_png_stream (cairo_read_func_t	read_func,
+					    void		*closure);
+
+#endif
+
+/* Recording-surface functions */
+
+cairo_public cairo_surface_t *
+cairo_recording_surface_create (cairo_content_t		 content,
+                                const cairo_rectangle_t *extents);
+
+cairo_public void
+cairo_recording_surface_ink_extents (cairo_surface_t *surface,
+                                     double *x0,
+                                     double *y0,
+                                     double *width,
+                                     double *height);
+
+/* Tee-surface functions */
+
+cairo_public cairo_surface_t *
+cairo_tee_surface_create (cairo_surface_t *master);
+
+cairo_public void
+cairo_tee_surface_add (cairo_surface_t *surface,
+		       cairo_surface_t *target);
+
+cairo_public void
+cairo_tee_surface_remove (cairo_surface_t *surface,
+			  cairo_surface_t *target);
+
+cairo_public cairo_surface_t *
+cairo_tee_surface_index (cairo_surface_t *surface,
+			 int index);
+
+/* Pattern creation functions */
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_rgb (double red, double green, double blue);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_rgba (double red, double green, double blue,
+			   double alpha);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_for_surface (cairo_surface_t *surface);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_linear (double x0, double y0,
+			     double x1, double y1);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_radial (double cx0, double cy0, double radius0,
+			     double cx1, double cy1, double radius1);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_reference (cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_pattern_destroy (cairo_pattern_t *pattern);
+
+cairo_public unsigned int
+cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
+
+cairo_public cairo_status_t
+cairo_pattern_status (cairo_pattern_t *pattern);
+
+cairo_public void *
+cairo_pattern_get_user_data (cairo_pattern_t		 *pattern,
+			     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
+			     const cairo_user_data_key_t *key,
+			     void			 *user_data,
+			     cairo_destroy_func_t	  destroy);
+
+/**
+ * cairo_pattern_type_t:
+ * @CAIRO_PATTERN_TYPE_SOLID: The pattern is a solid (uniform)
+ * color. It may be opaque or translucent.
+ * @CAIRO_PATTERN_TYPE_SURFACE: The pattern is a based on a surface (an image).
+ * @CAIRO_PATTERN_TYPE_LINEAR: The pattern is a linear gradient.
+ * @CAIRO_PATTERN_TYPE_RADIAL: The pattern is a radial gradient.
+ *
+ * #cairo_pattern_type_t is used to describe the type of a given pattern.
+ *
+ * The type of a pattern is determined by the function used to create
+ * it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
+ * functions create SOLID patterns. The remaining
+ * cairo_pattern_create<!-- --> functions map to pattern types in obvious
+ * ways.
+ *
+ * The pattern type can be queried with cairo_pattern_get_type()
+ *
+ * Most #cairo_pattern_t functions can be called with a pattern of any
+ * type, (though trying to change the extend or filter for a solid
+ * pattern will have no effect). A notable exception is
+ * cairo_pattern_add_color_stop_rgb() and
+ * cairo_pattern_add_color_stop_rgba() which must only be called with
+ * gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
+ * will be shutdown and put into an error state.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_pattern_type {
+    CAIRO_PATTERN_TYPE_SOLID,
+    CAIRO_PATTERN_TYPE_SURFACE,
+    CAIRO_PATTERN_TYPE_LINEAR,
+    CAIRO_PATTERN_TYPE_RADIAL
+} cairo_pattern_type_t;
+
+cairo_public cairo_pattern_type_t
+cairo_pattern_get_type (cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_pattern_add_color_stop_rgb (cairo_pattern_t *pattern,
+				  double offset,
+				  double red, double green, double blue);
+
+cairo_public void
+cairo_pattern_add_color_stop_rgba (cairo_pattern_t *pattern,
+				   double offset,
+				   double red, double green, double blue,
+				   double alpha);
+
+cairo_public void
+cairo_pattern_set_matrix (cairo_pattern_t      *pattern,
+			  const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_pattern_get_matrix (cairo_pattern_t *pattern,
+			  cairo_matrix_t  *matrix);
+
+/**
+ * cairo_extend_t:
+ * @CAIRO_EXTEND_NONE: pixels outside of the source pattern
+ *   are fully transparent
+ * @CAIRO_EXTEND_REPEAT: the pattern is tiled by repeating
+ * @CAIRO_EXTEND_REFLECT: the pattern is tiled by reflecting
+ *   at the edges (Implemented for surface patterns since 1.6)
+ * @CAIRO_EXTEND_PAD: pixels outside of the pattern copy
+ *   the closest pixel from the source (Since 1.2; but only
+ *   implemented for surface patterns since 1.6)
+ *
+ * #cairo_extend_t is used to describe how pattern color/alpha will be
+ * determined for areas "outside" the pattern's natural area, (for
+ * example, outside the surface bounds or outside the gradient
+ * geometry).
+ *
+ * The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
+ * and %CAIRO_EXTEND_PAD for gradient patterns.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_extend {
+    CAIRO_EXTEND_NONE,
+    CAIRO_EXTEND_REPEAT,
+    CAIRO_EXTEND_REFLECT,
+    CAIRO_EXTEND_PAD
+} cairo_extend_t;
+
+cairo_public void
+cairo_pattern_set_extend (cairo_pattern_t *pattern, cairo_extend_t extend);
+
+cairo_public cairo_extend_t
+cairo_pattern_get_extend (cairo_pattern_t *pattern);
+
+/**
+ * cairo_filter_t:
+ * @CAIRO_FILTER_FAST: A high-performance filter, with quality similar
+ *     to %CAIRO_FILTER_NEAREST
+ * @CAIRO_FILTER_GOOD: A reasonable-performance filter, with quality
+ *     similar to %CAIRO_FILTER_BILINEAR
+ * @CAIRO_FILTER_BEST: The highest-quality available, performance may
+ *     not be suitable for interactive use.
+ * @CAIRO_FILTER_NEAREST: Nearest-neighbor filtering
+ * @CAIRO_FILTER_BILINEAR: Linear interpolation in two dimensions
+ * @CAIRO_FILTER_GAUSSIAN: This filter value is currently
+ *     unimplemented, and should not be used in current code.
+ *
+ * #cairo_filter_t is used to indicate what filtering should be
+ * applied when reading pixel values from patterns. See
+ * cairo_pattern_set_source() for indicating the desired filter to be
+ * used with a particular pattern.
+ */
+typedef enum _cairo_filter {
+    CAIRO_FILTER_FAST,
+    CAIRO_FILTER_GOOD,
+    CAIRO_FILTER_BEST,
+    CAIRO_FILTER_NEAREST,
+    CAIRO_FILTER_BILINEAR,
+    CAIRO_FILTER_GAUSSIAN
+} cairo_filter_t;
+
+cairo_public void
+cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
+
+cairo_public cairo_filter_t
+cairo_pattern_get_filter (cairo_pattern_t *pattern);
+
+cairo_public cairo_status_t
+cairo_pattern_get_rgba (cairo_pattern_t *pattern,
+			double *red, double *green,
+			double *blue, double *alpha);
+
+cairo_public cairo_status_t
+cairo_pattern_get_surface (cairo_pattern_t *pattern,
+			   cairo_surface_t **surface);
+
+
+cairo_public cairo_status_t
+cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
+				   int index, double *offset,
+				   double *red, double *green,
+				   double *blue, double *alpha);
+
+cairo_public cairo_status_t
+cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
+				    int *count);
+
+cairo_public cairo_status_t
+cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
+				 double *x0, double *y0,
+				 double *x1, double *y1);
+
+cairo_public cairo_status_t
+cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
+				  double *x0, double *y0, double *r0,
+				  double *x1, double *y1, double *r1);
+
+/* Matrix functions */
+
+cairo_public void
+cairo_matrix_init (cairo_matrix_t *matrix,
+		   double  xx, double  yx,
+		   double  xy, double  yy,
+		   double  x0, double  y0);
+
+cairo_public void
+cairo_matrix_init_identity (cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_matrix_init_translate (cairo_matrix_t *matrix,
+			     double tx, double ty);
+
+cairo_public void
+cairo_matrix_init_scale (cairo_matrix_t *matrix,
+			 double sx, double sy);
+
+cairo_public void
+cairo_matrix_init_rotate (cairo_matrix_t *matrix,
+			  double radians);
+
+cairo_public void
+cairo_matrix_translate (cairo_matrix_t *matrix, double tx, double ty);
+
+cairo_public void
+cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
+
+cairo_public void
+cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
+
+cairo_public cairo_status_t
+cairo_matrix_invert (cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_matrix_multiply (cairo_matrix_t	    *result,
+		       const cairo_matrix_t *a,
+		       const cairo_matrix_t *b);
+
+cairo_public void
+cairo_matrix_transform_distance (const cairo_matrix_t *matrix,
+				 double *dx, double *dy);
+
+cairo_public void
+cairo_matrix_transform_point (const cairo_matrix_t *matrix,
+			      double *x, double *y);
+
+/* Region functions */
+
+typedef struct _cairo_region cairo_region_t;
+
+typedef struct _cairo_rectangle_int {
+    int x, y;
+    int width, height;
+} cairo_rectangle_int_t;
+
+typedef enum _cairo_region_overlap {
+    CAIRO_REGION_OVERLAP_IN,		/* completely inside region */
+    CAIRO_REGION_OVERLAP_OUT,		/* completely outside region */
+    CAIRO_REGION_OVERLAP_PART		/* partly inside region */
+} cairo_region_overlap_t;
+
+cairo_public cairo_region_t *
+cairo_region_create (void);
+
+cairo_public cairo_region_t *
+cairo_region_create_rectangle (const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_region_t *
+cairo_region_create_rectangles (const cairo_rectangle_int_t *rects,
+				int count);
+
+cairo_public cairo_region_t *
+cairo_region_copy (const cairo_region_t *original);
+
+cairo_public cairo_region_t *
+cairo_region_reference (cairo_region_t *);
+
+cairo_public void
+cairo_region_destroy (cairo_region_t *region);
+
+cairo_public cairo_bool_t
+cairo_region_equal (const cairo_region_t *a, const cairo_region_t *b);
+
+cairo_public cairo_status_t
+cairo_region_status (const cairo_region_t *region);
+
+cairo_public void
+cairo_region_get_extents (const cairo_region_t        *region,
+			  cairo_rectangle_int_t *extents);
+
+cairo_public int
+cairo_region_num_rectangles (const cairo_region_t *region);
+
+cairo_public void
+cairo_region_get_rectangle (const cairo_region_t        *region,
+			    int                    nth_rectangle,
+			    cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_bool_t
+cairo_region_is_empty (const cairo_region_t *region);
+
+cairo_public cairo_region_overlap_t
+cairo_region_contains_rectangle (const cairo_region_t *region,
+				 const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_bool_t
+cairo_region_contains_point (const cairo_region_t *region, int x, int y);
+
+cairo_public void
+cairo_region_translate (cairo_region_t *region, int dx, int dy);
+
+cairo_public cairo_status_t
+cairo_region_subtract (cairo_region_t *dst, const cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_subtract_rectangle (cairo_region_t *dst,
+				 const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_status_t
+cairo_region_intersect (cairo_region_t *dst, cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_intersect_rectangle (cairo_region_t *dst,
+				  const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_status_t
+cairo_region_union (cairo_region_t *dst, cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_union_rectangle (cairo_region_t *dst,
+			      const cairo_rectangle_int_t *rectangle);
+
+
+/* Functions to be used while debugging (not intended for use in production code) */
+cairo_public void
+cairo_debug_reset_static_data (void);
+
+
+CAIRO_END_DECLS
+
+#endif /* CAIRO_H */
diff --git a/src/cairo/cairoint.h b/src/cairo/cairoint.h
new file mode 100644
index 0000000..a9207a1
--- /dev/null
+++ b/src/cairo/cairoint.h
@@ -0,0 +1,2774 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+/*
+ * These definitions are solely for use by the implementation of cairo
+ * and constitute no kind of standard.  If you need any of these
+ * functions, please drop me a note.  Either the library needs new
+ * functionality, or there's a way to do what you need using the
+ * existing published interfaces. cworth@cworth.org
+ */
+
+#ifndef _CAIROINT_H_
+#define _CAIROINT_H_
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define cairo_public __declspec(dllexport)
+#endif
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+
+#ifdef _MSC_VER
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+#include "cairo.h"
+#include <pixman.h>
+
+#include "cairo-compiler-private.h"
+
+#if CAIRO_HAS_PS_SURFACE  || \
+    CAIRO_HAS_PDF_SURFACE || \
+    CAIRO_HAS_SVG_SURFACE || \
+    CAIRO_HAS_WIN32_SURFACE
+#define CAIRO_HAS_FONT_SUBSET 1
+#endif
+
+#if CAIRO_HAS_PS_SURFACE || CAIRO_HAS_PDF_SURFACE || CAIRO_HAS_FONT_SUBSET
+#define CAIRO_HAS_PDF_OPERATORS 1
+#endif
+
+CAIRO_BEGIN_DECLS
+
+#if _WIN32 && !_WIN32_WCE /* Permissions on WinCE? No worries! */
+cairo_private FILE *
+_cairo_win32_tmpfile (void);
+#define tmpfile() _cairo_win32_tmpfile()
+#endif
+
+#undef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#undef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2 1.41421356237309504880
+#endif
+
+#ifndef M_SQRT1_2
+#define M_SQRT1_2 0.707106781186547524400844362104849039
+#endif
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((int) (sizeof (__array) / sizeof (__array[0])))
+
+#undef STRINGIFY
+#undef STRINGIFY_ARG
+#define STRINGIFY(macro_or_string)    STRINGIFY_ARG (macro_or_string)
+#define STRINGIFY_ARG(contents)       #contents
+
+#if defined (__GNUC__)
+#define cairo_container_of(ptr, type, member) ({ \
+    const __typeof__ (((type *) 0)->member) *mptr__ = (ptr); \
+    (type *) ((char *) mptr__ - offsetof (type, member)); \
+})
+#else
+#define cairo_container_of(ptr, type, member) \
+    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
+#endif
+
+
+/* Size in bytes of buffer to use off the stack per functions.
+ * Mostly used by text functions.  For larger allocations, they'll
+ * malloc(). */
+#ifndef CAIRO_STACK_BUFFER_SIZE
+#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
+#endif
+
+#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
+
+#define ASSERT_NOT_REACHED		\
+do {					\
+    static const int NOT_REACHED = 0;	\
+    assert (NOT_REACHED);		\
+} while (0)
+#define COMPILE_TIME_ASSERT1(condition, line)		\
+    typedef int compile_time_assertion_at_line_##line##_failed [(condition)?1:-1]
+#define COMPILE_TIME_ASSERT0(condition, line)	COMPILE_TIME_ASSERT1(condition, line)
+#define COMPILE_TIME_ASSERT(condition)		COMPILE_TIME_ASSERT0(condition, __LINE__)
+
+#define CAIRO_ALPHA_IS_OPAQUE(alpha) ((alpha) >= ((double)0xff00 / (double)0xffff))
+#define CAIRO_ALPHA_SHORT_IS_OPAQUE(alpha) ((alpha) >= 0xff00)
+#define CAIRO_ALPHA_IS_ZERO(alpha) ((alpha) <= 0.0)
+
+#define CAIRO_COLOR_IS_OPAQUE(color) CAIRO_ALPHA_SHORT_IS_OPAQUE ((color)->alpha_short)
+
+/* Reverse the bits in a byte with 7 operations (no 64-bit):
+ * Devised by Sean Anderson, July 13, 2001.
+ * Source: http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits
+ */
+#define CAIRO_BITSWAP8(c) ((((c) * 0x0802LU & 0x22110LU) | ((c) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)
+
+/* Return the number of 1 bits in mask.
+ *
+ * GCC 3.4 supports a "population count" builtin, which on many targets is
+ * implemented with a single instruction. There is a fallback definition
+ * in libgcc in case a target does not have one, which should be just as
+ * good as the open-coded solution below, (which is "HACKMEM 169").
+ */
+static inline int cairo_const
+_cairo_popcount (uint32_t mask)
+{
+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+    return __builtin_popcount (mask);
+#else
+    register int y;
+
+    y = (mask >> 1) &033333333333;
+    y = mask - y - ((y >>1) & 033333333333);
+    return (((y + (y >> 3)) & 030707070707) % 077);
+#endif
+}
+
+#ifdef WORDS_BIGENDIAN
+#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) (c)
+#else
+#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
+#endif
+
+#ifdef WORDS_BIGENDIAN
+
+#define cpu_to_be16(v) (v)
+#define be16_to_cpu(v) (v)
+#define cpu_to_be32(v) (v)
+#define be32_to_cpu(v) (v)
+
+#else
+
+static inline uint16_t cairo_const
+cpu_to_be16(uint16_t v)
+{
+    return (v << 8) | (v >> 8);
+}
+
+static inline uint16_t cairo_const
+be16_to_cpu(uint16_t v)
+{
+    return cpu_to_be16 (v);
+}
+
+static inline uint32_t cairo_const
+cpu_to_be32(uint32_t v)
+{
+    return (cpu_to_be16 (v) << 16) | cpu_to_be16 (v >> 16);
+}
+
+static inline uint32_t cairo_const
+be32_to_cpu(uint32_t v)
+{
+    return cpu_to_be32 (v);
+}
+
+#endif
+
+#include "cairo-types-private.h"
+#include "cairo-cache-private.h"
+#include "cairo-reference-count-private.h"
+#include "cairo-spans-private.h"
+
+cairo_private void
+_cairo_box_from_doubles (cairo_box_t *box,
+			 double *x1, double *y1,
+			 double *x2, double *y2);
+
+cairo_private void
+_cairo_box_to_doubles (const cairo_box_t *box,
+		       double *x1, double *y1,
+		       double *x2, double *y2);
+
+cairo_private void
+_cairo_box_from_rectangle (cairo_box_t                 *box,
+			   const cairo_rectangle_int_t *rectangle);
+
+cairo_private void
+_cairo_box_round_to_rectangle (const cairo_box_t     *box,
+			       cairo_rectangle_int_t *rectangle);
+
+cairo_private void
+_cairo_boxes_get_extents (const cairo_box_t *boxes,
+			  int num_boxes,
+			  cairo_box_t *extents);
+
+static inline void
+_cairo_unbounded_rectangle_init (cairo_rectangle_int_t *rect)
+{
+    rect->x = CAIRO_RECT_INT_MIN;
+    rect->y = CAIRO_RECT_INT_MIN;
+    rect->width = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
+    rect->height = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
+}
+
+cairo_private cairo_bool_t
+_cairo_rectangle_intersect (cairo_rectangle_int_t *dst,
+			    const cairo_rectangle_int_t *src);
+
+cairo_private cairo_bool_t
+_cairo_box_intersects_line_segment (cairo_box_t *box,
+	                            cairo_line_t *line) cairo_pure;
+
+cairo_private cairo_bool_t
+_cairo_box_contains_point (cairo_box_t *box,
+	                   const cairo_point_t *point) cairo_pure;
+
+cairo_private void
+_cairo_composite_rectangles_init (cairo_composite_rectangles_t	*rects,
+                                  int				 all_x,
+                                  int				 all_y,
+                                  int				 width,
+                                  int				 height);
+
+/* cairo-array.c structures and functions */
+
+cairo_private void
+_cairo_array_init (cairo_array_t *array, int element_size);
+
+cairo_private void
+_cairo_array_init_snapshot (cairo_array_t	*array,
+			    const cairo_array_t *other);
+
+cairo_private void
+_cairo_array_fini (cairo_array_t *array);
+
+cairo_private cairo_status_t
+_cairo_array_grow_by (cairo_array_t *array, unsigned int additional);
+
+cairo_private void
+_cairo_array_truncate (cairo_array_t *array, unsigned int num_elements);
+
+cairo_private cairo_status_t
+_cairo_array_append (cairo_array_t *array, const void *element);
+
+cairo_private cairo_status_t
+_cairo_array_append_multiple (cairo_array_t	*array,
+			      const void	*elements,
+			      int		 num_elements);
+
+cairo_private cairo_status_t
+_cairo_array_allocate (cairo_array_t	 *array,
+		       unsigned int	  num_elements,
+		       void		**elements);
+
+cairo_private void *
+_cairo_array_index (cairo_array_t *array, unsigned int index);
+
+cairo_private void
+_cairo_array_copy_element (cairo_array_t *array, int index, void *dst);
+
+cairo_private int
+_cairo_array_num_elements (cairo_array_t *array);
+
+cairo_private int
+_cairo_array_size (cairo_array_t *array);
+
+typedef struct {
+    const cairo_user_data_key_t *key;
+    void *user_data;
+    cairo_destroy_func_t destroy;
+} cairo_user_data_slot_t;
+
+cairo_private void
+_cairo_user_data_array_init (cairo_user_data_array_t *array);
+
+cairo_private void
+_cairo_user_data_array_fini (cairo_user_data_array_t *array);
+
+cairo_private void *
+_cairo_user_data_array_get_data (cairo_user_data_array_t     *array,
+				 const cairo_user_data_key_t *key);
+
+cairo_private cairo_status_t
+_cairo_user_data_array_set_data (cairo_user_data_array_t     *array,
+				 const cairo_user_data_key_t *key,
+				 void			     *user_data,
+				 cairo_destroy_func_t	      destroy);
+
+cairo_private cairo_status_t
+_cairo_user_data_array_copy (cairo_user_data_array_t	*dst,
+			     cairo_user_data_array_t	*src);
+
+cairo_private void
+_cairo_user_data_array_foreach (cairo_user_data_array_t     *array,
+				void (*func) (const void *key,
+					      void *elt,
+					      void *closure),
+				void *closure);
+
+#define _CAIRO_HASH_INIT_VALUE 5381
+
+cairo_private unsigned long
+_cairo_hash_string (const char *c);
+
+cairo_private unsigned long
+_cairo_hash_bytes (unsigned long hash,
+		   const void *bytes,
+		   unsigned int length);
+
+/*
+ * A #cairo_unscaled_font_t is just an opaque handle we use in the
+ * glyph cache.
+ */
+typedef struct _cairo_unscaled_font {
+    cairo_hash_entry_t			 hash_entry;
+    cairo_reference_count_t		 ref_count;
+    const cairo_unscaled_font_backend_t	*backend;
+} cairo_unscaled_font_t;
+
+typedef struct _cairo_scaled_glyph {
+    cairo_hash_entry_t hash_entry;
+
+    cairo_text_extents_t    metrics;		/* user-space metrics */
+    cairo_text_extents_t    fs_metrics;		/* font-space metrics */
+    cairo_box_t		    bbox;		/* device-space bounds */
+    int16_t                 x_advance;		/* device-space rounded X advance */
+    int16_t                 y_advance;		/* device-space rounded Y advance */
+
+    cairo_image_surface_t   *surface;		/* device-space image */
+    cairo_path_fixed_t	    *path;		/* device-space outline */
+    cairo_surface_t         *recording_surface;	/* device-space recording-surface */
+
+    void		    *surface_private;	/* for the surface backend */
+} cairo_scaled_glyph_t;
+
+#define _cairo_scaled_glyph_index(g) ((g)->hash_entry.hash)
+#define _cairo_scaled_glyph_set_index(g, i)  ((g)->hash_entry.hash = (i))
+
+#include "cairo-scaled-font-private.h"
+
+struct _cairo_font_face {
+    /* hash_entry must be first */
+    cairo_hash_entry_t hash_entry;
+    cairo_status_t status;
+    cairo_reference_count_t ref_count;
+    cairo_user_data_array_t user_data;
+    const cairo_font_face_backend_t *backend;
+};
+
+cairo_private void
+_cairo_toy_font_face_reset_static_data (void);
+
+cairo_private void
+_cairo_ft_font_reset_static_data (void);
+
+/* the font backend interface */
+
+struct _cairo_unscaled_font_backend {
+    void (*destroy)     	    (void		             *unscaled_font);
+};
+
+/* #cairo_toy_font_face_t - simple family/slant/weight font faces used for
+ * the built-in font API
+ */
+
+typedef struct _cairo_toy_font_face {
+    cairo_font_face_t base;
+    const char *family;
+    cairo_bool_t owns_family;
+    cairo_font_slant_t slant;
+    cairo_font_weight_t weight;
+
+    cairo_font_face_t *impl_face; /* The non-toy font face this actually uses */
+} cairo_toy_font_face_t;
+
+typedef enum _cairo_scaled_glyph_info {
+    CAIRO_SCALED_GLYPH_INFO_METRICS	 = (1 << 0),
+    CAIRO_SCALED_GLYPH_INFO_SURFACE	 = (1 << 1),
+    CAIRO_SCALED_GLYPH_INFO_PATH	 = (1 << 2),
+    CAIRO_SCALED_GLYPH_INFO_RECORDING_SURFACE = (1 << 3)
+} cairo_scaled_glyph_info_t;
+
+typedef struct _cairo_scaled_font_subset {
+    cairo_scaled_font_t *scaled_font;
+    unsigned int font_id;
+    unsigned int subset_id;
+
+    /* Index of glyphs array is subset_glyph_index.
+     * Value of glyphs array is scaled_font_glyph_index.
+     */
+    unsigned long *glyphs;
+    unsigned long *to_unicode;
+    char          **utf8;
+    char          **glyph_names;
+    unsigned int num_glyphs;
+    cairo_bool_t is_composite;
+    cairo_bool_t is_scaled;
+} cairo_scaled_font_subset_t;
+
+struct _cairo_scaled_font_backend {
+    cairo_font_type_t type;
+
+    void
+    (*fini)		(void			*scaled_font);
+
+    cairo_warn cairo_int_status_t
+    (*scaled_glyph_init)	(void			     *scaled_font,
+				 cairo_scaled_glyph_t	     *scaled_glyph,
+				 cairo_scaled_glyph_info_t    info);
+
+    /* A backend only needs to implement this or ucs4_to_index(), not
+     * both. This allows the backend to do something more sophisticated
+     * then just converting characters one by one.
+     */
+    cairo_warn cairo_int_status_t
+    (*text_to_glyphs) (void                       *scaled_font,
+		       double		           x,
+		       double		           y,
+		       const char	          *utf8,
+		       int		           utf8_len,
+		       cairo_glyph_t	         **glyphs,
+		       int		          *num_glyphs,
+		       cairo_text_cluster_t      **clusters,
+		       int		          *num_clusters,
+		       cairo_text_cluster_flags_t *cluster_flags);
+
+    unsigned long
+    (*ucs4_to_index)		(void			     *scaled_font,
+				 uint32_t		      ucs4);
+    cairo_warn cairo_int_status_t
+    (*show_glyphs)	(void			*scaled_font,
+			 cairo_operator_t	 op,
+			 const cairo_pattern_t	*pattern,
+			 cairo_surface_t	*surface,
+			 int			 source_x,
+			 int			 source_y,
+			 int			 dest_x,
+			 int			 dest_y,
+			 unsigned int		 width,
+			 unsigned int		 height,
+			 cairo_glyph_t		*glyphs,
+			 int			 num_glyphs,
+			 cairo_region_t		*clip_region,
+			 int			*remaining_glyphs);
+
+    cairo_warn cairo_int_status_t
+    (*load_truetype_table)(void		        *scaled_font,
+                           unsigned long         tag,
+                           long                  offset,
+                           unsigned char        *buffer,
+                           unsigned long        *length);
+
+    /* ucs4 is set to -1 if the unicode character could not be found
+     * for the glyph */
+    cairo_warn cairo_int_status_t
+    (*index_to_ucs4)(void                       *scaled_font,
+		     unsigned long               index,
+                     uint32_t                   *ucs4);
+};
+
+struct _cairo_font_face_backend {
+    cairo_font_type_t	type;
+
+    cairo_warn cairo_status_t
+    (*create_for_toy)  (cairo_toy_font_face_t	*toy_face,
+			cairo_font_face_t      **font_face);
+
+    /* The destroy() function is allowed to resurrect the font face
+     * by re-referencing. This is needed for the FreeType backend.
+     */
+    void
+    (*destroy)     (void			*font_face);
+
+    cairo_warn cairo_status_t
+    (*scaled_font_create) (void				*font_face,
+			   const cairo_matrix_t		*font_matrix,
+			   const cairo_matrix_t		*ctm,
+			   const cairo_font_options_t	*options,
+			   cairo_scaled_font_t	       **scaled_font);
+
+    cairo_font_face_t *
+    (*get_implementation) (void				*font_face,
+			   const cairo_matrix_t		*font_matrix,
+			   const cairo_matrix_t		*ctm,
+			   const cairo_font_options_t	*options);
+};
+
+extern const cairo_private struct _cairo_font_face_backend _cairo_user_font_face_backend;
+
+/* concrete font backends */
+#if CAIRO_HAS_FT_FONT
+
+extern const cairo_private struct _cairo_font_face_backend _cairo_ft_font_face_backend;
+
+#endif
+
+#if CAIRO_HAS_WIN32_FONT
+
+extern const cairo_private struct _cairo_font_face_backend _cairo_win32_font_face_backend;
+
+#endif
+
+#if CAIRO_HAS_QUARTZ_FONT
+
+extern const cairo_private struct _cairo_font_face_backend _cairo_quartz_font_face_backend;
+
+#endif
+
+struct _cairo_surface_backend {
+    cairo_surface_type_t type;
+
+    cairo_surface_t *
+    (*create_similar)		(void			*surface,
+				 cairo_content_t	 content,
+				 int			 width,
+				 int			 height);
+
+    cairo_warn cairo_status_t
+    (*finish)			(void			*surface);
+
+    cairo_warn cairo_status_t
+    (*acquire_source_image)	(void                    *abstract_surface,
+				 cairo_image_surface_t  **image_out,
+				 void                   **image_extra);
+
+    void
+    (*release_source_image)	(void                   *abstract_surface,
+				 cairo_image_surface_t  *image,
+				 void                   *image_extra);
+
+    cairo_warn cairo_status_t
+    (*acquire_dest_image)       (void                    *abstract_surface,
+				 cairo_rectangle_int_t   *interest_rect,
+				 cairo_image_surface_t  **image_out,
+				 cairo_rectangle_int_t   *image_rect,
+				 void                   **image_extra);
+
+    void
+    (*release_dest_image)       (void                    *abstract_surface,
+				 cairo_rectangle_int_t   *interest_rect,
+				 cairo_image_surface_t   *image,
+				 cairo_rectangle_int_t   *image_rect,
+				 void                    *image_extra);
+
+    /* Create a new surface (@clone_out) with the following
+     * characteristics:
+     *
+     * 1. It is as compatible as possible with @surface (in terms of
+     *    efficiency)
+     *
+     * 2. It has the same contents as @src within the given rectangle.
+     *
+     * 3. The offset of the similar surface with respect to the original
+     *    surface is returned in the clone_offset vector.
+     *    - if you clone the entire surface, this vector is zero.
+     *    - if you clone (src_x, src_y)x(w, h) the vector is (src_x, src_y);
+     */
+    cairo_warn cairo_status_t
+    (*clone_similar)            (void                   *surface,
+				 cairo_surface_t        *src,
+				 int                     src_x,
+				 int                     src_y,
+				 int                     width,
+				 int                     height,
+				 int                    *clone_offset_x,
+				 int                    *clone_offset_y,
+				 cairo_surface_t       **clone_out);
+
+    /* XXX remove to a separate cairo_surface_compositor_t */
+    /* XXX: dst should be the first argument for consistency */
+    cairo_warn cairo_int_status_t
+    (*composite)		(cairo_operator_t	 op,
+				 const cairo_pattern_t	*src,
+				 const cairo_pattern_t	*mask,
+				 void			*dst,
+				 int			 src_x,
+				 int			 src_y,
+				 int			 mask_x,
+				 int			 mask_y,
+				 int			 dst_x,
+				 int			 dst_y,
+				 unsigned int		 width,
+				 unsigned int		 height,
+				 cairo_region_t		*clip_region);
+
+    cairo_warn cairo_int_status_t
+    (*fill_rectangles)		(void			 *surface,
+				 cairo_operator_t	  op,
+				 const cairo_color_t     *color,
+				 cairo_rectangle_int_t   *rects,
+				 int			  num_rects);
+
+    /* XXX: dst should be the first argument for consistency */
+    cairo_warn cairo_int_status_t
+    (*composite_trapezoids)	(cairo_operator_t	 op,
+				 const cairo_pattern_t	*pattern,
+				 void			*dst,
+				 cairo_antialias_t	 antialias,
+				 int			 src_x,
+				 int			 src_y,
+				 int			 dst_x,
+				 int			 dst_y,
+				 unsigned int		 width,
+				 unsigned int		 height,
+				 cairo_trapezoid_t	*traps,
+				 int			 num_traps,
+				 cairo_region_t		*region);
+
+    cairo_warn cairo_span_renderer_t *
+    (*create_span_renderer)	(cairo_operator_t			 op,
+				 const cairo_pattern_t			*pattern,
+                                 void					*dst,
+                                 cairo_antialias_t			 antialias,
+                                 const cairo_composite_rectangles_t *rects,
+				 cairo_region_t *clip_region);
+
+    cairo_warn cairo_bool_t
+    (*check_span_renderer)	(cairo_operator_t			 op,
+				 const cairo_pattern_t			*pattern,
+                                 void					*dst,
+                                 cairo_antialias_t			 antialias);
+
+    cairo_warn cairo_int_status_t
+    (*copy_page)		(void			*surface);
+
+    cairo_warn cairo_int_status_t
+    (*show_page)		(void			*surface);
+
+    /* Get the extents of the current surface. For many surface types
+     * this will be as simple as { x=0, y=0, width=surface->width,
+     * height=surface->height}.
+     *
+     * If this function is not implemented, or if it returns
+     * FALSE the surface is considered to be
+     * boundless and infinite bounds are used for it.
+     */
+    cairo_warn cairo_bool_t
+    (*get_extents)		(void			 *surface,
+				 cairo_rectangle_int_t   *extents);
+
+    /*
+     * This is an optional entry to let the surface manage its own glyph
+     * resources. If null, render against this surface, using image
+     * surfaces as glyphs.
+     */
+    cairo_warn cairo_int_status_t
+    (*old_show_glyphs)		(cairo_scaled_font_t	        *font,
+				 cairo_operator_t		 op,
+				 const cairo_pattern_t		*pattern,
+				 void				*surface,
+				 int				 source_x,
+				 int				 source_y,
+				 int				 dest_x,
+				 int				 dest_y,
+				 unsigned int			 width,
+				 unsigned int			 height,
+				 cairo_glyph_t			*glyphs,
+				 int				 num_glyphs,
+				 cairo_region_t			*clip_region);
+
+    void
+    (*get_font_options)         (void                  *surface,
+				 cairo_font_options_t  *options);
+
+    cairo_warn cairo_status_t
+    (*flush)                    (void                  *surface);
+
+    cairo_warn cairo_status_t
+    (*mark_dirty_rectangle)     (void                  *surface,
+				 int                    x,
+				 int                    y,
+				 int                    width,
+				 int                    height);
+
+    void
+    (*scaled_font_fini)		(cairo_scaled_font_t   *scaled_font);
+
+    void
+    (*scaled_glyph_fini)	(cairo_scaled_glyph_t	*scaled_glyph,
+				 cairo_scaled_font_t	*scaled_font);
+
+    /* OK, I'm starting over somewhat by defining the 5 top-level
+     * drawing operators for the surface backend here with consistent
+     * naming and argument-order conventions. */
+    cairo_warn cairo_int_status_t
+    (*paint)			(void			*surface,
+				 cairo_operator_t	 op,
+				 const cairo_pattern_t	*source,
+				 cairo_clip_t		*clip);
+
+    cairo_warn cairo_int_status_t
+    (*mask)			(void			*surface,
+				 cairo_operator_t	 op,
+				 const cairo_pattern_t	*source,
+				 const cairo_pattern_t	*mask,
+				 cairo_clip_t		*clip);
+
+    cairo_warn cairo_int_status_t
+    (*stroke)			(void			*surface,
+				 cairo_operator_t	 op,
+				 const cairo_pattern_t	*source,
+				 cairo_path_fixed_t	*path,
+				 cairo_stroke_style_t	*style,
+				 cairo_matrix_t		*ctm,
+				 cairo_matrix_t		*ctm_inverse,
+				 double			 tolerance,
+				 cairo_antialias_t	 antialias,
+				 cairo_clip_t		*clip);
+
+    cairo_warn cairo_int_status_t
+    (*fill)			(void			*surface,
+				 cairo_operator_t	 op,
+				 const cairo_pattern_t	*source,
+				 cairo_path_fixed_t	*path,
+				 cairo_fill_rule_t	 fill_rule,
+				 double			 tolerance,
+				 cairo_antialias_t	 antialias,
+				 cairo_clip_t           *clip);
+
+    cairo_warn cairo_int_status_t
+    (*show_glyphs)		(void			*surface,
+				 cairo_operator_t	 op,
+				 const cairo_pattern_t	*source,
+				 cairo_glyph_t		*glyphs,
+				 int			 num_glyphs,
+				 cairo_scaled_font_t	*scaled_font,
+				 cairo_clip_t           *clip,
+				 int			*remaining_glyphs);
+
+    cairo_surface_t *
+    (*snapshot)			(void			*surface);
+
+    cairo_bool_t
+    (*is_similar)		(void			*surface_a,
+	                         void			*surface_b,
+				 cairo_content_t         content);
+
+    cairo_warn cairo_int_status_t
+    (*fill_stroke)		(void			*surface,
+				 cairo_operator_t	 fill_op,
+				 const cairo_pattern_t	*fill_source,
+				 cairo_fill_rule_t	 fill_rule,
+				 double			 fill_tolerance,
+				 cairo_antialias_t	 fill_antialias,
+				 cairo_path_fixed_t	*path,
+				 cairo_operator_t	 stroke_op,
+				 const cairo_pattern_t	*stroke_source,
+				 cairo_stroke_style_t	*stroke_style,
+				 cairo_matrix_t		*stroke_ctm,
+				 cairo_matrix_t		*stroke_ctm_inverse,
+				 double			 stroke_tolerance,
+				 cairo_antialias_t	 stroke_antialias,
+				 cairo_clip_t		*clip);
+
+    cairo_surface_t *
+    (*create_solid_pattern_surface)
+			        (void			      *surface,
+				 const cairo_solid_pattern_t  *solid_pattern);
+
+    cairo_bool_t
+    (*can_repaint_solid_pattern_surface)
+			        (void			      *surface,
+				 const cairo_solid_pattern_t  *solid_pattern);
+
+    cairo_bool_t
+    (*has_show_text_glyphs)	(void			    *surface);
+
+    cairo_warn cairo_int_status_t
+    (*show_text_glyphs)		(void			    *surface,
+				 cairo_operator_t	     op,
+				 const cairo_pattern_t	    *source,
+				 const char		    *utf8,
+				 int			     utf8_len,
+				 cairo_glyph_t		    *glyphs,
+				 int			     num_glyphs,
+				 const cairo_text_cluster_t *clusters,
+				 int			     num_clusters,
+				 cairo_text_cluster_flags_t  cluster_flags,
+				 cairo_scaled_font_t	    *scaled_font,
+				 cairo_clip_t               *clip);
+};
+
+#include "cairo-surface-private.h"
+
+struct _cairo_image_surface {
+    cairo_surface_t base;
+
+    pixman_format_code_t pixman_format;
+    cairo_format_t format;
+    unsigned char *data;
+
+    int width;
+    int height;
+    int stride;
+    int depth;
+
+    pixman_image_t *pixman_image;
+    cairo_region_t *clip_region;
+
+    unsigned owns_data : 1;
+    unsigned transparency : 2;
+};
+
+extern const cairo_private cairo_surface_backend_t _cairo_image_surface_backend;
+
+#define CAIRO_EXTEND_SURFACE_DEFAULT CAIRO_EXTEND_NONE
+#define CAIRO_EXTEND_GRADIENT_DEFAULT CAIRO_EXTEND_PAD
+#define CAIRO_FILTER_DEFAULT CAIRO_FILTER_GOOD
+
+extern const cairo_private cairo_solid_pattern_t _cairo_pattern_black;
+
+
+typedef struct _cairo_surface_attributes {
+    cairo_matrix_t matrix;
+    cairo_extend_t extend;
+    cairo_filter_t filter;
+    cairo_bool_t has_component_alpha;
+    int		   x_offset;
+    int		   y_offset;
+    void	   *extra;
+} cairo_surface_attributes_t;
+
+typedef struct _cairo_traps {
+    cairo_status_t status;
+
+    const cairo_box_t *limits;
+    int num_limits;
+
+    unsigned int maybe_region : 1; /* hint: 0 implies that it cannot be */
+    unsigned int has_intersections : 1;
+    unsigned int is_rectilinear : 1;
+    unsigned int is_rectangular : 1;
+
+    int num_traps;
+    int traps_size;
+    cairo_trapezoid_t *traps;
+    cairo_trapezoid_t  traps_embedded[16];
+} cairo_traps_t;
+
+#define CAIRO_FONT_SLANT_DEFAULT   CAIRO_FONT_SLANT_NORMAL
+#define CAIRO_FONT_WEIGHT_DEFAULT  CAIRO_FONT_WEIGHT_NORMAL
+
+#define CAIRO_WIN32_FONT_FAMILY_DEFAULT "Arial"
+#define CAIRO_QUARTZ_FONT_FAMILY_DEFAULT  "Helvetica"
+#define CAIRO_FT_FONT_FAMILY_DEFAULT     ""
+#define CAIRO_USER_FONT_FAMILY_DEFAULT     "@cairo:"
+
+#if   CAIRO_HAS_WIN32_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_WIN32_FONT_FAMILY_DEFAULT
+#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_win32_font_face_backend
+
+#elif CAIRO_HAS_QUARTZ_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_QUARTZ_FONT_FAMILY_DEFAULT
+#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_quartz_font_face_backend
+
+#elif CAIRO_HAS_FT_FONT
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
+#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_ft_font_face_backend
+
+#else
+
+#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
+#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_user_font_face_backend
+
+#endif
+
+#define CAIRO_GSTATE_OPERATOR_DEFAULT	CAIRO_OPERATOR_OVER
+#define CAIRO_GSTATE_TOLERANCE_DEFAULT	0.1
+#define CAIRO_GSTATE_FILL_RULE_DEFAULT	CAIRO_FILL_RULE_WINDING
+#define CAIRO_GSTATE_LINE_WIDTH_DEFAULT	2.0
+#define CAIRO_GSTATE_LINE_CAP_DEFAULT	CAIRO_LINE_CAP_BUTT
+#define CAIRO_GSTATE_LINE_JOIN_DEFAULT	CAIRO_LINE_JOIN_MITER
+#define CAIRO_GSTATE_MITER_LIMIT_DEFAULT	10.0
+#define CAIRO_GSTATE_DEFAULT_FONT_SIZE  10.0
+
+#define CAIRO_SURFACE_RESOLUTION_DEFAULT 72.0
+#define CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT 300.0
+
+typedef struct _cairo_stroke_face {
+    cairo_point_t ccw;
+    cairo_point_t point;
+    cairo_point_t cw;
+    cairo_slope_t dev_vector;
+    cairo_point_double_t usr_vector;
+} cairo_stroke_face_t;
+
+/* cairo.c */
+
+static inline double cairo_const
+_cairo_restrict_value (double value, double min, double max)
+{
+    if (value < min)
+	return min;
+    else if (value > max)
+	return max;
+    else
+	return value;
+}
+
+/* C99 round() rounds to the nearest integral value with halfway cases rounded
+ * away from 0. _cairo_round rounds halfway cases toward negative infinity.
+ * This matches the rounding behaviour of _cairo_lround. */
+static inline double cairo_const
+_cairo_round (double r)
+{
+    return floor (r + .5);
+}
+
+cairo_private int
+_cairo_lround (double d) cairo_const;
+
+/* cairo-gstate.c */
+cairo_private cairo_status_t
+_cairo_gstate_init (cairo_gstate_t  *gstate,
+		    cairo_surface_t *target);
+
+cairo_private void
+_cairo_gstate_fini (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_save (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
+
+cairo_private cairo_status_t
+_cairo_gstate_restore (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
+
+cairo_private cairo_bool_t
+_cairo_gstate_is_redirected (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_parent_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_surface_t *
+_cairo_gstate_get_original_target (cairo_gstate_t *gstate);
+
+cairo_private cairo_clip_t *
+_cairo_gstate_get_clip (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_source (cairo_gstate_t *gstate, cairo_pattern_t *source);
+
+cairo_private cairo_pattern_t *
+_cairo_gstate_get_source (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_operator (cairo_gstate_t *gstate, cairo_operator_t op);
+
+cairo_private cairo_operator_t
+_cairo_gstate_get_operator (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_tolerance (cairo_gstate_t *gstate, double tolerance);
+
+cairo_private double
+_cairo_gstate_get_tolerance (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_fill_rule (cairo_gstate_t *gstate, cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_fill_rule_t
+_cairo_gstate_get_fill_rule (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_width (cairo_gstate_t *gstate, double width);
+
+cairo_private double
+_cairo_gstate_get_line_width (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_cap (cairo_gstate_t *gstate, cairo_line_cap_t line_cap);
+
+cairo_private cairo_line_cap_t
+_cairo_gstate_get_line_cap (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_line_join (cairo_gstate_t *gstate, cairo_line_join_t line_join);
+
+cairo_private cairo_line_join_t
+_cairo_gstate_get_line_join (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_dash (cairo_gstate_t *gstate, const double *dash, int num_dashes, double offset);
+
+cairo_private void
+_cairo_gstate_get_dash (cairo_gstate_t *gstate, double *dash, int *num_dashes, double *offset);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_miter_limit (cairo_gstate_t *gstate, double limit);
+
+cairo_private double
+_cairo_gstate_get_miter_limit (cairo_gstate_t *gstate);
+
+cairo_private void
+_cairo_gstate_get_matrix (cairo_gstate_t *gstate, cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_translate (cairo_gstate_t *gstate, double tx, double ty);
+
+cairo_private cairo_status_t
+_cairo_gstate_scale (cairo_gstate_t *gstate, double sx, double sy);
+
+cairo_private cairo_status_t
+_cairo_gstate_rotate (cairo_gstate_t *gstate, double angle);
+
+cairo_private cairo_status_t
+_cairo_gstate_transform (cairo_gstate_t	      *gstate,
+			 const cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_matrix (cairo_gstate_t       *gstate,
+			  const cairo_matrix_t *matrix);
+
+cairo_private void
+_cairo_gstate_identity_matrix (cairo_gstate_t *gstate);
+
+cairo_private void
+_cairo_gstate_user_to_device (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_user_to_device_distance (cairo_gstate_t *gstate, double *dx, double *dy);
+
+cairo_private void
+_cairo_gstate_device_to_user (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_device_to_user_distance (cairo_gstate_t *gstate, double *dx, double *dy);
+
+cairo_private void
+_cairo_gstate_user_to_backend (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_backend_to_user (cairo_gstate_t *gstate, double *x, double *y);
+
+cairo_private void
+_cairo_gstate_backend_to_user_rectangle (cairo_gstate_t *gstate,
+                                         double *x1, double *y1,
+                                         double *x2, double *y2,
+                                         cairo_bool_t *is_tight);
+
+cairo_private void
+_cairo_gstate_path_extents (cairo_gstate_t     *gstate,
+			    cairo_path_fixed_t *path,
+			    double *x1, double *y1,
+			    double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_paint (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_mask (cairo_gstate_t  *gstate,
+		    cairo_pattern_t *mask);
+
+cairo_private cairo_status_t
+_cairo_gstate_stroke (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_fill (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_copy_page (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_page (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_stroke_extents (cairo_gstate_t	 *gstate,
+			      cairo_path_fixed_t *path,
+                              double *x1, double *y1,
+			      double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_fill_extents (cairo_gstate_t     *gstate,
+			    cairo_path_fixed_t *path,
+                            double *x1, double *y1,
+			    double *x2, double *y2);
+
+cairo_private cairo_status_t
+_cairo_gstate_in_stroke (cairo_gstate_t	    *gstate,
+			 cairo_path_fixed_t *path,
+			 double		     x,
+			 double		     y,
+			 cairo_bool_t	    *inside_ret);
+
+cairo_private cairo_bool_t
+_cairo_gstate_in_fill (cairo_gstate_t	  *gstate,
+		       cairo_path_fixed_t *path,
+		       double		   x,
+		       double		   y);
+
+cairo_private cairo_bool_t
+_cairo_gstate_in_clip (cairo_gstate_t	  *gstate,
+		       double		   x,
+		       double		   y);
+
+cairo_private cairo_status_t
+_cairo_gstate_clip (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_reset_clip (cairo_gstate_t *gstate);
+
+cairo_private cairo_bool_t
+_cairo_gstate_clip_extents (cairo_gstate_t *gstate,
+		            double         *x1,
+		            double         *y1,
+			    double         *x2,
+			    double         *y2);
+
+cairo_private cairo_rectangle_list_t*
+_cairo_gstate_copy_clip_rectangle_list (cairo_gstate_t *gstate);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_surface (cairo_gstate_t	*gstate,
+			    cairo_surface_t	*surface,
+			    double		 x,
+			    double		 y,
+			    double		width,
+			    double		height);
+
+cairo_private cairo_status_t
+_cairo_gstate_select_font_face (cairo_gstate_t *gstate,
+				const char *family,
+				cairo_font_slant_t slant,
+				cairo_font_weight_t weight);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_size (cairo_gstate_t *gstate,
+			     double          size);
+
+cairo_private void
+_cairo_gstate_get_font_matrix (cairo_gstate_t *gstate,
+			       cairo_matrix_t *matrix);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
+			       const cairo_matrix_t *matrix);
+
+cairo_private void
+_cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
+				cairo_font_options_t *options);
+
+cairo_private void
+_cairo_gstate_set_font_options (cairo_gstate_t	           *gstate,
+				const cairo_font_options_t *options);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_font_face (cairo_gstate_t     *gstate,
+			     cairo_font_face_t **font_face);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_scaled_font (cairo_gstate_t       *gstate,
+			       cairo_scaled_font_t **scaled_font);
+
+cairo_private cairo_status_t
+_cairo_gstate_get_font_extents (cairo_gstate_t *gstate,
+				cairo_font_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
+			     cairo_font_face_t *font_face);
+
+cairo_private cairo_status_t
+_cairo_gstate_text_to_glyphs (cairo_gstate_t	         *gstate,
+			      double		          x,
+			      double		          y,
+			      const char	         *utf8,
+			      int		          utf8_len,
+			      cairo_glyph_t	        **glyphs,
+			      int		         *num_glyphs,
+			      cairo_text_cluster_t      **clusters,
+			      int		         *num_clusters,
+			      cairo_text_cluster_flags_t *cluster_flags);
+
+cairo_private cairo_status_t
+_cairo_gstate_glyph_extents (cairo_gstate_t *gstate,
+			     const cairo_glyph_t *glyphs,
+			     int num_glyphs,
+			     cairo_text_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_gstate_show_text_glyphs (cairo_gstate_t		   *gstate,
+				const char		   *utf8,
+				int			    utf8_len,
+				const cairo_glyph_t	   *glyphs,
+				int			    num_glyphs,
+				const cairo_text_cluster_t *clusters,
+				int			    num_clusters,
+			        cairo_text_cluster_flags_t  cluster_flags);
+
+cairo_private cairo_status_t
+_cairo_gstate_glyph_path (cairo_gstate_t      *gstate,
+			  const cairo_glyph_t *glyphs,
+			  int		       num_glyphs,
+			  cairo_path_fixed_t  *path);
+
+cairo_private cairo_status_t
+_cairo_gstate_set_antialias (cairo_gstate_t *gstate,
+			     cairo_antialias_t antialias);
+
+cairo_private cairo_antialias_t
+_cairo_gstate_get_antialias (cairo_gstate_t *gstate);
+
+cairo_private cairo_bool_t
+_cairo_operator_bounded_by_mask (cairo_operator_t op) cairo_const;
+
+cairo_private cairo_bool_t
+_cairo_operator_bounded_by_source (cairo_operator_t op) cairo_const;
+
+/* cairo-color.c */
+cairo_private const cairo_color_t *
+_cairo_stock_color (cairo_stock_t stock) cairo_pure;
+
+#define CAIRO_COLOR_WHITE       _cairo_stock_color (CAIRO_STOCK_WHITE)
+#define CAIRO_COLOR_BLACK       _cairo_stock_color (CAIRO_STOCK_BLACK)
+#define CAIRO_COLOR_TRANSPARENT _cairo_stock_color (CAIRO_STOCK_TRANSPARENT)
+
+cairo_private uint16_t
+_cairo_color_double_to_short (double d) cairo_const;
+
+cairo_private void
+_cairo_color_init (cairo_color_t *color);
+
+cairo_private void
+_cairo_color_init_rgb (cairo_color_t *color,
+		       double red, double green, double blue);
+
+cairo_private void
+_cairo_color_init_rgba (cairo_color_t *color,
+			double red, double green, double blue,
+			double alpha);
+
+cairo_private void
+_cairo_color_multiply_alpha (cairo_color_t *color,
+			     double	    alpha);
+
+cairo_private void
+_cairo_color_get_rgba (cairo_color_t *color,
+		       double	     *red,
+		       double	     *green,
+		       double	     *blue,
+		       double	     *alpha);
+
+cairo_private void
+_cairo_color_get_rgba_premultiplied (cairo_color_t *color,
+				     double	   *red,
+				     double	   *green,
+				     double	   *blue,
+				     double	   *alpha);
+
+cairo_private cairo_bool_t
+_cairo_color_equal (const cairo_color_t *color_a,
+                    const cairo_color_t *color_b) cairo_pure;
+
+/* cairo-font-face.c */
+
+extern const cairo_private cairo_font_face_t _cairo_font_face_nil;
+
+cairo_private void
+_cairo_font_face_init (cairo_font_face_t               *font_face,
+		       const cairo_font_face_backend_t *backend);
+
+cairo_private cairo_status_t
+_cairo_font_face_set_error (cairo_font_face_t *font_face,
+	                    cairo_status_t     status);
+
+cairo_private void
+_cairo_unscaled_font_init (cairo_unscaled_font_t               *font,
+			   const cairo_unscaled_font_backend_t *backend);
+
+cairo_private_no_warn cairo_unscaled_font_t *
+_cairo_unscaled_font_reference (cairo_unscaled_font_t *font);
+
+cairo_private void
+_cairo_unscaled_font_destroy (cairo_unscaled_font_t *font);
+
+/* cairo-font-face-twin.c */
+
+cairo_private cairo_font_face_t *
+_cairo_font_face_twin_create_fallback (void);
+
+cairo_private cairo_status_t
+_cairo_font_face_twin_create_for_toy (cairo_toy_font_face_t   *toy_face,
+				      cairo_font_face_t      **font_face);
+
+/* cairo-font-face-twin-data.c */
+
+extern const cairo_private int8_t _cairo_twin_outlines[];
+extern const cairo_private uint16_t _cairo_twin_charmap[128];
+
+/* cairo-font-options.c */
+
+cairo_private void
+_cairo_font_options_init_default (cairo_font_options_t *options);
+
+cairo_private void
+_cairo_font_options_init_copy (cairo_font_options_t		*options,
+			       const cairo_font_options_t	*other);
+
+/* cairo-hull.c */
+cairo_private cairo_status_t
+_cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
+
+/* cairo-lzw.c */
+cairo_private unsigned char *
+_cairo_lzw_compress (unsigned char *data, unsigned long *size_in_out);
+
+/* cairo-misc.c */
+cairo_private cairo_status_t
+_cairo_validate_text_clusters (const char		   *utf8,
+			       int			    utf8_len,
+			       const cairo_glyph_t	   *glyphs,
+			       int			    num_glyphs,
+			       const cairo_text_cluster_t  *clusters,
+			       int			    num_clusters,
+			       cairo_text_cluster_flags_t   cluster_flags);
+
+cairo_private cairo_status_t
+_cairo_intern_string (const char **str_inout, int len);
+
+cairo_private void
+_cairo_intern_string_reset_static_data (void);
+
+/* cairo-path-fixed.c */
+cairo_private cairo_path_fixed_t *
+_cairo_path_fixed_create (void);
+
+cairo_private void
+_cairo_path_fixed_init (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_init_copy (cairo_path_fixed_t *path,
+			     const cairo_path_fixed_t *other);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_equal (const cairo_path_fixed_t *path,
+			    const cairo_path_fixed_t *other);
+
+cairo_private void
+_cairo_path_fixed_fini (cairo_path_fixed_t *path);
+
+cairo_private void
+_cairo_path_fixed_destroy (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
+			   cairo_fixed_t	x,
+			   cairo_fixed_t	y);
+
+cairo_private void
+_cairo_path_fixed_new_sub_path (cairo_path_fixed_t *path);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_move_to (cairo_path_fixed_t *path,
+			       cairo_fixed_t	   dx,
+			       cairo_fixed_t	   dy);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_line_to (cairo_path_fixed_t *path,
+			   cairo_fixed_t	x,
+			   cairo_fixed_t	y);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_line_to (cairo_path_fixed_t *path,
+			       cairo_fixed_t	   dx,
+			       cairo_fixed_t	   dy);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_curve_to (cairo_path_fixed_t	*path,
+			    cairo_fixed_t x0, cairo_fixed_t y0,
+			    cairo_fixed_t x1, cairo_fixed_t y1,
+			    cairo_fixed_t x2, cairo_fixed_t y2);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_rel_curve_to (cairo_path_fixed_t *path,
+				cairo_fixed_t dx0, cairo_fixed_t dy0,
+				cairo_fixed_t dx1, cairo_fixed_t dy1,
+				cairo_fixed_t dx2, cairo_fixed_t dy2);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_close_path (cairo_path_fixed_t *path);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_get_current_point (cairo_path_fixed_t *path,
+				     cairo_fixed_t	*x,
+				     cairo_fixed_t	*y);
+
+typedef cairo_status_t
+(cairo_path_fixed_move_to_func_t) (void		 *closure,
+				   const cairo_point_t *point);
+
+typedef cairo_status_t
+(cairo_path_fixed_line_to_func_t) (void		 *closure,
+				   const cairo_point_t *point);
+
+typedef cairo_status_t
+(cairo_path_fixed_curve_to_func_t) (void	  *closure,
+				    const cairo_point_t *p0,
+				    const cairo_point_t *p1,
+				    const cairo_point_t *p2);
+
+typedef cairo_status_t
+(cairo_path_fixed_close_path_func_t) (void *closure);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_interpret (const cairo_path_fixed_t	  *path,
+		       cairo_direction_t		   dir,
+		       cairo_path_fixed_move_to_func_t	  *move_to,
+		       cairo_path_fixed_line_to_func_t	  *line_to,
+		       cairo_path_fixed_curve_to_func_t	  *curve_to,
+		       cairo_path_fixed_close_path_func_t *close_path,
+		       void				  *closure);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_interpret_flat (const cairo_path_fixed_t *path,
+		       cairo_direction_t		   dir,
+		       cairo_path_fixed_move_to_func_t	  *move_to,
+		       cairo_path_fixed_line_to_func_t	  *line_to,
+		       cairo_path_fixed_close_path_func_t *close_path,
+		       void				  *closure,
+		       double				  tolerance);
+
+cairo_private void
+_cairo_path_fixed_approximate_clip_extents (const cairo_path_fixed_t	*path,
+					    cairo_rectangle_int_t *extents);
+
+cairo_private void
+_cairo_path_fixed_approximate_fill_extents (const cairo_path_fixed_t *path,
+					    cairo_rectangle_int_t *extents);
+
+cairo_private void
+_cairo_path_fixed_fill_extents (const cairo_path_fixed_t	*path,
+				cairo_fill_rule_t	 fill_rule,
+				double			 tolerance,
+				cairo_rectangle_int_t	*extents);
+
+cairo_private void
+_cairo_path_fixed_approximate_stroke_extents (const cairo_path_fixed_t *path,
+					      cairo_stroke_style_t *style,
+					      const cairo_matrix_t *ctm,
+					      cairo_rectangle_int_t *extents);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_stroke_extents (const cairo_path_fixed_t *path,
+				  cairo_stroke_style_t *style,
+				  const cairo_matrix_t *ctm,
+				  const cairo_matrix_t *ctm_inverse,
+				  double tolerance,
+				  cairo_rectangle_int_t *extents);
+
+cairo_private void
+_cairo_path_fixed_bounds (const cairo_path_fixed_t *path,
+			  double *x1, double *y1,
+			  double *x2, double *y2);
+
+cairo_private void
+_cairo_path_fixed_transform (cairo_path_fixed_t	*path,
+			     const cairo_matrix_t	*matrix);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_box (const cairo_path_fixed_t *path,
+                          cairo_box_t *box);
+
+cairo_private cairo_bool_t
+_cairo_path_fixed_is_rectangle (const cairo_path_fixed_t *path,
+				cairo_box_t        *box);
+
+/* cairo-path-in-fill.c */
+cairo_private cairo_bool_t
+_cairo_path_fixed_in_fill (const cairo_path_fixed_t	*path,
+			   cairo_fill_rule_t	 fill_rule,
+			   double		 tolerance,
+			   double		 x,
+			   double		 y);
+
+/* cairo-path-fill.c */
+cairo_private cairo_status_t
+_cairo_path_fixed_fill_to_polygon (const cairo_path_fixed_t *path,
+				   double              tolerance,
+				   cairo_polygon_t      *polygon);
+
+cairo_private cairo_int_status_t
+_cairo_path_fixed_fill_rectilinear_to_traps (const cairo_path_fixed_t *path,
+					     cairo_fill_rule_t fill_rule,
+					     cairo_traps_t *traps);
+
+cairo_private cairo_region_t *
+_cairo_path_fixed_fill_rectilinear_to_region (const cairo_path_fixed_t	*path,
+					      cairo_fill_rule_t	 fill_rule,
+					      const cairo_rectangle_int_t *extents);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_fill_to_traps (const cairo_path_fixed_t   *path,
+				 cairo_fill_rule_t	     fill_rule,
+				 double			     tolerance,
+				 cairo_traps_t		    *traps);
+
+/* cairo-path-stroke.c */
+cairo_private cairo_status_t
+_cairo_path_fixed_stroke_to_polygon (const cairo_path_fixed_t	*path,
+				     cairo_stroke_style_t	*stroke_style,
+				     const cairo_matrix_t	*ctm,
+				     const cairo_matrix_t	*ctm_inverse,
+				     double		 tolerance,
+				     cairo_polygon_t	*polygon);
+
+cairo_private cairo_int_status_t
+_cairo_path_fixed_stroke_rectilinear_to_traps (const cairo_path_fixed_t	*path,
+					       cairo_stroke_style_t	*stroke_style,
+					       const cairo_matrix_t	*ctm,
+					       cairo_traps_t		*traps);
+cairo_private cairo_status_t
+_cairo_path_fixed_stroke_to_traps (const cairo_path_fixed_t	*path,
+				   cairo_stroke_style_t	*stroke_style,
+				   const cairo_matrix_t	*ctm,
+				   const cairo_matrix_t	*ctm_inverse,
+				   double		 tolerance,
+				   cairo_traps_t	*traps);
+
+cairo_private cairo_status_t
+_cairo_path_fixed_stroke_to_shaper (cairo_path_fixed_t	*path,
+				   cairo_stroke_style_t	*stroke_style,
+				   cairo_matrix_t	*ctm,
+				   cairo_matrix_t	*ctm_inverse,
+				   double		 tolerance,
+				   cairo_status_t (*add_triangle) (void *closure,
+								   const cairo_point_t triangle[3]),
+				   cairo_status_t (*add_triangle_fan) (void *closure,
+								       const cairo_point_t *midpt,
+								       const cairo_point_t *points,
+								       int npoints),
+				   cairo_status_t (*add_quad) (void *closure,
+							       const cairo_point_t quad[4]),
+				   void *closure);
+
+/* cairo-scaled-font.c */
+
+cairo_private void
+_cairo_scaled_font_freeze_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
+			      cairo_status_t status);
+
+cairo_private cairo_scaled_font_t *
+_cairo_scaled_font_create_in_error (cairo_status_t status);
+
+cairo_private void
+_cairo_scaled_font_reset_static_data (void);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_register_placeholder_and_unlock_font_map (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_unregister_placeholder_and_lock_font_map (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
+			 cairo_font_face_t		   *font_face,
+			 const cairo_matrix_t              *font_matrix,
+			 const cairo_matrix_t              *ctm,
+			 const cairo_font_options_t	   *options,
+			 const cairo_scaled_font_backend_t *backend);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
+				cairo_font_extents_t	    *fs_metrics);
+
+/* This should only be called on an error path by a scaled_font constructor */
+cairo_private void
+_cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_font_extents (cairo_scaled_font_t  *scaled_font,
+				 cairo_font_extents_t *extents);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
+					 const cairo_glyph_t	 *glyphs,
+					 int                      num_glyphs,
+					 cairo_rectangle_int_t   *extents,
+					 cairo_bool_t		 *overlap);
+
+cairo_private void
+_cairo_scaled_font_glyph_approximate_extents (cairo_scaled_font_t	 *scaled_font,
+					      const cairo_glyph_t	 *glyphs,
+					      int                      num_glyphs,
+					      cairo_rectangle_int_t   *extents);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_show_glyphs (cairo_scaled_font_t *scaled_font,
+				cairo_operator_t     op,
+				const cairo_pattern_t *source,
+				cairo_surface_t	    *surface,
+				int		     source_x,
+				int		     source_y,
+				int		     dest_x,
+				int		     dest_y,
+				unsigned int	     width,
+				unsigned int	     height,
+				cairo_glyph_t	    *glyphs,
+				int		     num_glyphs,
+				cairo_region_t	    *clip_region);
+
+cairo_private cairo_status_t
+_cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
+			       const cairo_glyph_t *glyphs,
+			       int                  num_glyphs,
+			       cairo_path_fixed_t  *path);
+
+cairo_private void
+_cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,
+				 cairo_scaled_font_t *scaled_font,
+				 cairo_text_extents_t *fs_metrics);
+
+cairo_private void
+_cairo_scaled_glyph_set_surface (cairo_scaled_glyph_t *scaled_glyph,
+				 cairo_scaled_font_t *scaled_font,
+				 cairo_image_surface_t *surface);
+
+cairo_private void
+_cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
+			      cairo_scaled_font_t *scaled_font,
+			      cairo_path_fixed_t *path);
+
+cairo_private void
+_cairo_scaled_glyph_set_recording_surface (cairo_scaled_glyph_t *scaled_glyph,
+                                           cairo_scaled_font_t *scaled_font,
+                                           cairo_surface_t *recording_surface);
+
+cairo_private cairo_int_status_t
+_cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
+			    unsigned long index,
+			    cairo_scaled_glyph_info_t info,
+			    cairo_scaled_glyph_t **scaled_glyph_ret);
+
+cairo_private double
+_cairo_scaled_font_get_max_scale (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
+_cairo_scaled_font_map_destroy (void);
+
+/* cairo-stroke-style.c */
+
+cairo_private void
+_cairo_stroke_style_init (cairo_stroke_style_t *style);
+
+cairo_private cairo_status_t
+_cairo_stroke_style_init_copy (cairo_stroke_style_t *style,
+			       cairo_stroke_style_t *other);
+
+cairo_private void
+_cairo_stroke_style_fini (cairo_stroke_style_t *style);
+
+cairo_private void
+_cairo_stroke_style_max_distance_from_path (const cairo_stroke_style_t *style,
+                                            const cairo_matrix_t *ctm,
+                                            double *dx, double *dy);
+
+/* cairo-surface.c */
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_in_error (cairo_status_t status);
+
+cairo_private cairo_status_t
+_cairo_surface_copy_mime_data (cairo_surface_t *dst,
+			       cairo_surface_t *src);
+
+cairo_private cairo_status_t
+_cairo_surface_set_error (cairo_surface_t	*surface,
+			  cairo_status_t	 status);
+
+cairo_private void
+_cairo_surface_set_resolution (cairo_surface_t *surface,
+                               double x_res,
+                               double y_res);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_similar_scratch (cairo_surface_t *other,
+				       cairo_content_t	content,
+				       int		width,
+				       int		height);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_similar_solid (cairo_surface_t	    *other,
+				     cairo_content_t	     content,
+				     int		     width,
+				     int		     height,
+				     const cairo_color_t    *color,
+				     cairo_bool_t	     allow_fallback);
+
+cairo_private cairo_surface_t *
+_cairo_surface_create_solid_pattern_surface (cairo_surface_t	   *other,
+					     const cairo_solid_pattern_t *solid_pattern);
+
+cairo_private cairo_int_status_t
+_cairo_surface_repaint_solid_pattern_surface (cairo_surface_t	    *other,
+					      cairo_surface_t       *solid_surface,
+					      const cairo_solid_pattern_t *solid_pattern);
+
+cairo_private void
+_cairo_surface_init (cairo_surface_t			*surface,
+		     const cairo_surface_backend_t	*backend,
+		     cairo_content_t			 content);
+
+cairo_private void
+_cairo_surface_set_font_options (cairo_surface_t       *surface,
+				 cairo_font_options_t  *options);
+
+cairo_private cairo_status_t
+_cairo_surface_composite (cairo_operator_t	op,
+			  const cairo_pattern_t	*src,
+			  const cairo_pattern_t	*mask,
+			  cairo_surface_t	*dst,
+			  int			 src_x,
+			  int			 src_y,
+			  int			 mask_x,
+			  int			 mask_y,
+			  int			 dst_x,
+			  int			 dst_y,
+			  unsigned int		 width,
+			  unsigned int		 height,
+			  cairo_region_t	*clip_region);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
+			       cairo_operator_t	    op,
+			       const cairo_color_t *color,
+			       int		    x,
+			       int		    y,
+			       int		    width,
+			       int		    height);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_region (cairo_surface_t	   *surface,
+			    cairo_operator_t	    op,
+			    const cairo_color_t    *color,
+			    cairo_region_t         *region);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_rectangles (cairo_surface_t		*surface,
+				cairo_operator_t         op,
+				const cairo_color_t	*color,
+				cairo_rectangle_int_t	*rects,
+				int			 num_rects);
+
+cairo_private cairo_status_t
+_cairo_surface_paint (cairo_surface_t	*surface,
+		      cairo_operator_t	 op,
+		      const cairo_pattern_t *source,
+		      cairo_clip_t	    *clip);
+
+cairo_private cairo_status_t
+_cairo_surface_mask (cairo_surface_t	*surface,
+		     cairo_operator_t	 op,
+		     const cairo_pattern_t	*source,
+		     const cairo_pattern_t	*mask,
+		     cairo_clip_t		*clip);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_stroke (cairo_surface_t	    *surface,
+			    cairo_operator_t	     fill_op,
+			    const cairo_pattern_t   *fill_source,
+			    cairo_fill_rule_t	     fill_rule,
+			    double		     fill_tolerance,
+			    cairo_antialias_t	     fill_antialias,
+			    cairo_path_fixed_t	    *path,
+			    cairo_operator_t	     stroke_op,
+			    const cairo_pattern_t   *stroke_source,
+			    cairo_stroke_style_t    *stroke_style,
+			    cairo_matrix_t	    *stroke_ctm,
+			    cairo_matrix_t	    *stroke_ctm_inverse,
+			    double		     stroke_tolerance,
+			    cairo_antialias_t	     stroke_antialias,
+			    cairo_clip_t	    *clip);
+
+cairo_private cairo_status_t
+_cairo_surface_stroke (cairo_surface_t		*surface,
+		       cairo_operator_t		 op,
+		       const cairo_pattern_t	*source,
+		       cairo_path_fixed_t	*path,
+		       cairo_stroke_style_t	*style,
+		       cairo_matrix_t		*ctm,
+		       cairo_matrix_t		*ctm_inverse,
+		       double			 tolerance,
+		       cairo_antialias_t	 antialias,
+		       cairo_clip_t		*clip);
+
+cairo_private cairo_status_t
+_cairo_surface_fill (cairo_surface_t	*surface,
+		     cairo_operator_t	 op,
+		     const cairo_pattern_t *source,
+		     cairo_path_fixed_t	*path,
+		     cairo_fill_rule_t	 fill_rule,
+		     double		 tolerance,
+		     cairo_antialias_t	 antialias,
+		     cairo_clip_t	*clip);
+
+cairo_private cairo_status_t
+_cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
+				 cairo_operator_t	     op,
+				 const cairo_pattern_t	    *source,
+				 const char		    *utf8,
+				 int			     utf8_len,
+				 cairo_glyph_t		    *glyphs,
+				 int			     num_glyphs,
+				 const cairo_text_cluster_t *clusters,
+				 int			     num_clusters,
+				 cairo_text_cluster_flags_t  cluster_flags,
+				 cairo_scaled_font_t	    *scaled_font,
+				 cairo_clip_t		    *clip);
+
+cairo_private cairo_status_t
+_cairo_surface_paint_extents (cairo_surface_t *surface,
+			      cairo_operator_t		op,
+			      const cairo_pattern_t	*source,
+			      cairo_clip_t		*clip,
+			      cairo_rectangle_int_t	*extents);
+
+cairo_private cairo_status_t
+_cairo_surface_mask_extents (cairo_surface_t *surface,
+			     cairo_operator_t		 op,
+			     const cairo_pattern_t	*source,
+			     const cairo_pattern_t	*mask,
+			     cairo_clip_t		*clip,
+			     cairo_rectangle_int_t	*extents);
+
+cairo_private cairo_status_t
+_cairo_surface_stroke_extents (cairo_surface_t *surface,
+			       cairo_operator_t op,
+			       const cairo_pattern_t *source,
+			       cairo_path_fixed_t	*path,
+			       cairo_stroke_style_t *style,
+			       const cairo_matrix_t *ctm,
+			       const cairo_matrix_t *ctm_inverse,
+			       double tolerance,
+			       cairo_antialias_t	 antialias,
+			       cairo_clip_t *clip,
+			       cairo_rectangle_int_t *extents);
+
+cairo_private cairo_status_t
+_cairo_surface_fill_extents (cairo_surface_t		*surface,
+			     cairo_operator_t		 op,
+			     const cairo_pattern_t	*source,
+			     cairo_path_fixed_t		*path,
+			     cairo_fill_rule_t		 fill_rule,
+			     double			 tolerance,
+			     cairo_antialias_t		 antialias,
+			     cairo_clip_t		*clip,
+			     cairo_rectangle_int_t	*extents);
+
+cairo_private cairo_status_t
+_cairo_surface_glyphs_extents (cairo_surface_t *surface,
+			       cairo_operator_t	   op,
+			       const cairo_pattern_t *source,
+			       cairo_glyph_t	  *glyphs,
+			       int		   num_glyphs,
+			       cairo_scaled_font_t  *scaled_font,
+			       cairo_clip_t         *clip,
+			       cairo_rectangle_int_t *extents);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_trapezoids (cairo_operator_t	op,
+				     const cairo_pattern_t *pattern,
+				     cairo_surface_t	*dst,
+				     cairo_antialias_t	antialias,
+				     int		src_x,
+				     int		src_y,
+				     int		dst_x,
+				     int		dst_y,
+				     unsigned int	width,
+				     unsigned int	height,
+				     cairo_trapezoid_t	*traps,
+				     int		ntraps,
+				     cairo_region_t	*clip_region);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_trapezoids_as_polygon (cairo_surface_t	*surface,
+						cairo_operator_t	 op,
+						const cairo_pattern_t	*pattern,
+						cairo_antialias_t	antialias,
+						int src_x, int src_y,
+						int dst_x, int dst_y,
+						int width, int height,
+						cairo_trapezoid_t	*traps,
+						int num_traps,
+						cairo_region_t	*clip_region);
+
+cairo_private cairo_span_renderer_t *
+_cairo_surface_create_span_renderer (cairo_operator_t			 op,
+				     const cairo_pattern_t		*pattern,
+				     cairo_surface_t			*dst,
+				     cairo_antialias_t			 antialias,
+				     const cairo_composite_rectangles_t *rects,
+				     cairo_region_t			*clip_region);
+
+cairo_private cairo_bool_t
+_cairo_surface_check_span_renderer (cairo_operator_t			 op,
+				    const cairo_pattern_t		*pattern,
+				    cairo_surface_t			*dst,
+				    cairo_antialias_t			 antialias);
+
+cairo_private cairo_status_t
+_cairo_surface_acquire_source_image (cairo_surface_t         *surface,
+				     cairo_image_surface_t  **image_out,
+				     void                   **image_extra);
+
+cairo_private void
+_cairo_surface_release_source_image (cairo_surface_t        *surface,
+				     cairo_image_surface_t  *image,
+				     void                   *image_extra);
+
+cairo_private cairo_status_t
+_cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
+				   cairo_rectangle_int_t   *interest_rect,
+				   cairo_image_surface_t  **image_out,
+				   cairo_rectangle_int_t   *image_rect,
+				   void                   **image_extra);
+
+cairo_private void
+_cairo_surface_release_dest_image (cairo_surface_t        *surface,
+				   cairo_rectangle_int_t  *interest_rect,
+				   cairo_image_surface_t  *image,
+				   cairo_rectangle_int_t  *image_rect,
+				   void                   *image_extra);
+
+cairo_private cairo_status_t
+_cairo_surface_clone_similar (cairo_surface_t  *surface,
+			      cairo_surface_t  *src,
+			      int               src_x,
+			      int               src_y,
+			      int               width,
+			      int               height,
+			      int              *clone_offset_x,
+			      int              *clone_offset_y,
+			      cairo_surface_t **clone_out);
+
+cairo_private cairo_surface_t *
+_cairo_surface_snapshot (cairo_surface_t *surface);
+
+cairo_private cairo_status_t
+_cairo_surface_attach_snapshot (cairo_surface_t *surface,
+				cairo_surface_t *snapshot,
+				cairo_surface_func_t detach_func);
+
+cairo_private cairo_surface_t *
+_cairo_surface_has_snapshot (cairo_surface_t *surface,
+			     const cairo_surface_backend_t *backend,
+			     cairo_content_t content);
+
+cairo_private void
+_cairo_surface_detach_snapshot (cairo_surface_t *snapshot);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_similar (cairo_surface_t *surface_a,
+	                   cairo_surface_t *surface_b,
+			   cairo_content_t  content);
+
+cairo_private cairo_bool_t
+_cairo_surface_get_extents (cairo_surface_t         *surface,
+			    cairo_rectangle_int_t   *extents);
+
+cairo_private cairo_status_t
+_cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
+				cairo_operator_t	 op,
+				const cairo_pattern_t	*pattern,
+				cairo_surface_t		*surface,
+				int			 source_x,
+				int			 source_y,
+				int			 dest_x,
+				int			 dest_y,
+				unsigned int		 width,
+				unsigned int		 height,
+				cairo_glyph_t		*glyphs,
+				int			 num_glyphs,
+				cairo_region_t		*clip_region);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
+					  cairo_surface_attributes_t *src_attr,
+					  int                         src_width,
+					  int                         src_height,
+					  cairo_surface_attributes_t *mask_attr,
+					  int                         mask_width,
+					  int                         mask_height,
+					  int			      src_x,
+					  int			      src_y,
+					  int			      mask_x,
+					  int			      mask_y,
+					  int			      dst_x,
+					  int			      dst_y,
+					  unsigned int		      width,
+					  unsigned int		      height,
+					  cairo_region_t	    *clip_region);
+
+cairo_private cairo_status_t
+_cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
+						cairo_surface_attributes_t *src_attr,
+						int                         src_width,
+						int                         src_height,
+						int                         mask_width,
+						int                         mask_height,
+						int			    src_x,
+						int			    src_y,
+						int			    mask_x,
+						int			    mask_y,
+						int			    dst_x,
+						int			    dst_y,
+						unsigned int		    width,
+						unsigned int		    height,
+						cairo_region_t		    *clip_region);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_opaque (const cairo_surface_t *surface);
+
+cairo_private void
+_cairo_surface_set_device_scale (cairo_surface_t *surface,
+				 double		  sx,
+				 double		  sy);
+
+cairo_private cairo_bool_t
+_cairo_surface_has_device_transform (cairo_surface_t *surface) cairo_pure;
+
+/* cairo-image-surface.c */
+
+/* XXX: In cairo 1.2.0 we added a new %CAIRO_FORMAT_RGB16_565 but
+ * neglected to adjust this macro. The net effect is that it's
+ * impossible to externally create an image surface with this
+ * format. This is perhaps a good thing since we also neglected to fix
+ * up things like cairo_surface_write_to_png() for the new format
+ * (-Wswitch-enum will tell you where). Is it obvious that format was
+ * added in haste?
+ *
+ * The reason for the new format was to allow the xlib backend to be
+ * used on X servers with a 565 visual. So the new format did its job
+ * for that, even without being considered "valid" for the sake of
+ * things like cairo_image_surface_create().
+ *
+ * Since 1.2.0 we ran into the same situtation with X servers with BGR
+ * visuals. This time we invented #cairo_internal_format_t instead,
+ * (see it for more discussion).
+ *
+ * The punchline is that %CAIRO_FORMAT_VALID must not conside any
+ * internal format to be valid. Also we need to decide if the
+ * RGB16_565 should be moved to instead be an internal format. If so,
+ * this macro need not change for it. (We probably will need to leave
+ * an RGB16_565 value in the header files for the sake of code that
+ * might have that value in it.)
+ *
+ * If we do decide to start fully supporting RGB16_565 as an external
+ * format, then %CAIRO_FORMAT_VALID needs to be adjusted to include
+ * it. But that should not happen before all necessary code is fixed
+ * to support it (at least cairo_surface_write_to_png() and a few spots
+ * in cairo-xlib-surface.c--again see -Wswitch-enum).
+ */
+#define CAIRO_FORMAT_INVALID ((unsigned int) -1)
+#define CAIRO_FORMAT_VALID(format) ((format) <= CAIRO_FORMAT_A1)
+
+/* pixman-required stride alignment in bytes. */
+#define CAIRO_STRIDE_ALIGNMENT (sizeof (uint32_t))
+#define CAIRO_STRIDE_FOR_WIDTH_BPP(w,bpp) \
+   ((((bpp)*(w)+7)/8 + CAIRO_STRIDE_ALIGNMENT-1) & -CAIRO_STRIDE_ALIGNMENT)
+
+#define CAIRO_CONTENT_VALID(content) ((content) && 			         \
+				      (((content) & ~(CAIRO_CONTENT_COLOR |      \
+						      CAIRO_CONTENT_ALPHA |      \
+						      CAIRO_CONTENT_COLOR_ALPHA))\
+				       == 0))
+
+cairo_private int
+_cairo_format_bits_per_pixel (cairo_format_t format) cairo_const;
+
+cairo_private cairo_format_t
+_cairo_format_from_content (cairo_content_t content) cairo_const;
+
+cairo_private cairo_content_t
+_cairo_content_from_format (cairo_format_t format) cairo_const;
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_for_pixman_image (pixman_image_t		*pixman_image,
+					      pixman_format_code_t	 pixman_format);
+
+cairo_private cairo_bool_t
+_pixman_format_from_masks (cairo_format_masks_t *masks,
+			   pixman_format_code_t *format_ret);
+
+cairo_private cairo_bool_t
+_pixman_format_to_masks (pixman_format_code_t	 pixman_format,
+			 cairo_format_masks_t	*masks);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_pixman_format (unsigned char		*data,
+						pixman_format_code_t	 pixman_format,
+						int			 width,
+						int			 height,
+						int			 stride);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_masks (unsigned char	       *data,
+					cairo_format_masks_t   *format,
+					int			width,
+					int			height,
+					int			stride);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_with_content (cairo_content_t	content,
+					  int			width,
+					  int			height);
+
+cairo_private cairo_surface_t *
+_cairo_image_surface_create_for_data_with_content (unsigned char	*data,
+						   cairo_content_t	 content,
+						   int			 width,
+						   int			 height,
+						   int			 stride);
+
+cairo_private void
+_cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface);
+
+cairo_private cairo_image_surface_t *
+_cairo_image_surface_coerce (cairo_image_surface_t	*surface,
+			     cairo_format_t		 format);
+cairo_private void
+_cairo_image_surface_span_render_row (int				 y,
+				      const cairo_half_open_span_t	 *spans,
+				      unsigned				 num_spans,
+				      cairo_image_surface_t              *mask,
+				      const cairo_composite_rectangles_t *rects);
+
+cairo_private cairo_image_transparency_t
+_cairo_image_analyze_transparency (cairo_image_surface_t      *image);
+
+cairo_private cairo_bool_t
+_cairo_surface_is_image (const cairo_surface_t *surface) cairo_pure;
+
+cairo_private cairo_bool_t
+_cairo_surface_is_recording (const cairo_surface_t *surface) cairo_pure;
+
+/* cairo-pen.c */
+cairo_private cairo_status_t
+_cairo_pen_init (cairo_pen_t	*pen,
+		 double		 radius,
+		 double		 tolerance,
+		 const cairo_matrix_t	*ctm);
+
+cairo_private void
+_cairo_pen_init_empty (cairo_pen_t *pen);
+
+cairo_private cairo_status_t
+_cairo_pen_init_copy (cairo_pen_t *pen, const cairo_pen_t *other);
+
+cairo_private void
+_cairo_pen_fini (cairo_pen_t *pen);
+
+cairo_private cairo_status_t
+_cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points);
+
+cairo_private cairo_status_t
+_cairo_pen_add_points_for_slopes (cairo_pen_t *pen,
+				  cairo_point_t *a,
+				  cairo_point_t *b,
+				  cairo_point_t *c,
+				  cairo_point_t *d);
+
+cairo_private int
+_cairo_pen_find_active_cw_vertex_index (const cairo_pen_t *pen,
+					const cairo_slope_t *slope);
+
+cairo_private int
+_cairo_pen_find_active_ccw_vertex_index (const cairo_pen_t *pen,
+					 const cairo_slope_t *slope);
+
+/* cairo-polygon.c */
+cairo_private void
+_cairo_polygon_init (cairo_polygon_t *polygon);
+
+cairo_private void
+_cairo_polygon_limit (cairo_polygon_t	*polygon,
+		      const cairo_box_t *boxes,
+		      int		 num_boxes);
+
+cairo_private void
+_cairo_polygon_fini (cairo_polygon_t *polygon);
+
+cairo_private cairo_status_t
+_cairo_polygon_add_line (cairo_polygon_t *polygon,
+			 const cairo_line_t *line,
+			 int top, int bottom,
+			 int dir);
+
+cairo_private cairo_status_t
+_cairo_polygon_add_external_edge (void *polygon,
+				  const cairo_point_t *p1,
+				  const cairo_point_t *p2);
+
+cairo_private cairo_status_t
+_cairo_polygon_move_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point);
+
+cairo_private cairo_status_t
+_cairo_polygon_line_to (cairo_polygon_t *polygon,
+			const cairo_point_t *point);
+
+cairo_private cairo_status_t
+_cairo_polygon_close (cairo_polygon_t *polygon);
+
+#define _cairo_polygon_status(P) ((cairo_polygon_t *) (P))->status
+
+/* cairo-spline.c */
+cairo_private cairo_bool_t
+_cairo_spline_init (cairo_spline_t *spline,
+		    cairo_spline_add_point_func_t add_point_func,
+		    void *closure,
+		    const cairo_point_t *a, const cairo_point_t *b,
+		    const cairo_point_t *c, const cairo_point_t *d);
+
+cairo_private cairo_status_t
+_cairo_spline_decompose (cairo_spline_t *spline, double tolerance);
+
+cairo_private cairo_status_t
+_cairo_spline_bound (cairo_spline_add_point_func_t add_point_func,
+		     void *closure,
+		     const cairo_point_t *p0, const cairo_point_t *p1,
+		     const cairo_point_t *p2, const cairo_point_t *p3);
+
+/* cairo-matrix.c */
+cairo_private void
+_cairo_matrix_get_affine (const cairo_matrix_t *matrix,
+			  double *xx, double *yx,
+			  double *xy, double *yy,
+			  double *x0, double *y0);
+
+cairo_private void
+_cairo_matrix_transform_bounding_box (const cairo_matrix_t *matrix,
+				      double *x1, double *y1,
+				      double *x2, double *y2,
+				      cairo_bool_t *is_tight);
+
+cairo_private void
+_cairo_matrix_transform_bounding_box_fixed (const cairo_matrix_t *matrix,
+					    cairo_box_t          *bbox,
+					    cairo_bool_t         *is_tight);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_invertible (const cairo_matrix_t *matrix) cairo_pure;
+
+cairo_private double
+_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix) cairo_pure;
+
+cairo_private cairo_status_t
+_cairo_matrix_compute_basis_scale_factors (const cairo_matrix_t *matrix,
+					   double *sx, double *sy, int x_major);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_identity (const cairo_matrix_t *matrix) cairo_pure;
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_translation (const cairo_matrix_t *matrix) cairo_pure;
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_integer_translation(const cairo_matrix_t *matrix,
+				     int *itx, int *ity);
+
+cairo_private cairo_bool_t
+_cairo_matrix_has_unity_scale (const cairo_matrix_t *matrix);
+
+cairo_private cairo_bool_t
+_cairo_matrix_is_pixel_exact (const cairo_matrix_t *matrix) cairo_pure;
+
+cairo_private double
+_cairo_matrix_transformed_circle_major_axis (const cairo_matrix_t *matrix,
+					     double radius) cairo_pure;
+
+cairo_private void
+_cairo_matrix_to_pixman_matrix (const cairo_matrix_t	*matrix,
+				pixman_transform_t	*pixman_transform,
+				double                   xc,
+				double                   yc);
+
+/* cairo-traps.c */
+cairo_private void
+_cairo_traps_init (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_limit (cairo_traps_t	*traps,
+		    const cairo_box_t	*boxes,
+		    int			 num_boxes);
+
+cairo_private cairo_status_t
+_cairo_traps_init_boxes (cairo_traps_t	    *traps,
+			 const cairo_box_t    *boxes,
+			 int		     num_boxes);
+
+cairo_private void
+_cairo_traps_clear (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_fini (cairo_traps_t *traps);
+
+#define _cairo_traps_status(T) (T)->status
+
+cairo_private void
+_cairo_traps_translate (cairo_traps_t *traps, int x, int y);
+
+cairo_private cairo_status_t
+_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
+				   const cairo_point_t *top_left,
+				   const cairo_point_t *bottom_right);
+
+cairo_private void
+_cairo_traps_add_trap (cairo_traps_t *traps,
+		       cairo_fixed_t top, cairo_fixed_t bottom,
+		       cairo_line_t *left, cairo_line_t *right);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectilinear_polygon (cairo_traps_t	 *traps,
+						       const cairo_polygon_t *polygon,
+						       cairo_fill_rule_t	  fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
+					   const cairo_polygon_t *polygon);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
+					 cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectangular_traps (cairo_traps_t *traps,
+						     cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectilinear_traps (cairo_traps_t *traps,
+						     cairo_fill_rule_t fill_rule);
+
+cairo_private int
+_cairo_traps_contain (const cairo_traps_t *traps,
+		      double x, double y);
+
+cairo_private void
+_cairo_traps_extents (const cairo_traps_t *traps,
+		      cairo_box_t         *extents);
+
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t  *traps,
+			     cairo_region_t **region);
+
+cairo_private cairo_status_t
+_cairo_traps_path (const cairo_traps_t *traps,
+		   cairo_path_fixed_t  *path);
+
+cairo_private void
+_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
+					    cairo_trapezoid_t *src_traps,
+					    int num_traps,
+					    double tx, double ty,
+					    double sx, double sy);
+
+/* cairo-pattern.c */
+
+cairo_private cairo_pattern_t *
+_cairo_pattern_create_in_error (cairo_status_t status);
+
+cairo_private cairo_status_t
+_cairo_pattern_create_copy (cairo_pattern_t	  **pattern,
+			    const cairo_pattern_t  *other);
+
+cairo_private cairo_status_t
+_cairo_pattern_init_copy (cairo_pattern_t	*pattern,
+			  const cairo_pattern_t *other);
+
+cairo_private void
+_cairo_pattern_init_static_copy (cairo_pattern_t	*pattern,
+				 const cairo_pattern_t *other);
+
+cairo_private cairo_status_t
+_cairo_pattern_init_snapshot (cairo_pattern_t       *pattern,
+			      const cairo_pattern_t *other);
+
+cairo_private void
+_cairo_pattern_init_solid (cairo_solid_pattern_t	*pattern,
+			   const cairo_color_t		*color,
+			   cairo_content_t		 content);
+
+cairo_private void
+_cairo_pattern_init_for_surface (cairo_surface_pattern_t *pattern,
+				 cairo_surface_t *surface);
+
+cairo_private void
+_cairo_pattern_init_linear (cairo_linear_pattern_t *pattern,
+			    double x0, double y0, double x1, double y1);
+
+cairo_private void
+_cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
+			    double cx0, double cy0, double radius0,
+			    double cx1, double cy1, double radius1);
+
+cairo_private void
+_cairo_pattern_fini (cairo_pattern_t *pattern);
+
+cairo_private void
+_cairo_pattern_fini_snapshot (cairo_pattern_t *pattern);
+
+cairo_private cairo_pattern_t *
+_cairo_pattern_create_solid (const cairo_color_t	*color,
+			     cairo_content_t		 content);
+
+cairo_private void
+_cairo_pattern_transform (cairo_pattern_t      *pattern,
+			  const cairo_matrix_t *ctm_inverse);
+
+cairo_private cairo_bool_t
+_cairo_pattern_is_opaque_solid (const cairo_pattern_t *pattern);
+
+cairo_private cairo_bool_t
+_cairo_pattern_is_opaque (const cairo_pattern_t *abstract_pattern);
+
+enum {
+    CAIRO_PATTERN_ACQUIRE_NONE = 0x0,
+    CAIRO_PATTERN_ACQUIRE_NO_REFLECT = 0x1,
+};
+cairo_private cairo_int_status_t
+_cairo_pattern_acquire_surface (const cairo_pattern_t	   *pattern,
+				cairo_surface_t		   *dst,
+				int			   x,
+				int			   y,
+				unsigned int		   width,
+				unsigned int		   height,
+				unsigned int		   flags,
+				cairo_surface_t		   **surface_out,
+				cairo_surface_attributes_t *attributes);
+
+cairo_private void
+_cairo_pattern_release_surface (const cairo_pattern_t	   *pattern,
+				cairo_surface_t		   *surface,
+				cairo_surface_attributes_t *attributes);
+
+cairo_private cairo_int_status_t
+_cairo_pattern_acquire_surfaces (const cairo_pattern_t	    *src,
+				 const cairo_pattern_t	    *mask,
+				 cairo_surface_t	    *dst,
+				 int			    src_x,
+				 int			    src_y,
+				 int			    mask_x,
+				 int			    mask_y,
+				 unsigned int		    width,
+				 unsigned int		    height,
+				 unsigned int		    flags,
+				 cairo_surface_t	    **src_out,
+				 cairo_surface_t	    **mask_out,
+				 cairo_surface_attributes_t *src_attributes,
+				 cairo_surface_attributes_t *mask_attributes);
+
+cairo_private void
+_cairo_pattern_get_extents (const cairo_pattern_t	    *pattern,
+			    cairo_rectangle_int_t           *extents);
+
+cairo_private unsigned long
+_cairo_pattern_hash (const cairo_pattern_t *pattern);
+
+cairo_private unsigned long
+_cairo_pattern_size (const cairo_pattern_t *pattern);
+
+cairo_private cairo_bool_t
+_cairo_pattern_equal (const cairo_pattern_t *a,
+		      const cairo_pattern_t *b);
+
+cairo_private void
+_cairo_pattern_reset_static_data (void);
+
+#if CAIRO_HAS_DRM_SURFACE
+
+cairo_private void
+_cairo_drm_device_reset_static_data (void);
+
+#endif
+
+cairo_private void
+_cairo_clip_reset_static_data (void);
+
+/* cairo-unicode.c */
+
+cairo_private int
+_cairo_utf8_get_char_validated (const char *p,
+				uint32_t   *unicode);
+
+cairo_private cairo_status_t
+_cairo_utf8_to_ucs4 (const char *str,
+		     int	 len,
+		     uint32_t  **result,
+		     int	*items_written);
+
+cairo_private int
+_cairo_ucs4_to_utf8 (uint32_t    unicode,
+		     char       *utf8);
+
+#if CAIRO_HAS_WIN32_FONT || CAIRO_HAS_QUARTZ_FONT || CAIRO_HAS_PDF_OPERATORS
+# define CAIRO_HAS_UTF8_TO_UTF16 1
+#endif
+#if CAIRO_HAS_UTF8_TO_UTF16
+cairo_private cairo_status_t
+_cairo_utf8_to_utf16 (const char *str,
+		      int	  len,
+		      uint16_t  **result,
+		      int	 *items_written);
+#endif
+
+#define _cairo_status_is_error(status) \
+    (status != CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS)
+
+cairo_private cairo_status_t
+_cairo_error (cairo_status_t status);
+
+/* hide compiler warnings when discarding the return value */
+#define _cairo_error_throw(status) do { \
+    cairo_status_t status__ = _cairo_error (status); \
+    (void) status__; \
+} while (0)
+
+/* Avoid unnecessary PLT entries.  */
+slim_hidden_proto (cairo_clip_preserve);
+slim_hidden_proto (cairo_close_path);
+slim_hidden_proto (cairo_create);
+slim_hidden_proto (cairo_curve_to);
+slim_hidden_proto (cairo_destroy);
+slim_hidden_proto (cairo_fill_preserve);
+slim_hidden_proto (cairo_font_face_destroy);
+slim_hidden_proto (cairo_font_face_get_user_data);
+slim_hidden_proto_no_warn (cairo_font_face_reference);
+slim_hidden_proto (cairo_font_face_set_user_data);
+slim_hidden_proto (cairo_font_options_equal);
+slim_hidden_proto (cairo_font_options_hash);
+slim_hidden_proto (cairo_font_options_merge);
+slim_hidden_proto (cairo_font_options_set_antialias);
+slim_hidden_proto (cairo_font_options_set_hint_metrics);
+slim_hidden_proto (cairo_font_options_set_hint_style);
+slim_hidden_proto (cairo_font_options_set_subpixel_order);
+slim_hidden_proto (cairo_font_options_status);
+slim_hidden_proto (cairo_format_stride_for_width);
+slim_hidden_proto (cairo_get_current_point);
+slim_hidden_proto (cairo_get_line_width);
+slim_hidden_proto (cairo_get_matrix);
+slim_hidden_proto (cairo_get_target);
+slim_hidden_proto (cairo_get_tolerance);
+slim_hidden_proto (cairo_glyph_allocate);
+slim_hidden_proto (cairo_glyph_free);
+slim_hidden_proto (cairo_image_surface_create);
+slim_hidden_proto (cairo_image_surface_create_for_data);
+slim_hidden_proto (cairo_image_surface_get_data);
+slim_hidden_proto (cairo_image_surface_get_format);
+slim_hidden_proto (cairo_image_surface_get_height);
+slim_hidden_proto (cairo_image_surface_get_stride);
+slim_hidden_proto (cairo_image_surface_get_width);
+slim_hidden_proto (cairo_line_to);
+slim_hidden_proto (cairo_mask);
+slim_hidden_proto (cairo_matrix_init);
+slim_hidden_proto (cairo_matrix_init_identity);
+slim_hidden_proto (cairo_matrix_init_rotate);
+slim_hidden_proto (cairo_matrix_init_scale);
+slim_hidden_proto (cairo_matrix_init_translate);
+slim_hidden_proto (cairo_matrix_invert);
+slim_hidden_proto (cairo_matrix_multiply);
+slim_hidden_proto (cairo_matrix_scale);
+slim_hidden_proto (cairo_matrix_transform_distance);
+slim_hidden_proto (cairo_matrix_transform_point);
+slim_hidden_proto (cairo_matrix_translate);
+slim_hidden_proto (cairo_move_to);
+slim_hidden_proto (cairo_new_path);
+slim_hidden_proto (cairo_paint);
+slim_hidden_proto (cairo_pattern_create_for_surface);
+slim_hidden_proto (cairo_pattern_create_rgb);
+slim_hidden_proto (cairo_pattern_create_rgba);
+slim_hidden_proto (cairo_pattern_destroy);
+slim_hidden_proto (cairo_pattern_get_extend);
+slim_hidden_proto_no_warn (cairo_pattern_reference);
+slim_hidden_proto (cairo_pattern_set_matrix);
+slim_hidden_proto (cairo_pop_group);
+slim_hidden_proto (cairo_push_group_with_content);
+slim_hidden_proto (cairo_rel_line_to);
+slim_hidden_proto (cairo_restore);
+slim_hidden_proto (cairo_save);
+slim_hidden_proto (cairo_scale);
+slim_hidden_proto (cairo_scaled_font_create);
+slim_hidden_proto (cairo_scaled_font_destroy);
+slim_hidden_proto (cairo_scaled_font_extents);
+slim_hidden_proto (cairo_scaled_font_get_ctm);
+slim_hidden_proto (cairo_scaled_font_get_font_face);
+slim_hidden_proto (cairo_scaled_font_get_font_matrix);
+slim_hidden_proto (cairo_scaled_font_get_font_options);
+slim_hidden_proto (cairo_scaled_font_glyph_extents);
+slim_hidden_proto_no_warn (cairo_scaled_font_reference);
+slim_hidden_proto (cairo_scaled_font_status);
+slim_hidden_proto (cairo_scaled_font_get_user_data);
+slim_hidden_proto (cairo_scaled_font_set_user_data);
+slim_hidden_proto (cairo_scaled_font_text_to_glyphs);
+slim_hidden_proto (cairo_set_font_options);
+slim_hidden_proto (cairo_set_font_size);
+slim_hidden_proto (cairo_set_line_cap);
+slim_hidden_proto (cairo_set_line_join);
+slim_hidden_proto (cairo_set_line_width);
+slim_hidden_proto (cairo_set_matrix);
+slim_hidden_proto (cairo_set_operator);
+slim_hidden_proto (cairo_set_source);
+slim_hidden_proto (cairo_set_source_rgb);
+slim_hidden_proto (cairo_set_source_surface);
+slim_hidden_proto (cairo_set_tolerance);
+slim_hidden_proto (cairo_status);
+slim_hidden_proto (cairo_stroke);
+slim_hidden_proto (cairo_stroke_preserve);
+slim_hidden_proto (cairo_surface_copy_page);
+slim_hidden_proto (cairo_surface_destroy);
+slim_hidden_proto (cairo_surface_finish);
+slim_hidden_proto (cairo_surface_flush);
+slim_hidden_proto (cairo_surface_get_content);
+slim_hidden_proto (cairo_surface_get_device_offset);
+slim_hidden_proto (cairo_surface_get_font_options);
+slim_hidden_proto (cairo_surface_get_mime_data);
+slim_hidden_proto (cairo_surface_get_type);
+slim_hidden_proto (cairo_surface_has_show_text_glyphs);
+slim_hidden_proto (cairo_surface_mark_dirty_rectangle);
+slim_hidden_proto_no_warn (cairo_surface_reference);
+slim_hidden_proto (cairo_surface_set_device_offset);
+slim_hidden_proto (cairo_surface_set_fallback_resolution);
+slim_hidden_proto (cairo_surface_set_mime_data);
+slim_hidden_proto (cairo_surface_show_page);
+slim_hidden_proto (cairo_surface_status);
+slim_hidden_proto (cairo_text_cluster_allocate);
+slim_hidden_proto (cairo_text_cluster_free);
+slim_hidden_proto (cairo_toy_font_face_create);
+slim_hidden_proto (cairo_toy_font_face_get_slant);
+slim_hidden_proto (cairo_toy_font_face_get_weight);
+slim_hidden_proto (cairo_translate);
+slim_hidden_proto (cairo_transform);
+slim_hidden_proto (cairo_user_font_face_create);
+slim_hidden_proto (cairo_user_font_face_set_init_func);
+slim_hidden_proto (cairo_user_font_face_set_render_glyph_func);
+slim_hidden_proto (cairo_user_font_face_set_unicode_to_glyph_func);
+slim_hidden_proto (cairo_user_to_device);
+slim_hidden_proto (cairo_user_to_device_distance);
+slim_hidden_proto (cairo_version_string);
+slim_hidden_proto (cairo_region_create);
+slim_hidden_proto (cairo_region_create_rectangle);
+slim_hidden_proto (cairo_region_create_rectangles);
+slim_hidden_proto (cairo_region_copy);
+slim_hidden_proto (cairo_region_reference);
+slim_hidden_proto (cairo_region_destroy);
+slim_hidden_proto (cairo_region_equal);
+slim_hidden_proto (cairo_region_status);
+slim_hidden_proto (cairo_region_get_extents);
+slim_hidden_proto (cairo_region_num_rectangles);
+slim_hidden_proto (cairo_region_get_rectangle);
+slim_hidden_proto (cairo_region_is_empty);
+slim_hidden_proto (cairo_region_contains_rectangle);
+slim_hidden_proto (cairo_region_contains_point);
+slim_hidden_proto (cairo_region_translate);
+slim_hidden_proto (cairo_region_subtract);
+slim_hidden_proto (cairo_region_subtract_rectangle);
+slim_hidden_proto (cairo_region_intersect);
+slim_hidden_proto (cairo_region_intersect_rectangle);
+slim_hidden_proto (cairo_region_union);
+slim_hidden_proto (cairo_region_union_rectangle);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+slim_hidden_proto (cairo_surface_write_to_png_stream);
+
+#endif
+
+CAIRO_END_DECLS
+
+#include "cairo-mutex-private.h"
+#include "cairo-fixed-private.h"
+#include "cairo-wideint-private.h"
+#include "cairo-malloc-private.h"
+#include "cairo-hash-private.h"
+
+#if HAVE_VALGRIND
+#include <memcheck.h>
+
+#define VG(x) x
+
+cairo_private void
+_cairo_debug_check_image_surface_is_defined (const cairo_surface_t *surface);
+
+#else
+
+#define VG(x)
+#define _cairo_debug_check_image_surface_is_defined(X)
+
+#endif
+
+cairo_private void
+_cairo_debug_print_path (FILE *stream, cairo_path_fixed_t *path);
+
+cairo_private void
+_cairo_debug_print_clip (FILE *stream, cairo_clip_t *clip);
+
+#endif
diff --git a/src/gpqueue/gpqueue.c b/src/gpqueue/gpqueue.c
new file mode 100644
index 0000000..53209d0
--- /dev/null
+++ b/src/gpqueue/gpqueue.c
@@ -0,0 +1,546 @@
+/* This code was submitted for consideration to GLib by
+ * Maik Zumstrull <maik.zumstrull@rz.uni-karlsruhe.de>
+ * Need to check licensing etc.. but presume intention is
+ * LGPL, same as glib.
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include "gpqueue.h"
+
+/**
+ * SECTION:priority_queues
+ * @short_description: a collection of data entries with associated priority
+ * values that returns entries one by one in order of priority
+ * 
+ * <para>
+ * The #GPQueue structure and its associated functions provide a sorted
+ * collection of objects. Entries can be inserted in any order and at any time,
+ * and an entry's priority can be changed after it has been inserted into the
+ * queue. Entries are supposed to be removed one at a time in order of priority
+ * with g_pqueue_pop(), but deleting entries out of order is possible.
+ * </para>
+ * <para>
+ * The entries <emphasis>cannot</emphasis> be iterated over in any way other
+ * than removing them one by one in order of priority, but when doing that,
+ * this structure is far more efficient than sorted lists or balanced trees,
+ * which on the other hand do not suffer from this restriction.
+ * </para>
+ * <para>
+ * You will want to be very careful with calls that use #GPQueueHandle.
+ * Handles immediately become invalid when an entry is removed from a #GPQueue,
+ * but the current implementation cannot detect this and will do unfortunate
+ * things to undefined memory locations if you try to use an invalid handle.
+ * </para>
+ * <note>
+ *   <para>
+ *     Internally, #GPQueue currently uses a Fibonacci heap to store
+ *     the entries. This implementation detail may change.
+ *   </para>
+ * </note>
+ **/
+
+struct _GPQueueNode {
+  GPQueueNode *next;
+  GPQueueNode *prev;
+  GPQueueNode *parent;
+  GPQueueNode *child;
+
+  gpointer data;
+
+  gint degree;
+  gboolean marked;
+};
+
+struct _GPQueue {
+  GPQueueNode *root;
+  GCompareDataFunc cmp;
+  gpointer *cmpdata;
+};
+
+/**
+ * g_pqueue_new:
+ * @compare_func: the #GCompareDataFunc used to sort the new priority queue.
+ *   This function is passed two elements of the queue and should return 0 if
+ *   they are equal, a negative value if the first comes before the second, and
+ *   a positive value if the second comes before the first.
+ * @compare_userdata: user data passed to @compare_func
+ * 
+ * Creates a new #GPQueue.
+ * 
+ * Returns: a new #GPQueue.
+ * 
+ * Since: 2.x
+ **/
+GPQueue*
+g_pqueue_new (GCompareDataFunc compare_func,
+              gpointer *compare_userdata)
+{
+  g_return_val_if_fail (compare_func != NULL, NULL);
+
+  GPQueue *pqueue = g_slice_new (GPQueue);
+  pqueue->root = NULL;
+  pqueue->cmp = compare_func;
+  pqueue->cmpdata = compare_userdata;
+  return pqueue;
+}
+
+/**
+ * g_pqueue_is_empty:
+ * @pqueue: a #GPQueue.
+ * 
+ * Returns %TRUE if the queue is empty.
+ * 
+ * Returns: %TRUE if the queue is empty.
+ * 
+ * Since: 2.x
+ **/
+gboolean
+g_pqueue_is_empty (GPQueue *pqueue)
+{
+  return (pqueue->root == NULL);
+}
+
+static inline gint
+cmp (GPQueue *pqueue,
+     GPQueueNode *a,
+     GPQueueNode *b)
+{
+  return pqueue->cmp (a->data, b->data, pqueue->cmpdata);
+}
+
+static inline void
+g_pqueue_node_cut (GPQueueNode *src)
+{
+  src->prev->next = src->next;
+  src->next->prev = src->prev;
+  src->next = src;
+  src->prev = src;
+}
+
+static inline void
+g_pqueue_node_insert_before (GPQueueNode *dest,
+                             GPQueueNode *src)
+{
+  GPQueueNode *prev;
+
+  prev = dest->prev;
+  dest->prev = src->prev;
+  src->prev->next = dest;
+  src->prev = prev;
+  prev->next = src;
+}
+
+static inline void
+g_pqueue_node_insert_after (GPQueueNode *dest,
+                            GPQueueNode *src)
+{
+  GPQueueNode *next;
+
+  next = dest->next;
+  dest->next = src;
+  src->prev->next = next;
+  next->prev = src->prev;
+  src->prev = dest;
+}
+
+/**
+ * g_pqueue_push:
+ * @pqueue: a #GPQueue.
+ * @data: the object to insert into the priority queue.
+ * 
+ * Inserts a new entry into a #GPQueue.
+ * 
+ * The returned handle can be used in calls to g_pqueue_remove() and
+ * g_pqueue_priority_changed(). Never make such calls for entries that have
+ * already been removed from the queue. The same @data can be inserted into
+ * a #GPQueue more than once, but remember that in this case,
+ * g_pqueue_priority_changed() needs to be called for
+ * <emphasis>every</emphasis> handle for that object if its priority changes.
+ * 
+ * Returns: a handle for the freshly inserted entry.
+ * 
+ * Since: 2.x
+ **/
+GPQueueHandle
+g_pqueue_push (GPQueue *pqueue,
+               gpointer data)
+{
+  GPQueueNode *e;
+
+  e = g_slice_new (GPQueueNode);
+  e->next = e;
+  e->prev = e;
+  e->parent = NULL;
+  e->child = NULL;
+  e->data = data;
+  e->degree = 0;
+  e->marked = FALSE;
+
+  if (pqueue->root != NULL) {
+    g_pqueue_node_insert_before (pqueue->root, e);
+    if (cmp (pqueue, e, pqueue->root) < 0)
+      pqueue->root = e;
+  } else {
+    pqueue->root = e;
+  }
+
+  return e;
+}
+
+/**
+ * g_pqueue_peek:
+ * @pqueue: a #GPQueue.
+ * 
+ * Returns the topmost entry's data pointer, or %NULL if the queue is empty.
+ * 
+ * If you need to tell the difference between an empty queue and a queue
+ * that happens to have a %NULL pointer at the top, check if the queue is
+ * empty first.
+ * 
+ * Returns: the topmost entry's data pointer, or %NULL if the queue is empty.
+ * 
+ * Since: 2.x
+ **/
+gpointer
+g_pqueue_peek (GPQueue *pqueue)
+{
+  return (pqueue->root != NULL) ? pqueue->root->data : NULL;
+}
+
+static inline GPQueueNode*
+g_pqueue_make_child (GPQueueNode *a,
+                     GPQueueNode *b)
+{
+  g_pqueue_node_cut(b);
+  if (a->child != NULL) {
+    g_pqueue_node_insert_before (a->child, b);
+    a->degree += 1;
+  } else {
+    a->child = b;
+    a->degree = 1;
+  }
+  b->parent = a;
+  return a;
+}
+
+static inline GPQueueNode*
+g_pqueue_join_trees (GPQueue *pqueue,
+                     GPQueueNode *a,
+                     GPQueueNode *b)
+{
+  if (cmp (pqueue, a, b) < 0)
+    return g_pqueue_make_child (a, b);
+  return g_pqueue_make_child (b, a);
+}
+
+static void
+g_pqueue_fix_rootlist (GPQueue* pqueue)
+{
+  gsize degnode_size;
+  GPQueueNode **degnode;
+  GPQueueNode sentinel;
+  GPQueueNode *current;
+  GPQueueNode *minimum;
+
+  /* We need to iterate over the circular list we are given and do
+   * several things:
+   * - Make sure all the elements are unmarked
+   * - Make sure to return the element in the list with smallest
+   *   priority value
+   * - Find elements of identical degree and join them into trees
+   * The last point is irrelevant for correctness, but essential
+   * for performance. If we did not do this, our data structure would
+   * degrade into an unsorted linked list.
+   */
+
+  degnode_size = (8 * sizeof(gpointer) + 1) * sizeof(gpointer);
+  degnode = g_slice_alloc0 (degnode_size);
+
+  sentinel.next = &sentinel;
+  sentinel.prev = &sentinel;
+  g_pqueue_node_insert_before (pqueue->root, &sentinel);
+
+  current = pqueue->root;
+  while (current != &sentinel) {
+    current->marked = FALSE;
+    current->parent = NULL;
+    gint d = current->degree;
+    if (degnode[d] == NULL) {
+      degnode[d] = current;
+      current = current->next;
+    } else {
+      if (degnode[d] != current) {
+        current = g_pqueue_join_trees (pqueue, degnode[d], current);
+        degnode[d] = NULL;
+      } else {
+        current = current->next;
+      }
+    }
+  }
+
+  current = sentinel.next;
+  minimum = current;
+  while (current != &sentinel) {
+    if (cmp (pqueue, current, minimum) < 0)
+      minimum = current;
+    current = current->next;
+  }
+  pqueue->root = minimum;
+
+  g_pqueue_node_cut (&sentinel);
+
+  g_slice_free1 (degnode_size, degnode);
+}
+
+static void
+g_pqueue_remove_root (GPQueue *pqueue,
+                      GPQueueNode *root)
+{
+  /* This removes a node at the root _level_ of the structure, which can be,
+   * but does not have to be, the actual pqueue->root node. That is why
+   * we require an explicit pointer to the node to be removed instead of just
+   * removing pqueue->root implictly.
+   */
+
+  /* Step one:
+   * If root has any children, pull them up to root level.
+   * At this time, we only deal with their next/prev pointers,
+   * further changes are made later in g_pqueue_fix_rootlist().
+   */
+  if (root->child) {
+    g_pqueue_node_insert_after (root, root->child);
+    root->child = NULL;
+    root->degree = 0;
+  }
+
+  /* Step two:
+   * Cut root out of the list.
+   */
+  if (root->next != root) {
+    pqueue->root = root->next;
+    g_pqueue_node_cut (root);
+    /* Step three:
+     * Clean up the remaining list.
+     */
+    g_pqueue_fix_rootlist (pqueue);
+  } else {
+    pqueue->root = NULL;
+  }
+
+  g_slice_free (GPQueueNode, root);
+}
+
+/**
+ * g_pqueue_pop:
+ * @pqueue: a #GPQueue.
+ * 
+ * Removes the topmost entry from a #GPQueue and returns its data pointer.
+ * Calling this on an empty #GPQueue is not an error, but removes nothing
+ * and returns %NULL.
+ * 
+ * If you need to tell the difference between an empty queue and a queue
+ * that happens to have a %NULL pointer at the top, check if the queue is
+ * empty first.
+ * 
+ * Returns: the topmost entry's data pointer, or %NULL if the queue was empty.
+ * 
+ * Since: 2.x
+ **/
+gpointer
+g_pqueue_pop (GPQueue *pqueue)
+{
+  gpointer data;
+
+  if (pqueue->root == NULL) return NULL;
+  data = pqueue->root->data;
+  g_pqueue_remove_root (pqueue, pqueue->root);
+  return data;
+}
+
+static inline void
+g_pqueue_make_root (GPQueue *pqueue,
+                    GPQueueNode *entry)
+{
+  /* This moves a node up to the root _level_ of the structure.
+   * It does not always become the actual root element (pqueue->root).
+   */
+
+  GPQueueNode *parent;
+
+  parent = entry->parent;
+  entry->parent = NULL;
+  entry->marked = FALSE;
+  if (parent != NULL) {
+    if (entry->next != entry) {
+      if (parent->child == entry) parent->child = entry->next;
+      g_pqueue_node_cut (entry);
+      parent->degree -= 1;
+    } else {
+      parent->child = NULL;
+      parent->degree = 0;
+    }
+    g_pqueue_node_insert_before (pqueue->root, entry);
+  }
+
+  if (cmp (pqueue, entry, pqueue->root) < 0)
+    pqueue->root = entry;
+}
+
+static void
+g_pqueue_cut_tree (GPQueue *pqueue,
+                   GPQueueNode *entry)
+{
+  /* This function moves an entry up to the root level of the structure.
+   * It extends g_pqueue_make_root() in that the entry's parent, grandparent
+   * etc. may also be moved to the root level if they are "marked". This is
+   * not essential for correctness, it just maintains the so-called "potential"
+   * of the structure, which is necessary for the amortized runtime analysis.
+   */
+
+  GPQueueNode *current;
+  GPQueueNode *parent;
+
+  current = entry;
+  while ((current != NULL) && (current->parent != NULL)) {
+    parent = current->parent;
+    g_pqueue_make_root (pqueue, entry);
+    if (parent->marked) {
+      current = parent;
+    } else {
+      parent->marked = TRUE;
+      current = NULL;
+    }
+  }
+  if (cmp (pqueue, entry, pqueue->root) < 0)
+    pqueue->root = entry;
+}
+
+/**
+ * g_pqueue_remove:
+ * @pqueue: a #GPQueue.
+ * @entry: a #GPQueueHandle for an entry in @pqueue.
+ * 
+ * Removes one entry from a #GPQueue.
+ * 
+ * Make sure that @entry refers to an entry that is actually part of
+ * @pqueue at the time, otherwise the behavior of this function is
+ * undefined (expect crashes).
+ * 
+ * Since: 2.x
+ **/
+void
+g_pqueue_remove (GPQueue* pqueue,
+                 GPQueueHandle entry)
+{
+  g_pqueue_cut_tree (pqueue, entry);
+  g_pqueue_remove_root (pqueue, entry);
+}
+
+/**
+ * g_pqueue_priority_changed:
+ * @pqueue: a #GPQueue.
+ * @entry: a #GPQueueHandle for an entry in @pqueue.
+ * 
+ * Notifies the #GPQueue that the priority of one entry has changed.
+ * The internal representation is updated accordingly.
+ * 
+ * Make sure that @entry refers to an entry that is actually part of
+ * @pqueue at the time, otherwise the behavior of this function is
+ * undefined (expect crashes).
+ * 
+ * Do not attempt to change the priorities of several entries at once.
+ * Every time a single object is changed, the #GPQueue needs to be updated
+ * by calling g_pqueue_priority_changed() for that object.
+ * 
+ * Since: 2.x
+ **/
+void
+g_pqueue_priority_changed (GPQueue* pqueue,
+                           GPQueueHandle entry)
+{
+  g_pqueue_cut_tree (pqueue, entry);
+
+  if (entry->child) {
+    g_pqueue_node_insert_after (entry, entry->child);
+    entry->child = NULL;
+    entry->degree = 0;
+  }
+
+  g_pqueue_fix_rootlist (pqueue);
+}
+
+/**
+ * g_pqueue_priority_decreased:
+ * @pqueue: a #GPQueue.
+ * @entry: a #GPQueueHandle for an entry in @pqueue.
+ * 
+ * Notifies the #GPQueue that the priority of one entry has
+ * <emphasis>decreased</emphasis>.
+ * 
+ * This is a special case of g_pqueue_priority_changed(). If you are absolutely
+ * sure that the new priority of @entry is lower than it was before, you
+ * may call this function instead of g_pqueue_priority_changed().
+ * 
+ * <note>
+ *   <para>
+ *     In the current implementation, an expensive step in
+ *     g_pqueue_priority_changed() can be skipped if the new priority is known
+ *     to be lower, leading to an amortized running time of O(1) instead of
+ *     O(log n). Of course, if the priority is not actually lower, behavior
+ *     is undefined.
+ *   </para>
+ * </note>
+ * 
+ * Since: 2.x
+ **/
+void
+g_pqueue_priority_decreased (GPQueue* pqueue,
+                             GPQueueHandle entry)
+{
+  g_pqueue_cut_tree (pqueue, entry);
+}
+
+static void
+g_pqueue_node_free_all (GPQueueNode *node)
+{
+  if (node == NULL) return;
+  g_pqueue_node_free_all (node->child);
+  node->prev->next = NULL;
+  g_pqueue_node_free_all (node->next);
+  g_slice_free (GPQueueNode, node);
+}
+
+/**
+ * g_pqueue_clear:
+ * @pqueue: a #GPQueue.
+ * 
+ * Removes all entries from a @pqueue.
+ * 
+ * Since: 2.x
+ **/
+void
+g_pqueue_clear (GPQueue* pqueue)
+{
+  g_pqueue_node_free_all (pqueue->root);
+  pqueue->root = NULL;
+}
+
+/**
+ * g_pqueue_free:
+ * @pqueue: a #GPQueue.
+ * 
+ * Deallocates the memory used by @pqueue itself, but not any memory pointed
+ * to by the data pointers of its entries.
+ * 
+ * Since: 2.x
+ **/
+void
+g_pqueue_free (GPQueue* pqueue)
+{
+  g_pqueue_clear (pqueue);
+  g_slice_free (GPQueue, pqueue);
+}
+
+#define __G_PQUEUE_C__
diff --git a/src/gpqueue/gpqueue.h b/src/gpqueue/gpqueue.h
new file mode 100644
index 0000000..bb5ff35
--- /dev/null
+++ b/src/gpqueue/gpqueue.h
@@ -0,0 +1,59 @@
+/* This code was submitted for consideration to GLib by
+ * Maik Zumstrull <maik.zumstrull@rz.uni-karlsruhe.de>
+ * Need to check licensing etc.. but presume intention is
+ * LGPL, same as glib.
+ */
+
+#ifndef __G_PQUEUE_H__
+#define __G_PQUEUE_H__
+
+G_BEGIN_DECLS
+
+typedef struct _GPQueueNode GPQueueNode;
+
+/**
+ * GPQueue:
+ * 
+ * An opaque structure representing a priority queue.
+ * 
+ * Since: 2.x
+ **/
+typedef struct _GPQueue GPQueue;
+
+/**
+ * GPQueueHandle:
+ * 
+ * An opaque value representing one entry in a #GPQueue.
+ * 
+ * Since: 2.x
+ **/
+typedef GPQueueNode* GPQueueHandle;
+
+GPQueue*	g_pqueue_new			(GCompareDataFunc compare_func,
+						 gpointer *compare_userdata);
+
+void		g_pqueue_free			(GPQueue* pqueue);
+
+gboolean	g_pqueue_is_empty		(GPQueue *pqueue);
+
+GPQueueHandle	g_pqueue_push			(GPQueue *pqueue,
+						 gpointer data);
+
+gpointer	g_pqueue_peek			(GPQueue *pqueue);
+
+gpointer	g_pqueue_pop			(GPQueue *pqueue);
+
+void		g_pqueue_remove			(GPQueue* pqueue,
+						 GPQueueHandle entry);
+
+void		g_pqueue_priority_changed	(GPQueue* pqueue,
+						 GPQueueHandle entry);
+
+void		g_pqueue_priority_decreased	(GPQueue* pqueue,
+						 GPQueueHandle entry);
+
+void		g_pqueue_clear			(GPQueue* pqueue);
+
+G_END_DECLS
+
+#endif /* __G_PQUEUE_H__ */
diff --git a/src/main.c b/src/main.c
index 3c3b4d0..bb98fea 100644
--- a/src/main.c
+++ b/src/main.c
@@ -56,6 +56,7 @@
 #include "polygon.h"
 #include "gettext.h"
 #include "pcb-printf.h"
+#include "sweep.h"
 
 #include "hid/common/actions.h"
 
@@ -1869,6 +1870,7 @@ char *program_directory = 0;
 
 #include "dolists.h"
 
+#if 1
 int
 main (int argc, char *argv[])
 {
@@ -2082,11 +2084,16 @@ main (int argc, char *argv[])
           UNKNOWN (Settings.GnetlistProgram));
 #endif
 
-  gui->do_export (0);
+  // bos_test_intersections ();
+  my_cairo_test ();
+
+  // gui->do_export (0);
+
 #if HAVE_DBUS
   pcb_dbus_finish();
 #endif
 
   return (0);
 }
+#endif
