Bottom: a44fe1a4be5bbe43e7d3548e5ef08bdac88b5cc5
Top:    0ffe7a4f848c3d4f7a761e2addac8ee629c3d224
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-26 02:11:16 +0000

Add basic conical surface support


---

diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 045805b..725e08b 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -16,6 +16,10 @@ typedef struct {
   double ax, ay, az; /* Direction of the axis */
   double radius;
 
+  /* For conical surfaces */
+  bool is_conical;
+  double semi_angle;
+
   appearance *appear;
 
   /* XXX: STEP specific - breaks encapsulation */
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index bcb8d6d..1e49158 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -113,6 +113,397 @@ emit_tristrip (face3d *face)
 //  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 }
 
+
+static void
+cone_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
+{
+  double refx, refy, refz;
+  double ortx, orty, ortz;
+  double vx, vy, vz;
+  double recip_length;
+  double cosa, sina;
+
+  refx = face->rx;
+  refy = face->ry;
+  refz = face->rz;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  /* v is dot product of vector from surface origin to point, and the axis direction */
+  *v = (x - face->ox) * face->ax +
+       (y - face->oy) * face->ay +
+       (z - face->oz) * face->az;
+
+  /* Find the vector to x,y,z in the plane of the cone slice at *v */
+  vx = x - face->ox - *v * face->ax;
+  vy = y - face->oy - *v * face->ay;
+  vz = z - face->oz - *v * face->az;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (vx, vy), vz);
+  vx *= recip_length;
+  vy *= recip_length;
+  vz *= recip_length;
+
+  /* Cosine is dot product of ref (normalised) and v (normalised) */
+  cosa = refx * vx + refy * vy + refz * vz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and v (normalised) */
+  sina = ortx * vx + orty * vy + ortz * vz; // sin (phi) = cos (phi - 90)
+
+  /* U is the angle */
+  *u = atan2 (sina, cosa);
+
+  if (*u < 0.0)
+    *u += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *u *= 180. / M_PI;
+}
+
+static void
+cone_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z,
+                           float *nx, float *ny, float *nz)
+{
+  float ortx, orty, ortz;
+  double cosu, sinu;
+  double rcosu, rsinu;
+  double tana;
+  double radius;
+  double recip_length;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  cosu = cos(u / 180. * M_PI);
+  sinu = sin(u / 180. * M_PI);
+  tana = tan(face->semi_angle / 180.0 * M_PI);
+
+  radius = face->radius + v * tana;
+  rcosu = radius * cosu;
+  rsinu = radius * sinu;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + rcosu * face->rx + rsinu * ortx + v * face->ax);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + rcosu * face->ry + rsinu * orty + v * face->ay);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + rcosu * face->rz + rsinu * ortz + v * face->az);
+
+  recip_length = 1.0 / hypot (1.0, tana);
+
+  *nx =  (cosu * face->rx + sinu * ortx - tana * face->ax) * recip_length;
+  *ny = -(cosu * face->ry + sinu * orty - tana * face->ay) * recip_length; /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+  *nz =  (cosu * face->rz + sinu * ortz - tana * face->az) * recip_length;
+
+  if (face->surface_orientation_reversed != (face->radius + v * tana < 0.0))
+    {
+      *nx = -*nx;
+      *ny = -*ny;
+      *nz = -*nz;
+    }
+}
+
+static void
+cone_bo_add_edge (borast_t *bo,
+                  double lu, double lv,
+                  double  u, double  v,
+                  bool is_outer)
+{
+  /* XXX: Not absolutely sure about this! */
+  if (fabs (u - lu) > fabs (u + 360.0f - lu))
+    {
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u + 360.0f),
+                   is_outer);
+#endif
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu - 360.0f),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+#endif
+    }
+  else if (fabs (u - lu) > fabs (u - 360.0f - lu))
+    {
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u - 360.0f),
+                   is_outer);
+#endif
+#if 1
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu + 360.0f),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+#endif
+    }
+  else
+    {
+      bo_add_edge (bo,
+                   MM_TO_COORD (lv), MM_TO_COORD (lu),
+                   MM_TO_COORD ( v), MM_TO_COORD ( u),
+                   is_outer);
+    }
+
+}
+static void
+cone_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  float *uv_points;
+  int i;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  borast_t *bo;
+  borast_traps_t traps;
+  int edge_count = 0;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_conical)
+    return;
+
+  /* Count up the number of edges space is required for */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+
+          edge_ensure_linearised (e);
+          edge_count += info->num_linearised_vertices;
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+    }
+
+  /* Worst case, we need 2x number of edges, since we repeat any which span the u=0, u=360 wrap-around. */
+  bo = bo_init (2 * edge_count);
+
+  /* Throw the edges to the rasteriser */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      float fu = 0.0f, fv = 0.0f;
+      float lu = 0.0f, lv = 0.0f;
+      float u, v;
+      bool first_vertex = true;
+      bool is_outer;
+      float wobble = 0.0f;
+
+      /* XXX: How can we tell if a contour is inner or outer??? */
+      is_outer = true;
+
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              cone_xyz_to_uv (face,
+                              info->linearised_vertices[vertex_idx * 3 + 0],
+                              info->linearised_vertices[vertex_idx * 3 + 1],
+                              info->linearised_vertices[vertex_idx * 3 + 2],
+                              &u, &v);
+
+              if (first_vertex)
+                {
+                  fu = u;
+                  fv = v + wobble;
+                }
+              else
+                {
+                  cone_bo_add_edge (bo,
+                                    lu, lv,
+                                     u,  v + wobble,
+                                    is_outer);
+                }
+
+              lu = u;
+              lv = v + wobble;
+              first_vertex = false;
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      cone_bo_add_edge (bo,
+                            lu, lv,
+                            fu, fv,
+                            is_outer);
+    }
+
+  _borast_traps_init (&traps);
+  bo_tesselate_to_traps (bo, false /* Don't combine adjacent y traps */,  &traps);
+
+  bo_free (bo);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  if (num_uv_points == 0) {
+    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+  uv_points = g_new0 (float, 2 * num_uv_points);
+
+  vertex_comp = 0;
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    /* NB: ybot > ytop, as this is all derived from a screen-space rasteriser with 0,0 in the top left */
+
+    /* Exclude strips entirely above or below the 0 <= u <= 360 range */
+    if (y_bot < MM_TO_COORD (0.0f))
+      continue;
+
+    if (y_top > MM_TO_COORD (360.0f))
+      continue;
+
+    /* Clamp evaluation coordinates otherwise (strips straddling the boundary)
+     * NB: Due to input parameter-space geometry duplication, the bit we trim
+     *     here will be duplicated on the other side of the wrap-around anyway
+     */
+    y_top = MAX(MM_TO_COORD(0.0f), y_top);
+    y_bot = MIN(y_bot, MM_TO_COORD(360.0f));
+
+
+    if (face->surface_orientation_reversed)
+      {
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+    else
+      {
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+
+      num_uv_points += 6;
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
+
+      num_uv_points += 6;
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+
+      num_uv_points += 6;
+    }
+  }
+
+  _borast_traps_fini (&traps);
+
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
+
+  face->tristrip_num_vertices = num_uv_points;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
+      cone_uv_to_xyz_and_normal(face,
+                                /* uv */
+                                COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                                COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                                /* xyz */
+                                &face->tristrip_vertices[vertex_comp + 0],
+                                &face->tristrip_vertices[vertex_comp + 1],
+                                &face->tristrip_vertices[vertex_comp + 2],
+                                /* Vertex normal */
+                                &face->tristrip_vertices[vertex_comp + 3],
+                                &face->tristrip_vertices[vertex_comp + 4],
+                                &face->tristrip_vertices[vertex_comp + 5]);
+
+      vertex_comp += BUFFER_STRIDE;
+    }
+
+  g_free (uv_points);
+}
+
+
 static void
 cylinder_xyz_to_uv (face3d *face, float x, float y, float z, float *u, float *v)
 {
@@ -1145,6 +1536,10 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
     {
       cylinder_ensure_tristrip (face);
     }
+  else if (face->is_conical)
+    {
+      cone_ensure_tristrip (face);
+    }
   else
     {
       /* We only know how to deal with planar and cylindrical faces for now */
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 9d3763a..78e57a9 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -1629,7 +1629,7 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Cylindrical_Surface") == 0)
             {
-              SdaiCylindrical_surface *cylinder = dynamic_cast<SdaiCylindrical_surface *>(surface);
+              auto *cylinder = dynamic_cast<SdaiCylindrical_surface *>(surface);
 //              printf ("WARNING: cylindrical surfaces are not supported yet\n");
 
               unpack_axis_geom (cylinder->position_ (),
@@ -1673,7 +1673,50 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Conical_Surface") == 0)
             {
+              auto *cone = dynamic_cast<SdaiConical_surface *>(surface);
 //              printf ("WARNING: conical surfaces are not supported yet\n");
+
+              unpack_axis_geom (cone->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_conical = true;
+              info->current_face->radius = cone->radius_ ();
+              /* XXX: Need to check the coordinate reference frames... testing currently against a file which uses radians */
+              info->current_face->semi_angle = cone->semi_angle_ () * 180. / M_PI;
+              printf ("Semi-angle = %f\n", info->current_face->semi_angle);
+
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
+                {
+                  info->current_face->surface_orientation_reversed = true;
+                }
+
             }
           else if (strcmp (surface->EntityName (), "Toroidal_Surface") == 0)
             {
