Bottom: e50662d85204030c3b639416893dde63a52cfdcd
Top:    aed814b0a1224ea817b91a93274fa57f4ea65195
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-04 19:24:22 +0000

Attempt at supporting arc-arc intersections in polygons

XXX: Looks like square pad clearance polygons might have extra un-necessary nodes?


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 47b171d..b6db56c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -40,6 +40,10 @@ PCB_SRCS = \
 	buffer.h \
 	change.c \
 	change.h \
+	circle_circle_intersect.c \
+	circle_circle_intersect.h \
+	circle_line_intersect.c \
+	circle_line_intersect.h \
 	clip.c \
 	clip.h \
 	compat.c \
diff --git a/src/circle_circle_intersect.c b/src/circle_circle_intersect.c
new file mode 100644
index 0000000..8ac5c01
--- /dev/null
+++ b/src/circle_circle_intersect.c
@@ -0,0 +1,118 @@
+/* circle_circle_intersection() *
+ * Determine the points where 2 circles in a common plane intersect.
+ *
+ * int circle_circle_intersection(
+ *                                // center and radius of 1st circle
+ *                                double x0, double y0, double r0,
+ *                                // center and radius of 2nd circle
+ *                                double x1, double y1, double r1,
+ *                                // 1st intersection point
+ *                                double *xi, double *yi,
+ *                                // 2nd intersection point
+ *                                double *xi_prime, double *yi_prime)
+ *
+ * This is a public domain work. 3/26/2005 Tim Voght
+ *
+ * Distinct return code for the single intersection case added by Peter Clifton 2014-07-05
+ *
+ */
+#include <stdio.h>
+#include <math.h>
+
+#define EPSILON (1e-8)
+
+
+int circle_circle_intersect (double x0, double y0, double r0,
+                             double x1, double y1, double r1,
+                             double *xi, double *yi,
+                             double *xi_prime, double *yi_prime)
+{
+  double a, dx, dy, d, h, rx, ry;
+  double x2, y2;
+
+  /* dx and dy are the vertical and horizontal distances between
+   * the circle centers.
+   */
+  dx = x1 - x0;
+  dy = y1 - y0;
+
+  /* Determine the straight-line distance between the centers. */
+  //d = sqrt((dy*dy) + (dx*dx));
+  d = hypot(dx,dy); // Suggested by Keith Briggs
+
+  /* Check for solvability. */
+  if (d > (r0 + r1))
+  {
+    /* no solution. circles do not intersect. */
+    return 0;
+  }
+  if (d < fabs(r0 - r1))
+  {
+    /* no solution. one circle is contained in the other */
+    return 0;
+  }
+
+  /* 'point 2' is the point where the line through the circle
+   * intersection points crosses the line between the circle
+   * centers.
+   */
+
+  /* Determine the distance from point 0 to point 2. */
+  a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
+
+  /* Determine the coordinates of point 2. */
+  x2 = x0 + (dx * a/d);
+  y2 = y0 + (dy * a/d);
+
+  /* Determine the distance from point 2 to either of the
+   * intersection points.
+   */
+  h = sqrt((r0*r0) - (a*a));
+
+  /* Now determine the offsets of the intersection points from
+   * point 2.
+   */
+  rx = -dy * (h/d);
+  ry = dx * (h/d);
+
+  /* Determine the absolute intersection points. */
+  *xi = x2 + rx;
+  *yi = y2 + ry;
+
+  if (fabs(h) < EPSILON)
+    return 1;
+
+  *xi_prime = x2 - rx;
+  *yi_prime = y2 - ry;
+
+  return 2;
+}
+
+#undef TEST
+
+#ifdef TEST
+
+void run_test(double x0, double y0, double r0,
+              double x1, double y1, double r1)
+{
+  double x3, y3, x3_prime, y3_prime;
+
+  printf("x0=%F, y0=%F, r0=%F, x1=%F, y1=%F, r1=%F :\n",
+          x0, y0, r0, x1, y1, r1);
+  circle_circle_intersection(x0, y0, r0, x1, y1, r1,
+                             &x3, &y3, &x3_prime, &y3_prime);
+  printf("  x3=%F, y3=%F, x3_prime=%F, y3_prime=%F\n",
+            x3, y3, x3_prime, y3_prime);
+}
+
+int main(void)
+{
+  /* Add more! */
+  run_test(-1.0, -1.0, 1.5, 1.0, 1.0, 2.0);
+  run_test(1.0, -1.0, 1.5, -1.0, 1.0, 2.0);
+  run_test(-1.0, 1.0, 1.5, 1.0, -1.0, 2.0);
+  run_test(1.0, 1.0, 1.5, -1.0, -1.0, 2.0);
+  exit(0);
+}
+#endif
+
diff --git a/src/circle_circle_intersect.h b/src/circle_circle_intersect.h
new file mode 100644
index 0000000..33289ef
--- /dev/null
+++ b/src/circle_circle_intersect.h
@@ -0,0 +1,4 @@
+int circle_circle_intersect (double x0, double y0, double r0,
+                             double x1, double y1, double r1,
+                             double *xi, double *yi,
+                             double *xi_prime, double *yi_prime);
diff --git a/src/circle_line_intersect.c b/src/circle_line_intersect.c
new file mode 100644
index 0000000..b008572
--- /dev/null
+++ b/src/circle_line_intersect.c
@@ -0,0 +1,68 @@
+/* Based on raysphere.c from:
+ * http://paulbourke.net/geometry/circlesphere/index.html#linesphere
+ *
+ * Converted to PCB coordinate types, and line/circle intersection in 2D
+ * by Peter Clifton 2014-07-05
+ */
+
+#include <math.h>
+
+#define EPSILON (1e-8)
+
+/*
+ * Calculate the intersection of a ray and a sphere
+ * The line segment is defined from p1 to p2
+ * The sphere is of radius r and centered at sc
+ * There are potentially two points of intersection given by
+ * p = p1 + mu1 (p2 - p1)
+ * p = p1 + mu2 (p2 - p1)
+ *
+ * Return 0 if the ray doesn't intersect the circle.
+ * Return 1 if the ray touches the circle at a single point.
+ * Return 2 if the ray intersects the circle.
+ */
+int
+circle_line_intersect (double cx, double cy, double r,
+                       double p1x, double p1y, double p2x, double p2y,
+                       double *mu1, double *mu2)
+{
+   double a,b,c;
+   double bb4ac;
+   double dpx;
+   double dpy;
+
+   dpx = p2x - p1x;
+   dpy = p2y - p1y;
+   a = dpx * dpx + dpy * dpy;
+   b = 2 * (dpx * (p1x - cx) + dpy * (p1y - cy));
+   c = cx * cx + cy * cy;
+   c += p1x * p1x + p1y * p1y;
+   c -= 2 * (cx * p1x + cy * p1y);
+   c -= r * r;
+   bb4ac = b * b - 4 * a * c;
+
+   if (fabs(a) < EPSILON)
+    {
+      *mu1 = 0;
+      *mu2 = 0;
+      return 0;
+    }
+
+   if (fabs(bb4ac) < EPSILON) {
+      *mu1 = -b / (2 * a);
+      *mu2 = 0;
+      return 1;
+   }
+
+   if (bb4ac < 0)
+    {
+      *mu1 = 0;
+      *mu2 = 0;
+      return 0;
+    }
+
+   *mu1 = (-b + sqrt(bb4ac)) / (2 * a);
+   *mu2 = (-b - sqrt(bb4ac)) / (2 * a);
+
+   return 2;
+}
diff --git a/src/circle_line_intersect.h b/src/circle_line_intersect.h
new file mode 100644
index 0000000..c7920d2
--- /dev/null
+++ b/src/circle_line_intersect.h
@@ -0,0 +1,3 @@
+int circle_line_intersect (double cx, double cy, double r,
+                           double p1x, double p1y, double p2x, double p2y,
+                           double *mu1, double *mu2);
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 3c1cee1..8bdb180 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -189,6 +189,17 @@ thindraw_contour (hidGC gc, PLINE *pl)
             hid_draw_fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
           else
             hid_draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
+
+          /* Draw the bounding box for arg segments */
+          if (0)
+            {
+              BoxType *bound = get_seg_bounds (pl, v->prev);
+
+              hid_draw_line (gc, bound->X1, bound->Y1, bound->X2, bound->Y1);
+              hid_draw_line (gc, bound->X2, bound->Y1, bound->X2, bound->Y2);
+              hid_draw_line (gc, bound->X2, bound->Y2, bound->X1, bound->Y2);
+              hid_draw_line (gc, bound->X1, bound->Y2, bound->X1, bound->Y1);
+            }
         }
       else
         {
diff --git a/src/polygon.c b/src/polygon.c
index 2bca1f3..6425c5e 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -112,7 +112,7 @@ dicer output is used for HIDs which cannot render things with holes
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 10
+#define UNSUBTRACT_BLOAT 100 /*10*/
 #define SUBTRACT_PIN_VIA_BATCH_SIZE 100
 #define SUBTRACT_LINE_BATCH_SIZE 20
 
diff --git a/src/polygon.h b/src/polygon.h
index 0643765..d47b1fc 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -106,4 +106,6 @@ void NoHolesPolygonDicer (PolygonType *p, const BoxType *clip,
                           void (*emit) (PLINE *, void *), void *user_data);
 void PolyToPolygonsOnLayer (DataType *, LayerType *, POLYAREA *, FlagType);
 POLYAREA *board_outline_poly (bool include_holes);
+
+BoxType *get_seg_bounds (PLINE *contour, VNODE *node);
 #endif
diff --git a/src/polygon1.c b/src/polygon1.c
index bb4d4af..63d4790 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -50,10 +50,13 @@
 #include "rtree.h"
 #include "heap.h"
 #include "pcb-printf.h"
+#include "misc.h"
+#include "circle_line_intersect.h"
+#include "circle_circle_intersect.h"
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
-#define EPSILON (1E-8)
+#define EPSILON (1E-6)
 #define IsZero(a, b) (fabs((a) - (b)) < EPSILON)
 
 /*********************************************************************/
@@ -239,12 +242,25 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
-/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
-  if (vect_equal (po, EDGE_BACKWARD_VERTEX (dest)->point))
-    return EDGE_BACKWARD_VERTEX (dest);
-  if (vect_equal (po, EDGE_FORWARD_VERTEX (dest)->point))
-    return EDGE_FORWARD_VERTEX (dest);
-  p = poly_CreateNode (po);
+  pcb_printf ("  New node is %f from previous, %f from next",
+              vect_dist2 (po, dest->point),
+              vect_dist2 (po, dest->next->point));
+
+#warning NOT SURE WHAT A SENSIBLE EPSILON IN INTEGER NANOMETERS IS - INCORRECT NUMBERS ONE WAY OR THE OTHER CAUSE BREAKAGE
+  if (vect_dist2 (po, EDGE_BACKWARD_VERTEX (dest)->point) < 3.)
+    {
+      printf ("\n");
+      return EDGE_BACKWARD_VERTEX (dest);
+    }
+  if (vect_dist2 (po, EDGE_FORWARD_VERTEX (dest)->point) < 3.)
+    {
+      printf ("\n");
+      return EDGE_FORWARD_VERTEX (dest);
+    }
+
+  printf (" - (CREATING NEW NODE AND EDGE)\n");
+
+  p = poly_CreateNodeFull (po, dest->is_round, dest->cx, dest->cy, dest->radius);
   if (p == NULL)
     return NULL;
   p->cvc_prev = p->cvc_next = NULL;
@@ -662,7 +678,7 @@ typedef struct info
   VNODE *v;
   struct seg *s;
   jmp_buf *env, sego, *touch;
-  int need_restart;
+//  int need_restart;
   insert_node_task *node_insert_list;
   bool debug;
 } info;
@@ -672,7 +688,7 @@ typedef struct contour_info
   PLINE *pa;
   jmp_buf restart;
   jmp_buf *getout;
-  int need_restart;
+//  int need_restart;
   insert_node_task *node_insert_list;
 } contour_info;
 
@@ -698,6 +714,31 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q->box.X2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (q->v)->point[0]) + 1;
   q->box.Y1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]);
   q->box.Y2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]) + 1;
+
+  if (q->v->is_round)
+    {
+      Angle start_angle;
+      Angle end_angle;
+      Angle delta_angle;
+      BoxType arc_bound;
+
+      start_angle = atan2 ((EDGE_BACKWARD_VERTEX (q->v)->point[1] - q->v->cy), -(EDGE_BACKWARD_VERTEX (q->v)->point[0] - q->v->cx)) / M180;
+      end_angle   = atan2 (( EDGE_FORWARD_VERTEX (q->v)->point[1] - q->v->cy), -( EDGE_FORWARD_VERTEX (q->v)->point[0] - q->v->cx)) / M180;
+
+#warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+      delta_angle = end_angle - start_angle;
+
+      if (delta_angle > 180.) delta_angle -= 360.;
+      if (delta_angle < -180.) delta_angle += 360.;
+
+      arc_bound = calc_thin_arc_bounds (q->v->cx, q->v->cy, q->v->radius, q->v->radius, start_angle, delta_angle);
+
+      MAKEMIN (q->box.X1, arc_bound.X1);
+      MAKEMIN (q->box.Y1, arc_bound.Y1);
+      MAKEMAX (q->box.X2, arc_bound.X2);
+      MAKEMAX (q->box.Y2, arc_bound.Y2);
+    }
+
   r_insert_entry (tree, (const BoxType *) q, 1);
   q = (seg *)malloc (sizeof (struct seg));
   if (!q)
@@ -709,6 +750,31 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q->box.X2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[0], EDGE_FORWARD_VERTEX (q->v)->point[0]) + 1;
   q->box.Y1 = min (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]);
   q->box.Y2 = max (EDGE_BACKWARD_VERTEX (q->v)->point[1], EDGE_FORWARD_VERTEX (q->v)->point[1]) + 1;
+
+  if (q->v->is_round)
+    {
+      Angle start_angle;
+      Angle end_angle;
+      Angle delta_angle;
+      BoxType arc_bound;
+
+      start_angle = atan2 ((EDGE_BACKWARD_VERTEX (q->v)->point[1] - q->v->cy), -(EDGE_BACKWARD_VERTEX (q->v)->point[0] - q->v->cx)) / M180;
+      end_angle   = atan2 (( EDGE_FORWARD_VERTEX (q->v)->point[1] - q->v->cy), -( EDGE_FORWARD_VERTEX (q->v)->point[0] - q->v->cx)) / M180;
+
+#warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+      delta_angle = end_angle - start_angle;
+
+      if (delta_angle > 180.) delta_angle -= 360.;
+      if (delta_angle < -180.) delta_angle += 360.;
+
+      arc_bound = calc_thin_arc_bounds (q->v->cx, q->v->cy, q->v->radius, q->v->radius, start_angle, delta_angle);
+
+      MAKEMIN (q->box.X1, arc_bound.X1);
+      MAKEMIN (q->box.Y1, arc_bound.Y1);
+      MAKEMAX (q->box.X2, arc_bound.X2);
+      MAKEMAX (q->box.Y2, arc_bound.Y2);
+    }
+
   r_insert_entry (tree, (const BoxType *) q, 1);
   r_delete_entry (tree, (const BoxType *) s);
   return 0;
@@ -749,6 +815,249 @@ prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
   return task;
 }
 
+static bool
+insert_vertex_in_seg (struct info *i, struct seg *s, Vector v)
+{
+  VNODE *new_node = node_add_single_point (s->v, v);
+  if (new_node == NULL)
+    return false;
+
+#ifdef DEBUG_INTERSECT
+  DEBUGP ("new intersection on segment \"i\" at %#mD\n", v[0], v[1]);
+#endif
+  i->node_insert_list = prepend_insert_node_task (i->node_insert_list, s, new_node);
+  s->intersected = 1;
+  return true;
+}
+
+static int
+seg_in_seg_line_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  Vector v1, v2;
+  int cnt;
+
+  assert (!s1->v->is_round);
+  assert (!s2->v->is_round);
+
+  cnt = vect_inters2 (EDGE_BACKWARD_VERTEX (s1->v)->point, EDGE_FORWARD_VERTEX (s1->v)->point,
+                      EDGE_BACKWARD_VERTEX (s2->v)->point, EDGE_FORWARD_VERTEX (s2->v)->point, v1, v2);
+
+  printf ("Intersecting\n");
+
+  pcb_printf ("  Line   %p (%mm, %mm)-(%mm, %mm)\n",
+              s1->v,
+              EDGE_BACKWARD_VERTEX (s1->v)->point[0],
+              EDGE_BACKWARD_VERTEX (s1->v)->point[1],
+              EDGE_FORWARD_VERTEX (s1->v)->point[0],
+              EDGE_FORWARD_VERTEX (s1->v)->point[1]);
+
+  pcb_printf ("  Line   %p (%mm, %mm)-(%mm, %mm) - intersect count is %i\n",
+              s2->v,
+              EDGE_BACKWARD_VERTEX (s2->v)->point[0],
+              EDGE_BACKWARD_VERTEX (s2->v)->point[1],
+              EDGE_FORWARD_VERTEX (s2->v)->point[0],
+              EDGE_FORWARD_VERTEX (s2->v)->point[1],
+              cnt);
+
+  if (cnt == 0)
+    {
+      printf ("\n");
+      return 0;
+    }
+
+  if (i->touch)  /* if checking touches one find and we're done */
+    longjmp (*i->touch, TOUCHES);
+
+  /* Mark the contour PLINEs as intersected */
+  s1->p->Flags.status = ISECTED;
+  s2->p->Flags.status = ISECTED;
+
+  for (; cnt; cnt--)
+    {
+      bool done_insert_on_s1 = insert_vertex_in_seg (i, s1, cnt > 1 ? v2 : v1); /* Was s2 */
+      bool done_insert_on_s2 = insert_vertex_in_seg (i, s2, cnt > 1 ? v2 : v1); /* Was s1 */
+
+      printf ("\n");
+
+      /* Skip any remaining r_search hits against segment i, as any futher
+       * intersections will be rejected until the next pass anyway.
+       */
+      if ((done_insert_on_s1 && s1 == i->s) ||
+          (done_insert_on_s2 && s2 == i->s))
+        longjmp (*i->env, 1);
+
+      /* If we inserted on s (but not i), skip return now, as we can't continue with
+       * the for-loop iteration if we modified geoemtry
+       */
+      if (done_insert_on_s1 || done_insert_on_s2)
+        return 0;
+    }
+
+  return 0;
+}
+
+static int
+seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  double m1, m2;
+  Vector v1, v2;
+  int cnt;
+  Angle start_angle;
+  Angle end_angle;
+  Angle delta_angle;
+
+  assert (s1->v->is_round);
+  assert (!s2->v->is_round);
+
+  cnt = circle_line_intersect ((double)s1->v->cx, (double)s1->v->cy, (double)s1->v->radius,
+                               (double)EDGE_BACKWARD_VERTEX (s2->v)->point[0], (double)EDGE_BACKWARD_VERTEX (s2->v)->point[1],
+                               (double) EDGE_FORWARD_VERTEX (s2->v)->point[0], (double) EDGE_FORWARD_VERTEX (s2->v)->point[1],
+                               &m1, &m2);
+  if (cnt == 0)
+    return 0;
+
+  start_angle = atan2 ((EDGE_BACKWARD_VERTEX (s1->v)->point[1] - s1->v->cy), -(EDGE_BACKWARD_VERTEX (s1->v)->point[0] - s1->v->cx)) / M180;
+  end_angle   = atan2 (( EDGE_FORWARD_VERTEX (s1->v)->point[1] - s1->v->cy), -( EDGE_FORWARD_VERTEX (s1->v)->point[0] - s1->v->cx)) / M180;
+
+  #warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+  delta_angle = end_angle - start_angle;
+
+  if (delta_angle > 180.) delta_angle -= 360.;
+  if (delta_angle < -180.) delta_angle += 360.;
+
+  printf ("Intersecting\n");
+
+  pcb_printf ("  circle %p (%mm, %mm) R=%mm, start_angle=%f, end_angle=%f, delta_angle=%f\n",
+              s1->v, s1->v->cx, s1->v->cy, s1->v->radius, start_angle, end_angle, delta_angle);
+
+  pcb_printf ("  Line   %p (%mm, %mm)-(%mm, %mm) - intersect count is %i\n",
+              s2->v,
+              EDGE_BACKWARD_VERTEX (s2->v)->point[0],
+              EDGE_BACKWARD_VERTEX (s2->v)->point[1],
+              EDGE_FORWARD_VERTEX (s2->v)->point[0],
+              EDGE_FORWARD_VERTEX (s2->v)->point[1],
+              cnt);
+
+  if (cnt == 2)
+    {
+      if (m2 < 0. - EPSILON || m2 > 1. + EPSILON)
+        {
+          printf ("  Second intersection is out of line bounds, m2 = %f\n", m2);
+          cnt--;
+        }
+      else
+        /* Process whether the m2 intersection lies on the arc */
+        {
+          Angle m2_angle;
+          Angle m2_delta;
+
+          Vcopy (v2, s2->v->point);
+          v2[0] += m2 * (EDGE_FORWARD_VERTEX (s2->v)->point[0] - EDGE_BACKWARD_VERTEX (s2->v)->point[0]);
+          v2[1] += m2 * (EDGE_FORWARD_VERTEX (s2->v)->point[1] - EDGE_BACKWARD_VERTEX (s2->v)->point[1]);
+
+          m2_angle = atan2 ((v2[1] - s1->v->cy), -(v2[0] - s1->v->cx)) / M180;
+          m2_delta = m2_angle - start_angle;
+
+          if (m2_delta > 180.) m2_delta -= 360.;
+          if (m2_delta < -180.) m2_delta += 360.;
+
+          pcb_printf ("  Second intersection is at (%mm, %mm), angle %f\n", v2[0], v2[1], m2_angle);
+
+          if ((delta_angle > 0. && ( m2_delta < 0. - EPSILON ||  m2_delta >  delta_angle + EPSILON)) ||
+              (delta_angle < 0. && (-m2_delta < 0. - EPSILON || -m2_delta > -delta_angle + EPSILON)))
+            {
+              printf ("  Excluding second intersection, as not on arc, m2_angle=%f m2_delta=%f, delta_angle=%f\n",
+                      m2_angle, m2_delta, delta_angle);
+              cnt --;
+            }
+        }
+    }
+
+  if (m1 < 0. - EPSILON || m1 > 1. + EPSILON)
+    {
+      printf ("  First intersection is out of line bounds, m1 = %f\n", m1);
+      cnt--;
+      m1 = m2;
+      Vcopy (v1, v2);
+    }
+  else
+    {
+      Angle m1_angle;
+      Angle m1_delta;
+
+      Vcopy (v1, s2->v->point);
+      v1[0] += m1 * (EDGE_FORWARD_VERTEX (s2->v)->point[0] - EDGE_BACKWARD_VERTEX (s2->v)->point[0]);
+      v1[1] += m1 * (EDGE_FORWARD_VERTEX (s2->v)->point[1] - EDGE_BACKWARD_VERTEX (s2->v)->point[1]);
+
+      m1_angle = atan2 ((v1[1] - s1->v->cy), -(v1[0] - s1->v->cx)) / M180;
+      m1_delta = m1_angle - start_angle;
+
+      if (m1_delta > 180.) m1_delta -= 360.;
+      if (m1_delta < -180.) m1_delta += 360.;
+
+      pcb_printf ("  First intersection is at (%mm, %mm), angle %f\n", v1[0], v1[1], m1_angle);
+
+      if ((delta_angle > 0. && ( m1_delta < 0. - EPSILON ||  m1_delta >  delta_angle + EPSILON)) ||
+          (delta_angle < 0. && (-m1_delta < 0. - EPSILON || -m1_delta > -delta_angle + EPSILON)))
+        {
+          printf ("  Excluding first intersection, as not on arc, m1_angle=%f m1_delta=%f, delta_angle=%f\n",
+                  m1_angle, m1_delta, delta_angle);
+          cnt --;
+          m1 = m2;
+          Vcopy (v1, v2);
+        }
+    }
+
+  /* Process whether the m1 intersection lies on the arc */
+
+  if (cnt == 0)
+    {
+      printf ("\n");
+      return 0;
+    }
+
+  if (i->touch)  /* if checking touches one find and we're done */
+    longjmp (*i->touch, TOUCHES);
+
+  /* Mark the contour PLINEs as intersected */
+  s1->p->Flags.status = ISECTED;
+  s2->p->Flags.status = ISECTED;
+
+  for (; cnt; cnt--)
+    {
+      bool done_insert_on_s1 = insert_vertex_in_seg (i, s1, cnt > 1 ? v2 : v1); /* Was s2 */
+      bool done_insert_on_s2 = insert_vertex_in_seg (i, s2, cnt > 1 ? v2 : v1); /* Was s1 */
+
+      printf ("\n");
+
+      /* Skip any remaining r_search hits against segment i, as any futher
+       * intersections will be rejected until the next pass anyway.
+       */
+      if ((done_insert_on_s1 && s1 == i->s) ||
+          (done_insert_on_s2 && s2 == i->s))
+        longjmp (*i->env, 1);
+
+      /* If we inserted on s (but not i), skip return now, as we can't continue with
+       * the for-loop iteration if we modified geoemtry
+       */
+      if (done_insert_on_s1 || done_insert_on_s2)
+        return 0;
+    }
+
+  return 0;
+}
+
+static int
+seg_in_seg_arc_arc (struct info *i, struct seg *s1, struct seg *s2)
+{
+  assert (s1->v->is_round);
+  assert (s2->v->is_round);
+
+//  printf ("Querying arc-arc intersection\n");
+  /* COP OUT */
+  return seg_in_seg_line_line (i, s1, s2);
+}
+
 /*
  * seg_in_seg()
  * (C) 2006 harry eaton
@@ -764,60 +1073,24 @@ static int
 seg_in_seg (const BoxType * b, void *cl)
 {
   struct info *i = (struct info *) cl;
-  struct seg *s = (struct seg *) b;
-  Vector s1, s2;
-  int cnt;
-  VNODE *new_node;
+  struct seg *s1 = (struct seg *) b;
+  struct seg *s2 = i->s;
 
   /* When new nodes are added at the end of a pass due to an intersection
    * the segments may be altered. If either segment we're looking at has
    * already been intersected this pass, skip it until the next pass.
    */
-  if (s->intersected || i->s->intersected)
+  if (s1->intersected || s2->intersected)
     return 0;
 
-  cnt = vect_inters2 (EDGE_BACKWARD_VERTEX (s->v)->point, EDGE_FORWARD_VERTEX (s->v)->point,
-		      EDGE_BACKWARD_VERTEX (i->v)->point, EDGE_FORWARD_VERTEX (i->v)->point, s1, s2);
-  if (!cnt)
-    return 0;
-  if (i->touch)			/* if checking touches one find and we're done */
-    longjmp (*i->touch, TOUCHES);
-  i->s->p->Flags.status = ISECTED;
-  s->p->Flags.status = ISECTED;
-  for (; cnt; cnt--)
-    {
-      bool done_insert_on_i = false;
-      new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"i\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, i->s, new_node);
-	  i->s->intersected = 1;
-	  done_insert_on_i = true;
-	}
-      new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"s\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, s, new_node);
-	  s->intersected = 1;
-	  return 0; /* Keep looking for intersections with segment "i" */
-	}
-      /* Skip any remaining r_search hits against segment i, as any futher
-       * intersections will be rejected until the next pass anyway.
-       */
-      if (done_insert_on_i)
-	longjmp (*i->env, 1);
-    }
-  return 0;
+  if (s1->v->is_round && s2->v->is_round)
+    return seg_in_seg_arc_arc (i, s1, s2);
+  else if (s1->v->is_round)
+    return seg_in_seg_arc_line (i, s1, s2);
+  else if (s2->v->is_round)
+    return seg_in_seg_arc_line (i, s2, s1);
+  else
+    return seg_in_seg_line_line (i, s1, s2);
 }
 
 static void *
@@ -831,26 +1104,36 @@ make_edge_tree (PLINE * pb)
     {
       s = (seg *)malloc (sizeof (struct seg));
       s->intersected = 0;
-      if (EDGE_BACKWARD_VERTEX (bv)->point[0] < EDGE_FORWARD_VERTEX (bv)->point[0])
-	{
-	  s->box.X1 = EDGE_BACKWARD_VERTEX (bv)->point[0];
-	  s->box.X2 = EDGE_FORWARD_VERTEX (bv)->point[0] + 1;
-	}
-      else
-	{
-	  s->box.X2 = EDGE_BACKWARD_VERTEX (bv)->point[0] + 1;
-	  s->box.X1 = EDGE_FORWARD_VERTEX (bv)->point[0];
-	}
-      if (EDGE_BACKWARD_VERTEX (bv)->point[1] < EDGE_FORWARD_VERTEX (bv)->point[1])
-	{
-	  s->box.Y1 = EDGE_BACKWARD_VERTEX (bv)->point[1];
-	  s->box.Y2 = EDGE_FORWARD_VERTEX (bv)->point[1] + 1;
-	}
-      else
-	{
-	  s->box.Y2 = EDGE_BACKWARD_VERTEX (bv)->point[1] + 1;
-	  s->box.Y1 = EDGE_FORWARD_VERTEX (bv)->point[1];
-	}
+
+      s->box.X1 = MIN (EDGE_BACKWARD_VERTEX (bv)->point[0], EDGE_FORWARD_VERTEX (bv)->point[0]);
+      s->box.X2 = MAX (EDGE_BACKWARD_VERTEX (bv)->point[0], EDGE_FORWARD_VERTEX (bv)->point[0]) + 1;
+      s->box.Y1 = MIN (EDGE_BACKWARD_VERTEX (bv)->point[1], EDGE_FORWARD_VERTEX (bv)->point[1]);
+      s->box.Y2 = MAX (EDGE_BACKWARD_VERTEX (bv)->point[1], EDGE_FORWARD_VERTEX (bv)->point[1]) + 1;
+
+      if (bv->is_round)
+        {
+          Angle start_angle;
+          Angle end_angle;
+          Angle delta_angle;
+          BoxType arc_bound;
+
+          start_angle = atan2 ((EDGE_BACKWARD_VERTEX (bv)->point[1] - bv->cy), -(EDGE_BACKWARD_VERTEX (bv)->point[0] - bv->cx)) / M180;
+          end_angle   = atan2 (( EDGE_FORWARD_VERTEX (bv)->point[1] - bv->cy), -( EDGE_FORWARD_VERTEX (bv)->point[0] - bv->cx)) / M180;
+
+#warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          arc_bound = calc_thin_arc_bounds (bv->cx, bv->cy, bv->radius, bv->radius, start_angle, delta_angle);
+
+          MAKEMIN (s->box.X1, arc_bound.X1);
+          MAKEMIN (s->box.Y1, arc_bound.Y1);
+          MAKEMAX (s->box.X2, arc_bound.X2);
+          MAKEMAX (s->box.Y2, arc_bound.Y2);
+        }
+
       s->v = bv;
       s->p = pb;
       r_insert_entry (ans, (const BoxType *) s, 1);
@@ -908,7 +1191,7 @@ contour_bounds_touch (const BoxType * b, void *cl)
   /* Have seg_in_seg return to our desired location if it touches */
   info.env = &restart;
   info.touch = c_info->getout;
-  info.need_restart = 0;
+//  info.need_restart = 0;
   info.node_insert_list = c_info->node_insert_list;
 
   /* Pick which contour has the fewer points, and do the loop
@@ -969,8 +1252,8 @@ contour_bounds_touch (const BoxType * b, void *cl)
   while ((av = NEXT_EDGE (av)) != &looping_over->head);
 
   c_info->node_insert_list = info.node_insert_list;
-  if (info.need_restart)
-    c_info->need_restart = 1;
+//  if (info.need_restart)
+//    c_info->need_restart = 1;
   return 0;
 }
 
@@ -982,7 +1265,7 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
   contour_info c_info;
   int need_restart = 0;
   insert_node_task *task;
-  c_info.need_restart = 0;
+//  c_info.need_restart = 0;
   c_info.node_insert_list = NULL;
 
   /* Search the r-tree of the object with most contours
@@ -1022,8 +1305,8 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.Y2 = pa->ymax + 1;
 
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
-      if (c_info.need_restart)
-	need_restart = 1;
+//      if (c_info.need_restart)
+//	need_restart = 1;
     }
 
   /* Process any deferred node insersions */
@@ -1032,9 +1315,6 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
-      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-      task->node_seg->v->is_round = false;
-
       /* Do insersion */
       PREV_VERTEX (task->new_node) = EDGE_BACKWARD_VERTEX (task->node_seg->v);
       NEXT_VERTEX (task->new_node) = EDGE_FORWARD_VERTEX (task->node_seg->v);
@@ -1042,13 +1322,14 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       EDGE_FORWARD_VERTEX (task->node_seg->v) = task->new_node;
       task->node_seg->p->Count++;
 
-      if (cntrbox_check (task->node_seg->p, task->new_node->point))
+#warning NEED AN UPDATE FOR ROUND CONTOURS HERE?
+      if (cntrbox_check (task->node_seg->p, task->new_node->point)) /* XXX: DOES THIS WORK / MATTER FOR ARC SEGMENT INSERTIONS? */
         {
           /* First delete the contour from the contour r-tree, as its bounds
            * may be adjusted whilst inserting nodes
            */
           r_delete_entry (b->contour_tree, (const BoxType *) task->node_seg->p);
-          cntrbox_adjust (task->node_seg->p, task->new_node->point);
+          cntrbox_adjust (task->node_seg->p, task->new_node->point); /* XXX: DOES THIS WORK / MATTER FOR ARC SEGMENT INSERTIONS? */
           r_insert_entry (b->contour_tree, (const BoxType *) task->node_seg->p, 0);
         }
 
@@ -3157,6 +3438,7 @@ poly_NewContour (VNODE *node)
   res->head.cx = node->cx;
   res->head.cy = node->cy;
   res->head.radius = node->radius;
+#warning THIS WILL BE BOGUS IF WE GET A CIRCULAR CONTOUR STARTING AT THE HEAD.. NEED 2ND POINT TO DETMERMINE BOUNDS
   cntrbox_adjust (res, res->head.point);
   g_slice_free (VNODE, node);
 
@@ -3217,7 +3499,7 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 {
   double area = 0;
   VNODE *p, *c;
-  Vector p1, p2;
+//  Vector p1, p2;
 
   assert (C != NULL);
 
@@ -3226,15 +3508,17 @@ poly_PreContour (PLINE * C, BOOLp optimize)
       for (c = NEXT_VERTEX ((p = &C->head)); c != &C->head; c = NEXT_VERTEX (p = c))
 	{
 	  /* if the previous node is on the same line with this one, we should remove it */
-	  Vsub2 (p1, c->point, p->point);
-	  Vsub2 (p2, NEXT_VERTEX (c)->point, c->point);
+//	  Vsub2 (p1, c->point, p->point);
+//	  Vsub2 (p2, NEXT_VERTEX (c)->point, c->point);
 	  /* If the product below is zero then
 	   * the points on either side of c 
 	   * are on the same line!
 	   * So, remove the point c
 	   */
 
-	  if (vect_det2 (p1, p2) == 0)
+#warning BROKEN FOR CIRCULAR CONTOURS
+//	  if (vect_det2 (p1, p2) == 0)
+          if (0)
 	    {
 	      poly_ExclVertex (c);
 	      g_slice_free (VNODE, c);
@@ -3255,7 +3539,31 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 	  area +=
 	    (double) (p->point[0] - c->point[0]) * (p->point[1] +
 						    c->point[1]);
+#warning NEED TO CATER FOR A ROUND SEGMENT
 	  cntrbox_adjust (C, c->point);
+          if (p->is_round)
+            {
+              Angle start_angle;
+              Angle end_angle;
+              Angle delta_angle;
+              BoxType arc_bound;
+
+              start_angle = atan2 ((p->point[1] - p->cy), -(p->point[0] - p->cx)) / M180;
+              end_angle   = atan2 ((c->point[1] - p->cy), -(c->point[0] - p->cx)) / M180;
+
+#warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+              delta_angle = end_angle - start_angle;
+
+              if (delta_angle > 180.) delta_angle -= 360.;
+              if (delta_angle < -180.) delta_angle += 360.;
+
+              arc_bound = calc_thin_arc_bounds (p->cx, p->cy, p->radius, p->radius, start_angle, delta_angle);
+
+              C->xmin = min (C->xmin, arc_bound.X1);
+              C->xmax = max (C->xmax, arc_bound.X2);
+              C->ymin = min (C->ymin, arc_bound.Y1);
+              C->ymax = max (C->ymax, arc_bound.Y2);
+            }
 	  C->Count++;
 	}
       while ((c = NEXT_VERTEX (p = c)) != &C->head);
@@ -3868,6 +4176,7 @@ poly_ChkContour (PLINE * a)
       a2 = a1;
       do
 	{
+#warning THIS DOES NOT TAKE INTO ACCOUNT arc-arc and arc-line segments
 	  if (!node_neighbours (a1, a2) &&
 	      (icnt = vect_inters2 (a1->point, a1->next->point,
 				    a2->point, a2->next->point, i1, i2)) > 0)
@@ -4231,3 +4540,35 @@ vect_inters2 (Vector p1, Vector p2, Vector q1, Vector q2,
  * perhaps reverse tracing the arc would require look-ahead to check
  * for arcs
  */
+
+
+BoxType *
+get_seg_bounds (PLINE *contour, VNODE *node)
+{
+  struct info info;
+  BoxType box;
+  double dx;
+
+  info.v = node;
+  /* compute the slant for region trimming */
+  dx = node->next->point[0] - node->point[0];
+  if (dx == 0)
+    info.m = 0;
+  else
+    {
+      info.m = (node->next->point[1] - node->point[1]) / dx;
+      info.b = node->point[1] - info.m * node->point[0];
+    }
+
+  box.X2 = (box.X1 = node->point[0]) + 1;
+  box.Y2 = (box.Y1 = node->point[1]) + 1;
+
+  /* fill in the segment in info corresponding to this node */
+  if (setjmp (info.sego) == 0)
+    {
+      r_search (contour->tree, &box, NULL, get_seg, &info);
+      assert (0);
+    }
+
+  return &info.s->box;
+}
