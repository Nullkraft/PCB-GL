Bottom: 1a4b7f9478e8580808f655aadf1237218a84648d
Top:    d20ac0b7318d7e861a1beb0b53bb15b89d8b906f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 16:18:52 +0100

Silly space navigator interface to allow funky views





---

diff --git a/src/Makefile.am b/src/Makefile.am
index 45aa6f5..2a566ab 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -307,7 +307,9 @@ LIBGTK_SRCS = \
 	hid/gtk/gui-pinout-preview.h \
 	hid/gtk/gui-pinout-window.c \
 	hid/gtk/gui-top-window.c \
-	hid/gtk/gui-utils.c
+	hid/gtk/gui-utils.c \
+	hid/gtk/snavi.c \
+	hid/gtk/snavi.h
 libgtk_a_SOURCES = ${LIBGTK_SRCS} hid/gtk/gtk_lists.h
 
 hid/gtk/gtk_lists.h : ${LIBGTK_SRCS} Makefile
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 544b6a2..6ab4993 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -119,7 +119,7 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
   ghid_set_status_line_label ();
 }
 
-static void
+void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
   ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 20e8e03..8c32c68 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -45,6 +45,8 @@
 #include "find.h"
 #include "search.h"
 #include "rats.h"
+#include "snavi.h"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -549,6 +551,8 @@ ghid_port_window_enter_cb (GtkWidget * widget,
       /* Make sure drawing area has keyboard focus when we are in it.
        */
       gtk_widget_grab_focus (out->drawing_area);
+      if (ghidgui->snavi != NULL)
+        snavi_set_led (ghidgui->snavi, TRUE);
     }
   ghidgui->in_popup = FALSE;
 
@@ -581,6 +585,9 @@ ghid_port_window_leave_cb (GtkWidget * widget,
       return FALSE;
     }
 
+  if (out->has_entered && !ghidgui->in_popup && ghidgui->snavi != NULL)
+    snavi_set_led (ghidgui->snavi, FALSE);
+
   out->has_entered = FALSE;
 
   ghid_screen_update ();
@@ -620,3 +627,31 @@ ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 
   return TRUE;
 }
+
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data)
+{
+  if (dx || dy)
+    ghid_pan_view_rel (-gport->view.coord_per_px * 5 * dx,
+                       -gport->view.coord_per_px * 5 * dy);
+  if (dz)
+    ghid_zoom_view_rel (gport->pcb_x, gport->pcb_y, 1.0 - (dz / 100.0));
+}
+
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data)
+{
+  /* FIXME: IFDEF HACK */
+#ifdef ENABLE_GL
+  ghid_trackball_external_rotate (GHID_TRACKBALL (gport->trackball),
+                                  dy / 100., dx / 100., dz / 100.);
+#endif
+}
+
+void ndof_done_cb (gpointer data)
+{
+}
+
+void ndof_button_cb (int button, int value, gpointer data)
+{
+  if (value == 1)
+    hid_actionl ("SwapSides", (button == 0) ? "V" : "H", NULL);
+}
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 9b606b2..cdaea8f 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -124,6 +124,7 @@ a zoom in/out.
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
 #include "gui-trackball.h"
+#include "snavi.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -1298,6 +1299,7 @@ ghid_build_pcb_top_window (void)
   /* FIXME: IFDEF HACK */
 #ifdef ENABLE_GL
   trackball = ghid_trackball_new ();
+  gport->trackball = trackball;
   g_signal_connect (trackball, "rotation-changed",
                     G_CALLBACK (ghid_port_rotate), NULL);
   g_signal_connect (trackball, "view-2d-changed",
@@ -1782,6 +1784,12 @@ ghid_do_export (HID_Attr_Val * options)
   if (stdin_listen)
     ghid_create_listener ();
 
+  ghidgui->snavi = setup_snavi (ndof_pan_cb,
+                                ndof_roll_cb,
+                                ndof_done_cb,
+                                ndof_button_cb,
+                                NULL);
+
   ghid_notify_gui_is_up ();
 
   gtk_main ();
diff --git a/src/hid/gtk/gui-trackball.c b/src/hid/gtk/gui-trackball.c
index 4f65084..6a42f59 100644
--- a/src/hid/gtk/gui-trackball.c
+++ b/src/hid/gtk/gui-trackball.c
@@ -100,6 +100,38 @@ button_release_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 }
 
 
+void
+ghid_trackball_external_rotate (GhidTrackball *ball, float dx, float dy, float dz)
+{
+  float axis[3];
+  float quart[4];
+#if 0
+  float quart_accum[4];
+
+  axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
+  axis_to_quat (axis, dx, quart_accum);
+
+  axis[0] = 0.; axis[1] = 1.; axis[2] = 0.;
+  axis_to_quat (axis, dy, quart);
+  add_quats (quart, quart_accum, quart_accum);
+
+  axis[0] = 0.; axis[1] = 0.; axis[2] = 1.;
+  axis_to_quat (axis, dz, quart);
+  add_quats (quart, quart_accum, quart_accum);
+
+  add_quats (quart_accum, ball->quart1, ball->quart1);
+#endif
+
+  if (dx == 0. && dy == 0. && dz == 0.) return;
+
+  axis[0] = dx; axis[1] = dy; axis[2] = dz;
+  axis_to_quat (axis, sqrt (dx * dx + dy * dy + dz * dz), quart);
+  add_quats (quart, ball->quart1, ball->quart1);
+
+  g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, ball->quart1);
+}
+
+
 static gboolean
 motion_notify_cb (GtkWidget *widget, GdkEventMotion *ev, gpointer userdata)
 {
diff --git a/src/hid/gtk/gui-trackball.h b/src/hid/gtk/gui-trackball.h
index d6bd03c..3af647e 100644
--- a/src/hid/gtk/gui-trackball.h
+++ b/src/hid/gtk/gui-trackball.h
@@ -65,6 +65,7 @@ struct _GhidTrackball
 
 GType ghid_trackball_get_type (void);
 
+void ghid_trackball_external_rotate (GhidTrackball *ball, float dx, float dy, float dz);
 GtkWidget *ghid_trackball_new (void);
 
 #endif /* __GHID_TRACKBALL_H__ */
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index e9a5ef9..12f9bc2 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -148,6 +148,8 @@ typedef struct
     library_window_width,
     library_window_height,
     netlist_window_height, history_size, settings_mode;
+
+  GIOChannel *snavi;
 }
 GhidGui;
 
@@ -173,6 +175,7 @@ typedef struct
 {
   GtkWidget *top_window,	/* toplevel widget              */
    *drawing_area;		/* and its drawing area */
+  GtkWidget *trackball;
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
   gint width, height;
@@ -300,6 +303,10 @@ gint ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 						GdkEventConfigure * ev,
 						GHidPort * out);
 
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data);
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data);
+void ndof_done_cb (gpointer data);
+void ndof_button_cb (int button, int value, gpointer data);
 
 /* gui-dialog.c function prototypes.
 */
@@ -510,6 +517,7 @@ void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);
 
 /* gtkhid-main.c */
+void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_pan_view_rel (Coord dx, Coord dy);
 void ghid_get_coords (const char *msg, Coord *x, Coord *y);
 gint PCBChanged (int argc, char **argv, Coord x, Coord y);
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
new file mode 100644
index 0000000..2f58f02
--- /dev/null
+++ b/src/hid/gtk/snavi.c
@@ -0,0 +1,189 @@
+/*
+ * spacenavi.c - a proof-of-concept hack to access the
+ * 3dconnexion space navigator
+ *
+ * Written by Simon Budig, placed in the public domain.
+ * it helps to read http://www.frogmouth.net/hid-doco/linux-hid.html .
+ *
+ * Adapted to control pcb by Peter Clifton
+ *
+ * For the LED to work a patch to the linux kernel is needed:
+ *   http://www.home.unix-ag.org/simon/files/spacenavigator-hid.patch
+ *
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include <glib.h>
+
+#define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))
+
+static void (*update_pan_cb)(int, int, int, gpointer);
+static void (*update_roll_cb)(int, int, int, gpointer);
+static void (*update_done_cb)(gpointer);
+static void (*button_cb)(int, int, gpointer);
+static gpointer cb_userdata;
+
+int snavi_set_led (GIOChannel *snavi, int led_state)
+{
+  struct input_event event;
+  GError      *error = NULL;
+  gsize        bytes_written;
+
+  event.time.tv_sec = 0;
+  event.time.tv_usec = 0;
+  event.type  = EV_LED;
+  event.code  = LED_MISC;
+  event.value = led_state;
+
+#if 0
+  g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+#endif
+
+  g_io_channel_write_chars (snavi,
+                            (gchar *) &event,
+                            sizeof (struct input_event),
+                            &bytes_written,
+                            &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+#if 0
+  g_io_channel_flush (snavi, &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+#endif
+
+  return bytes_written < sizeof (struct input_event);
+}
+
+
+#define BAND 5
+
+gboolean snavi_event (GIOChannel   *source,
+                      GIOCondition  condition,
+                      gpointer      data)
+{
+  static gint axes[6] = { 0, 0, 0, 0, 0, 0 };
+  /* static gint buttons[2] = { 0, 0 }; */
+  int i = 0;
+
+  struct       input_event event;
+  GError      *error = NULL;
+  gsize        bytes_read;
+
+  g_io_channel_read_chars (source,
+                           (gchar *) &event,
+                           sizeof (struct input_event),
+                           &bytes_read,
+                           &error);
+
+  if (error)
+    {
+      g_printerr ("%s\n", error->message);
+      return FALSE;
+    }
+
+  switch (event.type)
+    {
+      case EV_ABS:
+        if (event.code <= ABS_RZ)
+          axes[event.code - ABS_X] = event.value;
+        break;
+
+      case EV_KEY:
+        if (event.code >= BTN_0 && event.code <= BTN_1)
+          /* buttons[event.code - BTN_0] = event.value; */
+          button_cb (event.code - BTN_0, event.value, cb_userdata);
+        break;
+
+      case EV_SYN:
+        /*
+         * if multiple axes change simultaneously the linux
+         * input system sends multiple events.
+         * EV_SYN indicates that all changes have been reported.
+         */
+
+        /* Deadband */
+        for (i = 0; i < 6; i++) {
+          if (axes[i] > -BAND &&
+              axes[i] < BAND)
+            axes[i] = 0;
+        }
+
+        update_pan_cb (axes[0] / 70.0,
+                       axes[2] / 70.0,
+                       axes[1] / 70.0, cb_userdata);
+        update_roll_cb (axes[5] / 60.0,
+                        axes[3] / 60.0,
+                        axes[4] / 60.0, cb_userdata);
+        update_done_cb (cb_userdata);
+
+        axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
+        break;
+
+      default:
+        break;
+    }
+
+
+  return TRUE;
+}
+
+
+GIOChannel *
+setup_snavi (void (*update_pan)(int, int, int, gpointer),
+             void (*update_roll)(int, int, int, gpointer),
+             void (*update_done)(gpointer),
+             void (*button)(int, int, gpointer),
+             gpointer data)
+{
+  GIOChannel *snavi;
+
+  update_pan_cb = update_pan;
+  update_roll_cb = update_roll;
+  update_done_cb = update_done;
+  button_cb = button;
+  cb_userdata = data;
+#if 0
+  int fd;
+  int grab = 1;
+
+  fd = open("/dev/input/spacenavigator", O_RDWR);
+  ioctl (fd, EVIOCGRAB, &grab);
+
+  snavi = g_io_channel_unix_new (fd);
+#else
+  snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+#endif
+
+  if (snavi)
+    {
+      g_io_channel_set_encoding (snavi, NULL, NULL);
+      g_io_channel_set_buffered (snavi, FALSE);
+      g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
+    }
+
+  return snavi;
+}
diff --git a/src/hid/gtk/snavi.h b/src/hid/gtk/snavi.h
new file mode 100644
index 0000000..9b5011c
--- /dev/null
+++ b/src/hid/gtk/snavi.h
@@ -0,0 +1,6 @@
+GIOChannel *setup_snavi(void (*update_pan)(int dx, int dy, int dz, gpointer data),
+                        void (*update_roll)(int dx, int dy, int dz, gpointer data),
+                        void (*update_done)(gpointer data),
+                        void (*button)(int button, int value, gpointer data),
+                        gpointer data);
+void snavi_set_led (GIOChannel *snavi, int value);
