Bottom: 0bb3f1ce75911f2fde7e237fb0f06d4b5cd1e196
Top:    c56ce9add5680a495141aa44f3d44898f671a0d3
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 05:40:50 +0100

Silly space navigator interface to allow funky views





---

diff --git a/src/Makefile.am b/src/Makefile.am
index 6299ac5..716b337 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -272,7 +272,9 @@ LIBGTK_SRCS = \
 	hid/gtk/gui-top-window.c \
 	hid/gtk/gui-trackball.c \
 	hid/gtk/gui-trackball.h \
-	hid/gtk/gui-utils.c
+	hid/gtk/gui-utils.c \
+	hid/gtk/snavi.c \
+	hid/gtk/snavi.h
 libgtk_a_SOURCES = ${LIBGTK_SRCS} hid/gtk/gtk_lists.h
 
 hid/gtk/gtk_lists.h : ${LIBGTK_SRCS} Makefile
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index e2c3c80..cf7843f 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -46,6 +46,7 @@
 #include "error.h"
 #include "misc.h"
 #include "set.h"
+#include "snavi.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -1263,6 +1264,8 @@ ghid_port_window_enter_cb (GtkWidget * widget,
       /* Make sure drawing area has keyboard focus when we are in it.
        */
       gtk_widget_grab_focus (out->drawing_area);
+      if (ghidgui->snavi)
+        snavi_set_led (ghidgui->snavi, TRUE);
     }
   ghidgui->in_popup = FALSE;
 
@@ -1370,6 +1373,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	    }
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
+      else if (ghidgui->snavi)
+        snavi_set_led (ghidgui->snavi, FALSE);
     }
 
   if(cursor_in_viewport)
@@ -1418,3 +1423,27 @@ ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 
   return TRUE;
 }
+
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data)
+{
+  if (dx || dy)
+    ghid_port_ranges_pan (-gport->zoom * 5 * dx,
+                          -gport->zoom * 5 * dy, TRUE);
+  if (dz)
+    ghid_port_ranges_zoom (gport->zoom * (1.0 - (dz / 100.0)));
+}
+
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data)
+{
+}
+
+void ndof_done_cb (gpointer data)
+{
+}
+
+void ndof_button_cb (int button, int value, gpointer data)
+{
+  if (value == 1)
+    hid_actionl ("SwapSides", (button == 0) ? "V" : "H", NULL);
+}
+
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index c74e02c..a6397d0 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -123,6 +123,7 @@ a zoom in/out.
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
 #include "gui-trackball.h"
+#include "snavi.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2759,6 +2760,12 @@ ghid_do_export (HID_Attr_Val * options)
   if (stdin_listen)
     ghid_create_listener ();
 
+  ghidgui->snavi = setup_snavi (ndof_pan_cb,
+                                ndof_roll_cb,
+                                ndof_done_cb,
+                                ndof_button_cb,
+                                NULL);
+
   ghid_notify_gui_is_up ();
 
   gtk_main ();
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 98180d8..24e2df2 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -197,6 +197,8 @@ typedef struct
     library_window_width,
     library_window_height,
     netlist_window_height, history_size, settings_mode, auto_pan_speed;
+
+  GIOChannel *snavi;
 }
 GhidGui;
 
@@ -376,6 +378,10 @@ gint ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 						GdkEventConfigure * ev,
 						GHidPort * out);
 
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data);
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data);
+void ndof_done_cb (gpointer data);
+void ndof_button_cb (int button, int value, gpointer data);
 
 /* gui-dialog.c function prototypes.
 */
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
new file mode 100644
index 0000000..63b6907
--- /dev/null
+++ b/src/hid/gtk/snavi.c
@@ -0,0 +1,174 @@
+/*
+ * spacenavi.c - a proof-of-concept hack to access the
+ * 3dconnexion space navigator
+ *
+ * Written by Simon Budig, placed in the public domain.
+ * it helps to read http://www.frogmouth.net/hid-doco/linux-hid.html .
+ *
+ * Adapted to control pcb by Peter Clifton
+ *
+ * For the LED to work a patch to the linux kernel is needed:
+ *   http://www.home.unix-ag.org/simon/files/spacenavigator-hid.patch
+ *
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include <glib.h>
+
+#define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))
+
+static void (*update_pan_cb)(int, int, int, gpointer);
+static void (*update_roll_cb)(int, int, int, gpointer);
+static void (*update_done_cb)(gpointer);
+static void (*button_cb)(int, int, gpointer);
+static gpointer cb_userdata;
+
+int snavi_set_led (GIOChannel *snavi, int led_state)
+{
+  struct input_event event;
+  GError      *error = NULL;
+  gsize        bytes_written;
+
+  event.type  = EV_LED;
+  event.code  = LED_MISC;
+  event.value = led_state;
+
+  g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  g_io_channel_write_chars (snavi,
+                            (gchar *) &event,
+                            sizeof (struct input_event),
+                            &bytes_written,
+                            &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  g_io_channel_flush (snavi, &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  return bytes_written < sizeof (struct input_event);
+}
+
+
+#define BAND 5
+
+gboolean snavi_event (GIOChannel   *source,
+                      GIOCondition  condition,
+                      gpointer      data)
+{
+  static gint axes[6] = { 0, 0, 0, 0, 0, 0 };
+  static gint buttons[2] = { 0, 0 };
+  int i = 0;
+
+  struct       input_event event;
+  GError      *error = NULL;
+  gsize        bytes_read;
+
+  g_io_channel_read_chars (source,
+                           (gchar *) &event,
+                           sizeof (struct input_event),
+                           &bytes_read,
+                           &error);
+
+  if (error)
+    {
+      g_printerr ("%s\n", error->message);
+      return FALSE;
+    }
+
+  switch (event.type)
+    {
+      case EV_REL:
+        if (event.code <= REL_RZ)
+          axes[event.code - REL_X] = event.value;
+        break;
+
+      case EV_KEY:
+        if (event.code >= BTN_0 && event.code <= BTN_1)
+          buttons[event.code - BTN_0] = event.value;
+
+          button_cb (event.code - BTN_0, event.value, cb_userdata);
+        break;
+
+      case EV_SYN:
+        /*
+         * if multiple axes change simultaneously the linux
+         * input system sends multiple EV_REL events.
+         * EV_SYN indicates that all changes have been reported.
+         */
+
+        /* Deadband */
+        for (i = 0; i < 6; i++) {
+          if (axes[i] > -BAND &&
+              axes[i] < BAND)
+            axes[i] = 0;
+        }
+
+        update_pan_cb (axes[0] / 100.0,
+                       axes[2] / 100.0,
+                       axes[1] / 100.0, cb_userdata);
+        update_roll_cb (axes[5] / 100.0,
+                        axes[3] / 100.0,
+                        axes[2] / 100.0, cb_userdata);
+        update_done_cb (cb_userdata);
+
+        axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
+        break;
+
+      default:
+        break;
+    }
+
+
+  return TRUE;
+}
+
+
+GIOChannel *
+setup_snavi (void (*update_pan)(int, int, int, gpointer),
+             void (*update_roll)(int, int, int, gpointer),
+             void (*update_done)(gpointer),
+             void (*button)(int, int, gpointer),
+             gpointer data)
+{
+  int event_id;
+  GIOChannel *snavi;
+
+  update_pan_cb = update_pan;
+  update_roll_cb = update_roll;
+  update_done_cb = update_done;
+  button_cb = button;
+  cb_userdata = data;
+
+  snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+  if (snavi)
+    {
+      g_io_channel_set_encoding (snavi, NULL, NULL);
+      event_id = g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
+    }
+
+  return snavi;
+}
diff --git a/src/hid/gtk/snavi.h b/src/hid/gtk/snavi.h
new file mode 100644
index 0000000..9b5011c
--- /dev/null
+++ b/src/hid/gtk/snavi.h
@@ -0,0 +1,6 @@
+GIOChannel *setup_snavi(void (*update_pan)(int dx, int dy, int dz, gpointer data),
+                        void (*update_roll)(int dx, int dy, int dz, gpointer data),
+                        void (*update_done)(gpointer data),
+                        void (*button)(int button, int value, gpointer data),
+                        gpointer data);
+void snavi_set_led (GIOChannel *snavi, int value);
