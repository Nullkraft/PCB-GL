Bottom: 6539139c545aff3d82a20446f9d130786d3fe62b
Top:    4c5cdae1bf598b038ba855871c38e4c9a70e3a49
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-05-11 16:02:14 +0100

Silly space navigator interface to allow funky views





---

diff --git a/src/Makefile.am b/src/Makefile.am
index f21c807..2ce0991 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -280,7 +280,9 @@ LIBGTK_SRCS = \
 	hid/gtk/gui-top-window.c \
 	hid/gtk/gui-trackball.c \
 	hid/gtk/gui-trackball.h \
-	hid/gtk/gui-utils.c
+	hid/gtk/gui-utils.c \
+	hid/gtk/snavi.c \
+	hid/gtk/snavi.h
 libgtk_a_SOURCES = ${LIBGTK_SRCS} hid/gtk/gtk_lists.h
 
 hid/gtk/gtk_lists.h : ${LIBGTK_SRCS} Makefile
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 5ad3296..b9a2b30 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -50,6 +50,8 @@
 #include "search.h"
 #include "rats.h"
 #include "rtree.h"
+#include "snavi.h"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2038,6 +2040,8 @@ ghid_port_window_enter_cb (GtkWidget * widget,
       /* Make sure drawing area has keyboard focus when we are in it.
        */
       gtk_widget_grab_focus (out->drawing_area);
+      if (ghidgui->snavi)
+        snavi_set_led (ghidgui->snavi, TRUE);
     }
   ghidgui->in_popup = FALSE;
 
@@ -2145,6 +2149,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	    }
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
+      else if (ghidgui->snavi)
+        snavi_set_led (ghidgui->snavi, FALSE);
     }
 
   if(cursor_in_viewport)
@@ -2193,3 +2199,29 @@ ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 
   return TRUE;
 }
+
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data)
+{
+  if (dx || dy)
+    ghid_port_ranges_pan (-gport->zoom * 5 * dx,
+                          -gport->zoom * 5 * dy, TRUE);
+  if (dz)
+    ghid_port_ranges_zoom (gport->zoom * (1.0 - (dz / 100.0)));
+}
+
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data)
+{
+  ghid_trackball_external_rotate (GHID_TRACKBALL (gport->trackball),
+                                  dy / 100., dx / 100., dz / 100.);
+}
+
+void ndof_done_cb (gpointer data)
+{
+}
+
+void ndof_button_cb (int button, int value, gpointer data)
+{
+  if (value == 1)
+    hid_actionl ("SwapSides", (button == 0) ? "V" : "H", NULL);
+}
+
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index a61cff3..0cda4d5 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -123,6 +123,7 @@ a zoom in/out.
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
 #include "gui-trackball.h"
+#include "snavi.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2266,6 +2267,7 @@ ghid_build_pcb_top_window (void)
   make_layer_buttons(vbox, port);
 
   trackball = ghid_trackball_new ();
+  gport->trackball = trackball;
   g_signal_connect (trackball, "rotation-changed",
                     G_CALLBACK (ghid_port_rotate), NULL);
   g_signal_connect (trackball, "view-2d-changed",
@@ -2737,6 +2739,12 @@ ghid_do_export (HID_Attr_Val * options)
   if (stdin_listen)
     ghid_create_listener ();
 
+  ghidgui->snavi = setup_snavi (ndof_pan_cb,
+                                ndof_roll_cb,
+                                ndof_done_cb,
+                                ndof_button_cb,
+                                NULL);
+
   ghid_notify_gui_is_up ();
 
   gtk_main ();
diff --git a/src/hid/gtk/gui-trackball.c b/src/hid/gtk/gui-trackball.c
index 26440bb..33b8c81 100644
--- a/src/hid/gtk/gui-trackball.c
+++ b/src/hid/gtk/gui-trackball.c
@@ -99,6 +99,38 @@ button_release_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 }
 
 
+void
+ghid_trackball_external_rotate (GhidTrackball *ball, float dx, float dy, float dz)
+{
+  float axis[3];
+  float quart[4];
+#if 0
+  float quart_accum[4];
+
+  axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
+  axis_to_quat (axis, dx, quart_accum);
+
+  axis[0] = 0.; axis[1] = 1.; axis[2] = 0.;
+  axis_to_quat (axis, dy, quart);
+  add_quats (quart, quart_accum, quart_accum);
+
+  axis[0] = 0.; axis[1] = 0.; axis[2] = 1.;
+  axis_to_quat (axis, dz, quart);
+  add_quats (quart, quart_accum, quart_accum);
+
+  add_quats (quart_accum, ball->quart1, ball->quart1);
+#endif
+
+  if (dx == 0. && dy == 0. && dz == 0.) return;
+
+  axis[0] = dx; axis[1] = dy; axis[2] = dz;
+  axis_to_quat (axis, sqrt (dx * dx + dy * dy + dz * dz), quart);
+  add_quats (quart, ball->quart1, ball->quart1);
+
+  g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, ball->quart1);
+}
+
+
 static gboolean
 motion_notify_cb (GtkWidget *widget, GdkEventMotion *ev, gpointer userdata)
 {
diff --git a/src/hid/gtk/gui-trackball.h b/src/hid/gtk/gui-trackball.h
index d6bd03c..3af647e 100644
--- a/src/hid/gtk/gui-trackball.h
+++ b/src/hid/gtk/gui-trackball.h
@@ -65,6 +65,7 @@ struct _GhidTrackball
 
 GType ghid_trackball_get_type (void);
 
+void ghid_trackball_external_rotate (GhidTrackball *ball, float dx, float dy, float dz);
 GtkWidget *ghid_trackball_new (void);
 
 #endif /* __GHID_TRACKBALL_H__ */
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index b53ab2a..8013de9 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -181,6 +181,8 @@ typedef struct
     library_window_width,
     library_window_height,
     netlist_window_height, history_size, settings_mode, auto_pan_speed;
+
+  GIOChannel *snavi;
 }
 GhidGui;
 
@@ -193,6 +195,7 @@ typedef struct
 {
   GtkWidget *top_window,	/* toplevel widget              */
    *drawing_area;		/* and its drawing area */
+  GtkWidget *trackball;
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
   gint width, height;
@@ -358,6 +361,10 @@ gint ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 						GdkEventConfigure * ev,
 						GHidPort * out);
 
+void ndof_pan_cb (int dx, int dy, int dz, gpointer data);
+void ndof_roll_cb (int dx, int dy, int dz, gpointer data);
+void ndof_done_cb (gpointer data);
+void ndof_button_cb (int button, int value, gpointer data);
 
 /* gui-dialog.c function prototypes.
 */
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
new file mode 100644
index 0000000..6dd1b5f
--- /dev/null
+++ b/src/hid/gtk/snavi.c
@@ -0,0 +1,174 @@
+/*
+ * spacenavi.c - a proof-of-concept hack to access the
+ * 3dconnexion space navigator
+ *
+ * Written by Simon Budig, placed in the public domain.
+ * it helps to read http://www.frogmouth.net/hid-doco/linux-hid.html .
+ *
+ * Adapted to control pcb by Peter Clifton
+ *
+ * For the LED to work a patch to the linux kernel is needed:
+ *   http://www.home.unix-ag.org/simon/files/spacenavigator-hid.patch
+ *
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include <glib.h>
+
+#define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))
+
+static void (*update_pan_cb)(int, int, int, gpointer);
+static void (*update_roll_cb)(int, int, int, gpointer);
+static void (*update_done_cb)(gpointer);
+static void (*button_cb)(int, int, gpointer);
+static gpointer cb_userdata;
+
+int snavi_set_led (GIOChannel *snavi, int led_state)
+{
+  struct input_event event;
+  GError      *error = NULL;
+  gsize        bytes_written;
+
+  event.type  = EV_LED;
+  event.code  = LED_MISC;
+  event.value = led_state;
+
+  g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  g_io_channel_write_chars (snavi,
+                            (gchar *) &event,
+                            sizeof (struct input_event),
+                            &bytes_written,
+                            &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  g_io_channel_flush (snavi, &error);
+
+  if (error) {
+    g_printerr ("Error: %s\n", error->message);
+    /* FIXME: FREE THE ERROR??? */
+    return FALSE;
+  }
+
+  return bytes_written < sizeof (struct input_event);
+}
+
+
+#define BAND 5
+
+gboolean snavi_event (GIOChannel   *source,
+                      GIOCondition  condition,
+                      gpointer      data)
+{
+  static gint axes[6] = { 0, 0, 0, 0, 0, 0 };
+  static gint buttons[2] = { 0, 0 };
+  int i = 0;
+
+  struct       input_event event;
+  GError      *error = NULL;
+  gsize        bytes_read;
+
+  g_io_channel_read_chars (source,
+                           (gchar *) &event,
+                           sizeof (struct input_event),
+                           &bytes_read,
+                           &error);
+
+  if (error)
+    {
+      g_printerr ("%s\n", error->message);
+      return FALSE;
+    }
+
+  switch (event.type)
+    {
+      case EV_REL:
+        if (event.code <= REL_RZ)
+          axes[event.code - REL_X] = event.value;
+        break;
+
+      case EV_KEY:
+        if (event.code >= BTN_0 && event.code <= BTN_1)
+          buttons[event.code - BTN_0] = event.value;
+
+          button_cb (event.code - BTN_0, event.value, cb_userdata);
+        break;
+
+      case EV_SYN:
+        /*
+         * if multiple axes change simultaneously the linux
+         * input system sends multiple EV_REL events.
+         * EV_SYN indicates that all changes have been reported.
+         */
+
+        /* Deadband */
+        for (i = 0; i < 6; i++) {
+          if (axes[i] > -BAND &&
+              axes[i] < BAND)
+            axes[i] = 0;
+        }
+
+        update_pan_cb (axes[0] / 100.0,
+                       axes[2] / 100.0,
+                       axes[1] / 100.0, cb_userdata);
+        update_roll_cb (axes[5] / 100.0,
+                        axes[3] / 100.0,
+                        axes[4] / 100.0, cb_userdata);
+        update_done_cb (cb_userdata);
+
+        axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
+        break;
+
+      default:
+        break;
+    }
+
+
+  return TRUE;
+}
+
+
+GIOChannel *
+setup_snavi (void (*update_pan)(int, int, int, gpointer),
+             void (*update_roll)(int, int, int, gpointer),
+             void (*update_done)(gpointer),
+             void (*button)(int, int, gpointer),
+             gpointer data)
+{
+  int event_id;
+  GIOChannel *snavi;
+
+  update_pan_cb = update_pan;
+  update_roll_cb = update_roll;
+  update_done_cb = update_done;
+  button_cb = button;
+  cb_userdata = data;
+
+  snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+  if (snavi)
+    {
+      g_io_channel_set_encoding (snavi, NULL, NULL);
+      event_id = g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
+    }
+
+  return snavi;
+}
diff --git a/src/hid/gtk/snavi.h b/src/hid/gtk/snavi.h
new file mode 100644
index 0000000..9b5011c
--- /dev/null
+++ b/src/hid/gtk/snavi.h
@@ -0,0 +1,6 @@
+GIOChannel *setup_snavi(void (*update_pan)(int dx, int dy, int dz, gpointer data),
+                        void (*update_roll)(int dx, int dy, int dz, gpointer data),
+                        void (*update_done)(gpointer data),
+                        void (*button)(int button, int value, gpointer data),
+                        gpointer data);
+void snavi_set_led (GIOChannel *snavi, int value);
