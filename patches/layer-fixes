Bottom: 3222d26604515d3adca936047ff06a090f7eee97
Top:    6bf0b66b7fa58b57c6814bc0240b32d36c0f7133
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-17 01:59:01 +0000

Layer fixes

** SHOULD MERGE SOME OF THIS COMMIT DOWN INTO OTHER PATCHES? **

Fix mask display in 3D (Allow both side masks to display at once)
Fix rendering depths for silk and mask layers


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 70e03a7..61666c5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -85,36 +85,47 @@ compute_depth (int group)
 {
   static int last_depth_computed = 0;
 
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
+  int max_depth;
   int depth = last_depth_computed;
   int newgroup;
   int idx = (group >= 0
              && group <
              max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
+
+  max_depth = (1 + max_phys_group - min_phys_group) * 10;
+
   if (group >= 0 && group < max_group) {
     newgroup = group;
-#if 0
-    /* Re-ordering doesn't work, since we also need to adjust the rendering order */
-    if (group == 1)
-      newgroup = max_group - 1;
-    else if (group > 1)
-      newgroup = group - 1;
-#endif
-    depth = ((max_group - newgroup) * 10) * 200 / gport->zoom;
+
+    depth = (max_depth - newgroup * 10) * 200 / gport->zoom;
   } else if (SL_TYPE (idx) == SL_MASK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
-      depth = (max_group * 10 + 3) * 200 / gport->zoom;
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 3) * 200 / gport->zoom;
     } else {
       depth = (10 - 3) * 200 / gport->zoom;
     }
   } else if (SL_TYPE (idx) == SL_SILK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
-      depth = (max_group * 10 + 5) * 200 / gport->zoom;
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 5) * 200 / gport->zoom;
     } else {
       depth = (10 - 5) * 200 / gport->zoom;
     }
   } else if (SL_TYPE (idx) == SL_INVISIBLE) {
-    depth = (10 - 3) * 200 / gport->zoom;
+    if (Settings.ShowSolderSide) {
+      depth = (max_depth + 5) * 200 / gport->zoom;
+    } else {
+      depth = (10 - 5) * 200 / gport->zoom;
+    }
   }
 
   last_depth_computed = depth;
@@ -1547,6 +1558,10 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   struct cyl_info cyl_info;
   int reverse_layers;
   int save_show_solder;
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
 
   extern bool Gathering;
 
@@ -1568,22 +1583,35 @@ ghid_draw_everything (BoxTypePtr drawn_area)
 
   if (!global_view_2d && save_show_solder)
     reverse_layers = !reverse_layers;
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
 
-  memset (do_group, 0, sizeof (do_group));
-  for (ngroups = 0, i = 0; i < max_copper_layer; i++) {
-    LayerType *l;
-    int group;
-    int orderi;
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
-    orderi = reverse_layers ? max_copper_layer - i - 1 : i;
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
 
-    // Draw in numerical order when in 3D view
-    l = global_view_2d ? LAYER_ON_STACK (i) : LAYER_PTR (orderi);
-    group = GetLayerGroupNumberByNumber (global_view_2d ? LayerStack[i] : orderi);
+  memset (do_group, 0, sizeof (do_group));
+  if (global_view_2d) {
+    // Draw in layer stack order when in 2D view
+    for (ngroups = 0, i = 0; i < max_copper_layer; i++) {
+      int group = GetLayerGroupNumberByNumber (LayerStack[i]);
+
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
+    }
+  } else {
+    // Draw in group order when in 3D view
+    for (ngroups = 0, i = 0; i < max_group; i++) {
+      int group = reverse_layers ? max_group - 1 - i : i;
 
-    if (/*l->On && */!do_group[group]) {
-      do_group[group] = 1;
-      drawn_groups[ngroups++] = group;
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
     }
   }
 
@@ -1592,13 +1620,40 @@ ghid_draw_everything (BoxTypePtr drawn_area)
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
-    if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback, NULL);
     if (PCB->ElementOn) {
-      r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback, NULL);
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, backN_callback, NULL);
       DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
     }
+#if 1
+    if (!global_view_2d) {
+      /* Draw the solder mask if turned on */
+      if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0)) {
+        int save_swap = SWAP_IDENT;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        gui->set_layer ("componentmask", SL (MASK, TOP), 0);
+        //^__ HACK, THE GUI DOESNT WANT US TO DRAW THIS!
+        SWAP_IDENT = 0;
+        DrawMask (drawn_area);
+        SWAP_IDENT = save_swap;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      }
+      if (gui->set_layer ("componentmask", SL (MASK, TOP), 0)) {
+        int save_swap = SWAP_IDENT;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0);
+        //^__ HACK, THE GUI DOESNT WANT US TO DRAW THIS!
+        SWAP_IDENT = 1;
+        DrawMask (drawn_area);
+        SWAP_IDENT = save_swap;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      }
+      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0);
+    }
+#endif
+    if (global_view_2d)
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback, NULL);
+    if (PCB->ElementOn)
+      r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback, NULL);
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
   }
 
@@ -1607,7 +1662,11 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     DrawLayerGroup (drawn_groups [i], drawn_area);
 
 #if 1
-    if (!global_view_2d && i > 0) {
+    if (!global_view_2d && i > 0 &&
+        drawn_groups[i] >= min_phys_group &&
+        drawn_groups[i] <= max_phys_group &&
+        drawn_groups[i - 1] >= min_phys_group &&
+        drawn_groups[i - 1] <= max_phys_group) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->zoom;
