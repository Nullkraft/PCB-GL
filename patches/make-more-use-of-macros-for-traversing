Bottom: 854651fb0ee7f6f17997d805e8f649f2ad4ed584
Top:    2ba0871d4ce260989890e25022d42494e986e77a
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-02-18 17:17:40 +0000

Make more use of macros for traversing between edges and nodes in a specified direction

This greatly simplifies the code, at the cost of the traversal direction being
slightly less explicit.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 129b3f7..c0748c1 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -334,8 +334,7 @@ new_descriptor (VNODE * a, char poly, char side)
   l->poly = poly;
   l->side = side;
   l->next = l->prev = l;
-  if ((side == 'P' && a->prev->is_round == false) || /* previous, not round */
-      (side != 'P' && a      ->is_round == false))   /* next,     not round */
+  if (VERTEX_SIDE_DIR_EDGE (a, side)->is_round == false)  /* not round */
     { /* Line-segment case */
 
 #if 0
@@ -391,20 +390,21 @@ new_descriptor (VNODE * a, char poly, char side)
        * 90 degrees CW)
        */
 
+      center[0] = VERTEX_SIDE_DIR_EDGE (a, side)->cx;
+      center[1] = VERTEX_SIDE_DIR_EDGE (a, side)->cy;
+      l->curvature = (double)-compare_ccw_cw (a->point, center, EDGE_SIDE_DIR_VERTEX (VERTEX_SIDE_DIR_EDGE (a, side), side)->point) / VERTEX_SIDE_DIR_EDGE (a, side)->radius;
+#if 0
       if (side == 'P')		/* previous */
         {
-          center[0] = VERTEX_BACKWARD_EDGE (a)->cx;
-          center[1] = VERTEX_BACKWARD_EDGE (a)->cy;
           l->curvature = (double)+compare_ccw_cw (EDGE_BACKWARD_VERTEX (VERTEX_BACKWARD_EDGE (a))->point, center, a->point) / VERTEX_BACKWARD_EDGE (a)->radius;
           // OR: ?
           // l->curvature = (double)-compare_ccw_cw (a->point, center, a->prev->point) / a->prev->radius;
         }
       else				/* next */
         {
-          center[0] = VERTEX_FORWARD_EDGE (a)->cx;
-          center[1] = VERTEX_FORWARD_EDGE (a)->cy;
           l->curvature = (double)-compare_ccw_cw (a->point, center, EDGE_FORWARD_VERTEX (VERTEX_FORWARD_EDGE (a))->point) / VERTEX_FORWARD_EDGE (a)->radius;
         }
+#endif
 
       /* First of all, make v the radial line */
       vect_sub (v, center, a->point);
