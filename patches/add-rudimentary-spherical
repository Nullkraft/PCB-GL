Bottom: fae7d40eabfd2730ef1c1d4076b9c5c3adfc06e2
Top:    475164bb3f65645180b631c09b893235474f098b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2016-12-30 19:01:18 +0000

Add rudimentary spherical surface support


---

diff --git a/src/hid/common/face3d.h b/src/hid/common/face3d.h
index 4e9f1d7..7e0618e 100644
--- a/src/hid/common/face3d.h
+++ b/src/hid/common/face3d.h
@@ -25,6 +25,9 @@ typedef struct {
   /* NB: Use radius above for major_radius */
   double minor_radius;
 
+  /* For spherical surfaces */
+  bool is_spherical;
+
   appearance *appear;
 
   /* XXX: STEP specific - breaks encapsulation */
diff --git a/src/hid/common/face3d_gl.c b/src/hid/common/face3d_gl.c
index 9191b10..09b3d10 100644
--- a/src/hid/common/face3d_gl.c
+++ b/src/hid/common/face3d_gl.c
@@ -65,86 +65,904 @@
 
 #define BUFFER_STRIDE 6 /* 3x vertex + 3x normal */
 
+static void plane_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z, float *nx, float *ny, float *nz);
+
 static void
 emit_lines (face3d *face)
 {
   GLfloat *data_pointer = NULL;
 
-//  CHECK_IS_IN_CONTEXT ();
+//  CHECK_IS_IN_CONTEXT ();
+
+  if (face->tristrip_num_vertices == 0)
+    return;
+
+  data_pointer = face->tristrip_vertices;
+  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
+  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
+
+//  data_pointer = face->line_indices;
+//  glIndexPointer   (GL_INT, sizeof(GL_UNSIGNED_INT), data_pointer + 0);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_NORMAL_ARRAY);
+
+  glTexCoord2f (0.0f, 0.0f);
+
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glDrawElements (GL_LINES, face->line_num_indices, GL_UNSIGNED_INT, face->line_indices);
+  glPopAttrib ();
+
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_NORMAL_ARRAY);
+}
+
+
+static void
+emit_tristrip (face3d *face)
+{
+  GLfloat *data_pointer = NULL;
+
+//  CHECK_IS_IN_CONTEXT ();
+
+  if (face->tristrip_num_vertices == 0)
+    return;
+
+//  if (priv->buffer.use_vbo) {
+//    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+
+//    if (priv->buffer.use_map) {
+//      glUnmapBuffer (GL_ARRAY_BUFFER);
+//      priv->buffer.triangle_array = NULL;
+//    } else {
+//      glBufferData (GL_ARRAY_BUFFER,
+//                    BUFFER_STRIDE * priv->buffer.vertex_count,
+//                    priv->buffer.triangle_array,
+//                    GL_STREAM_DRAW);
+//    }
+//  } else {
+    data_pointer = face->tristrip_vertices;
+//  }
+
+  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
+  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
+//  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_NORMAL_ARRAY);
+//  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  glTexCoord2f (0.0f, 0.0f);
+
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, face->tristrip_num_vertices);
+#if 0
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glDrawArrays (GL_LINE_STRIP, 0, priv->buffer.vertex_count);
+  glPopAttrib ();
+#endif
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_NORMAL_ARRAY);
+//  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+}
+
+typedef struct {
+  double v;     /* v-coordinate at u=0 */
+  bool is_left; /* True if crossing is from u-pos towards u-neg */
+  bool is_right; /* True if crossing is from u-neg towards u-pos */
+  /* Could be neither... if we get fed an edge colinear with u=0... not sure if we need to cope with that or not */
+} u0_crossing;
+
+typedef struct {
+  u0_crossing *crossings; /* Pointer to array of crossigns */
+  int num_crossings;
+  int max_crossings;
+} crossing_info;
+
+/* Add a crossing to be considered to the u=0 crossing list */
+static void
+crossing_list_init (crossing_info *info)
+{
+  info->num_crossings = 0;
+  info->max_crossings = 20; /* Arbitrary start */
+  info->crossings = g_new0 (u0_crossing, info->max_crossings);
+}
+
+static void
+crossing_list_destroy (crossing_info *info)
+{
+  g_free (info->crossings);
+  /* NB: Don't free info its-self, allows it to be stack allocated */
+}
+
+/* Add a crossing to be considered to the u=0 crossing list */
+static double
+crossing_list_add (crossing_info *info,
+                   double u1, double v1,
+                   double u2, double v2)
+{
+  u0_crossing *cross;
+  double m;
+  double v;
+
+  if (info->num_crossings == info->max_crossings)
+    {
+      /* XXX: Reallocate more memory, copy old data etc.. */
+      printf ("Too many crossings, sorry!\n");
+      exit (-1);
+    }
+
+  cross = &info->crossings[info->num_crossings];
+  info->num_crossings++;
+
+  /* XXX: Not sure this is the most robust way to calculate the line intercept at u=0 */
+  m = (v2 - v1) / (u2 - u1);
+  v = v1 - m * u1;
+
+  cross->v = v;
+  cross->is_left = u1 > u2;
+  cross->is_right = u1 < u2;
+
+  return v;
+}
+
+/* Sort in ascending order of v */
+static int
+compare_crossings (const u0_crossing *c1, const u0_crossing *c2)
+{
+  return (c1->v < c2->v) ? -1 : ((c1->v > c2->v) ? 1 : 0);
+}
+
+static void
+crossing_list_sort (crossing_info *info)
+{
+  qsort (info->crossings, info->num_crossings, sizeof (*info->crossings), compare_crossings);
+}
+
+static void
+sphere_xyz_to_uv (face3d *face, double x, double y, double z, double *u, double *v)
+{
+  double refx, refy, refz;
+  double ortx, orty, ortz;
+  double rayx, rayy, rayz;
+  double vx, vy, vz;
+  double mx, my, mz;
+  double recip_length;
+  double cosu, sinu;
+  double rsinv;
+
+  refx = face->rx;
+  refy = face->ry;
+  refz = face->rz;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  /* Magnitude of vector component between sphere center and (x,y,z) in axis direction */
+  rsinv = (x - face->ox) * face->ax +
+          (y - face->oy) * face->ay +
+          (z - face->oz) * face->az;
+
+  /* Find the vector to x,y,z in the plane bisecting the sphere slice at z=0 */
+  rayx = x - face->ox - rsinv * face->ax;
+  rayy = y - face->oy - rsinv * face->ay;
+  rayz = z - face->oz - rsinv * face->az;
+
+  /* Normalise v */
+  recip_length = 1. / hypot (hypot (rayx, rayy), rayz);
+  rayx *= recip_length;
+  rayy *= recip_length;
+  rayz *= recip_length;
+
+  /* Cosine is dot product of ref (normalised) and ray (normalised) */
+  cosu = refx * rayx + refy * rayy + refz * rayz; // cos (phi)
+  /* Sine is dot product of ort (normalised) and ray (normalised) */
+  sinu = ortx * rayx + orty * rayy + ortz * rayz; // sin (phi) = cos (phi - 90)
+
+  /* U is the angle */
+  *u = atan2 (sinu, cosu);
+
+  /* V is the angle */
+  *v = asin (rsinv / face->radius);
+
+  if (*u < 0.0)
+    *u += 2.0 * M_PI;
+
+  /* Convert to degrees */
+  *u *= 180. / M_PI;
+
+  /* NB: Domain of v is already correct, -pi/2 to pi/2 */
+
+  /* Convert to degrees */
+  *v *= 180. / M_PI;
+}
+
+static void
+sphere_uv_to_xyz_and_normal (face3d *face,
+                             double u, double v,
+                             float *x, float *y, float *z,
+                             float *nx, float *ny, float *nz)
+{
+  float ortx, orty, ortz;
+  double cosu, sinu;
+  double cosv, sinv;
+  double Rcosvcosu, Rcosvsinu;
+  double rsinv;
+
+  ortx = face->ay * face->rz - face->az * face->ry;
+  orty = face->az * face->rx - face->ax * face->rz;
+  ortz = face->ax * face->ry - face->ay * face->rx;
+
+  cosu = cos(u / 180. * M_PI);
+  sinu = sin(u / 180. * M_PI);
+  cosv = cos(v / 180. * M_PI);
+  sinv = sin(v / 180. * M_PI);
+
+  rsinv = face->radius * sinv;
+
+  Rcosvcosu = face->radius * cosv * cosu;
+  Rcosvsinu = face->radius * cosv * sinu;
+
+  *x = STEP_X_TO_COORD(PCB, face->ox + Rcosvcosu * face->rx + Rcosvsinu * ortx + rsinv * face->ax);
+  *y = STEP_Y_TO_COORD(PCB, face->oy + Rcosvcosu * face->ry + Rcosvsinu * orty + rsinv * face->ay);
+  *z = STEP_Z_TO_COORD(PCB, face->oz + Rcosvcosu * face->rz + Rcosvsinu * ortz + rsinv * face->az);
+
+  *nx =  (cosv * cosu * face->rx + cosv * sinu * ortx + sinv * face->ax);
+  *ny = -(cosv * cosu * face->ry + cosv * sinu * orty + sinv * face->ay); /* XXX: Note this is minus, presumably due to PCB's coordinate space */
+  *nz =  (cosv * cosu * face->rz + cosv * sinu * ortz + sinv * face->az);
+
+  if (face->surface_orientation_reversed)
+    {
+      *nx = -*nx;
+      *ny = -*ny;
+      *nz = -*nz;
+    }
+}
+
+static void
+sphere_bo_add_edge_no_uwrap (borast_t *bo,
+                             double lu, double lv,
+                             double  u, double  v,
+                             bool is_outer)
+{
+  bo_add_edge (bo,
+               MM_TO_COORD (lu), MM_TO_COORD (lv),
+               MM_TO_COORD ( u), MM_TO_COORD ( v),
+               is_outer);
+}
+
+static void
+sphere_bo_add_edge (borast_t *bo,
+                    double lu, double lv,
+                    double  u, double  v,
+                    bool is_outer)
+{
+  /* XXX: Not absolutely sure about this! */
+  if (fabs (v - lv) > fabs (v + 180.0 - lv))
+    {
+      sphere_bo_add_edge_no_uwrap (bo,
+                                lu, lv,
+                                 u,  v + 180.0,
+                                is_outer);
+      sphere_bo_add_edge_no_uwrap (bo,
+                                lu, lv - 180.0,
+                                 u,  v,
+                                is_outer);
+    }
+  else if (fabs (v - lv) > fabs (v - 180.0 - lv))
+    {
+      sphere_bo_add_edge_no_uwrap (bo,
+                                lu, lv,
+                                 u,  v - 180.0,
+                                is_outer);
+      sphere_bo_add_edge_no_uwrap (bo,
+                                lu, lv + 180.0,
+                                 u,  v,
+                                is_outer);
+    }
+  else
+    {
+      sphere_bo_add_edge_no_uwrap (bo,
+                                lu, lv,
+                                 u,  v,
+                                is_outer);
+    }
+
+}
+
+static void
+sphere_ensure_tristrip (face3d *face)
+{
+  GList *c_iter;
+  int num_uv_points;
+  double *uv_points;
+  int num_line_indices = 0;
+  unsigned int *line_indices;
+  int i, j;
+  int vertex_comp;
+  contour3d *contour;
+  edge_ref e;
+  int x1, x2, x3, x4, y_top, y_bot;
+  borast_t *bo;
+  borast_traps_t traps;
+  int edge_count = 0;
+  crossing_info crosslist;
+  double current_u_with_vwrap = 0.0;
+  double min_u_with_vwrap = 360.0;
+  bool min_u_with_vwrap_is_end = false;
+//  int discarded_traps = 0;
+
+  /* Nothing to do if vertices are already cached */
+  if (face->tristrip_vertices != NULL)
+    return;
+
+  /* Don't waste time if we failed last time */
+  if (face->triangulate_failed)
+    return;
+
+  if (!face->is_spherical)
+    return;
+
+  /* Count up the number of edges space is required for */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+
+          edge_ensure_linearised (e);
+          edge_count += info->num_linearised_vertices;
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+    }
+
+  crossing_list_init (&crosslist);
+
+#if 1
+  /* Worst case, we need 2x number of edges, since we repeat any which span the u=0, u=360 wrap-around,
+   * and add additional vertical edges to segment the u,v space, plus more to initialise the rasterisation
+   * along the u=0 and u=360 edges.
+   */
+  bo = bo_init (2 * edge_count + 2 * 37 * 18  + 2 * crosslist.max_crossings); /* NB + 2 * 37 * 18 is kludge for our vertical bars */
+
+#if 1
+  {
+    int i;
+
+    for (i = 0; i <= 360; i += 10)
+      {
+        for (j = -90; j < 90; j += 10)
+          {
+            bo_add_edge (bo,
+                         MM_TO_COORD(i), MM_TO_COORD(j),
+                         MM_TO_COORD(i), MM_TO_COORD(j + 10.0),
+                         true);
+#if 1
+            bo_add_edge (bo,
+                         MM_TO_COORD(i), MM_TO_COORD(j),
+                         MM_TO_COORD(i), MM_TO_COORD(j + 10.0),
+                         false);
+#endif
+          }
+      }
+  }
+#endif
+
+//  printf ("About to walk sphere face bounds\n");
+
+  /* Throw the edges to the rasteriser */
+  for (c_iter = face->contours; c_iter != NULL; c_iter = g_list_next (c_iter))
+    {
+      float lost_u_phase = 0.0;
+      float lost_v_phase = 0.0;
+      double fu = 0.0, fv = 0.0;
+      double lu = 0.0, lv = 0.0;
+      double u, v;
+      bool first_vertex = true;
+      bool is_outer;
+      double intercept_v = 0.;
+
+//      printf ("Investigating a face bound\n");
+
+      /* XXX: How can we tell if a contour is inner or outer??? */
+      is_outer = true;
+
+      contour = c_iter->data;
+      e = contour->first_edge;
+
+      do
+        {
+          edge_info *info = UNDIR_DATA (e);
+          bool backwards_edge;
+
+          /* XXX: Do this without breaking abstraction? */
+          /* Detect SYM edges, reverse the circle normal */
+          backwards_edge = ((e & 2) == 2);
+
+          edge_ensure_linearised (e);
+
+          for (i = 0; i < info->num_linearised_vertices - 1; i++)
+            {
+              int vertex_idx = i;
+              float x, y, z, nx, ny, nz;
+
+              if (backwards_edge)
+                vertex_idx = info->num_linearised_vertices - 1 - i;
+
+              sphere_xyz_to_uv (face,
+                                info->linearised_vertices[vertex_idx * 3 + 0],
+                                info->linearised_vertices[vertex_idx * 3 + 1],
+                                info->linearised_vertices[vertex_idx * 3 + 2],
+                                &u, &v);
+
+              /* Add back on any wrapped phase */
+//              u += lost_u_phase;
+//              v += lost_v_phase;
+
+              if (first_vertex)
+                {
+                  fu = u;
+                  fv = v;
+                }
+              else
+                {
+#if 1
+//                  printf ("u = %f, delta since last u = %f\n", (double)u, (double)(u - lu));
+
+                  if (fabs (u - lu) > fabs (u + 360.0f - lu))
+                    {
+//                      printf ("Adding 360 degrees to lost u phase\n");
+                      lost_u_phase += 360.0f;
+//                      u += 360.0f;
+                        intercept_v = crossing_list_add (&crosslist, lu - 360., lv, u, v);
+
+                        sphere_bo_add_edge (bo, 0., intercept_v, u,    v       ,    is_outer);
+                        sphere_bo_add_edge (bo, lu, lv,          360., intercept_v, is_outer);
+                    }
+                  else if (fabs (u - lu) > fabs (u - 360.0f - lu))
+                    {
+//                      printf ("Subtracting 360 degrees to lost u phase\n");
+                      lost_u_phase -= 360.0f;
+//                      u -= 360.0f;
+                        intercept_v = crossing_list_add (&crosslist, lu, lv, u - 360., v);
+
+                        sphere_bo_add_edge (bo, lu,   lv,          0., intercept_v, is_outer);
+                        sphere_bo_add_edge (bo, 360., intercept_v, u,  v,           is_outer);
+                    }
+                  else
+                    {
+                      sphere_bo_add_edge (bo,  lu, lv, u,  v, is_outer);
+                    }
+#endif
+#if 1
+//                  printf ("v = %f, delta since last v = %f\n", (double)v, (double)(v - lv));
+
+                  if (fabs (v - lv) > fabs (v + 180.0f - lv))
+                    {
+//                      printf ("Adding 180 degrees to lost v phase\n");
+                      lost_v_phase += 180.0f;
+//                      v += 180.0f;
+                      current_u_with_vwrap = u; /* XXX: Don't necessarily assume current line is in u direction? */
+                    }
+                  else if (fabs (v - lv) > fabs (v - 180.0f - lv))
+                    {
+//                      printf ("Subtracting 180 degrees to lost v phase\n");
+                      lost_v_phase -= 180.0f;
+//                      v -= 180.0f;
+                      current_u_with_vwrap = u; /* XXX: Don't necessarily assume current line is in u direction? */
+                    }
+#endif
+
+                }
+
+              lu = u;
+              lv = v;
+              first_vertex = false;
+            }
+
+        }
+      while ((e = LNEXT(e)) != contour->first_edge);
+
+      if (fabs (fu - lu) > fabs (fu + 360.0f - lu))
+        {
+          lost_u_phase += 360.0f;
+            intercept_v = crossing_list_add (&crosslist, lu - 360., lv, fu, fv);
+
+            sphere_bo_add_edge (bo, 0., intercept_v, fu,   fv,          is_outer);
+            sphere_bo_add_edge (bo, lu, lv,          360., intercept_v, is_outer);
+        }
+      else if (fabs (fu - lu) > fabs (fu - 360.0f - lu))
+        {
+          lost_u_phase -= 360.0f;
+            intercept_v = crossing_list_add (&crosslist, lu, lv, fu - 360., fv);
+
+            sphere_bo_add_edge (bo, lu,   lv,          0., intercept_v, is_outer);
+            sphere_bo_add_edge (bo, 360., intercept_v, fu, fv,          is_outer);
+        }
+      else
+        {
+          sphere_bo_add_edge (bo,  lu, lv, fu, fv, is_outer);
+        }
+
+#if 1
+      if (fabs (fv - lv) > fabs (fv + 180.0f - lv))
+        {
+          lost_v_phase += 180.0f;
+          current_u_with_vwrap = u; /* XXX: Don't necessarily assume current line is in u direction? */
+        }
+      else if (fabs (fv - lv) > fabs (fv - 180.0f - lv))
+        {
+          lost_v_phase -= 180.0f;
+          current_u_with_vwrap = u; /* XXX: Don't necessarily assume current line is in u direction? */
+        }
+#endif
+
+#if 1
+      if (lost_v_phase > 1.0)
+        {
+          if (min_u_with_vwrap > current_u_with_vwrap)
+            {
+              min_u_with_vwrap = current_u_with_vwrap;
+              min_u_with_vwrap_is_end = true;
+            }
+        }
+      else if (lost_v_phase < 1.0)
+        {
+          if (min_u_with_vwrap > current_u_with_vwrap)
+            {
+              min_u_with_vwrap = current_u_with_vwrap;
+              min_u_with_vwrap_is_end = false;
+            }
+        }
+#endif
+//      printf ("Sphere contour has remaining lost phases u=%f, v=%f\n", lost_u_phase, lost_v_phase);
+
+#if 0
+      sphere_bo_add_edge (bo,
+                          lu, lv,
+                          fu, fv,
+                          is_outer);
+#endif
+    }
+
+  /* If required, invert start for the case where we have 2x v-wrapped outer-contours */
+  if (min_u_with_vwrap_is_end)
+    {
+      sphere_bo_add_edge_no_uwrap (bo,   0.00, -90.0,   0.00, 90.0, true);
+      sphere_bo_add_edge_no_uwrap (bo, 360.00, -90.0, 360.00, 90.0, true);
+    }
+
+  crossing_list_sort (&crosslist);
+
+  if (face->surface_orientation_reversed)
+    {
+      bool first_event = true;
+      double lstartv = -90.0;
+      bool started = false;
+
+      for (i = 0; i < crosslist.num_crossings; i++)
+        {
+#if 0
+          printf ("Got u=0 crossing at v=%f, is_left=%s, is_right=%s\n",
+                  crosslist.crossings[i].v,
+                  crosslist.crossings[i].is_left ? "true" : "false",
+                  crosslist.crossings[i].is_right ? "true" : "false");
+#endif
+
+          if (crosslist.crossings[i].is_left)
+            {
+              if (!started)
+                {
+                  /* Start */
+                  lstartv = crosslist.crossings[i].v;
+                }
+              /* Start */
+              started = true;
+            }
+          else if (crosslist.crossings[i].is_right)
+            {
+              /* Stop */
+              sphere_bo_add_edge_no_uwrap (bo, 0.0, lstartv, 0.0, crosslist.crossings[i].v, true);
+              sphere_bo_add_edge_no_uwrap (bo, 360.0, lstartv, 360.0, crosslist.crossings[i].v, true);
+              started = false;
+            }
+
+
+        }
+
+      if (started)
+        {
+          sphere_bo_add_edge_no_uwrap (bo, 0.0,   lstartv, 0.0,   90.0, true);
+          sphere_bo_add_edge_no_uwrap (bo, 360.0, lstartv, 360.0, 90.0, true);
+        }
+    }
+  else
+    {
+//      sphere_bo_add_edge_no_uwrap (bo, 0.0,   -90.0, 0.0,   90.0, true);
+//      sphere_bo_add_edge_no_uwrap (bo, 360.0, -90.0, 360.0, 90.0, true);
+
+      bool first_event = true;
+      double lstartv = -90.0;
+      bool started = false;
+
+      for (i = 0; i < crosslist.num_crossings; i++)
+        {
+
+          if (crosslist.crossings[i].is_right)
+            {
+              if (!started)
+                {
+                  /* Start */
+                  lstartv = crosslist.crossings[i].v;
+                }
+              /* Start */
+              started = true;
+            }
+          else if (crosslist.crossings[i].is_left)
+            {
+              /* Stop */
+              sphere_bo_add_edge_no_uwrap (bo,   0.0, lstartv,   0.0, crosslist.crossings[i].v, true);
+              sphere_bo_add_edge_no_uwrap (bo, 360.0, lstartv, 360.0, crosslist.crossings[i].v, true);
+              started = false;
+            }
+
+
+        }
+
+      if (started)
+        {
+          sphere_bo_add_edge_no_uwrap (bo, 0.0,   lstartv, 0.0,   90.0, true);
+          sphere_bo_add_edge_no_uwrap (bo, 360.0, lstartv, 360.0, 90.0, true);
+        }
+    }
+
+  _borast_traps_init (&traps);
+  bo_tesselate_to_traps (bo, false /* Don't combine adjacent y traps */,  &traps);
+
+  bo_free (bo);
+
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    /* Clamp evaluation coordinates otherwise (strips straddling the boundary)
+     * NB: Due to input parameter-space geometry duplication, the bit we trim
+     *     here will be duplicated on the other side of the wrap-around anyway
+     */
+    y_top = MAX(MM_TO_COORD(-90.0f), y_top);
+    y_bot = MIN(y_bot, MM_TO_COORD(90.0f));
+
+    x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+    x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+    x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+    x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+    /* Discard skinny traps (due to the way we split the u space with zero-width changes in inside/outside
+     * (Also discard skinny traps in v direction, presumably generated due to clamping y_top and y_bot)
+     */
+    if ((fabs(x1 - x2) < TRAP_WIDTH_EPSILON &&
+         fabs(x3 - x4) < TRAP_WIDTH_EPSILON) ||
+        fabs(y_top - y_bot) < TRAP_WIDTH_EPSILON)
+      {
+//        discarded_traps ++;
+        continue;
+      }
+
+    if ((x1 == x2) || (x3 == x4)) {
+      num_uv_points += 5 + 1; /* Three vertices + repeated start and end, extra repeat to sync backface culling */
+    } else {
+      num_uv_points += 6; /* Four vertices + repeated start and end */
+    }
+  }
+
+  if (num_uv_points == 0) {
+    printf ("Strange, contour didn't tesselate\n");
+    face->triangulate_failed = true;
+    return;
+  }
+
+//  printf ("Tesselated to %i traps, discarded %i\n", traps.num_traps, discarded_traps);
+
+  uv_points = g_new0 (double, 2 * num_uv_points + 8);
+  line_indices = g_new0 (unsigned int, 10 * traps.num_traps + 8);
+
+  vertex_comp = 0;
+  num_uv_points = 0;
+
+  for (i = 0; i < traps.num_traps; i++) {
+    y_top = traps.traps[i].top;
+    y_bot = traps.traps[i].bottom;
+
+    /* NB: ybot > ytop, as this is all derived from a screen-space rasteriser with 0,0 in the top left */
+
+#if 0
+    /* Exclude strips entirely above or below the 0 <= u <= 360 range */
+    if (y_bot < MM_TO_COORD (0.0f))
+      continue;
+
+    if (y_top > MM_TO_COORD (360.0f))
+      continue;
+#endif
+
+    /* Clamp evaluation coordinates otherwise (strips straddling the boundary)
+     * NB: Due to input parameter-space geometry duplication, the bit we trim
+     *     here will be duplicated on the other side of the wrap-around anyway
+     */
+    y_top = MAX(MM_TO_COORD(-90.0f), y_top);
+    y_bot = MIN(y_bot, MM_TO_COORD(90.0f));
+
+    /* NB: Backwards to other face types due to parameterisation differencs? */
+    if (!face->surface_orientation_reversed)
+      {
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+    else
+      {
+        x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+        x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+        x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+        x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+      }
+
+    /* Discard skinny traps (due to the way we split the u space with zero-width changes in inside/outside
+     * (Also discard skinny traps in v direction, presumably generated due to clamping y_top and y_bot)
+     */
+    if ((fabs(x1 - x2) < TRAP_WIDTH_EPSILON &&
+         fabs(x3 - x4) < TRAP_WIDTH_EPSILON) ||
+        fabs(y_top - y_bot) < TRAP_WIDTH_EPSILON)
+      {
+        continue;
+      }
 
-  if (face->tristrip_num_vertices == 0)
-    return;
+#if 1
+    /* Skip pieces which wrap around the u boundary */
+    if (x1 < MM_TO_COORD(0.0) ||
+        x2 < MM_TO_COORD(0.0) ||
+        x3 < MM_TO_COORD(0.0) ||
+        x4 < MM_TO_COORD(0.0) ||
+        x1 > MM_TO_COORD(360.0) ||
+        x2 > MM_TO_COORD(360.0) ||
+        x3 > MM_TO_COORD(360.0) ||
+        x4 > MM_TO_COORD(360.0))
+      continue;
+#endif
 
-  data_pointer = face->tristrip_vertices;
-  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
-  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
+    if (x1 == x2) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
 
-//  data_pointer = face->line_indices;
-//  glIndexPointer   (GL_INT, sizeof(GL_UNSIGNED_INT), data_pointer + 0);
+      num_uv_points += 6;
+    } else if (x3 == x4) {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Extra repeated vertex to keep backface culling in sync */
 
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glEnableClientState (GL_NORMAL_ARRAY);
+      num_uv_points += 6;
+    } else {
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x2;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x3;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x1;  uv_points[vertex_comp++] = y_top;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      uv_points[vertex_comp++] = x4;  uv_points[vertex_comp++] = y_bot;
+      /* NB: Repeated last virtex to separate from other tri-strip */
 
-  glTexCoord2f (0.0f, 0.0f);
+      line_indices[num_line_indices++] = num_uv_points + 1;
+      line_indices[num_line_indices++] = num_uv_points + 2;
 
-  glPushAttrib (GL_CURRENT_BIT);
-  glColor4f (1., 1., 1., 1.);
-  glDrawElements (GL_LINES, face->line_num_indices, GL_UNSIGNED_INT, face->line_indices);
-  glPopAttrib ();
+      line_indices[num_line_indices++] = num_uv_points + 1;
+      line_indices[num_line_indices++] = num_uv_points + 3;
 
-  glDisableClientState (GL_VERTEX_ARRAY);
-  glDisableClientState (GL_NORMAL_ARRAY);
-}
+      /* Central line */
+      line_indices[num_line_indices++] = num_uv_points + 2;
+      line_indices[num_line_indices++] = num_uv_points + 3;
 
+      line_indices[num_line_indices++] = num_uv_points + 3;
+      line_indices[num_line_indices++] = num_uv_points + 4;
 
-static void
-emit_tristrip (face3d *face)
-{
-  GLfloat *data_pointer = NULL;
+      line_indices[num_line_indices++] = num_uv_points + 4;
+      line_indices[num_line_indices++] = num_uv_points + 2;
 
-//  CHECK_IS_IN_CONTEXT ();
+      num_uv_points += 6;
+    }
+  }
 
-  if (face->tristrip_num_vertices == 0)
-    return;
+#if 1
+  uv_points[vertex_comp++] = MM_TO_COORD(  0.0);  uv_points[vertex_comp++] = MM_TO_COORD(-90.0);
+  uv_points[vertex_comp++] = MM_TO_COORD(  0.0);  uv_points[vertex_comp++] = MM_TO_COORD( 90.0);
+  uv_points[vertex_comp++] = MM_TO_COORD(360.0);  uv_points[vertex_comp++] = MM_TO_COORD( 90.0);
+  uv_points[vertex_comp++] = MM_TO_COORD(360.0);  uv_points[vertex_comp++] = MM_TO_COORD(-90.0);
 
-//  if (priv->buffer.use_vbo) {
-//    glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
+  line_indices[num_line_indices++] = num_uv_points + 0;
+  line_indices[num_line_indices++] = num_uv_points + 1;
+  line_indices[num_line_indices++] = num_uv_points + 1;
+  line_indices[num_line_indices++] = num_uv_points + 2;
+  line_indices[num_line_indices++] = num_uv_points + 2;
+  line_indices[num_line_indices++] = num_uv_points + 3;
+  line_indices[num_line_indices++] = num_uv_points + 3;
+  line_indices[num_line_indices++] = num_uv_points + 0;
+#endif
 
-//    if (priv->buffer.use_map) {
-//      glUnmapBuffer (GL_ARRAY_BUFFER);
-//      priv->buffer.triangle_array = NULL;
-//    } else {
-//      glBufferData (GL_ARRAY_BUFFER,
-//                    BUFFER_STRIDE * priv->buffer.vertex_count,
-//                    priv->buffer.triangle_array,
-//                    GL_STREAM_DRAW);
-//    }
-//  } else {
-    data_pointer = face->tristrip_vertices;
-//  }
+  face->line_indices = line_indices;
+  face->line_num_indices = num_line_indices;
 
-  glVertexPointer   (3, GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 0);
-  glNormalPointer   (GL_FLOAT, sizeof(GL_FLOAT) * BUFFER_STRIDE, data_pointer + 3);
-//  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+  _borast_traps_fini (&traps);
+#endif
 
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glEnableClientState (GL_NORMAL_ARRAY);
-//  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+  /* XXX: Would it be better to use the original vertices?
+   *      Rather than converting to u-v coordinates and back.
+   *      Probably at least need to use the u-v points to
+   *      perform the triangulation.
+   */
 
-  glTexCoord2f (0.0f, 0.0f);
+  face->tristrip_num_vertices = num_uv_points;
 
-  glDrawArrays (GL_TRIANGLE_STRIP, 0, face->tristrip_num_vertices);
+  num_uv_points += 4;
+  face->tristrip_vertices = g_new0 (float, BUFFER_STRIDE * num_uv_points);
+
+  vertex_comp = 0;
+  for (i = 0; i < num_uv_points; i++)
+    {
 #if 0
-  glPushAttrib (GL_CURRENT_BIT);
-  glColor4f (1., 1., 1., 1.);
-  glDrawArrays (GL_LINE_STRIP, 0, priv->buffer.vertex_count);
-  glPopAttrib ();
+      plane_uv_to_xyz_and_normal (face,
+                                  COORD_TO_MM (uv_points[2 * i + 0] * 0.1),
+                                  COORD_TO_MM (uv_points[2 * i + 1] * 0.1),
+                                  &face->tristrip_vertices[vertex_comp + 0],
+                                  &face->tristrip_vertices[vertex_comp + 1],
+                                  &face->tristrip_vertices[vertex_comp + 2],
+                                  /* Vertex normal */
+                                  &face->tristrip_vertices[vertex_comp + 3],
+                                  &face->tristrip_vertices[vertex_comp + 4],
+                                  &face->tristrip_vertices[vertex_comp + 5]);
+
+      vertex_comp += BUFFER_STRIDE;
+#else
+      sphere_uv_to_xyz_and_normal (face,
+                                   /* uv */
+                                   COORD_TO_MM (uv_points[2 * i + 0]), /* Inverse of arbitrary transformation above */
+                                   COORD_TO_MM (uv_points[2 * i + 1]), /* Inverse of arbitrary transformation above */
+                                   /* xyz */
+                                   &face->tristrip_vertices[vertex_comp + 0],
+                                   &face->tristrip_vertices[vertex_comp + 1],
+                                   &face->tristrip_vertices[vertex_comp + 2],
+                                   /* Vertex normal */
+                                   &face->tristrip_vertices[vertex_comp + 3],
+                                   &face->tristrip_vertices[vertex_comp + 4],
+                                   &face->tristrip_vertices[vertex_comp + 5]);
+
+      vertex_comp += BUFFER_STRIDE;
 #endif
-  glDisableClientState (GL_VERTEX_ARRAY);
-  glDisableClientState (GL_NORMAL_ARRAY);
-//  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+    }
+
+  g_free (uv_points);
 }
 
+
 static void
 toroid_xyz_to_uv (face3d *face, double x, double y, double z, double *u, double *v)
 {
@@ -269,7 +1087,7 @@ toroid_uv_to_xyz_and_normal (face3d *face,
   *ny = -(cosv * cosu * face->ry + cosv * sinu * orty + sinv * face->ay); /* XXX: Note this is minus, presumably due to PCB's coordinate space */
   *nz =  (cosv * cosu * face->rz + cosv * sinu * ortz + sinv * face->az);
 
-  if (face->surface_orientation_reversed)
+ if (face->surface_orientation_reversed)
     {
       *nx = -*nx;
       *ny = -*ny;
@@ -367,81 +1185,6 @@ toroid_bo_add_edge (borast_t *bo,
 
 }
 
-static void plane_uv_to_xyz_and_normal (face3d *face, float u, float v, float *x, float *y, float *z, float *nx, float *ny, float *nz);
-
-typedef struct {
-  double v;     /* v-coordinate at u=0 */
-  bool is_left; /* True if crossing is from u-pos towards u-neg */
-  bool is_right; /* True if crossing is from u-neg towards u-pos */
-  /* Could be neither... if we get fed an edge colinear with u=0... not sure if we need to cope with that or not */
-} u0_crossing;
-
-typedef struct {
-  u0_crossing *crossings; /* Pointer to array of crossigns */
-  int num_crossings;
-  int max_crossings;
-} crossing_info;
-
-/* Add a crossing to be considered to the u=0 crossing list */
-static void
-crossing_list_init (crossing_info *info)
-{
-  info->num_crossings = 0;
-  info->max_crossings = 20; /* Arbitrary start */
-  info->crossings = g_new0 (u0_crossing, info->max_crossings);
-}
-
-static void
-crossing_list_destroy (crossing_info *info)
-{
-  g_free (info->crossings);
-  /* NB: Don't free info its-self, allows it to be stack allocated */
-}
-
-/* Add a crossing to be considered to the u=0 crossing list */
-static double
-crossing_list_add (crossing_info *info,
-                   double u1, double v1,
-                   double u2, double v2)
-{
-  u0_crossing *cross;
-  double m;
-  double v;
-
-  if (info->num_crossings == info->max_crossings)
-    {
-      /* XXX: Reallocate more memory, copy old data etc.. */
-      printf ("Too many crossings, sorry!\n");
-      exit (-1);
-    }
-
-  cross = &info->crossings[info->num_crossings];
-  info->num_crossings++;
-
-  /* XXX: Not sure this is the most robust way to calculate the line intercept at u=0 */
-  m = (v2 - v1) / (u2 - u1);
-  v = v1 - m * u1;
-
-  cross->v = v;
-  cross->is_left = u1 > u2;
-  cross->is_right = u1 < u2;
-
-  return v;
-}
-
-/* Sort in ascending order of v */
-static int
-compare_crossings (const u0_crossing *c1, const u0_crossing *c2)
-{
-  return (c1->v < c2->v) ? -1 : ((c1->v > c2->v) ? 1 : 0);
-}
-
-static void
-crossing_list_sort (crossing_info *info)
-{
-  qsort (info->crossings, info->num_crossings, sizeof (*info->crossings), compare_crossings);
-}
-
 static void
 toroid_ensure_tristrip (face3d *face)
 {
@@ -2535,7 +3278,7 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
 
   if (face->is_planar)
     {
-      plane_ensure_tristrip (face);
+//      plane_ensure_tristrip (face);
     }
   else if (face->is_cylindrical)
     {
@@ -2549,6 +3292,10 @@ face3d_fill(hidGC gc, face3d *face, bool selected)
     {
       toroid_ensure_tristrip (face);
     }
+  else if (face->is_spherical)
+    {
+      sphere_ensure_tristrip (face);
+    }
   else
     {
       /* We only know how to deal with planar and cylindrical faces for now */
diff --git a/src/hid/step/model.cpp b/src/hid/step/model.cpp
index 6af4534..588f3c1 100644
--- a/src/hid/step/model.cpp
+++ b/src/hid/step/model.cpp
@@ -1533,6 +1533,12 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
           SdaiFace_surface *fs = (SdaiFace_surface *) face;
 
           SdaiSurface *surface = fs->face_geometry_ ();
+
+          if (surface == NULL_ENTITY)
+            {
+              printf ("ERROR: Got a NULL_ENTITY for surface - did the file not load properly?\n");
+              continue;
+            }
 #if 0
           std::cout << "Face " << face->name_ ().c_str () << " has surface of type " << surface->EntityName () << " and same_sense = " << fs->same_sense_ () << std::endl;
 #endif
@@ -1770,7 +1776,47 @@ process_sr_or_subtype(InstMgr *instance_list, SdaiShape_representation *sr, proc
             }
           else if (strcmp (surface->EntityName (), "Spherical_Surface") == 0)
             {
+              auto *sphere = dynamic_cast<SdaiSpherical_surface *>(surface);
 //              printf ("WARNING: spherical surfaces are not supported yet\n");
+
+              unpack_axis_geom (sphere->position_ (),
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              transform_vertex (info->current_transform,
+                                &info->current_face->ox,
+                                &info->current_face->oy,
+                                &info->current_face->oz);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->ax,
+                                &info->current_face->ay,
+                                &info->current_face->az);
+
+              transform_vector (info->current_transform,
+                                &info->current_face->rx,
+                                &info->current_face->ry,
+                                &info->current_face->rz);
+
+              info->current_face->is_spherical = true;
+              info->current_face->radius = sphere->radius_ ();
+
+              if (fs->same_sense_ ())
+                {
+                  info->current_face->surface_orientation_reversed = false;
+                }
+              else
+                {
+                  info->current_face->surface_orientation_reversed = true;
+                }
+
             }
           else
             {
